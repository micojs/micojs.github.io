(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Var = exports.UnaryExpression = exports.Scope = exports.Return = exports.Program = exports.Pop = exports.Objekt = exports.Method = exports.LookUp = exports.Location = exports.Literal = exports.Inline = exports.Error = exports.Deref = exports.Continue = exports.CallExpression = exports.Break = exports.BinaryExpression = exports.AssignmentExpression = exports.Array = void 0;
exports.getUniqueId = getUniqueId;
exports.getUniqueName = getUniqueName;
let uniqueId = 1;
function getUniqueId() {
  return uniqueId++;
}
function getUniqueName(prefix = "_") {
  return prefix + uniqueId();
}
class Expr {
  constructor() {
    this.id = getUniqueId();
    this.parent = null;
    this.program = null;
  }
  setProgram(prog) {
    this.program = prog;
  }
  toJSON() {
    return {
      constructor: this.constructor.name
    };
  }
}
class Pop extends Expr {}
exports.Pop = Pop;
;
class Deref extends Expr {}
exports.Deref = Deref;
;
class Return extends Expr {
  constructor(hasValue) {
    super();
    this.hasValue = hasValue;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      hasValue: this.hasValue
    };
  }
}
exports.Return = Return;
;
class Break extends Expr {
  constructor(target) {
    super();
    this.target = target;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      target: this.target ? this.target.id : null
    };
  }
}
exports.Break = Break;
;
class Continue extends Expr {
  constructor(target) {
    super();
    this.target = target;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      target: this.target ? this.target.id : null
    };
  }
}
exports.Continue = Continue;
;
class Array extends Expr {
  constructor(length) {
    super();
    this.length = length;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      length: this.length
    };
  }
}
exports.Array = Array;
class Objekt extends Expr {
  constructor(length, construct) {
    super();
    this.length = length;
    this.construct = construct;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      length: this.length
    };
  }
}
exports.Objekt = Objekt;
class CallExpression extends Expr {
  constructor(argc, isNew, isForward, discardResult) {
    super();
    this.argc = argc;
    this.isNew = isNew;
    this.isForward = isForward;
    this.discardResult = !!discardResult;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      argc: this.argc,
      isNew: this.isNew,
      isForward: this.isForward
    };
  }
}
exports.CallExpression = CallExpression;
class AssignmentExpression extends Expr {
  constructor(operator) {
    super();
    this.operator = operator;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      operator: this.operator
    };
  }
}
exports.AssignmentExpression = AssignmentExpression;
class BinaryExpression extends Expr {
  constructor(operator) {
    super();
    this.operator = operator;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      operator: this.operator
    };
  }
}
exports.BinaryExpression = BinaryExpression;
class UnaryExpression extends Expr {
  constructor(operator, prefix) {
    super();
    this.operator = operator;
    this.prefix = prefix;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      operator: this.operator
    };
  }
}
exports.UnaryExpression = UnaryExpression;
class LookUp extends Expr {
  constructor(name) {
    super();
    if (name === undefined) throw new Error("Internal error: invalid LookUp");
    this.variable = name;
    this.container = null;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      variable: this.variable,
      container: this.container
    };
  }
}
exports.LookUp = LookUp;
class Literal extends Expr {
  constructor(value) {
    super();
    this.declType = typeof value;
    if (this.declType == "number") {
      if ((value | 0) == value) {
        this.declType = "int32_t";
      } else {
        this.declType = "Float";
      }
    }
    if (this.declType == "boolean") {
      this.declType = "bool";
    }
    this.type = this.declType;
    this.hasCTV = true;
    this.CTV = value;
    this.value = value;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      value: this.value
    };
  }
}
exports.Literal = Literal;
class Inline {
  constructor(backend, code, target) {
    this.backend = backend;
    this.code = code && typeof code.join == 'function' ? code.join(' ') : code + "";
    this.target = target;
  }
  setProgram(prog) {}
  toJSON() {
    return {
      constructor: this.constructor.name
    };
  }
}
exports.Inline = Inline;
class Var {
  constructor(kind = "var", name = undefined, location = null) {
    this.id = getUniqueId();
    this.kind = kind;
    this.name = name;
    this.location = null;
    this.parent = null;
    this.context = null;
    this.deref = null;
    this.read = 0;
    this.write = 0;
    this.program = null;
    this.declType = null;
    this.type = null;
    this._hasCTV = false;
    this._CTV = undefined;
  }
  get hasCTV() {
    return this._hasCTV;
  }
  set hasCTV(value) {
    if (this.kind == "const" && this._hasCTV) {
      console.trace();
      throw "setting hasCTV " + this._hasCTV + " " + value;
    }
    this._hasCTV = value;
  }
  get CTV() {
    return this._CTV;
  }
  set CTV(value) {
    if (this.kind == "const" && this._hasCTV) {
      console.trace();
      throw "double assign on const";
    }
    this._hasCTV = true;
    this._CTV = value;
  }
  setType(type) {
    if (this.declType != type) {
      this.declType = null;
    }
    this.type = type;
  }
  setDeclType(type) {
    this.declType = this.type = type;
  }
  setProgram(prog) {
    this.program = prog;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      id: this.id,
      name: this.name,
      parent: this.parent ? this.parent.name : null,
      kind: this.kind
    };
  }
  addDeref(str) {
    if (!this.deref) this.deref = {};
    this.deref[str] = str;
    // console.log("Add deref: ", this.name, str);
  }

  isCaptured() {
    return this.parent.method.captured && this.id in this.parent.method.captured;
  }
  rename(name) {
    if (this.parent) {
      this.parent.remove(this);
      this.name = name;
      this.parent.add(this);
    } else {
      this.name = name;
    }
  }
}
exports.Var = Var;
class Scope extends Expr {
  constructor(name) {
    super();
    this.name = name;
    this.variables = [];
    this.index = Object.create(null);
    this.parent = null;
    this.children = [];
    this.method = null;
    this.transparent = false;
    this.breakable = false;
    this.hasBreak = false;
    this.continuable = false;
    this.hasContinue = false;
    this.returnable = false;
    this.debug = null;
    this.program = null;
    this.temporaries = [];
    this.preEnter = undefined;
    this.enterCondition = undefined;
    this.failEnter = undefined;
    this.preLoop = undefined;
    this.loopCondition = undefined;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      id: this.id,
      name: this.name,
      index: this.index,
      parent: this.parent ? this.parent.name : null,
      preEnter: this.preEnter,
      enterCondition: this.enterCondition,
      failEnter: this.failEnter,
      children: this.children,
      loopCondition: this.loopCondition,
      preLoop: this.preLoop
    };
  }
  label(str) {
    return str + "_" + this.id + (this.debug ? `/*${this.debug}*/` : '');
  }
  has(name, recursive) {
    if (this.transparent && this.parent) return this.parent.has(name, recursive);
    return name in this.index || recursive && this.parent && this.parent.has(name, true);
  }
  find(name, recursive, create) {
    if (this.transparent && this.parent) return this.parent.find(name, recursive);
    var ret = this.index[name];
    if (ret) return ret;
    if (!recursive || !this.parent) {
      if (create) {
        const ret = new Var('var', name);
        this.add(ret);
        return ret;
      }
      return;
    }
    ret = this.parent.find(name, true);
    if (ret && ret.parent.method != this.method && ret.parent.method.parent) {
      ret = this.method.capture(ret);
    }
    return ret;
  }
  remove(obj) {
    if (this.transparent && this.parent) {
      this.parent.remove(obj);
      return;
    }
    if (!obj || obj.parent != this) {
      return;
    }
    const pos = this.variables.indexOf(obj);
    if (pos != -1) {
      this.variables[pos] = this.variables[this.variables.length - 1];
      this.variables.pop();
    }
    if (this.index[obj.name] == obj) {
      delete this.index[obj.name];
    }
    delete this.index[obj.id];
  }
  addPreEnter() {
    const scope = new Scope();
    this.preEnter = scope;
    scope.parent = this;
    scope.transparent = true;
    scope.method = this.method;
    if (this.debug) scope.debug = this.debug + "(preEnter)";
    return scope;
  }
  addEnterCondition() {
    const scope = new Scope();
    this.enterCondition = scope;
    scope.parent = this;
    scope.transparent = true;
    scope.method = this.method;
    if (this.debug) scope.debug = this.debug + "(enterCondition)";
    return scope;
  }
  addFailEnter() {
    const scope = new Scope();
    this.failEnter = scope;
    scope.parent = this;
    scope.transparent = true;
    scope.method = this.method;
    if (this.debug) scope.debug = this.debug + "(failEnter)";
    return scope;
  }
  addPreLoop() {
    const scope = new Scope();
    this.preLoop = scope;
    scope.parent = this;
    scope.transparent = true;
    scope.method = this.method;
    if (this.debug) scope.debug = this.debug + "(preLoop)";
    return scope;
  }
  addLoopCondition() {
    const scope = new Scope();
    this.loopCondition = scope;
    scope.parent = this;
    scope.transparent = true;
    scope.method = this.method;
    if (this.debug) scope.debug = this.debug + "(loopCondition)";
    return scope;
  }
  setProgram(prog) {
    if (prog == this.program) return;
    this.program = prog;
    for (let obj of this.variables) obj.setProgram(prog);
    for (let obj of this.children) obj.setProgram(prog);
  }
  _reg(obj) {
    if (this.transparent) {
      return this.parent._reg(obj);
    } else {
      if (obj.name) this.index[obj.name] = obj;
      if (obj.id) this.index[obj.id] = obj;
      return this;
    }
  }
  add(obj) {
    if (!obj) throw new Error("Internal Error: adding null to scope");
    if (this.program) obj.setProgram(this.program);
    if (obj instanceof Var) {
      obj.parent = this._reg(obj);
      obj.parent.variables.push(obj);
    } else if (obj instanceof Method) {
      obj.parent = this._reg(obj);
      obj.parent.children.push(obj); // to-do: push context var instead
    } else if (obj instanceof Scope) {
      this._reg(obj);
      obj.parent = this;
      obj.parent.children.push(obj);
      obj.method = this.method;
    } else if (obj instanceof Expr) {
      this.children.push(obj);
      obj.parent = this;
    } else if (obj instanceof Inline) {
      this.children.push(obj);
      obj.parent = this;
    } else {
      throw new Error("Internal Error: Can't add to scope: ", obj);
    }
  }
}
exports.Scope = Scope;
class Method extends Scope {
  constructor(name) {
    super();
    this.name = name;
    this.method = this;
    this.args = new Var("const", "arguments");
    this.add(this.args);
    this.that = new Var("const", "this");
    this.add(this.that);
    this.isNative = false;
    this.isClass = false;
    this.context = undefined; // captured local variables
    this.captures = undefined;
    this.captured = undefined;
    this.capturers = undefined;
    this.caches = undefined;
    this.returnable = true;
    this.returnType = undefined;
  }
  guessObjectSize(reg) {
    reg = reg || new Set();
    let deref = 0;
    for (let key in this.index["this"].deref || {}) {
      if (reg.has(key)) continue;
      reg.add(key);
      deref++;
    }
    for (let key in this.index) {
      const method = this.index[key];
      if (!(method instanceof Method) || method.isClass) continue;
      deref += method.guessObjectSize(reg);
    }
    return deref;
  }
  toJSON() {
    return Object.assign(super.toJSON(), {
      name: this.name,
      args: this.args,
      isNative: this.isNative
    });
  }
  cached(name) {
    if (!this.caches) {
      this.caches = Object.create(null);
    }
    let ret = this.caches[name];
    if (!ret) {
      ret = this.caches[name] = new Var("cache");
      ret.hasCTV = false;
      this.add(ret);
      ret.name = name;
    }
    return ret;
  }
  capture(ext) {
    let ret = new Var("capture", ext.name);
    ret.context = ext.parent.method.setCaptured(ext, this);
    this.add(ret);
    if (!this.captures) {
      this.captures = {};
    }
    this.captures[ret.context.id] = ext.id;
    return ret;
  }
  setCaptured(local, capturer) {
    if (!this.captured) {
      this.captured = {};
      this.capturers = {};
      this.context = new Var("var");
      this.add(this.context);
    }
    this.captured[local.id] = local;
    if (!(capturer.id in this.capturers)) {
      const ctx = new Var("child-context");
      this.add(ctx);
      this.capturers[capturer.id] = {
        capturer,
        ctx
      };
    }
    return this.context;
  }
}
exports.Method = Method;
class Program {
  constructor() {
    this.main = new Method("_main");
    this.main.setProgram(this);
    this.resources = new Var("var", "R");
    this.resourceData = {};
    this.strings = [];
    this.sourceAST = [];
    this.main.add(this.resources);
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      main: this.main
    };
  }
}
exports.Program = Program;
class Location {
  constructor(file, line, column) {
    this.file = file;
    this.line = line;
    this.column = column;
  }
  clone() {
    return new Location(this.file, this.line, this.column);
  }
}
exports.Location = Location;
class Error {
  constructor(message, location) {
    this.message = message;
    this.location = location;
  }
  toJSON() {
    return {
      constructor: this.constructor.name,
      message: this.message,
      location: this.location
    };
  }
}
exports.Error = Error;

},{}],2:[function(require,module,exports){
(function (global){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parser = parser;
// 'use strict';

var isArray = Array.isArray;
function getOpName(op) {
  if (op.prototype._astname) {
    return op.prototype._astname;
  }
  throw new Error("Coudlnt decode operator name for: " + (op.name || op.toString()));
}
function abort(why) {
  console.log(new Error("ABORT:" + why).stack);
  throw new Error(why);
}
function isExpression(n) {
  return /Expression$/.test(n.type);
}
var idx = 0;
function createTempName(hint) {
  return '__temp$' + hint + '$' + idx++;
}
function ensureStatement(s) {
  var f = s;
  if (!isArray(s)) f = [f];
  for (var i = 0; i < f.length; ++i) {
    var v = f[i];
    if (isExpression(v)) {
      f[i] = {
        type: "ExpressionStatement",
        expression: v
      };
    }
  }
  if (isArray(s)) return s;else return f[0];
}
function ident(n) {
  return {
    type: "Identifier",
    name: n.valueOf()
  };
}
function member(o, p) {
  return {
    type: "MemberExpression",
    object: o,
    property: p,
    computed: false
  };
}
function literal(v) {
  if (typeof v === 'object') v = v.valueOf();
  if (typeof v === 'number' && 1 / v !== 1 / Math.abs(v)) {
    return {
      type: "UnaryExpression",
      argument: literal(-v),
      operator: '-'
    };
  }
  return {
    type: "Literal",
    value: v,
    raw: JSON.stringify(v)
  };
}
function binOp(left, op, right) {
  return {
    type: "BinaryExpression",
    left: left,
    right: right,
    operator: op
  };
}
function logicOp(left, op, right) {
  return {
    type: "LogicalExpression",
    left: left,
    right: right,
    operator: op
  };
}
function ternary(cond, a, b) {
  return {
    type: "ConditionalExpression",
    test: cond,
    consequent: a,
    alternate: b
  };
}
function var_(name, init) {
  return {
    type: "VariableDeclaration",
    kind: 'var',
    declarations: [{
      type: "VariableDeclarator",
      id: name,
      init: init ? init : undefined
    }]
  };
}
function transform(node, ctx) {
  //console.log(node.lineno, node.col_offset);
  var result = dispatch(node, ctx);
  if (node.range) result.range = [node.range[0], node.range[1]];
  if (node.loc) result.loc = node.loc;
  result.str = node.str;
  return result;
}
function dispatch(node, ctx) {
  if (!ctx.locals) ctx.locals = Object.create(null);
  if (!node) {
    console.log("WAT!", new Error().stack);
    throw new Error("What?");
  }
  if (isArray(node)) {
    var body = [];
    for (var i = 0; i < node.length; ++i) {
      var r = transform(node[i], ctx);
      if (isArray(r)) body.push.apply(body, r);else body.push(r);
    }
    return body;
  }
  switch (node._astname) {
    case 'Attribute':
      return transformAttribute(node, ctx);
    case 'Assign':
      return transformAssign(node, ctx);
    case 'AugAssign':
      return transformAugAssign(node, ctx);
    case 'BinOp':
      return transformBinOp(node, ctx);
    case 'BoolOp':
      return transformBoolOp(node, ctx);
    case 'Break':
      return transformBreak(node, ctx);
    case 'Call':
      return transformCall(node, ctx);
    case 'ClassDef':
      return transformClassDef(node, ctx);
    case 'Continue':
      return tranformContinue(node, ctx);
    case 'Compare':
      return transformCompare(node, ctx);
    case 'Dict':
      return transformDict(node, ctx);
    case 'Delete':
      return transformDel(node, ctx);
    case 'Expr':
      return transformExpr(node, ctx);
    case 'For':
      return transformFor(node, ctx);
    case 'FunctionDef':
      return transformFunctionDef(node, ctx);
    case 'GeneratorExp':
      return transformListComp(node, ctx);
    //TODO: Make this seperate
    case 'Global':
      return transformGlobal(node, ctx);
    case 'If':
      return transformIf(node, ctx);
    case 'Import':
      return NoOp();
    case 'Lambda':
      return transformLambda(node, ctx);
    case 'List':
      return transformList(node, ctx);
    case 'ListComp':
      return transformListComp(node, ctx);
    case 'Module':
      return transformModule(node, ctx);
    case 'Name':
      return transformName(node, ctx);
    case 'Print':
      return transformPrint(node, ctx);
    case 'Return':
      return transformReturn(node, ctx);
    case 'Str':
      return transformStr(node, ctx);
    case 'Subscript':
      return transformSubscript(node, ctx);
    case 'Tuple':
      return transformTuple(node, ctx);
    case 'Num':
      return transformNum(node, ctx);
    case 'Pass':
      return transformPass(node, ctx);
    case 'UnaryOp':
      return transformUnaryOp(node, ctx);
    case 'While':
      return transformWhile(node, ctx);
    default:
      console.log("Dont know how to transform: " + node._astname);
      console.log(JSON.stringify(node, null, '  '));
      throw new Error("Dont know how to transform: " + node._astname);
  }
}
function NoOp() {
  return [];
}
function makeVariableName(name) {
  var parts = Array.isArray(name) ? name : name.split(/\./g);
  if (parts.length === 1) return ident(name);
  var prop = parts.pop();
  return member(makeVariableName(parts), ident(prop));
}
function transformAttribute(node, ctx) {
  var n = node.attr;
  if (n._astname) n = transform(n, ctx);else n = {
    type: 'Identifier',
    name: n.valueOf()
  };
  return member(transform(node.value, ctx), n);
}
function transformAugAssign(node, ctx) {
  //TODO: We need to not inject left into the code twice
  //as it could have side effects.
  var right = transform(node.value, ctx);
  var left = transform(node.target, ctx);
  var tn = createTempName("left");
  var opName = getOpName(node.op);
  return [var_(ident(tn), left), ensureStatement({
    type: "AssignmentExpression",
    operator: '=',
    left: left,
    right: createBinOp(left, opName, right)
  })];
}
function transformAssign(node, ctx) {
  var results = [];
  for (var i = 0; i < node.targets.length; ++i) {
    var left = node.targets[i];
    if (ctx.writeTarget) {
      left = member(ctx.writeTarget, transform(left, ctx));
    }
    results.push.apply(results, createTupleUnpackingAssign(left, transform(node.value, ctx), ctx));
  }
  if (results.length == 1) return results[0];
  return {
    type: "BlockStatement",
    body: results
  };
}
function createBinOp(left, op, right) {
  if (op === 'FloorDiv') {
    return {
      type: "CallExpression",
      callee: makeVariableName('Math.floor'),
      arguments: [{
        type: "BinaryExpression",
        left: left,
        right: right,
        operator: '/'
      }]
    };
  }

  // var fxOps = {
  // 	"Add": "__pythonRuntime.ops.add",
  // 	"Mult": "__pythonRuntime.ops.multiply",
  // 	"Pow": "Math.pow"
  // };

  // if ( op in fxOps  ) {
  // 	var call = {
  // 		type: "CallExpression",
  // 		callee: makeVariableName(fxOps[op]),
  // 		arguments: [left, right]
  // 	};
  // 	return call;
  // }

  var operators = {
    "Add": "+",
    "Sub": "-",
    "Mod": "%",
    "Div": "/",
    "Mult": "*",
    "BitAnd": "&",
    "BitOr": "|",
    'BitXor': '^',
    "LShift": "<<",
    "RShift": ">>"
  };
  if (!(op in operators)) abort("Unknown binary operator: " + op);
  return binOp(left, operators[op], right);
}
function transformBinOp(node, ctx) {
  var left = transform(node.left, ctx);
  var right = transform(node.right, ctx);
  return createBinOp(left, getOpName(node.op), right);
}
function transformBoolOp(node, ctx) {
  var fvals = new Array(node.values.length);
  for (var i = 0; i < node.values.length; ++i) {
    fvals[i] = transform(node.values[i], ctx);
  }
  var opName = getOpName(node.op);
  var operators = {
    'And': '&&',
    'Or': '||'
  };
  if (!(opName in operators)) abort("Unknown bool opeartor: " + opName);
  var opstr = operators[opName];
  var result = fvals.pop();
  while (fvals.length > 0) {
    result = logicOp(fvals.pop(), opstr, result);
  }

  //TODO: Support || as well?
  return result;
}
function transformBreak(node, ctx) {
  return {
    type: "BreakStatement"
  };
}
function transformCall(node, ctx) {
  var builtins = ['len'];
  if (node.func._astname == 'Name') {
    switch (node.func.id.v) {
      case 'len':
        return {
          type: "MemberExpression",
          object: transform(node.args[0], ctx),
          property: {
            type: "Identifier",
            name: "length"
          }
        };
      case 'all':
      case 'ord':
      case 'sum':
      case 'any':
      case 'str':
      case 'chr':
      case 'ascii':
      case 'divmod':
      case 'range':
      case 'enumerate':
      case 'round':
      case 'filter':
      case 'abs':
      case 'float':
      case 'int':
      case 'hex':
      case 'tuple':
      case 'map':
      case 'bool':
      case 'max':
      case 'sorted':
      case 'min':
      case 'list':
      case 'oct':
      case 'pow':
      case 'reversed':
      case 'repr':
        return {
          type: 'CallExpression',
          callee: makeVariableName(node.func.id.v),
          arguments: transform(node.args, ctx)
        };
      case 'dict':
        var args = [];
        for (var i = 0; i < node.keywords.length; ++i) {
          args.push({
            type: "ArrayExpression",
            elements: [literal(node.keywords[i].arg.v), transform(node.keywords[i].value, ctx)]
          });
        }
        return {
          type: "NewExpression",
          callee: makeVariableName('__pythonRuntime.objects.dict'),
          arguments: args
        };
    }
  }
  var args = transform(node.args, ctx);
  if (node.keywords.length > 0) {
    var paramsDict = {
      type: "ObjectExpression",
      properties: [{
        type: "Property",
        key: ident("__kwp"),
        value: literal(true)
      }]
    };
    for (var i = 0; i < node.keywords.length; ++i) {
      var k = node.keywords[i];
      paramsDict.properties.push({
        type: "Property",
        key: ident(k.arg.v),
        value: transform(k.value, ctx)
      });
    }
    var extraArg = {
      type: "CallExpression",
      callee: makeVariableName('__pythonRuntime.utils.createParamsObj'),
      arguments: [paramsDict]
    };
    args.push(extraArg);
  }
  return {
    type: "CallExpression",
    callee: transform(node.func, ctx),
    arguments: args
  };
}
function transformClassDef(node, ctx) {
  var body = [];
  var proto = member(ident(node.name), ident('prototype'));
  var nctx = {
    writeTarget: proto,
    inClass: true,
    locals: Object.create(null)
  };
  if (node.bases.length > 1) alert("Multiple base classes not supported.");
  var base = node.bases.length > 0 ? transform(node.bases[0], ctx) : undefined;
  var ctorBody = [];
  ctorBody.push({
    type: "VariableDeclaration",
    kind: 'var',
    declarations: [{
      type: "VariableDeclarator",
      id: ident('that'),
      init: {
        type: "ThisExpression"
      }
    }]
  });
  ctorBody.push({
    type: "IfStatement",
    test: {
      type: "UnaryExpression",
      argument: binOp(ident('that'), "instanceof", ident(node.name)),
      operator: "!"
    },
    consequent: ensureStatement({
      type: "AssignmentExpression",
      left: ident('that'),
      right: {
        type: "CallExpression",
        callee: makeVariableName('Object.create'),
        arguments: [proto]
      },
      operator: '='
    })
  });
  ctorBody.push({
    type: "IfStatement",
    test: {
      type: "CallExpression",
      callee: member(proto, ident('hasOwnProperty')),
      arguments: [literal('__init__')]
    },
    consequent: ensureStatement({
      type: "CallExpression",
      callee: member(member(proto, ident('__init__')), ident('apply')),
      arguments: [ident('that'), ident('arguments')]
    })
  });
  if (base) {
    ctorBody.push(ensureStatement({
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: base,
        property: ident('apply'),
        computed: false
      },
      arguments: [ident('that'), ident('arguments')]
    }));
  }
  ctorBody.push({
    type: "ReturnStatement",
    argument: ident('that')
  });
  body.push({
    type: "FunctionDeclaration",
    id: ident(node.name),
    params: [],
    body: {
      type: "BlockStatement",
      body: ctorBody
    }
  });
  if (base) {
    body.push({
      type: "AssignmentExpression",
      left: proto,
      right: {
        type: "CallExpression",
        callee: makeVariableName('Object.create'),
        arguments: [member(base, ident('prototype'))]
      },
      operator: "="
    });
  }
  body = body.concat(transform(node.body, nctx));
  body.push({
    type: "ReturnStatement",
    argument: ident(node.name)
  });
  return {
    "type": "VariableDeclaration",
    "declarations": [{
      "type": "VariableDeclarator",
      "id": ident(node.name),
      "init": {
        type: "CallExpression",
        callee: {
          type: "FunctionExpression",
          params: [],
          body: {
            type: "BlockStatement",
            body: ensureStatement(body)
          }
        },
        arguments: []
      }
    }],
    "kind": ctx.varType || 'var'
  };
}
function tranformContinue(node, ctx) {
  return {
    type: "ContinueStatement"
  };
}
function makeCop(left, op, right) {
  var fxOps = {
    "In_": "in",
    "In": "in",
    "NotIn": "in"
  };
  var opName = getOpName(op);
  if (opName in fxOps) {
    var call = {
      type: "CallExpression",
      callee: makeVariableName("__pythonRuntime.ops." + fxOps[opName]),
      arguments: [left, right]
    };
    if (opName == "NotIn") {
      return {
        type: "UnaryExpression",
        argument: call,
        operator: "!"
      };
    } else {
      return call;
    }
  }
  var operators = {
    "Eq": "===",
    "NotEq": "!==",
    "LtE": "<=",
    "Lt": "<",
    "GtE": ">=",
    "Gt": ">",
    "Is": "===",
    "IsNot": "!=="
  };
  if (!(opName in operators)) abort("Unsuported Compare operator: " + opName);
  return binOp(left, operators[opName], right);
}
function transformCompare(node, ctx) {
  var left = transform(node.left, ctx);
  var result;
  for (var i = 0; i < node.comparators.length; ++i) {
    var right = transform(node.comparators[i], ctx);
    var cop = makeCop(left, node.ops[i], right);
    if (result) {
      result = logicOp(result, '&&', cop);
    } else {
      result = cop;
    }
    left = right;
  }
  return result;
}
function transformDel(node, ctx) {
  var result = [];
  for (var i = 0; i < node.targets.length; ++i) {
    var st = node.targets[i];
    var partial = transform(st, ctx);
    result.push({
      type: "AssignmentExpression",
      operator: "=",
      left: partial,
      right: {
        type: "UnaryExpression",
        argument: literal(0),
        operator: 'void',
        prefix: true
      }
    });
  }
  return ensureStatement({
    type: "SequenceExpression",
    expressions: result
  });
}
function transformDict(node, ctx) {
  var args = [];
  for (var i = 0; i < node.keys.length; ++i) {
    args.push({
      type: "ArrayExpression",
      elements: [transform(node.keys[i], ctx), transform(node.values[i], ctx)]
    });
  }
  return {
    type: "NewExpression",
    callee: makeVariableName("__pythonRuntime.objects.dict"),
    arguments: args
  };
}
function transformExpr(node, ctx) {
  return {
    type: "ExpressionStatement",
    expression: transform(node.value, ctx)
  };
}
function assignPossiblyWithDeclaration(target, value, ctx) {
  var left = target._astname ? transform(target, ctx) : target;
  var varible;
  if (left.type === "Identifier") varible = left.name;
  if (!varible || !ctx || !ctx.locals || ctx.locals[varible]) {
    return {
      type: "ExpressionStatement",
      expression: {
        type: "AssignmentExpression",
        operator: "=",
        left: left,
        right: value
      }
    };
  }
  ctx.locals[varible] = true;
  return {
    type: "VariableDeclaration",
    declarations: [{
      type: "VariableDeclarator",
      id: left,
      init: value
    }],
    kind: ctx.varType || 'var'
  };
}
function createTupleUnpackingAssign(target, value, ctx) {
  if (target._astname === 'Tuple') {
    var result = [];
    var tn = createTempName("right");
    result.push({
      type: "VariableDeclaration",
      kind: "var",
      declarations: [{
        type: "VariableDeclarator",
        id: ident(tn),
        init: value
      }]
    });
    for (var i = 0; i < target.elts.length; ++i) {
      result.push.apply(result, createTupleUnpackingAssign(target.elts[i], {
        type: "MemberExpression",
        object: ident(tn),
        property: literal(i),
        computed: true
      }, ctx));
    }
    return result;
  }
  return [assignPossiblyWithDeclaration(target, value, ctx)];
}
function createForLoop(iident, tident, iter, target, body, ctx) {
  body = createTupleUnpackingAssign(target, {
    type: "MemberExpression",
    object: tident,
    property: iident,
    computed: true
  }, ctx).concat(body);
  var riter = ternary({
    type: "CallExpression",
    callee: makeVariableName("Array.isArray"),
    arguments: [iter]
  }, iter, {
    type: "CallExpression",
    callee: makeVariableName("Object.keys"),
    arguments: [iter]
  });
  return {
    type: "ForStatement",
    init: {
      "type": "VariableDeclaration",
      "declarations": [{
        "type": "VariableDeclarator",
        "id": iident,
        "init": literal(0)
      }, {
        "type": "VariableDeclarator",
        "id": tident,
        "init": riter
      }],
      "kind": ctx.varType
    },
    test: binOp(iident, '<', {
      type: "MemberExpression",
      object: tident,
      property: {
        type: "Identifier",
        name: "length"
      }
    }),
    update: {
      "type": "UpdateExpression",
      "operator": "++",
      "prefix": true,
      "argument": iident
    },
    body: {
      type: "BlockStatement",
      body: body
    }
  };
}
function transformFor(node, ctx) {
  var name = createTempName('idx');
  var iident = ident(name);
  var tname = createTempName('target');
  var tident = {
    type: "Identifier",
    name: tname
  };
  var iter = transform(node.iter, ctx);
  var body = ensureStatement(transform(node.body, ctx));
  if (node.orelse && node.orelse.length > 0) abort("else: for-else statement unsupported.");
  return createForLoop(iident, tident, iter, node.target, body, ctx);
}
function prepareFunctionBody(node, ctx) {
  var args = node.args.args.slice(0);
  if (ctx.inClass) {
    //TODO: Make sure it's named self, maybe?
    args.shift();
  }
  var hasAnyArguments = args.length > 0 || node.args.vararg || node.args.kwarg;
  var nctx = {
    locals: Object.create(null),
    varType: ctx.varType
  };
  var body = ensureStatement(transform(node.body, nctx));
  var premble = [];
  if (ctx.inClass) {
    premble.push({
      "type": "VariableDeclaration",
      "declarations": [{
        "type": "VariableDeclarator",
        "id": ident('self'),
        "init": {
          type: "ThisExpression"
        }
      }],
      "kind": "var"
    });
  }
  if (hasAnyArguments) {
    var hasParams = createTempName('hasParams');
    var param0 = createTempName('param0');
    var realArgCount = createTempName('realArgCount');
    var argLen = makeVariableName('arguments.length');
    var argN = {
      type: "MemberExpression",
      object: ident('arguments'),
      property: binOp(argLen, '-', literal(1)),
      computed: true
    };
    var argNKeywords = {
      type: "MemberExpression",
      object: argN,
      property: ident('keywords'),
      computed: false
    };
    premble.push({
      "type": "VariableDeclaration",
      "declarations": [{
        "type": "VariableDeclarator",
        "id": ident(hasParams),
        "init": logicOp(binOp(argLen, '>', literal(0)), '&&', logicOp(argN, '&&', argNKeywords))
      }],
      "kind": "var"
    });
    var main = [];
    main.push({
      "type": "VariableDeclaration",
      "declarations": [{
        "type": "VariableDeclarator",
        "id": ident(param0),
        "init": ternary(ident(hasParams), argNKeywords, {
          type: "ObjectExpression",
          properties: []
        })
      }, {
        "type": "VariableDeclarator",
        "id": ident(realArgCount),
        "init": binOp(argLen, '-', ternary(ident(hasParams), literal(1), literal(0)))
      }],
      "kind": "var"
    });
    for (var i = 0; i < args.length; ++i) {
      var a = node.args.args[i];
      var didx = i - (node.args.args.length - node.args.defaults.length);
      var def = didx >= 0 ? transform(node.args.defaults[didx], ctx) : ident('undefined');
      main.push({
        type: "IfStatement",
        test: binOp(ident(realArgCount), '<', literal(i + 1)),
        consequent: ensureStatement({
          type: "AssignmentExpression",
          operator: "=",
          left: ident(a.id),
          right: ternary(binOp(literal(a.id), 'in', ident(param0)), {
            type: "MemberExpression",
            object: ident(param0),
            property: ident(a.id),
            computed: false
          }, def)
        })
      });
    }
    if (node.args.vararg) {
      main.push({
        "type": "VariableDeclaration",
        "declarations": [{
          "type": "VariableDeclarator",
          "id": ident(node.args.vararg),
          "init": {
            type: "CallExpression",
            callee: makeVariableName("Array.prototype.slice.call"),
            arguments: [ident('arguments'), literal(node.args.args.length), hasAnyArguments ? ident(realArgCount) : undefined]
          }
        }],
        "kind": "var"
      });
    }
    if (node.args.kwarg) {
      for (var i = 0; i < node.args.args.length; ++i) {
        main.push(ensureStatement({
          type: "UnaryExpression",
          operator: "delete",
          argument: {
            type: "MemberExpression",
            object: ident(param0),
            property: ident(node.args.args[i].id),
            computed: false
          }
        }));
      }
      main.push({
        "type": "VariableDeclaration",
        "declarations": [{
          "type": "VariableDeclarator",
          "id": ident(node.args.kwarg),
          "init": ident(param0)
        }],
        "kind": "var"
      });
    }
    premble = premble.concat(main); //TODO: If we dont have defauts, we can guard this with __hasParams
  }

  body = premble.concat(body);
  var params = transform(args, ctx);
  return {
    premble: premble,
    body: body,
    params: params
  };
}
function transformFunctionDef(node, ctx) {
  var data = prepareFunctionBody(node, ctx);
  if (ctx.writeTarget) {
    return ensureStatement({
      type: "AssignmentExpression",
      left: {
        type: "MemberExpression",
        object: ctx.writeTarget,
        property: ident(node.name)
      },
      right: {
        type: "FunctionExpression",
        name: ident(node.name),
        params: data.params,
        body: {
          type: "BlockStatement",
          body: data.body
        }
      },
      operator: '='
    });
  } else {
    return {
      type: "FunctionDeclaration",
      id: {
        type: "Identifier",
        name: node.name.v
      },
      params: data.params,
      body: {
        type: "BlockStatement",
        body: data.body
      }
    };
  }
}
function transformGlobal(node, ctx) {
  for (var i = 0; i < node.names.length; ++i) {
    ctx.locals[node.names[i].v] = true;
  }
  return [];
}
function transformIf(node, ctx) {
  var body = ensureStatement(transform(node.body, ctx));
  return {
    type: "IfStatement",
    test: transform(node.test, ctx),
    consequent: {
      type: "BlockStatement",
      body: body
    },
    alternate: node.orelse && node.orelse.length > 0 ? {
      type: "BlockStatement",
      body: ensureStatement(transform(node.orelse, ctx))
    } : undefined
  };
}
function transformLambda(node, ctx) {
  var data = prepareFunctionBody(node, ctx);

  //TODO: This is pretty sketchy.
  var last = data.body[data.body.length - 1];
  data.body[data.body.length - 1] = {
    type: "ReturnStatement",
    argument: last.expression
  };
  return {
    type: "FunctionExpression",
    params: data.params,
    body: {
      type: "BlockStatement",
      body: data.body
    }
  };
}
function transformList(node, ctx) {
  var call = {
    type: "CallExpression",
    callee: makeVariableName("__pythonRuntime.objects.list"),
    arguments: transform(node.elts, ctx)
  };
  return call;
}
function transformListComp(node, ctx) {
  var body = [];
  var aggrigator = createTempName('result');
  body.push({
    "type": "VariableDeclaration",
    "declarations": [{
      "type": "VariableDeclarator",
      "id": ident(aggrigator),
      "init": {
        type: "NewExpression",
        callee: makeVariableName('__pythonRuntime.objects.list'),
        arguments: []
      }
    }],
    "kind": "var"
  });
  var insideBody = [];
  insideBody.push(ensureStatement({
    type: "CallExpression",
    callee: {
      type: "MemberExpression",
      object: ident(aggrigator),
      property: ident('push'),
      computed: false
    },
    arguments: [transform(node.elt, ctx)]
  }));

  //if ( node.generators.length !== 1 ) abort("Unsuported number of generators");
  var gen = node.generators[0];
  for (var g = node.generators.length - 1; g >= 0; --g) {
    var idxName = createTempName('idx');
    var listName = createTempName("list" + g);
    var iterName = createTempName('iter');
    var gen = node.generators[g];
    for (var i = 0; i < gen.ifs.length; ++i) {
      insideBody.unshift({
        type: "IfStatement",
        test: {
          type: "UnaryExpression",
          argument: transform(gen.ifs[i], ctx),
          operator: "!"
        },
        consequent: {
          type: "ContinueStatement"
        }
      });
    }
    insideBody = [{
      type: "VariableDeclaration",
      kind: "var",
      declarations: [{
        type: "VariableDeclarator",
        id: ident(listName),
        init: transform(gen.iter, ctx)
      }]
    }, createForLoop(ident(idxName), ident(iterName), ident(listName), gen.target, insideBody, ctx)];
  }
  body.push.apply(body, insideBody);
  body.push({
    type: "ReturnStatement",
    argument: ident(aggrigator)
  });
  var expr = {
    type: "FunctionExpression",
    params: [],
    body: {
      type: "BlockStatement",
      body: body
    }
  };
  return {
    type: "CallExpression",
    callee: expr,
    arguments: []
  };
}
function transformModule(node, ctx) {
  return {
    type: "Program",
    body: ensureStatement(transform(node.body, ctx))
  };
}
function transformName(node, ctx) {
  if (node.id.v === 'True') return {
    type: "Literal",
    value: true,
    raw: "true"
  };
  if (node.id.v === 'False') return {
    type: "Literal",
    value: false,
    raw: "false"
  };
  if (node.id.v === 'None') return {
    type: "Literal",
    value: null,
    raw: "null"
  };
  if (node.id.v === 'random') return makeVariableName('rand');
  return ident(node.id);
}
function transformNum(node, ctx) {
  return literal(node.n);
}
function transformPrint(node, ctx) {
  return {
    type: "CallExpression",
    callee: makeVariableName("debug"),
    arguments: transform(node.values, ctx)
  };
}
function transformReturn(node, ctx) {
  return {
    type: "ReturnStatement",
    argument: node.value ? transform(node.value, ctx) : undefined
  };
}
function transformStr(node, ctx) {
  return literal(node.s.valueOf());
}
function transformTuple(node, ctx) {
  var call = {
    type: "CallExpression",
    callee: makeVariableName("__pythonRuntime.objects.tuple"),
    arguments: transform(node.elts, ctx)
  };
  return call;
}
function transformSubscript(node, ctx) {
  //TODO: Do silly pythonic list offset logic
  var val = transform(node.value, ctx);
  if (node.slice.value) {
    var lu = transform(node.slice.value, ctx);
    lu = {
      type: "CallExpression",
      callee: makeVariableName("__pythonRuntime.ops.subscriptIndex"),
      arguments: [val, lu]
    };
    return {
      type: "MemberExpression",
      computed: true,
      object: val,
      property: lu
    };
  }
  return {
    type: "CallExpression",
    callee: makeVariableName('__pythonRuntime.internal.slice'),
    arguments: [val, node.slice.lower ? transform(node.slice.lower, ctx) : ident('undefined'), node.slice.upper ? transform(node.slice.upper, ctx) : ident('undefined'), node.slice.step ? transform(node.slice.step, ctx) : ident('undefined')]
  };
}
function transformPass(node, ctx) {
  return {
    type: "EmptyStatement"
  };
}
function transformUnaryOp(node, ctx) {
  var argument = transform(node.operand, ctx);
  var fxOps = {
    "Add": "add",
    "Mult": "multiply"
  };
  var opName = getOpName(node.op);
  if (opName in fxOps) {
    var call = {
      type: "CallExpression",
      callee: makeVariableName("__pythonRuntime.ops." + fxOps[opName]),
      arguments: [argument]
    };
    return call;
  }
  var operators = {
    "Not": "!",
    "USub": "-",
    "Invert": "~"
  };
  if (!(opName in operators)) abort("Unknown unary operator: " + opName);
  return {
    type: "UnaryExpression",
    argument: argument,
    operator: operators[opName]
  };
}
function transformWhile(node, ctx) {
  if (node.orelse && node.orelse.length > 0) abort("else: statement for while unsupported.");
  return {
    type: "WhileStatement",
    test: transform(node.test, ctx),
    body: {
      type: "BlockStatement",
      body: ensureStatement(transform(node.body, ctx))
    }
  };
}

// module.exports = transform;

'use strict';

/* ---- /Users/rob/skulpty/lib/preamble.js ---- */

var goog = {
  global: global
};
var COMPILED = false;
goog.exportSymbol = function () {};
goog.require = function () {};
goog.inherits = function (childCtor, parentCtor) {
  if (!parentCtor) throw new Error("Cant inherit from undefined?");
  /** @constructor */
  function tempCtor() {}
  ;
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  /** @override */
  childCtor.prototype.constructor = childCtor;
};
goog.asserts = {
  assert: function (what, why) {
    if (!what) throw new Error("AssertionFailed:" + why);
  }
};
var Sk = Sk || {};
Sk.builtin = Sk.builtin || {};
Sk.builtin.bool = Boolean;
Sk.builtin.int_ = function Int(x) {
  this.v = x;
};
Sk.builtin.int_.prototype.threshold$ = Infinity;
Sk.builtin.int_.prototype.valueOf = function () {
  return this.v.valueOf();
};
Sk.builtin.tuple = function (x) {
  this.v = Array.prototype.slice.call(x, 0);
};
Sk.builtin.tuple.prototype.sq$length = function () {
  return this.length;
};
Sk.builtin.float_ = Number;
Sk.builtin.long = Number;
Sk.builtin.func = function (fx) {
  return fx;
};

/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/type.js ---- */

if (Sk.builtin === undefined) {
  Sk.builtin = {};
}

/**
 * Maps Python dunder names to the Skulpt Javascript function names that
 * implement them.
 *
 * Note: __add__, __mul__, and __rmul__ can be used for either numeric or
 * sequence types. Here, they default to the numeric versions (i.e. nb$add,
 * nb$multiply, and nb$reflected_multiply). This works because Sk.abstr.binary_op_
 * checks for the numeric shortcuts and not the sequence shortcuts when computing
 * a binary operation.
 *
 * Because many of these functions are used in contexts in which Skulpt does not
 * [yet] handle suspensions, the assumption is that they must not suspend. However,
 * some of these built-in functions are acquiring 'canSuspend' arguments to signal
 * where this is not the case. These need to be spliced out of the argument list before
 * it is passed to python. Array values in this map contain [dunderName, argumentIdx],
 * where argumentIdx specifies the index of the 'canSuspend' boolean argument.
 *
 * @type {Object}
 */
Sk.dunderToSkulpt = {
  "__eq__": "ob$eq",
  "__ne__": "ob$ne",
  "__lt__": "ob$lt",
  "__le__": "ob$le",
  "__gt__": "ob$gt",
  "__ge__": "ob$ge",
  "__hash__": "tp$hash",
  "__abs__": "nb$abs",
  "__neg__": "nb$negative",
  "__pos__": "nb$positive",
  "__int__": "nb$int_",
  "__long__": "nb$lng",
  "__float__": "nb$float_",
  "__add__": "nb$add",
  "__radd__": "nb$reflected_add",
  "__sub__": "nb$subtract",
  "__rsub__": "nb$reflected_subtract",
  "__mul__": "nb$multiply",
  "__rmul__": "nb$reflected_multiply",
  "__div__": "nb$divide",
  "__rdiv__": "nb$reflected_divide",
  "__floordiv__": "nb$floor_divide",
  "__rfloordiv__": "nb$reflected_floor_divide",
  "__mod__": "nb$remainder",
  "__rmod__": "nb$reflected_remainder",
  "__divmod__": "nb$divmod",
  "__rdivmod__": "nb$reflected_divmod",
  "__pow__": "nb$power",
  "__rpow__": "nb$reflected_power",
  "__contains__": "sq$contains",
  "__len__": ["sq$length", 1],
  "__get__": ["tp$descr_get", 3],
  "__set__": ["tp$descr_set", 3]
};

/**
 *
 * @constructor
 *
 * @param {*} name name or object to get type of, if only one arg
 *
 * @param {Sk.builtin.tuple=} bases
 *
 * @param {Object=} dict
 *
 *
 * This type represents the type of `type'. *Calling* an instance of
 * this builtin type named "type" creates class objects. The resulting
 * class objects will have various tp$xyz attributes on them that allow
 * for the various operations on that object.
 *
 * calling the type or calling an instance of the type? or both?
 */
Sk.builtin.type = function (name, bases, dict) {
  var mro;
  var obj;
  var klass;
  var v;
  if (bases === undefined && dict === undefined) {
    // 1 arg version of type()
    // the argument is an object, not a name and returns a type object
    obj = name;
    return obj.ob$type;
  } else {
    // argument dict must be of type dict
    if (dict.tp$name !== "dict") {
      throw new Sk.builtin.TypeError("type() argument 3 must be dict, not " + Sk.abstr.typeName(dict));
    }

    // checks if name must be string
    if (!Sk.builtin.checkString(name)) {
      throw new Sk.builtin.TypeError("type() argument 1 must be str, not " + Sk.abstr.typeName(name));
    }

    // argument bases must be of type tuple
    if (bases.tp$name !== "tuple") {
      throw new Sk.builtin.TypeError("type() argument 2 must be tuple, not " + Sk.abstr.typeName(bases));
    }

    // type building version of type

    // dict is the result of running the classes code object
    // (basically the dict of functions). those become the prototype
    // object of the class).

    /**
    * The constructor is a stub, that gets called from object.__new__
    * @constructor
    */
    klass = function (args, kws) {
      var args_copy;

      // Call up through the chain in case there's a built-in object
      // whose constructor we need to initialise
      if (klass.prototype.tp$base !== undefined) {
        if (klass.prototype.tp$base.sk$klass) {
          klass.prototype.tp$base.call(this, args, kws);
        } else {
          // Call super constructor if subclass of a builtin
          args_copy = args.slice();
          args_copy.unshift(klass, this);
          Sk.abstr.superConstructor.apply(undefined, args_copy);
        }
      }
      this["$d"] = new Sk.builtin.dict([]);
      this["$d"].mp$ass_subscript(new Sk.builtin.str("__dict__"), this["$d"]);
    };
    var _name = Sk.ffi.remapToJs(name); // unwrap name string to js for latter use

    var inheritsBuiltin = false;

    // Invoking the class object calls __new__() to generate a new instance,
    // then __init__() to initialise it
    klass.tp$call = function (args, kws) {
      var newf = Sk.builtin.type.typeLookup(klass, "__new__"),
        newargs;
      var self;
      args = args || [];
      kws = kws || [];
      if (newf === undefined || newf === Sk.builtin.object.prototype["__new__"]) {
        // No override -> just call the constructor
        self = new klass(args, kws);
        newf = undefined;
      } else {
        newargs = args.slice();
        newargs.unshift(klass);
        self = Sk.misceval.applyOrSuspend(newf, undefined, undefined, kws, newargs);
      }
      return Sk.misceval.chain(self, function (s) {
        var init = Sk.builtin.type.typeLookup(s.ob$type, "__init__");
        self = s; // in case __new__ suspended

        if (init !== undefined) {
          args.unshift(self);
          return Sk.misceval.applyOrSuspend(init, undefined, undefined, kws, args);
        } else if (newf === undefined && (args.length !== 0 || kws.length !== 0) && !inheritsBuiltin) {
          // We complain about spurious constructor arguments if neither __new__
          // nor __init__ were overridden
          throw new Sk.builtin.TypeError("__init__() got unexpected argument(s)");
        }
      }, function (r) {
        if (r !== Sk.builtin.none.none$ && r !== undefined) {
          throw new Sk.builtin.TypeError("__init__() should return None, not " + Sk.abstr.typeName(r));
        } else {
          return self;
        }
      });
    };
    if (bases.v.length === 0 && Sk.python3) {
      // new style class, inherits from object by default
      Sk.abstr.setUpInheritance(_name, klass, Sk.builtin.object);
    }
    var parent,
      it,
      firstAncestor,
      builtin_bases = [];
    // Set up inheritance from any builtins
    for (it = bases.tp$iter(), parent = it.tp$iternext(); parent !== undefined; parent = it.tp$iternext()) {
      if (firstAncestor === undefined) {
        firstAncestor = parent;
      }
      while (parent.sk$klass && parent.prototype.tp$base) {
        parent = parent.prototype.tp$base;
      }
      if (!parent.sk$klass && builtin_bases.indexOf(parent) < 0) {
        builtin_bases.push(parent);
        inheritsBuiltin = true;
      }
    }
    if (builtin_bases.length > 1) {
      throw new Sk.builtin.TypeError("Multiple inheritance with more than one builtin type is unsupported");
    }

    // Javascript does not support multiple inheritance, so only the first
    // base (if any) will directly inherit in Javascript
    if (firstAncestor !== undefined) {
      goog.inherits(klass, firstAncestor);
      if (firstAncestor.prototype instanceof Sk.builtin.object || firstAncestor === Sk.builtin.object) {
        klass.prototype.tp$base = firstAncestor;
      }
    }
    klass.prototype.tp$name = _name;
    klass.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(_name, klass);

    // set __module__ if not present (required by direct type(name, bases, dict) calls)
    var module_lk = new Sk.builtin.str("__module__");
    if (dict.mp$lookup(module_lk) === undefined) {
      dict.mp$ass_subscript(module_lk, Sk.globals["__name__"]);
    }

    // copy properties into our klass object
    // uses python iter methods
    var k;
    for (it = dict.tp$iter(), k = it.tp$iternext(); k !== undefined; k = it.tp$iternext()) {
      v = dict.mp$subscript(k);
      if (v === undefined) {
        v = null;
      }
      klass.prototype[k.v] = v;
      klass[k.v] = v;
    }
    klass["__class__"] = klass;
    klass["__name__"] = name;
    klass.sk$klass = true;
    klass.prototype["$r"] = function () {
      var cname;
      var mod;
      var reprf = this.tp$getattr("__repr__");
      if (reprf !== undefined && reprf.im_func !== Sk.builtin.object.prototype["__repr__"]) {
        return Sk.misceval.apply(reprf, undefined, undefined, undefined, []);
      }
      if (klass.prototype.tp$base !== undefined && klass.prototype.tp$base !== Sk.builtin.object && klass.prototype.tp$base.prototype["$r"] !== undefined) {
        // If subclass of a builtin which is not object, use that class' repr
        return klass.prototype.tp$base.prototype["$r"].call(this);
      } else {
        // Else, use default repr for a user-defined class instance
        mod = dict.mp$subscript(module_lk); // lookup __module__
        cname = "";
        if (mod) {
          cname = mod.v + ".";
        }
        return new Sk.builtin.str("<" + cname + _name + " object>");
      }
    };
    klass.prototype.tp$setattr = function (name, data, canSuspend) {
      var r,
        /** @type {(Object|undefined)} */setf = Sk.builtin.object.prototype.GenericGetAttr.call(this, "__setattr__");
      if (setf !== undefined) {
        r = Sk.misceval.callsimOrSuspend( /** @type {Object} */setf, new Sk.builtin.str(name), data);
        return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);
      }
      return Sk.builtin.object.prototype.GenericSetAttr.call(this, name, data);
    };
    klass.prototype.tp$getattr = function (name, canSuspend) {
      var r, /** @type {(Object|undefined)} */getf;
      // Convert AttributeErrors back into 'undefined' returns to match the tp$getattr
      // convention
      var callCatchUndefined = function () {
        return Sk.misceval.tryCatch(function () {
          return Sk.misceval.callsimOrSuspend( /** @type {Object} */getf, new Sk.builtin.str(name));
        }, function (e) {
          if (e instanceof Sk.builtin.AttributeError) {
            return undefined;
          } else {
            throw e;
          }
        });
      };
      getf = Sk.builtin.object.prototype.GenericGetAttr.call(this, "__getattribute__");
      if (getf !== undefined) {
        r = callCatchUndefined();
      } else {
        r = Sk.builtin.object.prototype.GenericGetAttr.call(this, name);
        if (r === undefined) {
          getf = Sk.builtin.object.prototype.GenericGetAttr.call(this, "__getattr__");
          if (getf !== undefined) {
            r = callCatchUndefined();
          }
        }
      }
      return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);
    };
    klass.prototype.tp$str = function () {
      var strf = this.tp$getattr("__str__");
      if (strf !== undefined && strf.im_func !== Sk.builtin.object.prototype["__str__"]) {
        return Sk.misceval.apply(strf, undefined, undefined, undefined, []);
      }
      if (klass.prototype.tp$base !== undefined && klass.prototype.tp$base !== Sk.builtin.object && klass.prototype.tp$base.prototype.tp$str !== undefined) {
        // If subclass of a builtin which is not object, use that class' repr
        return klass.prototype.tp$base.prototype.tp$str.call(this);
      }
      return this["$r"]();
    };
    klass.prototype.tp$length = function (canSuspend) {
      var r = Sk.misceval.chain(Sk.abstr.gattr(this, "__len__", canSuspend), function (lenf) {
        return Sk.misceval.applyOrSuspend(lenf, undefined, undefined, undefined, []);
      });
      return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);
    };
    klass.prototype.tp$call = function (args, kw) {
      return Sk.misceval.chain(this.tp$getattr("__call__", true), function (callf) {
        if (callf === undefined) {
          throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(this) + "' object is not callable");
        }
        return Sk.misceval.applyOrSuspend(callf, undefined, undefined, kw, args);
      });
    };
    klass.prototype.tp$iter = function () {
      var iterf = this.tp$getattr("__iter__");
      if (iterf === undefined) {
        throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(this) + "' object is not iterable");
      }
      return Sk.misceval.callsim(iterf);
    };
    klass.prototype.tp$iternext = function (canSuspend) {
      var self = this;
      var r = Sk.misceval.chain(self.tp$getattr("next", canSuspend), function ( /** {Object} */iternextf) {
        if (iternextf === undefined) {
          throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(self) + "' object is not iterable");
        }
        return Sk.misceval.tryCatch(function () {
          return Sk.misceval.callsimOrSuspend(iternextf);
        }, function (e) {
          if (e instanceof Sk.builtin.StopIteration) {
            return undefined;
          } else {
            throw e;
          }
        });
      });
      return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);
    };
    klass.prototype.tp$getitem = function (key, canSuspend) {
      var getf = this.tp$getattr("__getitem__", canSuspend),
        r;
      if (getf !== undefined) {
        r = Sk.misceval.applyOrSuspend(getf, undefined, undefined, undefined, [key]);
        return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);
      }
      throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(this) + "' object does not support indexing");
    };
    klass.prototype.tp$setitem = function (key, value, canSuspend) {
      var setf = this.tp$getattr("__setitem__", canSuspend),
        r;
      if (setf !== undefined) {
        r = Sk.misceval.applyOrSuspend(setf, undefined, undefined, undefined, [key, value]);
        return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);
      }
      throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(this) + "' object does not support item assignment");
    };
    if (bases) {
      //print("building mro for", name);
      //for (var i = 0; i < bases.length; ++i)
      //print("base[" + i + "]=" + bases[i].tp$name);
      klass["$d"] = new Sk.builtin.dict([]);
      klass["$d"].mp$ass_subscript(Sk.builtin.type.basesStr_, bases);
      mro = Sk.builtin.type.buildMRO(klass);
      klass["$d"].mp$ass_subscript(Sk.builtin.type.mroStr_, mro);
      klass.tp$mro = mro;
      //print("mro result", Sk.builtin.repr(mro).v);
    }

    // fix for class attributes
    klass.tp$setattr = Sk.builtin.type.prototype.tp$setattr;
    var shortcutDunder = function (skulpt_name, magic_name, magic_func, canSuspendIdx) {
      klass.prototype[skulpt_name] = function () {
        var args = Array.prototype.slice.call(arguments),
          canSuspend;
        args.unshift(magic_func, this);
        if (canSuspendIdx !== null) {
          canSuspend = args[canSuspendIdx + 1];
          args.splice(canSuspendIdx + 1, 1);
          if (canSuspend) {
            return Sk.misceval.callsimOrSuspend.apply(undefined, args);
          }
        }
        return Sk.misceval.callsim.apply(undefined, args);
      };
    };

    // Register skulpt shortcuts to magic methods defined by this class.
    // Dynamically deflined methods (eg those returned by __getattr__())
    // cannot be used by these magic functions; this is consistent with
    // how CPython handles "new-style" classes:
    // https://docs.python.org/2/reference/datamodel.html#special-method-lookup-for-old-style-classes
    var dunder, skulpt_name, canSuspendIdx;
    for (dunder in Sk.dunderToSkulpt) {
      skulpt_name = Sk.dunderToSkulpt[dunder];
      if (typeof skulpt_name === "string") {
        canSuspendIdx = null;
      } else {
        canSuspendIdx = skulpt_name[1];
        skulpt_name = skulpt_name[0];
      }
      if (klass[dunder]) {
        // scope workaround
        shortcutDunder(skulpt_name, dunder, klass[dunder], canSuspendIdx);
      }
    }
    return klass;
  }
};

/**
 *
 */
Sk.builtin.type.makeTypeObj = function (name, newedInstanceOfType) {
  Sk.builtin.type.makeIntoTypeObj(name, newedInstanceOfType);
  return newedInstanceOfType;
};
Sk.builtin.type.makeIntoTypeObj = function (name, t) {
  goog.asserts.assert(name !== undefined);
  goog.asserts.assert(t !== undefined);
  t.ob$type = Sk.builtin.type;
  t.tp$name = name;
  t["$r"] = function () {
    var ctype;
    var mod = t.__module__;
    var cname = "";
    if (mod) {
      cname = mod.v + ".";
    }
    ctype = "class";
    if (!mod && !t.sk$klass && !Sk.python3) {
      ctype = "type";
    }
    return new Sk.builtin.str("<" + ctype + " '" + cname + t.tp$name + "'>");
  };
  t.tp$str = undefined;
  t.tp$getattr = Sk.builtin.type.prototype.tp$getattr;
  t.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
  t.tp$richcompare = Sk.builtin.type.prototype.tp$richcompare;
  t.sk$type = true;
  return t;
};
Sk.builtin.type.ob$type = Sk.builtin.type;
Sk.builtin.type.tp$name = "type";
Sk.builtin.type["$r"] = function () {
  if (Sk.python3) {
    return new Sk.builtin.str("<class 'type'>");
  } else {
    return new Sk.builtin.str("<type 'type'>");
  }
};

//Sk.builtin.type.prototype.tp$descr_get = function() { print("in type descr_get"); };

//Sk.builtin.type.prototype.tp$name = "type";

// basically the same as GenericGetAttr except looks in the proto instead
Sk.builtin.type.prototype.tp$getattr = function (name, canSuspend) {
  var res;
  var tp = this;
  var descr;
  var f;
  if (this["$d"]) {
    res = this["$d"].mp$lookup(new Sk.builtin.str(name));
    if (res !== undefined) {
      return res;
    }
  }
  descr = Sk.builtin.type.typeLookup(tp, name);

  //print("type.tpgetattr descr", descr, descr.tp$name, descr.func_code, name);
  if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {
    f = descr.tp$descr_get;
    // todo;if (f && descr.tp$descr_set) // is a data descriptor if it has a set
    // return f.call(descr, this, this.ob$type);
  }

  if (f) {
    // non-data descriptor
    return f.call(descr, Sk.builtin.none.none$, tp, canSuspend);
  }
  if (descr !== undefined) {
    return descr;
  }
  return undefined;
};
Sk.builtin.type.prototype.tp$setattr = function (name, value) {
  // class attributes are direct properties of the object
  this[name] = value;
};
Sk.builtin.type.typeLookup = function (type, name) {
  var mro = type.tp$mro;
  var pyname = new Sk.builtin.str(name);
  var base;
  var res;
  var i;

  // todo; probably should fix this, used for builtin types to get stuff
  // from prototype
  if (!mro) {
    if (type.prototype) {
      return type.prototype[name];
    }
    return undefined;
  }
  for (i = 0; i < mro.v.length; ++i) {
    base = mro.v[i];
    if (base.hasOwnProperty(name)) {
      return base[name];
    }
    res = base["$d"].mp$lookup(pyname);
    if (res !== undefined) {
      return res;
    }
    if (base.prototype && base.prototype[name] !== undefined) {
      return base.prototype[name];
    }
  }
  return undefined;
};
Sk.builtin.type.mroMerge_ = function (seqs) {
  /*
   var tmp = [];
   for (var i = 0; i < seqs.length; ++i)
   {
   tmp.push(new Sk.builtin.list(seqs[i]));
   }
   print(Sk.builtin.repr(new Sk.builtin.list(tmp)).v);
   */
  var seq;
  var i;
  var next;
  var k;
  var sseq;
  var j;
  var cand;
  var cands;
  var res = [];
  for (;;) {
    for (i = 0; i < seqs.length; ++i) {
      seq = seqs[i];
      if (seq.length !== 0) {
        break;
      }
    }
    if (i === seqs.length) {
      // all empty
      return res;
    }
    cands = [];
    for (i = 0; i < seqs.length; ++i) {
      seq = seqs[i];
      //print("XXX", Sk.builtin.repr(new Sk.builtin.list(seq)).v);
      if (seq.length !== 0) {
        cand = seq[0];
        //print("CAND", Sk.builtin.repr(cand).v);
        OUTER: for (j = 0; j < seqs.length; ++j) {
          sseq = seqs[j];
          for (k = 1; k < sseq.length; ++k) {
            if (sseq[k] === cand) {
              break OUTER;
            }
          }
        }

        // cand is not in any sequences' tail -> constraint-free
        if (j === seqs.length) {
          cands.push(cand);
        }
      }
    }
    if (cands.length === 0) {
      throw new Sk.builtin.TypeError("Inconsistent precedences in type hierarchy");
    }
    next = cands[0];
    // append next to result and remove from sequences
    res.push(next);
    for (i = 0; i < seqs.length; ++i) {
      seq = seqs[i];
      if (seq.length > 0 && seq[0] === next) {
        seq.splice(0, 1);
      }
    }
  }
};
Sk.builtin.type.buildMRO_ = function (klass) {
  // MERGE(klass + mro(bases) + bases)
  var i;
  var bases;
  var all = [[klass]];

  //Sk.debugout("buildMRO for", klass.tp$name);

  var kbases = klass["$d"].mp$subscript(Sk.builtin.type.basesStr_);
  for (i = 0; i < kbases.v.length; ++i) {
    all.push(Sk.builtin.type.buildMRO_(kbases.v[i]));
  }
  bases = [];
  for (i = 0; i < kbases.v.length; ++i) {
    bases.push(kbases.v[i]);
  }
  all.push(bases);
  return Sk.builtin.type.mroMerge_(all);
};

/*
 * C3 MRO (aka CPL) linearization. Figures out which order to search through
 * base classes to determine what should override what. C3 does the "right
 * thing", and it's what Python has used since 2.3.
 *
 * Kind of complicated to explain, but not really that complicated in
 * implementation. Explanations:
 *
 * http://people.csail.mit.edu/jrb/goo/manual.43/goomanual_55.html
 * http://www.python.org/download/releases/2.3/mro/
 * http://192.220.96.201/dylan/linearization-oopsla96.html
 *
 * This implementation is based on a post by Samuele Pedroni on python-dev
 * (http://mail.python.org/pipermail/python-dev/2002-October/029176.html) when
 * discussing its addition to Python.
 */
Sk.builtin.type.buildMRO = function (klass) {
  return new Sk.builtin.tuple(Sk.builtin.type.buildMRO_(klass));
};
Sk.builtin.type.prototype.tp$richcompare = function (other, op) {
  var r2;
  var r1;
  if (other.ob$type != Sk.builtin.type) {
    return undefined;
  }
  if (!this["$r"] || !other["$r"]) {
    return undefined;
  }
  r1 = new Sk.builtin.str(this["$r"]().v.slice(1, 6));
  r2 = new Sk.builtin.str(other["$r"]().v.slice(1, 6));
  if (this["$r"]().v.slice(1, 6) !== "class") {
    r1 = this["$r"]();
    r2 = other["$r"]();
  }
  return r1.tp$richcompare(r2, op);
};

/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/abstract.js ---- */

/**
 * @namespace Sk.abstr
 *
 */
Sk.abstr = {};

//
// Number
//

Sk.abstr.typeName = function (v) {
  var vtypename;
  if (v.tp$name !== undefined) {
    vtypename = v.tp$name;
  } else {
    vtypename = "<invalid type>";
  }
  return vtypename;
};
Sk.abstr.binop_type_error = function (v, w, name) {
  var vtypename = Sk.abstr.typeName(v),
    wtypename = Sk.abstr.typeName(w);
  throw new Sk.builtin.TypeError("unsupported operand type(s) for " + name + ": '" + vtypename + "' and '" + wtypename + "'");
};
Sk.abstr.unop_type_error = function (v, name) {
  var vtypename = Sk.abstr.typeName(v),
    uop = {
      "UAdd": "+",
      "USub": "-",
      "Invert": "~"
    }[name];
  throw new Sk.builtin.TypeError("bad operand type for unary " + uop + ": '" + vtypename + "'");
};

/**
 * lookup and return the LHS object slot function method.  This coudl be either a builtin slot function or a dunder method defined by the user.
 * @param obj
 * @param name
 * @returns {Object|null|undefined}
 * @private
 */
Sk.abstr.boNameToSlotFuncLhs_ = function (obj, name) {
  if (obj === null) {
    return undefined;
  }
  switch (name) {
    case "Add":
      return obj.nb$add ? obj.nb$add : obj["__add__"];
    case "Sub":
      return obj.nb$subtract ? obj.nb$subtract : obj["__sub__"];
    case "Mult":
      return obj.nb$multiply ? obj.nb$multiply : obj["__mul__"];
    case "Div":
      return obj.nb$divide ? obj.nb$divide : obj["__div__"];
    case "FloorDiv":
      return obj.nb$floor_divide ? obj.nb$floor_divide : obj["__floordiv__"];
    case "Mod":
      return obj.nb$remainder ? obj.nb$remainder : obj["__mod__"];
    case "DivMod":
      return obj.nb$divmod ? obj.nb$divmod : obj["__divmod__"];
    case "Pow":
      return obj.nb$power ? obj.nb$power : obj["__pow__"];
    case "LShift":
      return obj.nb$lshift ? obj.nb$lshift : obj["__lshift__"];
    case "RShift":
      return obj.nb$rshift ? obj.nb$rshift : obj["__rshift__"];
    case "BitAnd":
      return obj.nb$and ? obj.nb$and : obj["__and__"];
    case "BitXor":
      return obj.nb$xor ? obj.nb$xor : obj["__xor__"];
    case "BitOr":
      return obj.nb$or ? obj.nb$or : obj["__or__"];
  }
};
Sk.abstr.boNameToSlotFuncRhs_ = function (obj, name) {
  if (obj === null) {
    return undefined;
  }
  switch (name) {
    case "Add":
      return obj.nb$reflected_add ? obj.nb$reflected_add : obj["__radd__"];
    case "Sub":
      return obj.nb$reflected_subtract ? obj.nb$reflected_subtract : obj["__rsub__"];
    case "Mult":
      return obj.nb$reflected_multiply ? obj.nb$reflected_multiply : obj["__rmul__"];
    case "Div":
      return obj.nb$reflected_divide ? obj.nb$reflected_divide : obj["__rdiv__"];
    case "FloorDiv":
      return obj.nb$reflected_floor_divide ? obj.nb$reflected_floor_divide : obj["__rfloordiv__"];
    case "Mod":
      return obj.nb$reflected_remainder ? obj.nb$reflected_remainder : obj["__rmod__"];
    case "DivMod":
      return obj.nb$reflected_divmod ? obj.nb$reflected_divmod : obj["__rdivmod__"];
    case "Pow":
      return obj.nb$reflected_power ? obj.nb$reflected_power : obj["__rpow__"];
    case "LShift":
      return obj.nb$reflected_lshift ? obj.nb$reflected_lshift : obj["__rlshift__"];
    case "RShift":
      return obj.nb$reflected_rshift ? obj.nb$reflected_rshift : obj["__rrshift__"];
    case "BitAnd":
      return obj.nb$reflected_and ? obj.nb$reflected_and : obj["__rand__"];
    case "BitXor":
      return obj.nb$reflected_xor ? obj.nb$reflected_xor : obj["__rxor__"];
    case "BitOr":
      return obj.nb$reflected_or ? obj.nb$reflected_or : obj["__ror__"];
  }
};
Sk.abstr.iboNameToSlotFunc_ = function (obj, name) {
  switch (name) {
    case "Add":
      return obj.nb$inplace_add ? obj.nb$inplace_add : obj["__iadd__"];
    case "Sub":
      return obj.nb$inplace_subtract ? obj.nb$inplace_subtract : obj["__isub__"];
    case "Mult":
      return obj.nb$inplace_multiply ? obj.nb$inplace_multiply : obj["__imul__"];
    case "Div":
      return obj.nb$inplace_divide ? obj.nb$inplace_divide : obj["__idiv__"];
    case "FloorDiv":
      return obj.nb$inplace_floor_divide ? obj.nb$inplace_floor_divide : obj["__ifloordiv__"];
    case "Mod":
      return obj.nb$inplace_remainder;
    case "Pow":
      return obj.nb$inplace_power;
    case "LShift":
      return obj.nb$inplace_lshift ? obj.nb$inplace_lshift : obj["__ilshift__"];
    case "RShift":
      return obj.nb$inplace_rshift ? obj.nb$inplace_rshift : obj["__irshift__"];
    case "BitAnd":
      return obj.nb$inplace_and;
    case "BitOr":
      return obj.nb$inplace_or;
    case "BitXor":
      return obj.nb$inplace_xor ? obj.nb$inplace_xor : obj["__ixor__"];
  }
};
Sk.abstr.uoNameToSlotFunc_ = function (obj, name) {
  if (obj === null) {
    return undefined;
  }
  switch (name) {
    case "USub":
      return obj.nb$negative ? obj.nb$negative : obj["__neg__"];
    case "UAdd":
      return obj.nb$positive ? obj.nb$positive : obj["__pos__"];
    case "Invert":
      return obj.nb$invert ? obj.nb$invert : obj["__invert__"];
  }
};
Sk.abstr.binary_op_ = function (v, w, opname) {
  var wop;
  var ret;
  var vop;

  // All Python inheritance is now enforced with Javascript inheritance
  // (see Sk.abstr.setUpInheritance). This checks if w's type is a strict
  // subclass of v's type
  var w_is_subclass = w.constructor.prototype instanceof v.constructor;

  // From the Python 2.7 docs:
  //
  // "If the right operands type is a subclass of the left operands type and
  // that subclass provides the reflected method for the operation, this
  // method will be called before the left operands non-reflected method.
  // This behavior allows subclasses to override their ancestors operations."
  //
  // -- https://docs.python.org/2/reference/datamodel.html#index-92

  if (w_is_subclass) {
    wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);
    if (wop !== undefined) {
      if (wop.call) {
        ret = wop.call(w, v);
      } else {
        ret = Sk.misceval.callsim(wop, w, v);
      }
      if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {
        return ret;
      }
    }
  }
  vop = Sk.abstr.boNameToSlotFuncLhs_(v, opname);
  if (vop !== undefined) {
    if (vop.call) {
      ret = vop.call(v, w);
    } else {
      ret = Sk.misceval.callsim(vop, v, w);
    }
    if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {
      return ret;
    }
  }
  // Don't retry RHS if failed above
  if (!w_is_subclass) {
    wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);
    if (wop !== undefined) {
      if (wop.call) {
        ret = wop.call(w, v);
      } else {
        ret = Sk.misceval.callsim(wop, w, v);
      }
      if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {
        return ret;
      }
    }
  }
  Sk.abstr.binop_type_error(v, w, opname);
};
Sk.abstr.binary_iop_ = function (v, w, opname) {
  var wop;
  var ret;
  var vop = Sk.abstr.iboNameToSlotFunc_(v, opname);
  if (vop !== undefined) {
    if (vop.call) {
      ret = vop.call(v, w);
    } else {
      // assume that vop is an __xxx__ type method
      ret = Sk.misceval.callsim(vop, v, w);
    }
    if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {
      return ret;
    }
  }
  // If there wasn't an in-place operation, fall back to the binop
  return Sk.abstr.binary_op_(v, w, opname);
};
Sk.abstr.unary_op_ = function (v, opname) {
  var ret;
  var vop = Sk.abstr.uoNameToSlotFunc_(v, opname);
  if (vop !== undefined) {
    if (vop.call) {
      ret = vop.call(v);
    } else {
      // assume that vop is an __xxx__ type method
      ret = Sk.misceval.callsim(vop, v); //  added to be like not-in-place... is this okay?
    }

    if (ret !== undefined) {
      return ret;
    }
  }
  Sk.abstr.unop_type_error(v, opname);
};

//
// handle upconverting a/b from number to long if op causes too big/small a
// result, or if either of the ops are already longs
Sk.abstr.numOpAndPromote = function (a, b, opfn) {
  var tmp;
  var ans;
  if (a === null || b === null) {
    return undefined;
  }
  if (typeof a === "number" && typeof b === "number") {
    ans = opfn(a, b);
    // todo; handle float   Removed RNL (bugs in lng, and it should be a question of precision, not magnitude -- this was just wrong)
    if ((ans > Sk.builtin.int_.threshold$ || ans < -Sk.builtin.int_.threshold$) && Math.floor(ans) === ans) {
      return [Sk.builtin.lng.fromInt$(a), Sk.builtin.lng.fromInt$(b)];
    } else {
      return ans;
    }
  } else if (a === undefined || b === undefined) {
    throw new Sk.builtin.NameError("Undefined variable in expression");
  }
  if (a.constructor === Sk.builtin.lng) {
    return [a, b];
  } else if ((a.constructor === Sk.builtin.int_ || a.constructor === Sk.builtin.float_) && b.constructor === Sk.builtin.complex) {
    // special case of upconverting nmber and complex
    // can we use here the Sk.builtin.checkComplex() method?
    tmp = new Sk.builtin.complex(a);
    return [tmp, b];
  } else if (a.constructor === Sk.builtin.int_ || a.constructor === Sk.builtin.float_) {
    return [a, b];
  } else if (typeof a === "number") {
    tmp = Sk.builtin.assk$(a);
    return [tmp, b];
  } else {
    return undefined;
  }
};
Sk.abstr.boNumPromote_ = {
  "Add": function (a, b) {
    return a + b;
  },
  "Sub": function (a, b) {
    return a - b;
  },
  "Mult": function (a, b) {
    return a * b;
  },
  "Mod": function (a, b) {
    var m;
    if (b === 0) {
      throw new Sk.builtin.ZeroDivisionError("division or modulo by zero");
    }
    m = a % b;
    return m * b < 0 ? m + b : m;
  },
  "Div": function (a, b) {
    if (b === 0) {
      throw new Sk.builtin.ZeroDivisionError("division or modulo by zero");
    } else {
      return a / b;
    }
  },
  "FloorDiv": function (a, b) {
    if (b === 0) {
      throw new Sk.builtin.ZeroDivisionError("division or modulo by zero");
    } else {
      return Math.floor(a / b);
    } // todo; wrong? neg?
  },

  "Pow": Math.pow,
  "BitAnd": function (a, b) {
    var m = a & b;
    if (m < 0) {
      m = m + 4294967296; // convert back to unsigned
    }

    return m;
  },
  "BitOr": function (a, b) {
    var m = a | b;
    if (m < 0) {
      m = m + 4294967296; // convert back to unsigned
    }

    return m;
  },
  "BitXor": function (a, b) {
    var m = a ^ b;
    if (m < 0) {
      m = m + 4294967296; // convert back to unsigned
    }

    return m;
  },
  "LShift": function (a, b) {
    var m;
    if (b < 0) {
      throw new Sk.builtin.ValueError("negative shift count");
    }
    m = a << b;
    if (m > a) {
      return m;
    } else {
      // Fail, this will get recomputed with longs
      return a * Math.pow(2, b);
    }
  },
  "RShift": function (a, b) {
    var m;
    if (b < 0) {
      throw new Sk.builtin.ValueError("negative shift count");
    }
    m = a >> b;
    if (a > 0 && m < 0) {
      // fix incorrect sign extension
      m = m & Math.pow(2, 32 - b) - 1;
    }
    return m;
  }
};
Sk.abstr.numberBinOp = function (v, w, op) {
  var tmp;
  var numPromoteFunc = Sk.abstr.boNumPromote_[op];
  if (numPromoteFunc !== undefined) {
    tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);
    if (typeof tmp === "number") {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.int_) {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.float_) {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {
      return tmp;
    } else if (tmp !== undefined) {
      v = tmp[0];
      w = tmp[1];
    }
  }
  return Sk.abstr.binary_op_(v, w, op);
};
goog.exportSymbol("Sk.abstr.numberBinOp", Sk.abstr.numberBinOp);
Sk.abstr.numberInplaceBinOp = function (v, w, op) {
  var tmp;
  var numPromoteFunc = Sk.abstr.boNumPromote_[op];
  if (numPromoteFunc !== undefined) {
    tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);
    if (typeof tmp === "number") {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.int_) {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.float_) {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {
      return tmp;
    } else if (tmp !== undefined) {
      v = tmp[0];
      w = tmp[1];
    }
  }
  return Sk.abstr.binary_iop_(v, w, op);
};
goog.exportSymbol("Sk.abstr.numberInplaceBinOp", Sk.abstr.numberInplaceBinOp);
Sk.abstr.numberUnaryOp = function (v, op) {
  var value;
  if (op === "Not") {
    return Sk.misceval.isTrue(v) ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$;
  } else if (v instanceof Sk.builtin.bool) {
    value = Sk.builtin.asnum$(v);
    if (op === "USub") {
      return new Sk.builtin.int_(-value);
    }
    if (op === "UAdd") {
      return new Sk.builtin.int_(value);
    }
    if (op === "Invert") {
      return new Sk.builtin.int_(~value);
    }
  } else {
    if (op === "USub" && v.nb$negative) {
      return v.nb$negative();
    }
    if (op === "UAdd" && v.nb$positive) {
      return v.nb$positive();
    }
    if (op === "Invert" && v.nb$invert) {
      return v.nb$invert();
    }
  }
  return Sk.abstr.unary_op_(v, op);
};
goog.exportSymbol("Sk.abstr.numberUnaryOp", Sk.abstr.numberUnaryOp);

//
// Sequence
//

Sk.abstr.fixSeqIndex_ = function (seq, i) {
  i = Sk.builtin.asnum$(i);
  if (i < 0 && seq.sq$length) {
    i += seq.sq$length();
  }
  return i;
};

/**
 * @param {*} seq
 * @param {*} ob
 * @param {boolean=} canSuspend
 */
Sk.abstr.sequenceContains = function (seq, ob, canSuspend) {
  var seqtypename;
  var special;
  var r;
  if (seq.sq$contains) {
    return seq.sq$contains(ob);
  }

  /**
   *  Look for special method and call it, we have to distinguish between built-ins and
   *  python objects
   */
  special = Sk.abstr.lookupSpecial(seq, "__contains__");
  if (special != null) {
    // method on builtin, provide this arg
    return Sk.misceval.isTrue(Sk.misceval.callsim(special, seq, ob));
  }
  if (!Sk.builtin.checkIterable(seq)) {
    seqtypename = Sk.abstr.typeName(seq);
    throw new Sk.builtin.TypeError("argument of type '" + seqtypename + "' is not iterable");
  }
  r = Sk.misceval.iterFor(Sk.abstr.iter(seq), function (i) {
    if (Sk.misceval.richCompareBool(i, ob, "Eq")) {
      return new Sk.misceval.Break(true);
    } else {
      return false;
    }
  }, false);
  return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);
};
Sk.abstr.sequenceConcat = function (seq1, seq2) {
  var seq1typename;
  if (seq1.sq$concat) {
    return seq1.sq$concat(seq2);
  }
  seq1typename = Sk.abstr.typeName(seq1);
  throw new Sk.builtin.TypeError("'" + seq1typename + "' object can't be concatenated");
};
Sk.abstr.sequenceGetIndexOf = function (seq, ob) {
  var seqtypename;
  var i, it;
  var index;
  if (seq.index) {
    return Sk.misceval.callsim(seq.index, seq, ob);
  }
  if (Sk.builtin.checkIterable(seq)) {
    index = 0;
    for (it = Sk.abstr.iter(seq), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
      if (Sk.misceval.richCompareBool(ob, i, "Eq")) {
        return new Sk.builtin.int_(index);
      }
      index += 1;
    }
    throw new Sk.builtin.ValueError("sequence.index(x): x not in sequence");
  }
  seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError("argument of type '" + seqtypename + "' is not iterable");
};
Sk.abstr.sequenceGetCountOf = function (seq, ob) {
  var seqtypename;
  var i, it;
  var count;
  if (seq.count) {
    return Sk.misceval.callsim(seq.count, seq, ob);
  }
  if (Sk.builtin.checkIterable(seq)) {
    count = 0;
    for (it = Sk.abstr.iter(seq), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
      if (Sk.misceval.richCompareBool(ob, i, "Eq")) {
        count += 1;
      }
    }
    return new Sk.builtin.int_(count);
  }
  seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError("argument of type '" + seqtypename + "' is not iterable");
};
Sk.abstr.sequenceGetItem = function (seq, i, canSuspend) {
  var seqtypename;
  if (seq.mp$subscript) {
    return seq.mp$subscript(i);
  }
  seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError("'" + seqtypename + "' object is unsubscriptable");
};
Sk.abstr.sequenceSetItem = function (seq, i, x, canSuspend) {
  var seqtypename;
  if (seq.mp$ass_subscript) {
    return seq.mp$ass_subscript(i, x);
  }
  seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError("'" + seqtypename + "' object does not support item assignment");
};
Sk.abstr.sequenceDelItem = function (seq, i) {
  var seqtypename;
  if (seq.sq$del_item) {
    i = Sk.abstr.fixSeqIndex_(seq, i);
    seq.sq$del_item(i);
    return;
  }
  seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError("'" + seqtypename + "' object does not support item deletion");
};
Sk.abstr.sequenceRepeat = function (f, seq, n) {
  var ntypename;
  var count;
  n = Sk.builtin.asnum$(n);
  count = Sk.misceval.asIndex(n);
  if (count === undefined) {
    ntypename = Sk.abstr.typeName(n);
    throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '" + ntypename + "'");
  }
  return f.call(seq, n);
};
Sk.abstr.sequenceGetSlice = function (seq, i1, i2) {
  var seqtypename;
  if (seq.sq$slice) {
    i1 = Sk.abstr.fixSeqIndex_(seq, i1);
    i2 = Sk.abstr.fixSeqIndex_(seq, i2);
    return seq.sq$slice(i1, i2);
  } else if (seq.mp$subscript) {
    return seq.mp$subscript(new Sk.builtin.slice(i1, i2));
  }
  seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError("'" + seqtypename + "' object is unsliceable");
};
Sk.abstr.sequenceDelSlice = function (seq, i1, i2) {
  var seqtypename;
  if (seq.sq$del_slice) {
    i1 = Sk.abstr.fixSeqIndex_(seq, i1);
    i2 = Sk.abstr.fixSeqIndex_(seq, i2);
    seq.sq$del_slice(i1, i2);
    return;
  }
  seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError("'" + seqtypename + "' doesn't support slice deletion");
};
Sk.abstr.sequenceSetSlice = function (seq, i1, i2, x) {
  var seqtypename;
  if (seq.sq$ass_slice) {
    i1 = Sk.abstr.fixSeqIndex_(seq, i1);
    i2 = Sk.abstr.fixSeqIndex_(seq, i2);
    seq.sq$ass_slice(i1, i2, x);
  } else if (seq.mp$ass_subscript) {
    seq.mp$ass_subscript(new Sk.builtin.slice(i1, i2), x);
  } else {
    seqtypename = Sk.abstr.typeName(seq);
    throw new Sk.builtin.TypeError("'" + seqtypename + "' object doesn't support slice assignment");
  }
};

// seq - Python object to unpack
// n   - JavaScript number of items to unpack
Sk.abstr.sequenceUnpack = function (seq, n) {
  var res = [];
  var it, i;
  if (!Sk.builtin.checkIterable(seq)) {
    throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(seq) + "' object is not iterable");
  }
  for (it = Sk.abstr.iter(seq), i = it.tp$iternext(); i !== undefined && res.length < n; i = it.tp$iternext()) {
    res.push(i);
  }
  if (res.length < n) {
    throw new Sk.builtin.ValueError("need more than " + res.length + " values to unpack");
  }
  if (i !== undefined) {
    throw new Sk.builtin.ValueError("too many values to unpack");
  }

  // Return Javascript array of items
  return res;
};

//
// Object
//

Sk.abstr.objectFormat = function (obj, format_spec) {
  var meth; // PyObject
  var result; // PyObject

  // If no format_spec is provided, use an empty string
  if (format_spec == null) {
    format_spec = "";
  }

  // Find the (unbound!) __format__ method (a borrowed reference)
  meth = Sk.abstr.lookupSpecial(obj, "__format__");
  if (meth == null) {
    throw new Sk.builtin.TypeError("Type " + Sk.abstr.typeName(obj) + "doesn't define __format__");
  }

  // And call it
  result = Sk.misceval.callsim(meth, obj, format_spec);
  if (!Sk.builtin.checkString(result)) {
    throw new Sk.builtin.TypeError("__format__ must return a str, not " + Sk.abstr.typeName(result));
  }
  return result;
};
Sk.abstr.objectAdd = function (a, b) {
  var btypename;
  var atypename;
  if (a.nb$add) {
    return a.nb$add(b);
  }
  atypename = Sk.abstr.typeName(a);
  btypename = Sk.abstr.typeName(b);
  throw new Sk.builtin.TypeError("unsupported operand type(s) for +: '" + atypename + "' and '" + btypename + "'");
};

// in Python 2.6, this behaviour seems to be defined for numbers and bools (converts bool to int)
Sk.abstr.objectNegative = function (obj) {
  var objtypename;
  var obj_asnum = Sk.builtin.asnum$(obj); // this will also convert bool type to int

  if (obj instanceof Sk.builtin.bool) {
    obj = new Sk.builtin.int_(obj_asnum);
  }
  if (obj.nb$negative) {
    return obj.nb$negative();
  }
  objtypename = Sk.abstr.typeName(obj);
  throw new Sk.builtin.TypeError("bad operand type for unary -: '" + objtypename + "'");
};

// in Python 2.6, this behaviour seems to be defined for numbers and bools (converts bool to int)
Sk.abstr.objectPositive = function (obj) {
  var objtypename = Sk.abstr.typeName(obj);
  var obj_asnum = Sk.builtin.asnum$(obj); // this will also convert bool type to int

  if (obj instanceof Sk.builtin.bool) {
    obj = new Sk.builtin.int_(obj_asnum);
  }
  if (obj.nb$negative) {
    return obj.nb$positive();
  }
  throw new Sk.builtin.TypeError("bad operand type for unary +: '" + objtypename + "'");
};
Sk.abstr.objectDelItem = function (o, key) {
  var otypename;
  var keytypename;
  var keyValue;
  if (o !== null) {
    if (o.mp$del_subscript) {
      o.mp$del_subscript(key);
      return;
    }
    if (o.sq$ass_item) {
      keyValue = Sk.misceval.asIndex(key);
      if (keyValue === undefined) {
        keytypename = Sk.abstr.typeName(key);
        throw new Sk.builtin.TypeError("sequence index must be integer, not '" + keytypename + "'");
      }
      Sk.abstr.sequenceDelItem(o, keyValue);
      return;
    }
    // if o is a slice do something else...
  }

  otypename = Sk.abstr.typeName(o);
  throw new Sk.builtin.TypeError("'" + otypename + "' object does not support item deletion");
};
goog.exportSymbol("Sk.abstr.objectDelItem", Sk.abstr.objectDelItem);
Sk.abstr.objectGetItem = function (o, key, canSuspend) {
  var otypename;
  if (o !== null) {
    if (o.tp$getitem) {
      return o.tp$getitem(key, canSuspend);
    } else if (o.mp$subscript) {
      return o.mp$subscript(key, canSuspend);
    } else if (Sk.misceval.isIndex(key) && o.sq$item) {
      return Sk.abstr.sequenceGetItem(o, Sk.misceval.asIndex(key), canSuspend);
    }
  }
  otypename = Sk.abstr.typeName(o);
  throw new Sk.builtin.TypeError("'" + otypename + "' does not support indexing");
};
goog.exportSymbol("Sk.abstr.objectGetItem", Sk.abstr.objectGetItem);
Sk.abstr.objectSetItem = function (o, key, v, canSuspend) {
  var otypename;
  if (o !== null) {
    if (o.tp$setitem) {
      return o.tp$setitem(key, v, canSuspend);
    } else if (o.mp$ass_subscript) {
      return o.mp$ass_subscript(key, v, canSuspend);
    } else if (Sk.misceval.isIndex(key) && o.sq$ass_item) {
      return Sk.abstr.sequenceSetItem(o, Sk.misceval.asIndex(key), v, canSuspend);
    }
  }
  otypename = Sk.abstr.typeName(o);
  throw new Sk.builtin.TypeError("'" + otypename + "' does not support item assignment");
};
goog.exportSymbol("Sk.abstr.objectSetItem", Sk.abstr.objectSetItem);
Sk.abstr.gattr = function (obj, nameJS, canSuspend) {
  var ret, f;
  var objname = Sk.abstr.typeName(obj);
  if (obj === null) {
    throw new Sk.builtin.AttributeError("'" + objname + "' object has no attribute '" + nameJS + "'");
  }
  if (obj.tp$getattr !== undefined) {
    ret = obj.tp$getattr(nameJS, canSuspend);
  }
  ret = Sk.misceval.chain(ret, function (r) {
    if (r === undefined) {
      throw new Sk.builtin.AttributeError("'" + objname + "' object has no attribute '" + nameJS + "'");
    }
    return r;
  });
  return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
};
goog.exportSymbol("Sk.abstr.gattr", Sk.abstr.gattr);
Sk.abstr.sattr = function (obj, nameJS, data, canSuspend) {
  var objname = Sk.abstr.typeName(obj),
    r,
    setf;
  if (obj === null) {
    throw new Sk.builtin.AttributeError("'" + objname + "' object has no attribute '" + nameJS + "'");
  }
  if (obj.tp$setattr !== undefined) {
    return obj.tp$setattr(nameJS, data, canSuspend);
  } else {
    throw new Sk.builtin.AttributeError("'" + objname + "' object has no attribute '" + nameJS + "'");
  }
};
goog.exportSymbol("Sk.abstr.sattr", Sk.abstr.sattr);
Sk.abstr.iternext = function (it, canSuspend) {
  return it.tp$iternext(canSuspend);
};
goog.exportSymbol("Sk.abstr.iternext", Sk.abstr.iternext);

/**
 * Get the iterator for a Python object  This iterator could be one of the following.
 * This is the preferred mechanism for consistently getting the correct iterator.  You should
 * not just use tp$iter because that could lead to incorrect behavior of a user created class.
 *
 * - tp$iter
 * - A user defined `__iter__` method
 * - A user defined `__getitem__` method
 *
 * @param obj
 *
 * @throws {Sk.builtin.TypeError}
 * @returns {Object}
 */

Sk.abstr.iter = function (obj) {
  var iter;
  var getit;
  var ret;

  /**
   * Builds an iterator around classes that have a __getitem__ method.
   *
   * @constructor
   */
  var seqIter = function (obj) {
    this.idx = 0;
    this.myobj = obj;
    this.getitem = Sk.abstr.lookupSpecial(obj, "__getitem__");
    this.tp$iternext = function () {
      var ret;
      try {
        ret = Sk.misceval.callsim(this.getitem, this.myobj, Sk.ffi.remapToPy(this.idx));
      } catch (e) {
        if (e instanceof Sk.builtin.IndexError || e instanceof Sk.builtin.StopIteration) {
          return undefined;
        } else {
          throw e;
        }
      }
      this.idx++;
      return ret;
    };
  };
  if (obj.tp$getattr) {
    iter = Sk.abstr.lookupSpecial(obj, "__iter__");
    if (iter) {
      ret = Sk.misceval.callsim(iter, obj);
      if (ret.tp$iternext) {
        return ret;
      }
    }
  }
  if (obj.tp$iter) {
    try {
      // catch and ignore not iterable error here.
      ret = obj.tp$iter();
      if (ret.tp$iternext) {
        return ret;
      }
    } catch (e) {}
  }
  getit = Sk.abstr.lookupSpecial(obj, "__getitem__");
  if (getit) {
    // create internal iterobject if __getitem__
    return new seqIter(obj);
  }
  throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(obj) + "' object is not iterable");
};
goog.exportSymbol("Sk.abstr.iter", Sk.abstr.iter);

/**
 * Special method look up. First try getting the method via
 * internal dict and getattr. If getattr is not present (builtins)
 * try if method is defined on the object itself
 *
 * @returns {null|Object} Return null if not found or the function
 */
Sk.abstr.lookupSpecial = function (op, str) {
  var res;
  var obtp;
  if (op.ob$type) {
    obtp = op.ob$type;
  } else {
    return null;
  }
  return Sk.builtin.type.typeLookup(obtp, str);
};
goog.exportSymbol("Sk.abstr.lookupSpecial", Sk.abstr.lookupSpecial);

/**
 * Mark a class as unhashable and prevent its `__hash__` function from being called.
 * @param  {function(...[?])} thisClass The class to mark as unhashable.
 * @return {undefined}
 */
Sk.abstr.markUnhashable = function (thisClass) {
  var proto = thisClass.prototype;
  proto.__hash__ = Sk.builtin.none.none$;
  proto.tp$hash = Sk.builtin.none.none$;
};

/**
 * Set up inheritance between two Python classes. This allows only for single
 * inheritance -- multiple inheritance is not supported by Javascript.
 *
 * Javascript's inheritance is prototypal. This means that properties must
 * be defined on the superclass' prototype in order for subclasses to inherit
 * them.
 *
 * ```
 * Sk.superclass.myProperty                 # will NOT be inherited
 * Sk.superclass.prototype.myProperty       # will be inherited
 * ```
 *
 * In order for a class to be subclassable, it must (directly or indirectly)
 * inherit from Sk.builtin.object so that it will be properly initialized in
 * {@link Sk.doOneTimeInitialization} (in src/import.js). Further, all Python
 * builtins should inherit from Sk.builtin.object.
 *
 * @param {string} childName The Python name of the child (subclass).
 * @param {function(...[?])} child     The subclass.
 * @param {function(...[?])} parent    The superclass.
 * @return {undefined}
 */
Sk.abstr.setUpInheritance = function (childName, child, parent) {
  goog.inherits(child, parent);
  child.prototype.tp$base = parent;
  child.prototype.tp$name = childName;
  child.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(childName, child);
};

/**
 * Call the super constructor of the provided class, with the object `self` as
 * the `this` value of that constructor. Any arguments passed to this function
 * after `self` will be passed as-is to the constructor.
 *
 * @param  {function(...[?])} thisClass The subclass.
 * @param  {Object} self      The instance of the subclas.
 * @param  {...?} args Arguments to pass to the constructor.
 * @return {undefined}
 */
Sk.abstr.superConstructor = function (thisClass, self, args) {
  var argumentsForConstructor = Array.prototype.slice.call(arguments, 2);
  thisClass.prototype.tp$base.apply(self, argumentsForConstructor);
};

/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/object.js ---- */

/**
 * @constructor
 * Sk.builtin.object
 *
 * @description
 * Constructor for Python object. All Python classes (builtin and user-defined)
 * should inherit from this class.
 *
 * @return {Sk.builtin.object} Python object
 */
Sk.builtin.object = function () {
  if (!(this instanceof Sk.builtin.object)) {
    return new Sk.builtin.object();
  }
  return this;
};
var _tryGetSubscript = function (dict, pyName) {
  try {
    return dict.mp$subscript(pyName);
  } catch (x) {
    return undefined;
  }
};

/**
 * Get an attribute
 * @param {string} name JS name of the attribute
 * @param {boolean=} canSuspend Can we return a suspension?
 * @return {undefined}
 */
Sk.builtin.object.prototype.GenericGetAttr = function (name, canSuspend) {
  var res;
  var f;
  var descr;
  var tp;
  var dict;
  var pyName = new Sk.builtin.str(name);
  goog.asserts.assert(typeof name === "string");
  tp = this.ob$type;
  goog.asserts.assert(tp !== undefined, "object has no ob$type!");
  dict = this["$d"] || this.constructor["$d"];

  // todo; assert? force?
  if (dict) {
    if (dict.mp$lookup) {
      res = dict.mp$lookup(pyName);
    } else if (dict.mp$subscript) {
      res = _tryGetSubscript(dict, pyName);
    } else if (typeof dict === "object") {
      // todo; definitely the wrong place for this. other custom tp$getattr won't work on object -- bnm -- implemented custom __getattr__ in abstract.js
      res = dict[name];
    }
    if (res !== undefined) {
      return res;
    }
  }
  descr = Sk.builtin.type.typeLookup(tp, name);

  // otherwise, look in the type for a descr
  if (descr !== undefined && descr !== null) {
    f = descr.tp$descr_get;
    // todo - data descriptors (ie those with tp$descr_set too) get a different lookup priority

    if (f) {
      // non-data descriptor
      return f.call(descr, this, this.ob$type, canSuspend);
    }
  }
  if (descr !== undefined) {
    return descr;
  }
  return undefined;
};
goog.exportSymbol("Sk.builtin.object.prototype.GenericGetAttr", Sk.builtin.object.prototype.GenericGetAttr);
Sk.builtin.object.prototype.GenericPythonGetAttr = function (self, name) {
  return Sk.builtin.object.prototype.GenericGetAttr.call(self, name.v);
};
goog.exportSymbol("Sk.builtin.object.prototype.GenericPythonGetAttr", Sk.builtin.object.prototype.GenericPythonGetAttr);

/**
 * @param {string} name
 * @param {undefined} value
 * @param {boolean=} canSuspend
 * @return {undefined}
 */
Sk.builtin.object.prototype.GenericSetAttr = function (name, value, canSuspend) {
  var objname = Sk.abstr.typeName(this);
  var pyname;
  var dict;
  var tp = this.ob$type;
  var descr;
  var f;
  goog.asserts.assert(typeof name === "string");
  goog.asserts.assert(tp !== undefined, "object has no ob$type!");
  dict = this["$d"] || this.constructor["$d"];
  descr = Sk.builtin.type.typeLookup(tp, name);

  // otherwise, look in the type for a descr
  if (descr !== undefined && descr !== null) {
    f = descr.tp$descr_set;
    // todo; is this the right lookup priority for data descriptors?
    if (f) {
      return f.call(descr, this, value, canSuspend);
    }
  }
  if (dict.mp$ass_subscript) {
    pyname = new Sk.builtin.str(name);
    if (this instanceof Sk.builtin.object && !this.ob$type.sk$klass && dict.mp$lookup(pyname) === undefined) {
      // Cannot add new attributes to a builtin object
      throw new Sk.builtin.AttributeError("'" + objname + "' object has no attribute '" + Sk.unfixReserved(name) + "'");
    }
    dict.mp$ass_subscript(new Sk.builtin.str(name), value);
  } else if (typeof dict === "object") {
    dict[name] = value;
  }
};
goog.exportSymbol("Sk.builtin.object.prototype.GenericSetAttr", Sk.builtin.object.prototype.GenericSetAttr);
Sk.builtin.object.prototype.GenericPythonSetAttr = function (self, name, value) {
  return Sk.builtin.object.prototype.GenericSetAttr.call(self, name.v, value);
};
goog.exportSymbol("Sk.builtin.object.prototype.GenericPythonSetAttr", Sk.builtin.object.prototype.GenericPythonSetAttr);
Sk.builtin.object.prototype.HashNotImplemented = function () {
  throw new Sk.builtin.TypeError("unhashable type: '" + Sk.abstr.typeName(this) + "'");
};
Sk.builtin.object.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.object.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;

// Although actual attribute-getting happens in pure Javascript via tp$getattr, classes
// overriding __getattr__ etc need to be able to call object.__getattr__ etc from Python
Sk.builtin.object.prototype["__getattr__"] = Sk.builtin.object.prototype.GenericPythonGetAttr;
Sk.builtin.object.prototype["__setattr__"] = Sk.builtin.object.prototype.GenericPythonSetAttr;

/**
 * The name of this class.
 * @type {string}
 */
Sk.builtin.object.prototype.tp$name = "object";

/**
 * The type object of this class.
 * @type {Sk.builtin.type}
 */
Sk.builtin.object.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj("object", Sk.builtin.object);
Sk.builtin.object.prototype.ob$type.sk$klass = undefined; // Nonsense for closure compiler
Sk.builtin.object.prototype.tp$descr_set = undefined; // Nonsense for closure compiler

/** Default implementations of dunder methods found in all Python objects */
/**
 * Default implementation of __new__ just calls the class constructor
 * @name  __new__
 * @memberOf Sk.builtin.object.prototype
 * @instance
 */
Sk.builtin.object.prototype["__new__"] = function (cls) {
  Sk.builtin.pyCheckArgs("__new__", arguments, 1, 1, false, false);
  return new cls([], []);
};

/**
 * Python wrapper for `__repr__` method.
 * @name  __repr__
 * @memberOf Sk.builtin.object.prototype
 * @instance
 */
Sk.builtin.object.prototype["__repr__"] = function (self) {
  Sk.builtin.pyCheckArgs("__repr__", arguments, 0, 0, false, true);
  return self["$r"]();
};

/**
 * Python wrapper for `__str__` method.
 * @name  __str__
 * @memberOf Sk.builtin.object.prototype
 * @instance
 */
Sk.builtin.object.prototype["__str__"] = function (self) {
  Sk.builtin.pyCheckArgs("__str__", arguments, 0, 0, false, true);
  return self["$r"]();
};

/**
 * Python wrapper for `__hash__` method.
 * @name  __hash__
 * @memberOf Sk.builtin.object.prototype
 * @instance
 */
Sk.builtin.object.prototype["__hash__"] = function (self) {
  Sk.builtin.pyCheckArgs("__hash__", arguments, 0, 0, false, true);
  return self.tp$hash();
};

/**
 * Python wrapper for `__eq__` method.
 * @name  __eq__
 * @memberOf Sk.builtin.object.prototype
 * @instance
 */
Sk.builtin.object.prototype["__eq__"] = function (self, other) {
  Sk.builtin.pyCheckArgs("__eq__", arguments, 1, 1, false, true);
  return self.ob$eq(other);
};

/**
 * Python wrapper for `__ne__` method.
 * @name  __ne__
 * @memberOf Sk.builtin.object.prototype
 * @instance
 */
Sk.builtin.object.prototype["__ne__"] = function (self, other) {
  Sk.builtin.pyCheckArgs("__ne__", arguments, 1, 1, false, true);
  return self.ob$ne(other);
};

/**
 * Python wrapper for `__lt__` method.
 * @name  __lt__
 * @memberOf Sk.builtin.object.prototype
 * @instance
 */
Sk.builtin.object.prototype["__lt__"] = function (self, other) {
  Sk.builtin.pyCheckArgs("__lt__", arguments, 1, 1, false, true);
  return self.ob$lt(other);
};

/**
 * Python wrapper for `__le__` method.
 * @name  __le__
 * @memberOf Sk.builtin.object.prototype
 * @instance
 */
Sk.builtin.object.prototype["__le__"] = function (self, other) {
  Sk.builtin.pyCheckArgs("__le__", arguments, 1, 1, false, true);
  return self.ob$le(other);
};

/**
 * Python wrapper for `__gt__` method.
 * @name  __gt__
 * @memberOf Sk.builtin.object.prototype
 * @instance
 */
Sk.builtin.object.prototype["__gt__"] = function (self, other) {
  Sk.builtin.pyCheckArgs("__gt__", arguments, 1, 1, false, true);
  return self.ob$gt(other);
};

/**
 * Python wrapper for `__ge__` method.
 * @name  __ge__
 * @memberOf Sk.builtin.object.prototype
 * @instance
 */
Sk.builtin.object.prototype["__ge__"] = function (self, other) {
  Sk.builtin.pyCheckArgs("__ge__", arguments, 1, 1, false, true);
  return self.ob$ge(other);
};

/** Default implementations of Javascript functions used in dunder methods */

/**
 * Return the string representation of this instance.
 *
 * Javascript function, returns Python object.
 *
 * @name  $r
 * @memberOf Sk.builtin.object.prototype
 * @return {Sk.builtin.str} The Python string representation of this instance.
 */
Sk.builtin.object.prototype["$r"] = function () {
  return new Sk.builtin.str("<object>");
};
Sk.builtin.hashCount = 1;
Sk.builtin.idCount = 1;

/**
 * Return the hash value of this instance.
 *
 * Javascript function, returns Python object.
 *
 * @return {Sk.builtin.int_} The hash value
 */
Sk.builtin.object.prototype.tp$hash = function () {
  if (!this.$savedHash_) {
    this.$savedHash_ = new Sk.builtin.int_(Sk.builtin.hashCount++);
  }
  return this.$savedHash_;
};

/**
 * Perform equality check between this instance and a Python object (i.e. this == other).
 *
 * Implements `__eq__` dunder method.
 *
 * Javascript function, returns Python object.
 *
 * @param  {Object} other The Python object to check for equality.
 * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if equal, false otherwise
 */
Sk.builtin.object.prototype.ob$eq = function (other) {
  if (this === other) {
    return Sk.builtin.bool.true$;
  }
  return Sk.builtin.NotImplemented.NotImplemented$;
};

/**
 * Perform non-equality check between this instance and a Python object (i.e. this != other).
 *
 * Implements `__ne__` dunder method.
 *
 * Javascript function, returns Python object.
 *
 * @param  {Object} other The Python object to check for non-equality.
 * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if not equal, false otherwise
 */
Sk.builtin.object.prototype.ob$ne = function (other) {
  if (this === other) {
    return Sk.builtin.bool.false$;
  }
  return Sk.builtin.NotImplemented.NotImplemented$;
};

/**
 * Determine if this instance is less than a Python object (i.e. this < other).
 *
 * Implements `__lt__` dunder method.
 *
 * Javascript function, returns Python object.
 *
 * @param  {Object} other The Python object to compare.
 * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this < other, false otherwise
 */
Sk.builtin.object.prototype.ob$lt = function (other) {
  return Sk.builtin.NotImplemented.NotImplemented$;
};

/**
 * Determine if this instance is less than or equal to a Python object (i.e. this <= other).
 *
 * Implements `__le__` dunder method.
 *
 * Javascript function, returns Python object.
 *
 * @param  {Object} other The Python object to compare.
 * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this <= other, false otherwise
 */
Sk.builtin.object.prototype.ob$le = function (other) {
  return Sk.builtin.NotImplemented.NotImplemented$;
};

/**
 * Determine if this instance is greater than a Python object (i.e. this > other).
 *
 * Implements `__gt__` dunder method.
 *
 * Javascript function, returns Python object.
 *
 * @param  {Object} other The Python object to compare.
 * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this > other, false otherwise
 */
Sk.builtin.object.prototype.ob$gt = function (other) {
  return Sk.builtin.NotImplemented.NotImplemented$;
};

/**
 * Determine if this instance is greater than or equal to a Python object (i.e. this >= other).
 *
 * Implements `__ge__` dunder method.
 *
 * Javascript function, returns Python object.
 *
 * @param  {Object} other The Python object to compare.
 * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this >= other, false otherwise
 */
Sk.builtin.object.prototype.ob$ge = function (other) {
  return Sk.builtin.NotImplemented.NotImplemented$;
};

// Wrap the following functions in Sk.builtin.func once that class is initialized
/**
 * Array of all the Python functions which are methods of this class.
 * @type {Array}
 */
Sk.builtin.object.pythonFunctions = ["__repr__", "__str__", "__hash__", "__eq__", "__ne__", "__lt__", "__le__", "__gt__", "__ge__", "__getattr__", "__setattr__"];

/**
 * @constructor
 * Sk.builtin.none
 *
 * @extends {Sk.builtin.object}
 */
Sk.builtin.none = function () {
  this.v = null;
};
Sk.abstr.setUpInheritance("NoneType", Sk.builtin.none, Sk.builtin.object);

/** @override */
Sk.builtin.none.prototype["$r"] = function () {
  return new Sk.builtin.str("None");
};

/** @override */
Sk.builtin.none.prototype.tp$hash = function () {
  return new Sk.builtin.int_(0);
};

/**
 * Python None constant.
 * @type {Sk.builtin.none}
 */
Sk.builtin.none.none$ = new Sk.builtin.none();

/**
 * @constructor
 * Sk.builtin.NotImplemented
 *
 * @extends {Sk.builtin.object}
 */
Sk.builtin.NotImplemented = function () {};
Sk.abstr.setUpInheritance("NotImplementedType", Sk.builtin.NotImplemented, Sk.builtin.object);

/** @override */
Sk.builtin.NotImplemented.prototype["$r"] = function () {
  return new Sk.builtin.str("NotImplemented");
};

/**
 * Python NotImplemented constant.
 * @type {Sk.builtin.NotImplemented}
 */
Sk.builtin.NotImplemented.NotImplemented$ = new Sk.builtin.NotImplemented();
goog.exportSymbol("Sk.builtin.none", Sk.builtin.none);
goog.exportSymbol("Sk.builtin.NotImplemented", Sk.builtin.NotImplemented);

/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/function.js ---- */

/**
 * @namespace Sk.builtin
 */

/**
 * Check arguments to Python functions to ensure the correct number of
 * arguments are passed.
 *
 * @param {string} name the name of the function
 * @param {Object} args the args passed to the function
 * @param {number} minargs the minimum number of allowable arguments
 * @param {number=} maxargs optional maximum number of allowable
 * arguments (default: Infinity)
 * @param {boolean=} kwargs optional true if kwargs, false otherwise
 * (default: false)
 * @param {boolean=} free optional true if free vars, false otherwise
 * (default: false)
 */
Sk.builtin.pyCheckArgs = function (name, args, minargs, maxargs, kwargs, free) {
  var nargs = args.length;
  var msg = "";
  if (maxargs === undefined) {
    maxargs = Infinity;
  }
  if (kwargs) {
    nargs -= 1;
  }
  if (free) {
    nargs -= 1;
  }
  if (nargs < minargs || nargs > maxargs) {
    if (minargs === maxargs) {
      msg = name + "() takes exactly " + minargs + " arguments";
    } else if (nargs < minargs) {
      msg = name + "() takes at least " + minargs + " arguments";
    } else {
      msg = name + "() takes at most " + maxargs + " arguments";
    }
    msg += " (" + nargs + " given)";
    throw new Sk.builtin.TypeError(msg);
  }
};
goog.exportSymbol("Sk.builtin.pyCheckArgs", Sk.builtin.pyCheckArgs);

/**
 * Check type of argument to Python functions.
 *
 * @param {string} name the name of the argument
 * @param {string} exptype string of the expected type name
 * @param {boolean} check truthy if type check passes, falsy otherwise
 */
Sk.builtin.pyCheckType = function (name, exptype, check) {
  if (!check) {
    throw new Sk.builtin.TypeError(name + " must be a " + exptype);
  }
};
goog.exportSymbol("Sk.builtin.pyCheckType", Sk.builtin.pyCheckType);
Sk.builtin.checkSequence = function (arg) {
  return arg !== null && arg.mp$subscript !== undefined;
};
goog.exportSymbol("Sk.builtin.checkSequence", Sk.builtin.checkSequence);

/**
 * Use this to test whether or not a Python object is iterable.  You should **not** rely
 * on the presence of tp$iter on the object as a good test, as it could be a user defined
 * class with `__iter__` defined or ``__getitem__``  This tests for all of those cases
 *
 * @param arg {Object}   A Python object
 * @returns {boolean} true if the object is iterable
 */
Sk.builtin.checkIterable = function (arg) {
  var ret = false;
  if (arg !== null) {
    try {
      ret = Sk.abstr.iter(arg);
      if (ret) {
        return true;
      } else {
        return false;
      }
    } catch (e) {
      if (e instanceof Sk.builtin.TypeError) {
        return false;
      } else {
        throw e;
      }
    }
  }
  return ret;
};
goog.exportSymbol("Sk.builtin.checkIterable", Sk.builtin.checkIterable);
Sk.builtin.checkCallable = function (obj) {
  // takes care of builtin functions and methods, builtins
  if (typeof obj === "function") {
    return true;
  }
  // takes care of python function, methods and lambdas
  if (obj instanceof Sk.builtin.func) {
    return true;
  }
  // takes care of instances of methods
  if (obj instanceof Sk.builtin.method) {
    return true;
  }
  // go up the prototype chain to see if the class has a __call__ method
  if (Sk.abstr.lookupSpecial(obj, "__call__") !== undefined) {
    return true;
  }
  return false;
};
Sk.builtin.checkNumber = function (arg) {
  return arg !== null && (typeof arg === "number" || arg instanceof Sk.builtin.int_ || arg instanceof Sk.builtin.float_ || arg instanceof Sk.builtin.lng);
};
goog.exportSymbol("Sk.builtin.checkNumber", Sk.builtin.checkNumber);

/**
 * Checks for complex type, delegates to internal method
 * Most skulpt users would search here!
 */
Sk.builtin.checkComplex = function (arg) {
  return Sk.builtin.complex._complex_check(arg);
};
goog.exportSymbol("Sk.builtin.checkComplex", Sk.builtin.checkComplex);
Sk.builtin.checkInt = function (arg) {
  return arg !== null && (typeof arg === "number" && arg === (arg | 0) || arg instanceof Sk.builtin.int_ || arg instanceof Sk.builtin.lng);
};
goog.exportSymbol("Sk.builtin.checkInt", Sk.builtin.checkInt);
Sk.builtin.checkFloat = function (arg) {
  return arg !== null && arg instanceof Sk.builtin.float_;
};
goog.exportSymbol("Sk.builtin.checkFloat", Sk.builtin.checkFloat);
Sk.builtin.checkString = function (arg) {
  return arg !== null && arg.__class__ == Sk.builtin.str;
};
goog.exportSymbol("Sk.builtin.checkString", Sk.builtin.checkString);
Sk.builtin.checkClass = function (arg) {
  return arg !== null && arg.sk$type;
};
goog.exportSymbol("Sk.builtin.checkClass", Sk.builtin.checkClass);
Sk.builtin.checkBool = function (arg) {
  return arg instanceof Sk.builtin.bool;
};
goog.exportSymbol("Sk.builtin.checkBool", Sk.builtin.checkBool);
Sk.builtin.checkNone = function (arg) {
  return arg instanceof Sk.builtin.none;
};
goog.exportSymbol("Sk.builtin.checkNone", Sk.builtin.checkNone);
Sk.builtin.checkFunction = function (arg) {
  return arg !== null && arg.tp$call !== undefined;
};
goog.exportSymbol("Sk.builtin.checkFunction", Sk.builtin.checkFunction);

/**
 * @constructor
 * Sk.builtin.func
 *
 * @description
 * This function converts a Javascript function into a Python object that is callable.  Or just
 * think of it as a Python function rather than a Javascript function now.  This is an important
 * distinction in skulpt because once you have Python function you cannot just call it.
 * You must now use Sk.misceval.callsim to call the Python function.
 *
 * @param {Function} code the javascript implementation of this function
 * @param {Object=} globals the globals where this function was defined.
 * Can be undefined (which will be stored as null) for builtins. (is
 * that ok?)
 * @param {Object=} closure dict of free variables
 * @param {Object=} closure2 another dict of free variables that will be
 * merged into 'closure'. there's 2 to simplify generated code (one is $free,
 * the other is $cell)
 *
 * closure is the cell variables from the parent scope that we need to close
 * over. closure2 is the free variables in the parent scope that we also might
 * need to access.
 *
 * NOTE: co_varnames and co_name are defined by compiled code only, so we have
 * to access them via dict-style lookup for closure.
 *
 */
Sk.builtin.func = function (code, globals, closure, closure2) {
  var k;
  this.func_code = code;
  this.func_globals = globals || null;
  if (closure2 !== undefined) {
    // todo; confirm that modification here can't cause problems
    for (k in closure2) {
      closure[k] = closure2[k];
    }
  }
  this.func_closure = closure;
  return this;
};
goog.exportSymbol("Sk.builtin.func", Sk.builtin.func);
Sk.builtin.func.prototype.tp$name = "function";
Sk.builtin.func.prototype.tp$descr_get = function (obj, objtype) {
  goog.asserts.assert(obj !== undefined && objtype !== undefined);
  if (obj === Sk.builtin.none.none$) {
    return this;
  }
  return new Sk.builtin.method(this, obj, objtype);
};
Sk.builtin.func.prototype.tp$call = function (args, kw) {
  var j;
  var i;
  var numvarnames;
  var varnames;
  var kwlen;
  var kwargsarr;
  var expectskw;
  var name;
  var numargs;
  expectskw = this.func_code["co_kwargs"];
  kwargsarr = [];
  if (this.func_code["no_kw"] && kw) {
    name = this.func_code && this.func_code["co_name"] && this.func_code["co_name"].v || "<native JS>";
    throw new Sk.builtin.TypeError(name + "() takes no keyword arguments");
  }
  if (kw) {
    // bind the kw args
    kwlen = kw.length;
    varnames = this.func_code["co_varnames"];
    numvarnames = varnames && varnames.length;
    for (i = 0; i < kwlen; i += 2) {
      // todo; make this a dict mapping name to offset
      for (j = 0; j < numvarnames; ++j) {
        if (kw[i] === varnames[j]) {
          break;
        }
      }
      if (varnames && j !== numvarnames) {
        if (j in args) {
          name = this.func_code && this.func_code["co_name"] && this.func_code["co_name"].v || "<native JS>";
          throw new Sk.builtin.TypeError(name + "() got multiple values for keyword argument '" + kw[i] + "'");
        }
        args[j] = kw[i + 1];
      } else if (expectskw) {
        // build kwargs dict
        kwargsarr.push(new Sk.builtin.str(kw[i]));
        kwargsarr.push(kw[i + 1]);
      } else {
        name = this.func_code && this.func_code["co_name"] && this.func_code["co_name"].v || "<native JS>";
        throw new Sk.builtin.TypeError(name + "() got an unexpected keyword argument '" + kw[i] + "'");
      }
    }
  }
  if (this.func_closure) {
    // todo; OK to modify?
    if (this.func_code["co_varnames"]) {
      // Make sure all default arguments are in args before adding closure
      numargs = args.length;
      numvarnames = this.func_code["co_varnames"].length;
      for (i = numargs; i < numvarnames; i++) {
        args.push(undefined);
      }
    }
    args.push(this.func_closure);
  }
  if (expectskw) {
    args.unshift(kwargsarr);
  }

  //print(JSON.stringify(args, null, 2));

  // note: functions expect 'this' to be globals to avoid having to
  // slice/unshift onto the main args
  return this.func_code.apply(this.func_globals, args);
};
Sk.builtin.func.prototype.tp$getattr = function (key) {
  return this[key];
};
Sk.builtin.func.prototype.tp$setattr = function (key, value) {
  this[key] = value;
};

//todo; investigate why the other doesn't work
//Sk.builtin.type.makeIntoTypeObj('function', Sk.builtin.func);
Sk.builtin.func.prototype.ob$type = Sk.builtin.type.makeTypeObj("function", new Sk.builtin.func(null, null));
Sk.builtin.func.prototype["$r"] = function () {
  var name = this.func_code && this.func_code["co_name"] && this.func_code["co_name"].v || "<native JS>";
  return new Sk.builtin.str("<function " + name + ">");
};

/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/seqtype.js ---- */

/**
 * @constructor
 * Sk.builtin.seqtype
 *
 * @description
 * Abstract class for Python sequence types.
 *
 * @extends {Sk.builtin.object}
 *
 * @return {undefined} Cannot instantiate a Sk.builtin.seqtype object
 */
Sk.builtin.seqtype = function () {
  throw new Sk.builtin.ExternalError("Cannot instantiate abstract Sk.builtin.seqtype class");
};
Sk.abstr.setUpInheritance("SequenceType", Sk.builtin.seqtype, Sk.builtin.object);
Sk.builtin.seqtype.sk$abstract = true;

/**
 * Python wrapper of `__len__` method.
 *
 * @name  __len__
 * @instance
 * @memberOf Sk.builtin.seqtype.prototype
 */
Sk.builtin.seqtype.prototype["__len__"] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs("__len__", arguments, 0, 0, false, true);
  return new Sk.builtin.int_(self.sq$length());
});

/**
 * Python wrapper of `__iter__` method.
 *
 * @name  __iter__
 * @instance
 * @memberOf Sk.builtin.seqtype.prototype
 */
Sk.builtin.seqtype.prototype["__iter__"] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs("__iter__", arguments, 0, 0, false, true);
  return self.tp$iter();
});

/**
 * Python wrapper of `__contains__` method.
 *
 * @name  __contains__
 * @instance
 * @memberOf Sk.builtin.seqtype.prototype
 */
Sk.builtin.seqtype.prototype["__contains__"] = new Sk.builtin.func(function (self, item) {
  Sk.builtin.pyCheckArgs("__contains__", arguments, 1, 1, false, true);
  if (self.sq$contains(item)) {
    return Sk.builtin.bool.true$;
  } else {
    return Sk.builtin.bool.false$;
  }
});

/**
 * Python wrapper of `__getitem__` method.
 *
 * @name  __getitem__
 * @instance
 * @memberOf Sk.builtin.seqtype.prototype
 */
Sk.builtin.seqtype.prototype["__getitem__"] = new Sk.builtin.func(function (self, key) {
  Sk.builtin.pyCheckArgs("__getitem__", arguments, 1, 1, false, true);
  return self.mp$subscript(key);
});

/**
 * Python wrapper of `__add__` method.
 *
 * @name  __add__
 * @instance
 * @memberOf Sk.builtin.seqtype.prototype
 */
Sk.builtin.seqtype.prototype["__add__"] = new Sk.builtin.func(function (self, other) {
  Sk.builtin.pyCheckArgs("__add__", arguments, 1, 1, false, true);
  return self.sq$concat(other);
});

/**
 * Python wrapper of `__mul__` method.
 *
 * @name  __mul__
 * @instance
 * @memberOf Sk.builtin.seqtype.prototype
 */
Sk.builtin.seqtype.prototype["__mul__"] = new Sk.builtin.func(function (self, n) {
  Sk.builtin.pyCheckArgs("__mul__", arguments, 1, 1, false, true);
  if (!Sk.misceval.isIndex(n)) {
    throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '" + Sk.abstr.typeName(n) + "'");
  }
  return self.sq$repeat(n);
});

/**
 * Python wrapper of `__rmul__` method.
 *
 * @name  __rmul__
 * @instance
 * @memberOf Sk.builtin.seqtype.prototype
 */
Sk.builtin.seqtype.prototype["__rmul__"] = new Sk.builtin.func(function (self, n) {
  Sk.builtin.pyCheckArgs("__rmul__", arguments, 1, 1, false, true);
  return self.sq$repeat(n);
});

/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/str.js ---- */

Sk.builtin.interned = {};

/**
 * @constructor
 * @param {*} x
 * @extends Sk.builtin.object
 */
Sk.builtin.str = function (x) {
  var ret;
  if (x === undefined) {
    x = "";
  }
  if (x instanceof Sk.builtin.str) {
    return x;
  }
  if (!(this instanceof Sk.builtin.str)) {
    return new Sk.builtin.str(x);
  }

  // convert to js string
  if (x === true) {
    ret = "True";
  } else if (x === false) {
    ret = "False";
  } else if (x === null || x instanceof Sk.builtin.none) {
    ret = "None";
  } else if (x instanceof Sk.builtin.bool) {
    if (x.v) {
      ret = "True";
    } else {
      ret = "False";
    }
  } else if (typeof x === "number") {
    ret = x.toString();
    if (ret === "Infinity") {
      ret = "inf";
    } else if (ret === "-Infinity") {
      ret = "-inf";
    }
  } else if (typeof x === "string") {
    ret = x;
  } else if (x.tp$str !== undefined) {
    ret = x.tp$str();
    if (!(ret instanceof Sk.builtin.str)) {
      throw new Sk.builtin.ValueError("__str__ didn't return a str");
    }
    return ret;
  } else {
    return Sk.misceval.objectRepr(x);
  }

  // interning required for strings in py
  if (Sk.builtin.interned["1" + ret]) {
    return Sk.builtin.interned["1" + ret];
  }
  this.__class__ = Sk.builtin.str;
  this.v = ret;
  this["v"] = this.v;
  Sk.builtin.interned["1" + ret] = this;
  return this;
};
goog.exportSymbol("Sk.builtin.str", Sk.builtin.str);
Sk.abstr.setUpInheritance("str", Sk.builtin.str, Sk.builtin.seqtype);
Sk.builtin.str.prototype.mp$subscript = function (index) {
  var ret;
  if (Sk.misceval.isIndex(index)) {
    index = Sk.misceval.asIndex(index);
    if (index < 0) {
      index = this.v.length + index;
    }
    if (index < 0 || index >= this.v.length) {
      throw new Sk.builtin.IndexError("string index out of range");
    }
    return new Sk.builtin.str(this.v.charAt(index));
  } else if (index instanceof Sk.builtin.slice) {
    ret = "";
    index.sssiter$(this, function (i, wrt) {
      if (i >= 0 && i < wrt.v.length) {
        ret += wrt.v.charAt(i);
      }
    });
    return new Sk.builtin.str(ret);
  } else {
    throw new Sk.builtin.TypeError("string indices must be integers, not " + Sk.abstr.typeName(index));
  }
};
Sk.builtin.str.prototype.sq$length = function () {
  return this.v.length;
};
Sk.builtin.str.prototype.sq$concat = function (other) {
  var otypename;
  if (!other || !Sk.builtin.checkString(other)) {
    otypename = Sk.abstr.typeName(other);
    throw new Sk.builtin.TypeError("cannot concatenate 'str' and '" + otypename + "' objects");
  }
  return new Sk.builtin.str(this.v + other.v);
};
Sk.builtin.str.prototype.nb$add = Sk.builtin.str.prototype.sq$concat;
Sk.builtin.str.prototype.nb$inplace_add = Sk.builtin.str.prototype.sq$concat;
Sk.builtin.str.prototype.sq$repeat = function (n) {
  var i;
  var ret;
  if (!Sk.misceval.isIndex(n)) {
    throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '" + Sk.abstr.typeName(n) + "'");
  }
  n = Sk.misceval.asIndex(n);
  ret = "";
  for (i = 0; i < n; ++i) {
    ret += this.v;
  }
  return new Sk.builtin.str(ret);
};
Sk.builtin.str.prototype.nb$multiply = Sk.builtin.str.prototype.sq$repeat;
Sk.builtin.str.prototype.nb$inplace_multiply = Sk.builtin.str.prototype.sq$repeat;
Sk.builtin.str.prototype.sq$item = function () {
  goog.asserts.fail();
};
Sk.builtin.str.prototype.sq$slice = function (i1, i2) {
  i1 = Sk.builtin.asnum$(i1);
  i2 = Sk.builtin.asnum$(i2);
  if (i1 < 0) {
    i1 = 0;
  }
  return new Sk.builtin.str(this.v.substr(i1, i2 - i1));
};
Sk.builtin.str.prototype.sq$contains = function (ob) {
  if (!(ob instanceof Sk.builtin.str)) {
    throw new Sk.builtin.TypeError("TypeError: 'In <string> requires string as left operand");
  }
  return this.v.indexOf(ob.v) != -1;
};
Sk.builtin.str.prototype.__iter__ = new Sk.builtin.func(function (self) {
  return new Sk.builtin.str_iter_(self);
});
Sk.builtin.str.prototype.tp$iter = function () {
  return new Sk.builtin.str_iter_(this);
};
Sk.builtin.str.prototype.tp$richcompare = function (other, op) {
  if (!(other instanceof Sk.builtin.str)) {
    return undefined;
  }
  switch (op) {
    case "Lt":
      return this.v < other.v;
    case "LtE":
      return this.v <= other.v;
    case "Eq":
      return this.v === other.v;
    case "NotEq":
      return this.v !== other.v;
    case "Gt":
      return this.v > other.v;
    case "GtE":
      return this.v >= other.v;
    default:
      goog.asserts.fail();
  }
};
Sk.builtin.str.prototype["$r"] = function () {
  // single is preferred
  var ashex;
  var c;
  var i;
  var ret;
  var len;
  var quote = "'";
  //jshint ignore:start
  if (this.v.indexOf("'") !== -1 && this.v.indexOf('"') === -1) {
    quote = '"';
  }
  //jshint ignore:end
  len = this.v.length;
  ret = quote;
  for (i = 0; i < len; ++i) {
    c = this.v.charAt(i);
    if (c === quote || c === "\\") {
      ret += "\\" + c;
    } else if (c === "\t") {
      ret += "\\t";
    } else if (c === "\n") {
      ret += "\\n";
    } else if (c === "\r") {
      ret += "\\r";
    } else if (c < " " || c >= 0x7f) {
      ashex = c.charCodeAt(0).toString(16);
      if (ashex.length < 2) {
        ashex = "0" + ashex;
      }
      ret += "\\x" + ashex;
    } else {
      ret += c;
    }
  }
  ret += quote;
  return new Sk.builtin.str(ret);
};
Sk.builtin.str.re_escape_ = function (s) {
  var c;
  var i;
  var ret = [];
  var re = /^[A-Za-z0-9]+$/;
  for (i = 0; i < s.length; ++i) {
    c = s.charAt(i);
    if (re.test(c)) {
      ret.push(c);
    } else {
      if (c === "\\000") {
        ret.push("\\000");
      } else {
        ret.push("\\" + c);
      }
    }
  }
  return ret.join("");
};
Sk.builtin.str.prototype["lower"] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs("lower", arguments, 1, 1);
  return new Sk.builtin.str(self.v.toLowerCase());
});
Sk.builtin.str.prototype["upper"] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs("upper", arguments, 1, 1);
  return new Sk.builtin.str(self.v.toUpperCase());
});
Sk.builtin.str.prototype["capitalize"] = new Sk.builtin.func(function (self) {
  var i;
  var cap;
  var orig;
  Sk.builtin.pyCheckArgs("capitalize", arguments, 1, 1);
  orig = self.v;
  if (orig.length === 0) {
    return new Sk.builtin.str("");
  }
  cap = orig.charAt(0).toUpperCase();
  for (i = 1; i < orig.length; i++) {
    cap += orig.charAt(i).toLowerCase();
  }
  return new Sk.builtin.str(cap);
});
Sk.builtin.str.prototype["join"] = new Sk.builtin.func(function (self, seq) {
  var it, i;
  var arrOfStrs;
  Sk.builtin.pyCheckArgs("join", arguments, 2, 2);
  Sk.builtin.pyCheckType("seq", "iterable", Sk.builtin.checkIterable(seq));
  arrOfStrs = [];
  for (it = seq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    if (i.constructor !== Sk.builtin.str) {
      throw new Sk.builtin.TypeError("TypeError: sequence item " + arrOfStrs.length + ": expected string, " + typeof i + " found");
    }
    arrOfStrs.push(i.v);
  }
  return new Sk.builtin.str(arrOfStrs.join(self.v));
});
Sk.builtin.str.prototype["split"] = new Sk.builtin.func(function (self, on, howmany) {
  var splits;
  var index;
  var match;
  var result;
  var s;
  var str;
  var regex;
  Sk.builtin.pyCheckArgs("split", arguments, 1, 3);
  if (on === undefined || on instanceof Sk.builtin.none) {
    on = null;
  }
  if (on !== null && !Sk.builtin.checkString(on)) {
    throw new Sk.builtin.TypeError("expected a string");
  }
  if (on !== null && on.v === "") {
    throw new Sk.builtin.ValueError("empty separator");
  }
  if (howmany !== undefined && !Sk.builtin.checkInt(howmany)) {
    throw new Sk.builtin.TypeError("an integer is required");
  }
  howmany = Sk.builtin.asnum$(howmany);
  regex = /[\s]+/g;
  str = self.v;
  if (on === null) {
    str = goog.string.trimLeft(str);
  } else {
    // Escape special characters in "on" so we can use a regexp
    s = on.v.replace(/([.*+?=|\\\/()\[\]\{\}^$])/g, "\\$1");
    regex = new RegExp(s, "g");
  }

  // This is almost identical to re.split,
  // except how the regexp is constructed

  result = [];
  index = 0;
  splits = 0;
  while ((match = regex.exec(str)) != null) {
    if (match.index === regex.lastIndex) {
      // empty match
      break;
    }
    result.push(new Sk.builtin.str(str.substring(index, match.index)));
    index = regex.lastIndex;
    splits += 1;
    if (howmany && splits >= howmany) {
      break;
    }
  }
  str = str.substring(index);
  if (on !== null || str.length > 0) {
    result.push(new Sk.builtin.str(str));
  }
  return new Sk.builtin.list(result);
});
Sk.builtin.str.prototype["strip"] = new Sk.builtin.func(function (self, chars) {
  var regex;
  var pattern;
  Sk.builtin.pyCheckArgs("strip", arguments, 1, 2);
  if (chars !== undefined && !Sk.builtin.checkString(chars)) {
    throw new Sk.builtin.TypeError("strip arg must be None or str");
  }
  if (chars === undefined) {
    pattern = /^\s+|\s+$/g;
  } else {
    regex = Sk.builtin.str.re_escape_(chars.v);
    pattern = new RegExp("^[" + regex + "]+|[" + regex + "]+$", "g");
  }
  return new Sk.builtin.str(self.v.replace(pattern, ""));
});
Sk.builtin.str.prototype["lstrip"] = new Sk.builtin.func(function (self, chars) {
  var regex;
  var pattern;
  Sk.builtin.pyCheckArgs("lstrip", arguments, 1, 2);
  if (chars !== undefined && !Sk.builtin.checkString(chars)) {
    throw new Sk.builtin.TypeError("lstrip arg must be None or str");
  }
  if (chars === undefined) {
    pattern = /^\s+/g;
  } else {
    regex = Sk.builtin.str.re_escape_(chars.v);
    pattern = new RegExp("^[" + regex + "]+", "g");
  }
  return new Sk.builtin.str(self.v.replace(pattern, ""));
});
Sk.builtin.str.prototype["rstrip"] = new Sk.builtin.func(function (self, chars) {
  var regex;
  var pattern;
  Sk.builtin.pyCheckArgs("rstrip", arguments, 1, 2);
  if (chars !== undefined && !Sk.builtin.checkString(chars)) {
    throw new Sk.builtin.TypeError("rstrip arg must be None or str");
  }
  if (chars === undefined) {
    pattern = /\s+$/g;
  } else {
    regex = Sk.builtin.str.re_escape_(chars.v);
    pattern = new RegExp("[" + regex + "]+$", "g");
  }
  return new Sk.builtin.str(self.v.replace(pattern, ""));
});
Sk.builtin.str.prototype["partition"] = new Sk.builtin.func(function (self, sep) {
  var pos;
  var sepStr;
  Sk.builtin.pyCheckArgs("partition", arguments, 2, 2);
  Sk.builtin.pyCheckType("sep", "string", Sk.builtin.checkString(sep));
  sepStr = new Sk.builtin.str(sep);
  pos = self.v.indexOf(sepStr.v);
  if (pos < 0) {
    return new Sk.builtin.tuple([self, Sk.builtin.str.$emptystr, Sk.builtin.str.$emptystr]);
  }
  return new Sk.builtin.tuple([new Sk.builtin.str(self.v.substring(0, pos)), sepStr, new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))]);
});
Sk.builtin.str.prototype["rpartition"] = new Sk.builtin.func(function (self, sep) {
  var pos;
  var sepStr;
  Sk.builtin.pyCheckArgs("rpartition", arguments, 2, 2);
  Sk.builtin.pyCheckType("sep", "string", Sk.builtin.checkString(sep));
  sepStr = new Sk.builtin.str(sep);
  pos = self.v.lastIndexOf(sepStr.v);
  if (pos < 0) {
    return new Sk.builtin.tuple([Sk.builtin.str.$emptystr, Sk.builtin.str.$emptystr, self]);
  }
  return new Sk.builtin.tuple([new Sk.builtin.str(self.v.substring(0, pos)), sepStr, new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))]);
});
Sk.builtin.str.prototype["count"] = new Sk.builtin.func(function (self, pat, start, end) {
  var normaltext;
  var ctl;
  var slice;
  var m;
  Sk.builtin.pyCheckArgs("count", arguments, 2, 4);
  if (!Sk.builtin.checkString(pat)) {
    throw new Sk.builtin.TypeError("expected a character buffer object");
  }
  if (start !== undefined && !Sk.builtin.checkInt(start)) {
    throw new Sk.builtin.TypeError("slice indices must be integers or None or have an __index__ method");
  }
  if (end !== undefined && !Sk.builtin.checkInt(end)) {
    throw new Sk.builtin.TypeError("slice indices must be integers or None or have an __index__ method");
  }
  if (start === undefined) {
    start = 0;
  } else {
    start = Sk.builtin.asnum$(start);
    start = start >= 0 ? start : self.v.length + start;
  }
  if (end === undefined) {
    end = self.v.length;
  } else {
    end = Sk.builtin.asnum$(end);
    end = end >= 0 ? end : self.v.length + end;
  }
  normaltext = pat.v.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  m = new RegExp(normaltext, "g");
  slice = self.v.slice(start, end);
  ctl = slice.match(m);
  if (!ctl) {
    return new Sk.builtin.int_(0);
  } else {
    return new Sk.builtin.int_(ctl.length);
  }
});
Sk.builtin.str.prototype["ljust"] = new Sk.builtin.func(function (self, len, fillchar) {
  var newstr;
  Sk.builtin.pyCheckArgs("ljust", arguments, 2, 3);
  if (!Sk.builtin.checkInt(len)) {
    throw new Sk.builtin.TypeError("integer argument exepcted, got " + Sk.abstr.typeName(len));
  }
  if (fillchar !== undefined && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {
    throw new Sk.builtin.TypeError("must be char, not " + Sk.abstr.typeName(fillchar));
  }
  if (fillchar === undefined) {
    fillchar = " ";
  } else {
    fillchar = fillchar.v;
  }
  len = Sk.builtin.asnum$(len);
  if (self.v.length >= len) {
    return self;
  } else {
    newstr = Array.prototype.join.call({
      length: Math.floor(len - self.v.length) + 1
    }, fillchar);
    return new Sk.builtin.str(self.v + newstr);
  }
});
Sk.builtin.str.prototype["rjust"] = new Sk.builtin.func(function (self, len, fillchar) {
  var newstr;
  Sk.builtin.pyCheckArgs("rjust", arguments, 2, 3);
  if (!Sk.builtin.checkInt(len)) {
    throw new Sk.builtin.TypeError("integer argument exepcted, got " + Sk.abstr.typeName(len));
  }
  if (fillchar !== undefined && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {
    throw new Sk.builtin.TypeError("must be char, not " + Sk.abstr.typeName(fillchar));
  }
  if (fillchar === undefined) {
    fillchar = " ";
  } else {
    fillchar = fillchar.v;
  }
  len = Sk.builtin.asnum$(len);
  if (self.v.length >= len) {
    return self;
  } else {
    newstr = Array.prototype.join.call({
      length: Math.floor(len - self.v.length) + 1
    }, fillchar);
    return new Sk.builtin.str(newstr + self.v);
  }
});
Sk.builtin.str.prototype["center"] = new Sk.builtin.func(function (self, len, fillchar) {
  var newstr;
  var newstr1;
  Sk.builtin.pyCheckArgs("center", arguments, 2, 3);
  if (!Sk.builtin.checkInt(len)) {
    throw new Sk.builtin.TypeError("integer argument exepcted, got " + Sk.abstr.typeName(len));
  }
  if (fillchar !== undefined && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {
    throw new Sk.builtin.TypeError("must be char, not " + Sk.abstr.typeName(fillchar));
  }
  if (fillchar === undefined) {
    fillchar = " ";
  } else {
    fillchar = fillchar.v;
  }
  len = Sk.builtin.asnum$(len);
  if (self.v.length >= len) {
    return self;
  } else {
    newstr1 = Array.prototype.join.call({
      length: Math.floor((len - self.v.length) / 2) + 1
    }, fillchar);
    newstr = newstr1 + self.v + newstr1;
    if (newstr.length < len) {
      newstr = newstr + fillchar;
    }
    return new Sk.builtin.str(newstr);
  }
});
Sk.builtin.str.prototype["find"] = new Sk.builtin.func(function (self, tgt, start, end) {
  var idx;
  Sk.builtin.pyCheckArgs("find", arguments, 2, 4);
  if (!Sk.builtin.checkString(tgt)) {
    throw new Sk.builtin.TypeError("expected a character buffer object");
  }
  if (start !== undefined && !Sk.builtin.checkInt(start)) {
    throw new Sk.builtin.TypeError("slice indices must be integers or None or have an __index__ method");
  }
  if (end !== undefined && !Sk.builtin.checkInt(end)) {
    throw new Sk.builtin.TypeError("slice indices must be integers or None or have an __index__ method");
  }
  if (start === undefined) {
    start = 0;
  } else {
    start = Sk.builtin.asnum$(start);
    start = start >= 0 ? start : self.v.length + start;
  }
  if (end === undefined) {
    end = self.v.length;
  } else {
    end = Sk.builtin.asnum$(end);
    end = end >= 0 ? end : self.v.length + end;
  }
  idx = self.v.indexOf(tgt.v, start);
  idx = idx >= start && idx < end ? idx : -1;
  return new Sk.builtin.int_(idx);
});
Sk.builtin.str.prototype["index"] = new Sk.builtin.func(function (self, tgt, start, end) {
  var idx;
  Sk.builtin.pyCheckArgs("index", arguments, 2, 4);
  idx = Sk.misceval.callsim(self["find"], self, tgt, start, end);
  if (Sk.builtin.asnum$(idx) === -1) {
    throw new Sk.builtin.ValueError("substring not found");
  }
  return idx;
});
Sk.builtin.str.prototype["rfind"] = new Sk.builtin.func(function (self, tgt, start, end) {
  var idx;
  Sk.builtin.pyCheckArgs("rfind", arguments, 2, 4);
  if (!Sk.builtin.checkString(tgt)) {
    throw new Sk.builtin.TypeError("expected a character buffer object");
  }
  if (start !== undefined && !Sk.builtin.checkInt(start)) {
    throw new Sk.builtin.TypeError("slice indices must be integers or None or have an __index__ method");
  }
  if (end !== undefined && !Sk.builtin.checkInt(end)) {
    throw new Sk.builtin.TypeError("slice indices must be integers or None or have an __index__ method");
  }
  if (start === undefined) {
    start = 0;
  } else {
    start = Sk.builtin.asnum$(start);
    start = start >= 0 ? start : self.v.length + start;
  }
  if (end === undefined) {
    end = self.v.length;
  } else {
    end = Sk.builtin.asnum$(end);
    end = end >= 0 ? end : self.v.length + end;
  }
  idx = self.v.lastIndexOf(tgt.v, end);
  idx = idx !== end ? idx : self.v.lastIndexOf(tgt.v, end - 1);
  idx = idx >= start && idx < end ? idx : -1;
  return new Sk.builtin.int_(idx);
});
Sk.builtin.str.prototype["rindex"] = new Sk.builtin.func(function (self, tgt, start, end) {
  var idx;
  Sk.builtin.pyCheckArgs("rindex", arguments, 2, 4);
  idx = Sk.misceval.callsim(self["rfind"], self, tgt, start, end);
  if (Sk.builtin.asnum$(idx) === -1) {
    throw new Sk.builtin.ValueError("substring not found");
  }
  return idx;
});
Sk.builtin.str.prototype["startswith"] = new Sk.builtin.func(function (self, tgt) {
  Sk.builtin.pyCheckArgs("startswith", arguments, 2, 2);
  Sk.builtin.pyCheckType("tgt", "string", Sk.builtin.checkString(tgt));
  return new Sk.builtin.bool(self.v.indexOf(tgt.v) === 0);
});

// http://stackoverflow.com/questions/280634/endswith-in-javascript
Sk.builtin.str.prototype["endswith"] = new Sk.builtin.func(function (self, tgt) {
  Sk.builtin.pyCheckArgs("endswith", arguments, 2, 2);
  Sk.builtin.pyCheckType("tgt", "string", Sk.builtin.checkString(tgt));
  return new Sk.builtin.bool(self.v.indexOf(tgt.v, self.v.length - tgt.v.length) !== -1);
});
Sk.builtin.str.prototype["replace"] = new Sk.builtin.func(function (self, oldS, newS, count) {
  var c;
  var patt;
  Sk.builtin.pyCheckArgs("replace", arguments, 3, 4);
  Sk.builtin.pyCheckType("oldS", "string", Sk.builtin.checkString(oldS));
  Sk.builtin.pyCheckType("newS", "string", Sk.builtin.checkString(newS));
  if (count !== undefined && !Sk.builtin.checkInt(count)) {
    throw new Sk.builtin.TypeError("integer argument expected, got " + Sk.abstr.typeName(count));
  }
  count = Sk.builtin.asnum$(count);
  patt = new RegExp(Sk.builtin.str.re_escape_(oldS.v), "g");
  if (count === undefined || count < 0) {
    return new Sk.builtin.str(self.v.replace(patt, newS.v));
  }
  c = 0;
  function replacer(match) {
    c++;
    if (c <= count) {
      return newS.v;
    }
    return match;
  }
  return new Sk.builtin.str(self.v.replace(patt, replacer));
});
Sk.builtin.str.prototype["zfill"] = new Sk.builtin.func(function (self, len) {
  var str = self.v;
  var ret;
  var zeroes;
  var offset;
  var pad = "";
  Sk.builtin.pyCheckArgs("zfill", arguments, 2, 2);
  if (!Sk.builtin.checkInt(len)) {
    throw new Sk.builtin.TypeError("integer argument exepected, got " + Sk.abstr.typeName(len));
  }

  // figure out how many zeroes are needed to make the proper length
  zeroes = len.v - str.length;
  // offset by 1 if there is a +/- at the beginning of the string
  offset = str[0] === "+" || str[0] === "-" ? 1 : 0;
  for (var i = 0; i < zeroes; i++) {
    pad += "0";
  }
  // combine the string and the zeroes
  ret = str.substr(0, offset) + pad + str.substr(offset);
  return new Sk.builtin.str(ret);
});
Sk.builtin.str.prototype["isdigit"] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs("isdigit", arguments, 1, 1);
  return new Sk.builtin.bool(/^\d+$/.test(self.v));
});
Sk.builtin.str.prototype["isspace"] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs("isspace", arguments, 1, 1);
  return new Sk.builtin.bool(/^\s+$/.test(self.v));
});
Sk.builtin.str.prototype["expandtabs"] = new Sk.builtin.func(function (self, tabsize) {
  // var input = self.v;
  // var expanded = "";
  // var split;
  // var spacestr = "";
  // var spacerem;

  var spaces;
  var expanded;
  Sk.builtin.pyCheckArgs("expandtabs", arguments, 1, 2);
  if (tabsize !== undefined && !Sk.builtin.checkInt(tabsize)) {
    throw new Sk.builtin.TypeError("integer argument exepected, got " + Sk.abstr.typeName(tabsize));
  }
  if (tabsize === undefined) {
    tabsize = 8;
  } else {
    tabsize = Sk.builtin.asnum$(tabsize);
  }
  spaces = new Array(tabsize + 1).join(" ");
  expanded = self.v.replace(/([^\r\n\t]*)\t/g, function (a, b) {
    return b + spaces.slice(b.length % tabsize);
  });
  return new Sk.builtin.str(expanded);
});
Sk.builtin.str.prototype["swapcase"] = new Sk.builtin.func(function (self) {
  var ret;
  Sk.builtin.pyCheckArgs("swapcase", arguments, 1, 1);
  ret = self.v.replace(/[a-z]/gi, function (c) {
    var lc = c.toLowerCase();
    return lc === c ? c.toUpperCase() : lc;
  });
  return new Sk.builtin.str(ret);
});
Sk.builtin.str.prototype["splitlines"] = new Sk.builtin.func(function (self, keepends) {
  var data = self.v;
  var i = 0;
  var j = i;
  var selflen = self.v.length;
  var strs_w = [];
  var ch;
  var eol;
  var sol = 0;
  var slice;
  Sk.builtin.pyCheckArgs("splitlines", arguments, 1, 2);
  if (keepends !== undefined && !Sk.builtin.checkBool(keepends)) {
    throw new Sk.builtin.TypeError("boolean argument expected, got " + Sk.abstr.typeName(keepends));
  }
  if (keepends === undefined) {
    keepends = false;
  } else {
    keepends = keepends.v;
  }
  for (i = 0; i < selflen; i++) {
    ch = data.charAt(i);
    if (data.charAt(i + 1) === "\n" && ch === "\r") {
      eol = i + 2;
      slice = data.slice(sol, eol);
      if (!keepends) {
        slice = slice.replace(/(\r|\n)/g, "");
      }
      strs_w.push(new Sk.builtin.str(slice));
      sol = eol;
    } else if (ch === "\n" && data.charAt(i - 1) !== "\r" || ch === "\r") {
      eol = i + 1;
      slice = data.slice(sol, eol);
      if (!keepends) {
        slice = slice.replace(/(\r|\n)/g, "");
      }
      strs_w.push(new Sk.builtin.str(slice));
      sol = eol;
    }
  }
  if (sol < selflen) {
    eol = selflen;
    slice = data.slice(sol, eol);
    if (!keepends) {
      slice = slice.replace(/(\r|\n)/g, "");
    }
    strs_w.push(new Sk.builtin.str(slice));
  }
  return new Sk.builtin.list(strs_w);
});
Sk.builtin.str.prototype["title"] = new Sk.builtin.func(function (self) {
  var ret;
  Sk.builtin.pyCheckArgs("title", arguments, 1, 1);
  ret = self.v.replace(/[a-z][a-z]*/gi, function (str) {
    return str[0].toUpperCase() + str.substr(1).toLowerCase();
  });
  return new Sk.builtin.str(ret);
});
Sk.builtin.str.prototype["isalpha"] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs("isalpha", arguments, 1, 1);
  return new Sk.builtin.bool(self.v.length && goog.string.isAlpha(self.v));
});
Sk.builtin.str.prototype["isalnum"] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs("isalnum", arguments, 1, 1);
  return new Sk.builtin.bool(self.v.length && goog.string.isAlphaNumeric(self.v));
});

// does not account for unicode numeric values
Sk.builtin.str.prototype["isnumeric"] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs("isnumeric", arguments, 1, 1);
  return new Sk.builtin.bool(self.v.length && goog.string.isNumeric(self.v));
});
Sk.builtin.str.prototype["islower"] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs("islower", arguments, 1, 1);
  return new Sk.builtin.bool(self.v.length && /[a-z]/.test(self.v) && !/[A-Z]/.test(self.v));
});
Sk.builtin.str.prototype["isupper"] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs("isupper", arguments, 1, 1);
  return new Sk.builtin.bool(self.v.length && !/[a-z]/.test(self.v) && /[A-Z]/.test(self.v));
});
Sk.builtin.str.prototype["istitle"] = new Sk.builtin.func(function (self) {
  // Comparing to str.title() seems the most intuitive thing, but it fails on "",
  // Other empty-ish strings with no change.
  var input = self.v;
  var cased = false;
  var previous_is_cased = false;
  var pos;
  var ch;
  Sk.builtin.pyCheckArgs("istitle", arguments, 1, 1);
  for (pos = 0; pos < input.length; pos++) {
    ch = input.charAt(pos);
    if (!/[a-z]/.test(ch) && /[A-Z]/.test(ch)) {
      if (previous_is_cased) {
        return new Sk.builtin.bool(false);
      }
      previous_is_cased = true;
      cased = true;
    } else if (/[a-z]/.test(ch) && !/[A-Z]/.test(ch)) {
      if (!previous_is_cased) {
        return new Sk.builtin.bool(false);
      }
      cased = true;
    } else {
      previous_is_cased = false;
    }
  }
  return new Sk.builtin.bool(cased);
});
Sk.builtin.str.prototype.nb$remainder = function (rhs) {
  // % format op. rhs can be a value, a tuple, or something with __getitem__ (dict)

  // From http://docs.python.org/library/stdtypes.html#string-formatting the
  // format looks like:
  // 1. The '%' character, which marks the start of the specifier.
  // 2. Mapping key (optional), consisting of a parenthesised sequence of characters (for example, (somename)).
  // 3. Conversion flags (optional), which affect the result of some conversion types.
  // 4. Minimum field width (optional). If specified as an '*' (asterisk), the actual width is read from the next
  // element of the tuple in values, and the object to convert comes after the minimum field width and optional
  // precision. 5. Precision (optional), given as a '.' (dot) followed by the precision. If specified as '*' (an
  // asterisk), the actual width is read from the next element of the tuple in values, and the value to convert comes
  // after the precision. 6. Length modifier (optional). 7. Conversion type.  length modifier is ignored

  var ret;
  var replFunc;
  var index;
  var regex;
  if (rhs.constructor !== Sk.builtin.tuple && (rhs.mp$subscript === undefined || rhs.constructor === Sk.builtin.str)) {
    rhs = new Sk.builtin.tuple([rhs]);
  }

  // general approach is to use a regex that matches the format above, and
  // do an re.sub with a function as replacement to make the subs.

  //           1 2222222222222222   33333333   444444444   5555555555555  66666  777777777777777777
  regex = /%(\([a-zA-Z0-9]+\))?([#0 +\-]+)?(\*|[0-9]+)?(\.(\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrs%])/g;
  index = 0;
  replFunc = function (substring, mappingKey, conversionFlags, fieldWidth, precision, precbody, conversionType) {
    var result;
    var convName;
    var convValue;
    var base;
    var r;
    var mk;
    var value;
    var handleWidth;
    var formatNumber;
    var alternateForm;
    var precedeWithSign;
    var blankBeforePositive;
    var leftAdjust;
    var zeroPad;
    var i;
    fieldWidth = Sk.builtin.asnum$(fieldWidth);
    precision = Sk.builtin.asnum$(precision);
    if (mappingKey === undefined || mappingKey === "") {
      i = index++;
    } // ff passes '' not undef for some reason

    if (precision === "") {
      // ff passes '' here aswell causing problems with G,g, etc.
      precision = undefined;
    }
    zeroPad = false;
    leftAdjust = false;
    blankBeforePositive = false;
    precedeWithSign = false;
    alternateForm = false;
    if (conversionFlags) {
      if (conversionFlags.indexOf("-") !== -1) {
        leftAdjust = true;
      } else if (conversionFlags.indexOf("0") !== -1) {
        zeroPad = true;
      }
      if (conversionFlags.indexOf("+") !== -1) {
        precedeWithSign = true;
      } else if (conversionFlags.indexOf(" ") !== -1) {
        blankBeforePositive = true;
      }
      alternateForm = conversionFlags.indexOf("#") !== -1;
    }
    if (precision) {
      precision = parseInt(precision.substr(1), 10);
    }
    formatNumber = function (n, base) {
      var precZeroPadded;
      var prefix;
      var didSign;
      var neg;
      var r;
      var j;
      base = Sk.builtin.asnum$(base);
      neg = false;
      didSign = false;
      if (typeof n === "number") {
        if (n < 0) {
          n = -n;
          neg = true;
        }
        r = n.toString(base);
      } else if (n instanceof Sk.builtin.float_) {
        r = n.str$(base, false);
        if (r.length > 2 && r.substr(-2) === ".0") {
          r = r.substr(0, r.length - 2);
        }
        neg = n.nb$isnegative();
      } else if (n instanceof Sk.builtin.int_) {
        r = n.str$(base, false);
        neg = n.nb$isnegative();
      } else if (n instanceof Sk.builtin.lng) {
        r = n.str$(base, false);
        neg = n.nb$isnegative(); //	neg = n.size$ < 0;	RNL long.js change
      }

      goog.asserts.assert(r !== undefined, "unhandled number format");
      precZeroPadded = false;
      if (precision) {
        //print("r.length",r.length,"precision",precision);
        for (j = r.length; j < precision; ++j) {
          r = "0" + r;
          precZeroPadded = true;
        }
      }
      prefix = "";
      if (neg) {
        prefix = "-";
      } else if (precedeWithSign) {
        prefix = "+" + prefix;
      } else if (blankBeforePositive) {
        prefix = " " + prefix;
      }
      if (alternateForm) {
        if (base === 16) {
          prefix += "0x";
        } else if (base === 8 && !precZeroPadded && r !== "0") {
          prefix += "0";
        }
      }
      return [prefix, r];
    };
    handleWidth = function (args) {
      var totLen;
      var prefix = args[0];
      var r = args[1];
      var j;
      if (fieldWidth) {
        fieldWidth = parseInt(fieldWidth, 10);
        totLen = r.length + prefix.length;
        if (zeroPad) {
          for (j = totLen; j < fieldWidth; ++j) {
            r = "0" + r;
          }
        } else if (leftAdjust) {
          for (j = totLen; j < fieldWidth; ++j) {
            r = r + " ";
          }
        } else {
          for (j = totLen; j < fieldWidth; ++j) {
            prefix = " " + prefix;
          }
        }
      }
      return prefix + r;
    };

    //print("Rhs:",rhs, "ctor", rhs.constructor);
    if (rhs.constructor === Sk.builtin.tuple) {
      value = rhs.v[i];
    } else if (rhs.mp$subscript !== undefined && mappingKey !== undefined) {
      mk = mappingKey.substring(1, mappingKey.length - 1);
      //print("mk",mk);
      value = rhs.mp$subscript(new Sk.builtin.str(mk));
    } else if (rhs.constructor === Sk.builtin.dict || rhs.constructor === Sk.builtin.list) {
      // new case where only one argument is provided
      value = rhs;
    } else {
      throw new Sk.builtin.AttributeError(rhs.tp$name + " instance has no attribute 'mp$subscript'");
    }
    base = 10;
    if (conversionType === "d" || conversionType === "i") {
      return handleWidth(formatNumber(value, 10));
    } else if (conversionType === "o") {
      return handleWidth(formatNumber(value, 8));
    } else if (conversionType === "x") {
      return handleWidth(formatNumber(value, 16));
    } else if (conversionType === "X") {
      return handleWidth(formatNumber(value, 16)).toUpperCase();
    } else if (conversionType === "f" || conversionType === "F" || conversionType === "e" || conversionType === "E" || conversionType === "g" || conversionType === "G") {
      convValue = Sk.builtin.asnum$(value);
      if (typeof convValue === "string") {
        convValue = Number(convValue);
      }
      if (convValue === Infinity) {
        return "inf";
      }
      if (convValue === -Infinity) {
        return "-inf";
      }
      if (isNaN(convValue)) {
        return "nan";
      }
      convName = ["toExponential", "toFixed", "toPrecision"]["efg".indexOf(conversionType.toLowerCase())];
      if (precision === undefined || precision === "") {
        if (conversionType === "e" || conversionType === "E") {
          precision = 6;
        } else if (conversionType === "f" || conversionType === "F") {
          precision = 7;
        }
      }
      result = convValue[convName](precision); // possible loose of negative zero sign

      // apply sign to negative zeros, floats only!
      if (Sk.builtin.checkFloat(value)) {
        if (convValue === 0 && 1 / convValue === -Infinity) {
          result = "-" + result; // add sign for zero
        }
      }

      if ("EFG".indexOf(conversionType) !== -1) {
        result = result.toUpperCase();
      }
      return handleWidth(["", result]);
    } else if (conversionType === "c") {
      if (typeof value === "number") {
        return String.fromCharCode(value);
      } else if (value instanceof Sk.builtin.int_) {
        return String.fromCharCode(value.v);
      } else if (value instanceof Sk.builtin.float_) {
        return String.fromCharCode(value.v);
      } else if (value instanceof Sk.builtin.lng) {
        return String.fromCharCode(value.str$(10, false)[0]);
      } else if (value.constructor === Sk.builtin.str) {
        return value.v.substr(0, 1);
      } else {
        throw new Sk.builtin.TypeError("an integer is required");
      }
    } else if (conversionType === "r") {
      r = Sk.builtin.repr(value);
      if (precision) {
        return r.v.substr(0, precision);
      }
      return r.v;
    } else if (conversionType === "s") {
      r = new Sk.builtin.str(value);
      if (precision) {
        return r.v.substr(0, precision);
      }
      if (fieldWidth) {
        r.v = handleWidth([" ", r.v]);
      }
      return r.v;
    } else if (conversionType === "%") {
      return "%";
    }
  };
  ret = this.v.replace(regex, replFunc);
  return new Sk.builtin.str(ret);
};

/**
 * @constructor
 * @param {Object} obj
 */
Sk.builtin.str_iter_ = function (obj) {
  if (!(this instanceof Sk.builtin.str_iter_)) {
    return new Sk.builtin.str_iter_(obj);
  }
  this.$index = 0;
  this.$obj = obj.v.slice();
  this.sq$length = this.$obj.length;
  this.tp$iter = this;
  this.tp$iternext = function () {
    if (this.$index >= this.sq$length) {
      return undefined;
    }
    return new Sk.builtin.str(this.$obj.substr(this.$index++, 1));
  };
  this.$r = function () {
    return new Sk.builtin.str("iterator");
  };
  return this;
};
Sk.abstr.setUpInheritance("iterator", Sk.builtin.str_iter_, Sk.builtin.object);
Sk.builtin.str_iter_.prototype.__class__ = Sk.builtin.str_iter_;
Sk.builtin.str_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs("__iter__", arguments, 0, 0, true, false);
  return self;
});
Sk.builtin.str_iter_.prototype["next"] = new Sk.builtin.func(function (self) {
  var ret = self.tp$iternext();
  if (ret === undefined) {
    throw new Sk.builtin.StopIteration();
  }
  return ret;
});

/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/tokenize.js ---- */

/*
 * This is a port of tokenize.py by Ka-Ping Yee.
 *
 * each call to readline should return one line of input as a string, or
 * undefined if it's finished.
 *
 * callback is called for each token with 5 args:
 * 1. the token type
 * 2. the token string
 * 3. [ start_row, start_col ]
 * 4. [ end_row, end_col ]
 * 5. logical line where the token was found, including continuation lines
 *
 * callback can return true to abort.
 *
 */

/**
 * @constructor
 */
Sk.Tokenizer = function (filename, interactive, callback) {
  this.filename = filename;
  this.callback = callback;
  this.lnum = 0;
  this.parenlev = 0;
  this.parenstack = [];
  this.continued = false;
  this.namechars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";
  this.numchars = "0123456789";
  this.contstr = "";
  this.needcont = false;
  this.contline = undefined;
  this.indents = [0];
  this.endprog = /.*/;
  this.strstart = [-1, -1];
  this.interactive = interactive;
  this.doneFunc = function () {
    var i;
    for (i = 1; i < this.indents.length; ++i)
    // pop remaining indent levels
    {
      if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, "", [this.lnum, 0], [this.lnum, 0], "")) {
        return "done";
      }
    }
    if (this.callback(Sk.Tokenizer.Tokens.T_ENDMARKER, "", [this.lnum, 0], [this.lnum, 0], "")) {
      return "done";
    }
    return "failed";
  };
};

/**
 * @enum {number}
 */
Sk.Tokenizer.Tokens = {
  T_ENDMARKER: 0,
  T_NAME: 1,
  T_NUMBER: 2,
  T_STRING: 3,
  T_NEWLINE: 4,
  T_INDENT: 5,
  T_DEDENT: 6,
  T_LPAR: 7,
  T_RPAR: 8,
  T_LSQB: 9,
  T_RSQB: 10,
  T_COLON: 11,
  T_COMMA: 12,
  T_SEMI: 13,
  T_PLUS: 14,
  T_MINUS: 15,
  T_STAR: 16,
  T_SLASH: 17,
  T_VBAR: 18,
  T_AMPER: 19,
  T_LESS: 20,
  T_GREATER: 21,
  T_EQUAL: 22,
  T_DOT: 23,
  T_PERCENT: 24,
  T_BACKQUOTE: 25,
  T_LBRACE: 26,
  T_RBRACE: 27,
  T_EQEQUAL: 28,
  T_NOTEQUAL: 29,
  T_LESSEQUAL: 30,
  T_GREATEREQUAL: 31,
  T_TILDE: 32,
  T_CIRCUMFLEX: 33,
  T_LEFTSHIFT: 34,
  T_RIGHTSHIFT: 35,
  T_DOUBLESTAR: 36,
  T_PLUSEQUAL: 37,
  T_MINEQUAL: 38,
  T_STAREQUAL: 39,
  T_SLASHEQUAL: 40,
  T_PERCENTEQUAL: 41,
  T_AMPEREQUAL: 42,
  T_VBAREQUAL: 43,
  T_CIRCUMFLEXEQUAL: 44,
  T_LEFTSHIFTEQUAL: 45,
  T_RIGHTSHIFTEQUAL: 46,
  T_DOUBLESTAREQUAL: 47,
  T_DOUBLESLASH: 48,
  T_DOUBLESLASHEQUAL: 49,
  T_AT: 50,
  T_OP: 51,
  T_COMMENT: 52,
  T_NL: 53,
  T_RARROW: 54,
  T_ERRORTOKEN: 55,
  T_N_TOKENS: 56,
  T_NT_OFFSET: 256
};

/** @param {...*} x */
function group(x) {
  var args = Array.prototype.slice.call(arguments);
  return "(" + args.join("|") + ")";
}

/** @param {...*} x */
function any(x) {
  return group.apply(null, arguments) + "*";
}

/** @param {...*} x */
function maybe(x) {
  return group.apply(null, arguments) + "?";
}

/* we have to use string and ctor to be able to build patterns up. + on /.../
 * does something strange. */
var Whitespace = "[ \\f\\t]*";
var Comment_ = "#[^\\r\\n]*";
var Ident = "[a-zA-Z_]\\w*";
var Binnumber = "0[bB][01]*";
var Hexnumber = "0[xX][\\da-fA-F]*[lL]?";
var Octnumber = "0[oO]?[0-7]*[lL]?";
var Decnumber = "[1-9]\\d*[lL]?";
var Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber);
var Exponent = "[eE][-+]?\\d+";
var Pointfloat = group("\\d+\\.\\d*", "\\.\\d+") + maybe(Exponent);
var Expfloat = "\\d+" + Exponent;
var Floatnumber = group(Pointfloat, Expfloat);
var Imagnumber = group("\\d+[jJ]", Floatnumber + "[jJ]");
var Number_ = group(Imagnumber, Floatnumber, Intnumber);

// tail end of ' string
var Single = "^[^'\\\\]*(?:\\\\.[^'\\\\]*)*'";
// tail end of " string
var Double_ = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"';
// tail end of ''' string
var Single3 = "[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''";
// tail end of """ string
var Double3 = '[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';
var Triple = group("[ubUB]?[rR]?'''", '[ubUB]?[rR]?"""');
var String_ = group("[uU]?[rR]?'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'", '[uU]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"');

// Because of leftmost-then-longest match semantics, be sure to put the
// longest operators first (e.g., if = came before ==, == would get
// recognized as two instances of =).
var Operator = group("\\*\\*=?", ">>=?", "<<=?", "<>", "!=", "//=?", "->", "[+\\-*/%&|^=<>]=?", "~");
var Bracket = "[\\][(){}]";
var Special = group("\\r?\\n", "[:;.,`@]");
var Funny = group(Operator, Bracket, Special);
var ContStr = group("[uUbB]?[rR]?'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*" + group("'", "\\\\\\r?\\n"), "[uUbB]?[rR]?\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*" + group("\"", "\\\\\\r?\\n"));
var PseudoExtras = group("\\\\\\r?\\n", Comment_, Triple);
// Need to prefix with "^" as we only want to match what's next
var PseudoToken = "^" + group(PseudoExtras, Number_, Funny, ContStr, Ident);
var triple_quoted = {
  "'''": true,
  '"""': true,
  "r'''": true,
  'r"""': true,
  "R'''": true,
  'R"""': true,
  "u'''": true,
  'u"""': true,
  "U'''": true,
  'U"""': true,
  "b'''": true,
  'b"""': true,
  "B'''": true,
  'B"""': true,
  "ur'''": true,
  'ur"""': true,
  "Ur'''": true,
  'Ur"""': true,
  "uR'''": true,
  'uR"""': true,
  "UR'''": true,
  'UR"""': true,
  "br'''": true,
  'br"""': true,
  "Br'''": true,
  'Br"""': true,
  "bR'''": true,
  'bR"""': true,
  "BR'''": true,
  'BR"""': true
};
var single_quoted = {
  "'": true,
  '"': true,
  "r'": true,
  'r"': true,
  "R'": true,
  'R"': true,
  "u'": true,
  'u"': true,
  "U'": true,
  'U"': true,
  "b'": true,
  'b"': true,
  "B'": true,
  'B"': true,
  "ur'": true,
  'ur"': true,
  "Ur'": true,
  'Ur"': true,
  "uR'": true,
  'uR"': true,
  "UR'": true,
  'UR"': true,
  "br'": true,
  'br"': true,
  "Br'": true,
  'Br"': true,
  "bR'": true,
  'bR"': true,
  "BR'": true,
  'BR"': true
};

// hack to make closure keep those objects. not sure what a better way is.
(function () {
  var k;
  for (k in triple_quoted) {}
  for (k in single_quoted) {}
})();
var tabsize = 8;
function contains(a, obj) {
  var i = a.length;
  while (i--) {
    if (a[i] === obj) {
      return true;
    }
  }
  return false;
}
function rstrip(input, what) {
  var i;
  for (i = input.length; i > 0; --i) {
    if (what.indexOf(input.charAt(i - 1)) === -1) {
      break;
    }
  }
  return input.substring(0, i);
}
Sk.Tokenizer.prototype.generateTokens = function (line) {
  var nl_pos;
  var newl;
  var initial;
  var token;
  var epos;
  var spos;
  var start;
  var pseudomatch;
  var capos;
  var comment_token;
  var endmatch, pos, column, end, max;

  // bnm - Move these definitions in this function otherwise test state is preserved between
  // calls on single3prog and double3prog causing weird errors with having multiple instances
  // of triple quoted strings in the same program.

  var pseudoprog = new RegExp(PseudoToken);
  var single3prog = new RegExp(Single3, "g");
  var double3prog = new RegExp(Double3, "g");
  var endprogs = {
    "'": new RegExp(Single, "g"),
    "\"": new RegExp(Double_, "g"),
    "'''": single3prog,
    '"""': double3prog,
    "r'''": single3prog,
    'r"""': double3prog,
    "u'''": single3prog,
    'u"""': double3prog,
    "b'''": single3prog,
    'b"""': double3prog,
    "ur'''": single3prog,
    'ur"""': double3prog,
    "br'''": single3prog,
    'br"""': double3prog,
    "R'''": single3prog,
    'R"""': double3prog,
    "U'''": single3prog,
    'U"""': double3prog,
    "B'''": single3prog,
    'B"""': double3prog,
    "uR'''": single3prog,
    'uR"""': double3prog,
    "Ur'''": single3prog,
    'Ur"""': double3prog,
    "UR'''": single3prog,
    'UR"""': double3prog,
    "bR'''": single3prog,
    'bR"""': double3prog,
    "Br'''": single3prog,
    'Br"""': double3prog,
    "BR'''": single3prog,
    'BR"""': double3prog,
    'r': null,
    'R': null,
    'u': null,
    'U': null,
    'b': null,
    'B': null
  };
  if (!line) {
    line = '';
  }
  //print("LINE:'"+line+"'");

  this.lnum += 1;
  pos = 0;
  max = line.length;
  if (this.contstr.length > 0) {
    if (!line) {
      throw new Sk.builtin.SyntaxError("EOF in multi-line string", this.filename, this.strstart[0], this.strstart[1], {
        kind: "STRING_EOF",
        line: this.contline
      });
    }
    this.endprog.lastIndex = 0;
    endmatch = this.endprog.test(line);
    if (endmatch) {
      pos = end = this.endprog.lastIndex;
      if (this.callback(Sk.Tokenizer.Tokens.T_STRING, this.contstr + line.substring(0, end), this.strstart, [this.lnum, end], this.contline + line)) {
        return 'done';
      }
      this.contstr = '';
      this.needcont = false;
      this.contline = undefined;
    } else if (this.needcont && line.substring(line.length - 2) !== "\\\n" && line.substring(line.length - 3) !== "\\\r\n") {
      if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, this.contstr + line, this.strstart, [this.lnum, line.length], this.contline)) {
        return 'done';
      }
      this.contstr = '';
      this.contline = undefined;
      return false;
    } else {
      this.contstr += line;
      this.contline = this.contline + line;
      return false;
    }
  } else if (this.parenlev === 0 && !this.continued) {
    if (!line) {
      return this.doneFunc();
    }
    column = 0;
    while (pos < max) {
      if (line.charAt(pos) === ' ') {
        column += 1;
      } else if (line.charAt(pos) === '\t') {
        column = (column / tabsize + 1) * tabsize;
      } else if (line.charAt(pos) === '\f') {
        column = 0;
      } else {
        break;
      }
      pos = pos + 1;
    }
    if (pos === max) {
      return this.doneFunc();
    }
    if ("#\r\n".indexOf(line.charAt(pos)) !== -1)
      // skip comments or blank lines
      {
        if (line.charAt(pos) === '#') {
          comment_token = rstrip(line.substring(pos), '\r\n');
          nl_pos = pos + comment_token.length;
          if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, comment_token, [this.lnum, pos], [this.lnum, pos + comment_token.length], line)) {
            return 'done';
          }
          //print("HERE:1");
          if (this.callback(Sk.Tokenizer.Tokens.T_NL, line.substring(nl_pos), [this.lnum, nl_pos], [this.lnum, line.length], line)) {
            return 'done';
          }
          return false;
        } else {
          //print("HERE:2");
          if (this.callback(Sk.Tokenizer.Tokens.T_NL, line.substring(pos), [this.lnum, pos], [this.lnum, line.length], line)) {
            return 'done';
          }
          if (!this.interactive) {
            return false;
          }
        }
      }
    if (column > this.indents[this.indents.length - 1])
      // count indents or dedents
      {
        this.indents.push(column);
        if (this.callback(Sk.Tokenizer.Tokens.T_INDENT, line.substring(0, pos), [this.lnum, 0], [this.lnum, pos], line)) {
          return 'done';
        }
      }
    while (column < this.indents[this.indents.length - 1]) {
      if (!contains(this.indents, column)) {
        throw new Sk.builtin.IndentationError("unindent does not match any outer indentation level", this.filename, this.lnum, pos, line);
      }
      this.indents.splice(this.indents.length - 1, 1);
      //print("dedent here");
      if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [this.lnum, pos], [this.lnum, pos], line)) {
        return 'done';
      }
    }
  } else
    // continued statement
    {
      if (!line) {
        throw new Sk.builtin.SyntaxError("EOF in multi-line statement", this.filename, this.lnum, 0, {
          kind: 'STATEMENT_EOF',
          parenlev: this.parenlev,
          parenstack: this.parenstack
        });
      }
      this.continued = false;
    }
  while (pos < max) {
    //print("pos:"+pos+":"+max);
    // js regexes don't return any info about matches, other than the
    // content. we'd like to put a \w+ before pseudomatch, but then we
    // can't get any data
    capos = line.charAt(pos);
    while (capos === ' ' || capos === '\f' || capos === '\t') {
      pos += 1;
      capos = line.charAt(pos);
    }
    pseudoprog.lastIndex = 0;
    pseudomatch = pseudoprog.exec(line.substring(pos));
    if (pseudomatch) {
      start = pos;
      end = start + pseudomatch[1].length;
      spos = [this.lnum, start];
      epos = [this.lnum, end];
      pos = end;
      token = line.substring(start, end);
      initial = line.charAt(start);
      //Sk.debugout("token:",token, "initial:",initial, start, end);
      if (this.numchars.indexOf(initial) !== -1 || initial === '.' && token !== '.') {
        if (this.callback(Sk.Tokenizer.Tokens.T_NUMBER, token, spos, epos, line)) {
          return 'done';
        }
      } else if (initial === '\r' || initial === '\n') {
        newl = Sk.Tokenizer.Tokens.T_NEWLINE;
        //print("HERE:3");
        if (this.parenlev > 0) {
          newl = Sk.Tokenizer.Tokens.T_NL;
        }
        if (this.callback(newl, token, spos, epos, line)) {
          return 'done';
        }
      } else if (initial === '#') {
        if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, token, spos, epos, line)) {
          return 'done';
        }
      } else if (triple_quoted.hasOwnProperty(token)) {
        this.endprog = endprogs[token];
        this.endprog.lastIndex = 0;
        endmatch = this.endprog.test(line.substring(pos));
        if (endmatch) {
          pos = this.endprog.lastIndex + pos;
          token = line.substring(start, pos);
          if (this.callback(Sk.Tokenizer.Tokens.T_STRING, token, spos, [this.lnum, pos], line)) {
            return 'done';
          }
        } else {
          this.strstart = [this.lnum, start];
          this.contstr = line.substring(start);
          this.contline = line;
          return false;
        }
      } else if (single_quoted.hasOwnProperty(initial) || single_quoted.hasOwnProperty(token.substring(0, 2)) || single_quoted.hasOwnProperty(token.substring(0, 3))) {
        if (token[token.length - 1] === '\n') {
          this.strstart = [this.lnum, start];
          this.endprog = endprogs[initial] || endprogs[token[1]] || endprogs[token[2]];
          this.contstr = line.substring(start);
          this.needcont = true;
          this.contline = line;
          //print("i, t1, t2", initial, token[1], token[2]);
          //print("ep, cs", this.endprog, this.contstr);
          return false;
        } else {
          if (this.callback(Sk.Tokenizer.Tokens.T_STRING, token, spos, epos, line)) {
            return 'done';
          }
        }
      } else if (this.namechars.indexOf(initial) !== -1) {
        if (this.callback(Sk.Tokenizer.Tokens.T_NAME, token, spos, epos, line)) {
          return 'done';
        }
      } else if (initial === '\\') {
        //print("HERE:4");
        if (this.callback(Sk.Tokenizer.Tokens.T_NL, token, spos, [this.lnum, pos], line)) {
          return 'done';
        }
        this.continued = true;
      } else {
        if ('([{'.indexOf(initial) !== -1) {
          this.parenlev += 1;
          this.parenstack.push([initial, this.lnum, pos]);
        } else if (')]}'.indexOf(initial) !== -1) {
          this.parenlev -= 1;
          this.parenstack.pop();
        }
        if (this.callback(Sk.Tokenizer.Tokens.T_OP, token, spos, epos, line)) {
          return 'done';
        }
      }
    } else {
      if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, line.charAt(pos), [this.lnum, pos], [this.lnum, pos + 1], line)) {
        return 'done';
      }
      pos += 1;
    }
  }
  return false;
};
Sk.Tokenizer.tokenNames = {
  0: 'T_ENDMARKER',
  1: 'T_NAME',
  2: 'T_NUMBER',
  3: 'T_STRING',
  4: 'T_NEWLINE',
  5: 'T_INDENT',
  6: 'T_DEDENT',
  7: 'T_LPAR',
  8: 'T_RPAR',
  9: 'T_LSQB',
  10: 'T_RSQB',
  11: 'T_COLON',
  12: 'T_COMMA',
  13: 'T_SEMI',
  14: 'T_PLUS',
  15: 'T_MINUS',
  16: 'T_STAR',
  17: 'T_SLASH',
  18: 'T_VBAR',
  19: 'T_AMPER',
  20: 'T_LESS',
  21: 'T_GREATER',
  22: 'T_EQUAL',
  23: 'T_DOT',
  24: 'T_PERCENT',
  25: 'T_BACKQUOTE',
  26: 'T_LBRACE',
  27: 'T_RBRACE',
  28: 'T_EQEQUAL',
  29: 'T_NOTEQUAL',
  30: 'T_LESSEQUAL',
  31: 'T_GREATEREQUAL',
  32: 'T_TILDE',
  33: 'T_CIRCUMFLEX',
  34: 'T_LEFTSHIFT',
  35: 'T_RIGHTSHIFT',
  36: 'T_DOUBLESTAR',
  37: 'T_PLUSEQUAL',
  38: 'T_MINEQUAL',
  39: 'T_STAREQUAL',
  40: 'T_SLASHEQUAL',
  41: 'T_PERCENTEQUAL',
  42: 'T_AMPEREQUAL',
  43: 'T_VBAREQUAL',
  44: 'T_CIRCUMFLEXEQUAL',
  45: 'T_LEFTSHIFTEQUAL',
  46: 'T_RIGHTSHIFTEQUAL',
  47: 'T_DOUBLESTAREQUAL',
  48: 'T_DOUBLESLASH',
  49: 'T_DOUBLESLASHEQUAL',
  50: 'T_AT',
  51: 'T_OP',
  52: 'T_COMMENT',
  53: 'T_NL',
  54: 'T_RARROW',
  55: 'T_ERRORTOKEN',
  56: 'T_N_TOKENS',
  256: 'T_NT_OFFSET'
};
goog.exportSymbol("Sk.Tokenizer", Sk.Tokenizer);
goog.exportSymbol("Sk.Tokenizer.prototype.generateTokens", Sk.Tokenizer.prototype.generateTokens);
goog.exportSymbol("Sk.Tokenizer.tokenNames", Sk.Tokenizer.tokenNames);

/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/gen/parse_tables.js ---- */

// generated by pgen/main.py
Sk.OpMap = {
  "(": Sk.Tokenizer.Tokens.T_LPAR,
  ")": Sk.Tokenizer.Tokens.T_RPAR,
  "[": Sk.Tokenizer.Tokens.T_LSQB,
  "]": Sk.Tokenizer.Tokens.T_RSQB,
  ":": Sk.Tokenizer.Tokens.T_COLON,
  ",": Sk.Tokenizer.Tokens.T_COMMA,
  ";": Sk.Tokenizer.Tokens.T_SEMI,
  "+": Sk.Tokenizer.Tokens.T_PLUS,
  "-": Sk.Tokenizer.Tokens.T_MINUS,
  "*": Sk.Tokenizer.Tokens.T_STAR,
  "/": Sk.Tokenizer.Tokens.T_SLASH,
  "|": Sk.Tokenizer.Tokens.T_VBAR,
  "&": Sk.Tokenizer.Tokens.T_AMPER,
  "<": Sk.Tokenizer.Tokens.T_LESS,
  ">": Sk.Tokenizer.Tokens.T_GREATER,
  "=": Sk.Tokenizer.Tokens.T_EQUAL,
  ".": Sk.Tokenizer.Tokens.T_DOT,
  "%": Sk.Tokenizer.Tokens.T_PERCENT,
  "`": Sk.Tokenizer.Tokens.T_BACKQUOTE,
  "{": Sk.Tokenizer.Tokens.T_LBRACE,
  "}": Sk.Tokenizer.Tokens.T_RBRACE,
  "@": Sk.Tokenizer.Tokens.T_AT,
  "==": Sk.Tokenizer.Tokens.T_EQEQUAL,
  "!=": Sk.Tokenizer.Tokens.T_NOTEQUAL,
  "<>": Sk.Tokenizer.Tokens.T_NOTEQUAL,
  "<=": Sk.Tokenizer.Tokens.T_LESSEQUAL,
  ">=": Sk.Tokenizer.Tokens.T_GREATEREQUAL,
  "~": Sk.Tokenizer.Tokens.T_TILDE,
  "^": Sk.Tokenizer.Tokens.T_CIRCUMFLEX,
  "<<": Sk.Tokenizer.Tokens.T_LEFTSHIFT,
  ">>": Sk.Tokenizer.Tokens.T_RIGHTSHIFT,
  "**": Sk.Tokenizer.Tokens.T_DOUBLESTAR,
  "+=": Sk.Tokenizer.Tokens.T_PLUSEQUAL,
  "-=": Sk.Tokenizer.Tokens.T_MINEQUAL,
  "*=": Sk.Tokenizer.Tokens.T_STAREQUAL,
  "/=": Sk.Tokenizer.Tokens.T_SLASHEQUAL,
  "%=": Sk.Tokenizer.Tokens.T_PERCENTEQUAL,
  "&=": Sk.Tokenizer.Tokens.T_AMPEREQUAL,
  "|=": Sk.Tokenizer.Tokens.T_VBAREQUAL,
  "^=": Sk.Tokenizer.Tokens.T_CIRCUMFLEXEQUAL,
  "<<=": Sk.Tokenizer.Tokens.T_LEFTSHIFTEQUAL,
  ">>=": Sk.Tokenizer.Tokens.T_RIGHTSHIFTEQUAL,
  "**=": Sk.Tokenizer.Tokens.T_DOUBLESTAREQUAL,
  "//": Sk.Tokenizer.Tokens.T_DOUBLESLASH,
  "//=": Sk.Tokenizer.Tokens.T_DOUBLESLASHEQUAL,
  "->": Sk.Tokenizer.Tokens.T_RARROW
};
Sk.ParseTables = {
  sym: {
    and_expr: 257,
    and_test: 258,
    arglist: 259,
    argument: 260,
    arith_expr: 261,
    assert_stmt: 262,
    atom: 263,
    augassign: 264,
    break_stmt: 265,
    classdef: 266,
    comp_for: 267,
    comp_if: 268,
    comp_iter: 269,
    comp_op: 270,
    comparison: 271,
    compound_stmt: 272,
    continue_stmt: 273,
    debugger_stmt: 274,
    decorated: 275,
    decorator: 276,
    decorators: 277,
    del_stmt: 278,
    dictorsetmaker: 279,
    dotted_as_name: 280,
    dotted_as_names: 281,
    dotted_name: 282,
    encoding_decl: 283,
    eval_input: 284,
    except_clause: 285,
    exec_stmt: 286,
    expr: 287,
    expr_stmt: 288,
    exprlist: 289,
    factor: 290,
    file_input: 291,
    flow_stmt: 292,
    for_stmt: 293,
    fpdef: 294,
    fplist: 295,
    funcdef: 296,
    global_stmt: 297,
    if_stmt: 298,
    import_as_name: 299,
    import_as_names: 300,
    import_from: 301,
    import_name: 302,
    import_stmt: 303,
    lambdef: 304,
    list_for: 305,
    list_if: 306,
    list_iter: 307,
    listmaker: 308,
    not_test: 309,
    old_lambdef: 310,
    old_test: 311,
    or_test: 312,
    parameters: 313,
    pass_stmt: 314,
    power: 315,
    print_stmt: 316,
    raise_stmt: 317,
    return_stmt: 318,
    shift_expr: 319,
    simple_stmt: 320,
    single_input: 256,
    sliceop: 321,
    small_stmt: 322,
    stmt: 323,
    subscript: 324,
    subscriptlist: 325,
    suite: 326,
    term: 327,
    test: 328,
    testlist: 329,
    testlist1: 330,
    testlist_comp: 331,
    testlist_safe: 332,
    trailer: 333,
    try_stmt: 334,
    varargslist: 335,
    while_stmt: 336,
    with_item: 337,
    with_stmt: 338,
    xor_expr: 339,
    yield_expr: 340,
    yield_stmt: 341
  },
  number2symbol: {
    256: 'single_input',
    257: 'and_expr',
    258: 'and_test',
    259: 'arglist',
    260: 'argument',
    261: 'arith_expr',
    262: 'assert_stmt',
    263: 'atom',
    264: 'augassign',
    265: 'break_stmt',
    266: 'classdef',
    267: 'comp_for',
    268: 'comp_if',
    269: 'comp_iter',
    270: 'comp_op',
    271: 'comparison',
    272: 'compound_stmt',
    273: 'continue_stmt',
    274: 'debugger_stmt',
    275: 'decorated',
    276: 'decorator',
    277: 'decorators',
    278: 'del_stmt',
    279: 'dictorsetmaker',
    280: 'dotted_as_name',
    281: 'dotted_as_names',
    282: 'dotted_name',
    283: 'encoding_decl',
    284: 'eval_input',
    285: 'except_clause',
    286: 'exec_stmt',
    287: 'expr',
    288: 'expr_stmt',
    289: 'exprlist',
    290: 'factor',
    291: 'file_input',
    292: 'flow_stmt',
    293: 'for_stmt',
    294: 'fpdef',
    295: 'fplist',
    296: 'funcdef',
    297: 'global_stmt',
    298: 'if_stmt',
    299: 'import_as_name',
    300: 'import_as_names',
    301: 'import_from',
    302: 'import_name',
    303: 'import_stmt',
    304: 'lambdef',
    305: 'list_for',
    306: 'list_if',
    307: 'list_iter',
    308: 'listmaker',
    309: 'not_test',
    310: 'old_lambdef',
    311: 'old_test',
    312: 'or_test',
    313: 'parameters',
    314: 'pass_stmt',
    315: 'power',
    316: 'print_stmt',
    317: 'raise_stmt',
    318: 'return_stmt',
    319: 'shift_expr',
    320: 'simple_stmt',
    321: 'sliceop',
    322: 'small_stmt',
    323: 'stmt',
    324: 'subscript',
    325: 'subscriptlist',
    326: 'suite',
    327: 'term',
    328: 'test',
    329: 'testlist',
    330: 'testlist1',
    331: 'testlist_comp',
    332: 'testlist_safe',
    333: 'trailer',
    334: 'try_stmt',
    335: 'varargslist',
    336: 'while_stmt',
    337: 'with_item',
    338: 'with_stmt',
    339: 'xor_expr',
    340: 'yield_expr',
    341: 'yield_stmt'
  },
  dfas: {
    256: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]], {
      2: 1,
      4: 1,
      5: 1,
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      10: 1,
      11: 1,
      12: 1,
      13: 1,
      14: 1,
      15: 1,
      16: 1,
      17: 1,
      18: 1,
      19: 1,
      20: 1,
      21: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 1,
      28: 1,
      29: 1,
      30: 1,
      31: 1,
      32: 1,
      33: 1,
      34: 1,
      35: 1,
      36: 1,
      37: 1
    }],
    257: [[[[38, 1]], [[39, 0], [0, 1]]], {
      6: 1,
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    258: [[[[40, 1]], [[41, 0], [0, 1]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    259: [[[[42, 1], [43, 2], [44, 3]], [[45, 4]], [[46, 5], [0, 2]], [[45, 6]], [[46, 7], [0, 4]], [[42, 1], [43, 2], [44, 3], [0, 5]], [[0, 6]], [[43, 4], [44, 3]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1,
      42: 1,
      44: 1
    }],
    260: [[[[45, 1]], [[47, 2], [48, 3], [0, 1]], [[45, 3]], [[0, 3]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    261: [[[[49, 1]], [[26, 0], [37, 0], [0, 1]]], {
      6: 1,
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    262: [[[[21, 1]], [[45, 2]], [[46, 3], [0, 2]], [[45, 4]], [[0, 4]]], {
      21: 1
    }],
    263: [[[[19, 1], [8, 2], [9, 5], [30, 4], [14, 3], [15, 6], [22, 2]], [[19, 1], [0, 1]], [[0, 2]], [[50, 7], [51, 2]], [[52, 2], [53, 8], [54, 8]], [[55, 2], [56, 9]], [[57, 10]], [[51, 2]], [[52, 2]], [[55, 2]], [[15, 2]]], {
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      30: 1
    }],
    264: [[[[58, 1], [59, 1], [60, 1], [61, 1], [62, 1], [63, 1], [64, 1], [65, 1], [66, 1], [67, 1], [68, 1], [69, 1]], [[0, 1]]], {
      58: 1,
      59: 1,
      60: 1,
      61: 1,
      62: 1,
      63: 1,
      64: 1,
      65: 1,
      66: 1,
      67: 1,
      68: 1,
      69: 1
    }],
    265: [[[[33, 1]], [[0, 1]]], {
      33: 1
    }],
    266: [[[[10, 1]], [[22, 2]], [[70, 3], [30, 4]], [[71, 5]], [[52, 6], [72, 7]], [[0, 5]], [[70, 3]], [[52, 6]]], {
      10: 1
    }],
    267: [[[[29, 1]], [[73, 2]], [[74, 3]], [[75, 4]], [[76, 5], [0, 4]], [[0, 5]]], {
      29: 1
    }],
    268: [[[[32, 1]], [[77, 2]], [[76, 3], [0, 2]], [[0, 3]]], {
      32: 1
    }],
    269: [[[[78, 1], [48, 1]], [[0, 1]]], {
      29: 1,
      32: 1
    }],
    270: [[[[79, 1], [80, 1], [7, 2], [81, 1], [79, 1], [74, 1], [82, 1], [83, 3], [84, 1], [85, 1]], [[0, 1]], [[74, 1]], [[7, 1], [0, 3]]], {
      7: 1,
      74: 1,
      79: 1,
      80: 1,
      81: 1,
      82: 1,
      83: 1,
      84: 1,
      85: 1
    }],
    271: [[[[86, 1]], [[87, 0], [0, 1]]], {
      6: 1,
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    272: [[[[88, 1], [89, 1], [90, 1], [91, 1], [92, 1], [93, 1], [94, 1], [95, 1]], [[0, 1]]], {
      4: 1,
      10: 1,
      16: 1,
      18: 1,
      29: 1,
      32: 1,
      35: 1,
      36: 1
    }],
    273: [[[[34, 1]], [[0, 1]]], {
      34: 1
    }],
    274: [[[[13, 1]], [[0, 1]]], {
      13: 1
    }],
    275: [[[[96, 1]], [[94, 2], [91, 2]], [[0, 2]]], {
      35: 1
    }],
    276: [[[[35, 1]], [[97, 2]], [[2, 4], [30, 3]], [[52, 5], [98, 6]], [[0, 4]], [[2, 4]], [[52, 5]]], {
      35: 1
    }],
    277: [[[[99, 1]], [[99, 1], [0, 1]]], {
      35: 1
    }],
    278: [[[[23, 1]], [[73, 2]], [[0, 2]]], {
      23: 1
    }],
    279: [[[[45, 1]], [[70, 2], [48, 3], [46, 4], [0, 1]], [[45, 5]], [[0, 3]], [[45, 6], [0, 4]], [[48, 3], [46, 7], [0, 5]], [[46, 4], [0, 6]], [[45, 8], [0, 7]], [[70, 9]], [[45, 10]], [[46, 7], [0, 10]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    280: [[[[97, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]], {
      22: 1
    }],
    281: [[[[101, 1]], [[46, 0], [0, 1]]], {
      22: 1
    }],
    282: [[[[22, 1]], [[102, 0], [0, 1]]], {
      22: 1
    }],
    283: [[[[22, 1]], [[0, 1]]], {
      22: 1
    }],
    284: [[[[72, 1]], [[2, 1], [103, 2]], [[0, 2]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    285: [[[[104, 1]], [[45, 2], [0, 1]], [[100, 3], [46, 3], [0, 2]], [[45, 4]], [[0, 4]]], {
      104: 1
    }],
    286: [[[[17, 1]], [[86, 2]], [[74, 3], [0, 2]], [[45, 4]], [[46, 5], [0, 4]], [[45, 6]], [[0, 6]]], {
      17: 1
    }],
    287: [[[[105, 1]], [[106, 0], [0, 1]]], {
      6: 1,
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    288: [[[[72, 1]], [[107, 2], [47, 3], [0, 1]], [[72, 4], [53, 4]], [[72, 5], [53, 5]], [[0, 4]], [[47, 3], [0, 5]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    289: [[[[86, 1]], [[46, 2], [0, 1]], [[86, 1], [0, 2]]], {
      6: 1,
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    290: [[[[37, 2], [26, 2], [6, 2], [108, 1]], [[0, 1]], [[109, 1]]], {
      6: 1,
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    291: [[[[2, 0], [103, 1], [110, 0]], [[0, 1]]], {
      2: 1,
      4: 1,
      5: 1,
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      10: 1,
      11: 1,
      12: 1,
      13: 1,
      14: 1,
      15: 1,
      16: 1,
      17: 1,
      18: 1,
      19: 1,
      20: 1,
      21: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 1,
      28: 1,
      29: 1,
      30: 1,
      31: 1,
      32: 1,
      33: 1,
      34: 1,
      35: 1,
      36: 1,
      37: 1,
      103: 1
    }],
    292: [[[[111, 1], [112, 1], [113, 1], [114, 1], [115, 1]], [[0, 1]]], {
      5: 1,
      20: 1,
      27: 1,
      33: 1,
      34: 1
    }],
    293: [[[[29, 1]], [[73, 2]], [[74, 3]], [[72, 4]], [[70, 5]], [[71, 6]], [[116, 7], [0, 6]], [[70, 8]], [[71, 9]], [[0, 9]]], {
      29: 1
    }],
    294: [[[[30, 1], [22, 2]], [[117, 3]], [[0, 2]], [[52, 2]]], {
      22: 1,
      30: 1
    }],
    295: [[[[118, 1]], [[46, 2], [0, 1]], [[118, 1], [0, 2]]], {
      22: 1,
      30: 1
    }],
    296: [[[[4, 1]], [[22, 2]], [[119, 3]], [[70, 4]], [[71, 5]], [[0, 5]]], {
      4: 1
    }],
    297: [[[[28, 1]], [[22, 2]], [[46, 1], [0, 2]]], {
      28: 1
    }],
    298: [[[[32, 1]], [[45, 2]], [[70, 3]], [[71, 4]], [[116, 5], [120, 1], [0, 4]], [[70, 6]], [[71, 7]], [[0, 7]]], {
      32: 1
    }],
    299: [[[[22, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]], {
      22: 1
    }],
    300: [[[[121, 1]], [[46, 2], [0, 1]], [[121, 1], [0, 2]]], {
      22: 1
    }],
    301: [[[[31, 1]], [[97, 2], [102, 3]], [[25, 4]], [[97, 2], [25, 4], [102, 3]], [[122, 5], [42, 5], [30, 6]], [[0, 5]], [[122, 7]], [[52, 5]]], {
      31: 1
    }],
    302: [[[[25, 1]], [[123, 2]], [[0, 2]]], {
      25: 1
    }],
    303: [[[[124, 1], [125, 1]], [[0, 1]]], {
      25: 1,
      31: 1
    }],
    304: [[[[11, 1]], [[70, 2], [126, 3]], [[45, 4]], [[70, 2]], [[0, 4]]], {
      11: 1
    }],
    305: [[[[29, 1]], [[73, 2]], [[74, 3]], [[127, 4]], [[128, 5], [0, 4]], [[0, 5]]], {
      29: 1
    }],
    306: [[[[32, 1]], [[77, 2]], [[128, 3], [0, 2]], [[0, 3]]], {
      32: 1
    }],
    307: [[[[129, 1], [130, 1]], [[0, 1]]], {
      29: 1,
      32: 1
    }],
    308: [[[[45, 1]], [[129, 2], [46, 3], [0, 1]], [[0, 2]], [[45, 4], [0, 3]], [[46, 3], [0, 4]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    309: [[[[7, 1], [131, 2]], [[40, 2]], [[0, 2]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    310: [[[[11, 1]], [[70, 2], [126, 3]], [[77, 4]], [[70, 2]], [[0, 4]]], {
      11: 1
    }],
    311: [[[[132, 1], [75, 1]], [[0, 1]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    312: [[[[133, 1]], [[134, 0], [0, 1]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    313: [[[[30, 1]], [[52, 2], [126, 3]], [[0, 2]], [[52, 2]]], {
      30: 1
    }],
    314: [[[[24, 1]], [[0, 1]]], {
      24: 1
    }],
    315: [[[[135, 1]], [[44, 2], [136, 1], [0, 1]], [[109, 3]], [[0, 3]]], {
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      30: 1
    }],
    316: [[[[12, 1]], [[45, 2], [137, 3], [0, 1]], [[46, 4], [0, 2]], [[45, 5]], [[45, 2], [0, 4]], [[46, 6], [0, 5]], [[45, 7]], [[46, 8], [0, 7]], [[45, 7], [0, 8]]], {
      12: 1
    }],
    317: [[[[5, 1]], [[45, 2], [0, 1]], [[46, 3], [0, 2]], [[45, 4]], [[46, 5], [0, 4]], [[45, 6]], [[0, 6]]], {
      5: 1
    }],
    318: [[[[20, 1]], [[72, 2], [0, 1]], [[0, 2]]], {
      20: 1
    }],
    319: [[[[138, 1]], [[139, 0], [137, 0], [0, 1]]], {
      6: 1,
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    320: [[[[140, 1]], [[2, 2], [141, 3]], [[0, 2]], [[140, 1], [2, 2]]], {
      5: 1,
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      12: 1,
      13: 1,
      14: 1,
      15: 1,
      17: 1,
      19: 1,
      20: 1,
      21: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 1,
      28: 1,
      30: 1,
      31: 1,
      33: 1,
      34: 1,
      37: 1
    }],
    321: [[[[70, 1]], [[45, 2], [0, 1]], [[0, 2]]], {
      70: 1
    }],
    322: [[[[142, 1], [143, 1], [144, 1], [145, 1], [146, 1], [147, 1], [148, 1], [149, 1], [150, 1], [151, 1]], [[0, 1]]], {
      5: 1,
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      12: 1,
      13: 1,
      14: 1,
      15: 1,
      17: 1,
      19: 1,
      20: 1,
      21: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 1,
      28: 1,
      30: 1,
      31: 1,
      33: 1,
      34: 1,
      37: 1
    }],
    323: [[[[1, 1], [3, 1]], [[0, 1]]], {
      4: 1,
      5: 1,
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      10: 1,
      11: 1,
      12: 1,
      13: 1,
      14: 1,
      15: 1,
      16: 1,
      17: 1,
      18: 1,
      19: 1,
      20: 1,
      21: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 1,
      28: 1,
      29: 1,
      30: 1,
      31: 1,
      32: 1,
      33: 1,
      34: 1,
      35: 1,
      36: 1,
      37: 1
    }],
    324: [[[[45, 1], [70, 2], [102, 3]], [[70, 2], [0, 1]], [[45, 4], [152, 5], [0, 2]], [[102, 6]], [[152, 5], [0, 4]], [[0, 5]], [[102, 5]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1,
      70: 1,
      102: 1
    }],
    325: [[[[153, 1]], [[46, 2], [0, 1]], [[153, 1], [0, 2]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1,
      70: 1,
      102: 1
    }],
    326: [[[[1, 1], [2, 2]], [[0, 1]], [[154, 3]], [[110, 4]], [[155, 1], [110, 4]]], {
      2: 1,
      5: 1,
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      12: 1,
      13: 1,
      14: 1,
      15: 1,
      17: 1,
      19: 1,
      20: 1,
      21: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 1,
      28: 1,
      30: 1,
      31: 1,
      33: 1,
      34: 1,
      37: 1
    }],
    327: [[[[109, 1]], [[156, 0], [42, 0], [157, 0], [158, 0], [0, 1]]], {
      6: 1,
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    328: [[[[75, 1], [159, 2]], [[32, 3], [0, 1]], [[0, 2]], [[75, 4]], [[116, 5]], [[45, 2]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    329: [[[[45, 1]], [[46, 2], [0, 1]], [[45, 1], [0, 2]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    330: [[[[45, 1]], [[46, 0], [0, 1]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    331: [[[[45, 1]], [[48, 2], [46, 3], [0, 1]], [[0, 2]], [[45, 4], [0, 3]], [[46, 3], [0, 4]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    332: [[[[77, 1]], [[46, 2], [0, 1]], [[77, 3]], [[46, 4], [0, 3]], [[77, 3], [0, 4]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    333: [[[[30, 1], [102, 2], [14, 3]], [[52, 4], [98, 5]], [[22, 4]], [[160, 6]], [[0, 4]], [[52, 4]], [[51, 4]]], {
      14: 1,
      30: 1,
      102: 1
    }],
    334: [[[[16, 1]], [[70, 2]], [[71, 3]], [[161, 4], [162, 5]], [[70, 6]], [[70, 7]], [[71, 8]], [[71, 9]], [[161, 4], [116, 10], [162, 5], [0, 8]], [[0, 9]], [[70, 11]], [[71, 12]], [[162, 5], [0, 12]]], {
      16: 1
    }],
    335: [[[[42, 1], [118, 2], [44, 3]], [[22, 4]], [[47, 5], [46, 6], [0, 2]], [[22, 7]], [[46, 8], [0, 4]], [[45, 9]], [[42, 1], [118, 2], [44, 3], [0, 6]], [[0, 7]], [[44, 3]], [[46, 6], [0, 9]]], {
      22: 1,
      30: 1,
      42: 1,
      44: 1
    }],
    336: [[[[18, 1]], [[45, 2]], [[70, 3]], [[71, 4]], [[116, 5], [0, 4]], [[70, 6]], [[71, 7]], [[0, 7]]], {
      18: 1
    }],
    337: [[[[45, 1]], [[100, 2], [0, 1]], [[86, 3]], [[0, 3]]], {
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      11: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    338: [[[[36, 1]], [[163, 2]], [[70, 3], [46, 1]], [[71, 4]], [[0, 4]]], {
      36: 1
    }],
    339: [[[[164, 1]], [[165, 0], [0, 1]]], {
      6: 1,
      8: 1,
      9: 1,
      14: 1,
      15: 1,
      19: 1,
      22: 1,
      26: 1,
      30: 1,
      37: 1
    }],
    340: [[[[27, 1]], [[72, 2], [0, 1]], [[0, 2]]], {
      27: 1
    }],
    341: [[[[53, 1]], [[0, 1]]], {
      27: 1
    }]
  },
  states: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]], [[[38, 1]], [[39, 0], [0, 1]]], [[[40, 1]], [[41, 0], [0, 1]]], [[[42, 1], [43, 2], [44, 3]], [[45, 4]], [[46, 5], [0, 2]], [[45, 6]], [[46, 7], [0, 4]], [[42, 1], [43, 2], [44, 3], [0, 5]], [[0, 6]], [[43, 4], [44, 3]]], [[[45, 1]], [[47, 2], [48, 3], [0, 1]], [[45, 3]], [[0, 3]]], [[[49, 1]], [[26, 0], [37, 0], [0, 1]]], [[[21, 1]], [[45, 2]], [[46, 3], [0, 2]], [[45, 4]], [[0, 4]]], [[[19, 1], [8, 2], [9, 5], [30, 4], [14, 3], [15, 6], [22, 2]], [[19, 1], [0, 1]], [[0, 2]], [[50, 7], [51, 2]], [[52, 2], [53, 8], [54, 8]], [[55, 2], [56, 9]], [[57, 10]], [[51, 2]], [[52, 2]], [[55, 2]], [[15, 2]]], [[[58, 1], [59, 1], [60, 1], [61, 1], [62, 1], [63, 1], [64, 1], [65, 1], [66, 1], [67, 1], [68, 1], [69, 1]], [[0, 1]]], [[[33, 1]], [[0, 1]]], [[[10, 1]], [[22, 2]], [[70, 3], [30, 4]], [[71, 5]], [[52, 6], [72, 7]], [[0, 5]], [[70, 3]], [[52, 6]]], [[[29, 1]], [[73, 2]], [[74, 3]], [[75, 4]], [[76, 5], [0, 4]], [[0, 5]]], [[[32, 1]], [[77, 2]], [[76, 3], [0, 2]], [[0, 3]]], [[[78, 1], [48, 1]], [[0, 1]]], [[[79, 1], [80, 1], [7, 2], [81, 1], [79, 1], [74, 1], [82, 1], [83, 3], [84, 1], [85, 1]], [[0, 1]], [[74, 1]], [[7, 1], [0, 3]]], [[[86, 1]], [[87, 0], [0, 1]]], [[[88, 1], [89, 1], [90, 1], [91, 1], [92, 1], [93, 1], [94, 1], [95, 1]], [[0, 1]]], [[[34, 1]], [[0, 1]]], [[[13, 1]], [[0, 1]]], [[[96, 1]], [[94, 2], [91, 2]], [[0, 2]]], [[[35, 1]], [[97, 2]], [[2, 4], [30, 3]], [[52, 5], [98, 6]], [[0, 4]], [[2, 4]], [[52, 5]]], [[[99, 1]], [[99, 1], [0, 1]]], [[[23, 1]], [[73, 2]], [[0, 2]]], [[[45, 1]], [[70, 2], [48, 3], [46, 4], [0, 1]], [[45, 5]], [[0, 3]], [[45, 6], [0, 4]], [[48, 3], [46, 7], [0, 5]], [[46, 4], [0, 6]], [[45, 8], [0, 7]], [[70, 9]], [[45, 10]], [[46, 7], [0, 10]]], [[[97, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]], [[[101, 1]], [[46, 0], [0, 1]]], [[[22, 1]], [[102, 0], [0, 1]]], [[[22, 1]], [[0, 1]]], [[[72, 1]], [[2, 1], [103, 2]], [[0, 2]]], [[[104, 1]], [[45, 2], [0, 1]], [[100, 3], [46, 3], [0, 2]], [[45, 4]], [[0, 4]]], [[[17, 1]], [[86, 2]], [[74, 3], [0, 2]], [[45, 4]], [[46, 5], [0, 4]], [[45, 6]], [[0, 6]]], [[[105, 1]], [[106, 0], [0, 1]]], [[[72, 1]], [[107, 2], [47, 3], [0, 1]], [[72, 4], [53, 4]], [[72, 5], [53, 5]], [[0, 4]], [[47, 3], [0, 5]]], [[[86, 1]], [[46, 2], [0, 1]], [[86, 1], [0, 2]]], [[[37, 2], [26, 2], [6, 2], [108, 1]], [[0, 1]], [[109, 1]]], [[[2, 0], [103, 1], [110, 0]], [[0, 1]]], [[[111, 1], [112, 1], [113, 1], [114, 1], [115, 1]], [[0, 1]]], [[[29, 1]], [[73, 2]], [[74, 3]], [[72, 4]], [[70, 5]], [[71, 6]], [[116, 7], [0, 6]], [[70, 8]], [[71, 9]], [[0, 9]]], [[[30, 1], [22, 2]], [[117, 3]], [[0, 2]], [[52, 2]]], [[[118, 1]], [[46, 2], [0, 1]], [[118, 1], [0, 2]]], [[[4, 1]], [[22, 2]], [[119, 3]], [[70, 4]], [[71, 5]], [[0, 5]]], [[[28, 1]], [[22, 2]], [[46, 1], [0, 2]]], [[[32, 1]], [[45, 2]], [[70, 3]], [[71, 4]], [[116, 5], [120, 1], [0, 4]], [[70, 6]], [[71, 7]], [[0, 7]]], [[[22, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]], [[[121, 1]], [[46, 2], [0, 1]], [[121, 1], [0, 2]]], [[[31, 1]], [[97, 2], [102, 3]], [[25, 4]], [[97, 2], [25, 4], [102, 3]], [[122, 5], [42, 5], [30, 6]], [[0, 5]], [[122, 7]], [[52, 5]]], [[[25, 1]], [[123, 2]], [[0, 2]]], [[[124, 1], [125, 1]], [[0, 1]]], [[[11, 1]], [[70, 2], [126, 3]], [[45, 4]], [[70, 2]], [[0, 4]]], [[[29, 1]], [[73, 2]], [[74, 3]], [[127, 4]], [[128, 5], [0, 4]], [[0, 5]]], [[[32, 1]], [[77, 2]], [[128, 3], [0, 2]], [[0, 3]]], [[[129, 1], [130, 1]], [[0, 1]]], [[[45, 1]], [[129, 2], [46, 3], [0, 1]], [[0, 2]], [[45, 4], [0, 3]], [[46, 3], [0, 4]]], [[[7, 1], [131, 2]], [[40, 2]], [[0, 2]]], [[[11, 1]], [[70, 2], [126, 3]], [[77, 4]], [[70, 2]], [[0, 4]]], [[[132, 1], [75, 1]], [[0, 1]]], [[[133, 1]], [[134, 0], [0, 1]]], [[[30, 1]], [[52, 2], [126, 3]], [[0, 2]], [[52, 2]]], [[[24, 1]], [[0, 1]]], [[[135, 1]], [[44, 2], [136, 1], [0, 1]], [[109, 3]], [[0, 3]]], [[[12, 1]], [[45, 2], [137, 3], [0, 1]], [[46, 4], [0, 2]], [[45, 5]], [[45, 2], [0, 4]], [[46, 6], [0, 5]], [[45, 7]], [[46, 8], [0, 7]], [[45, 7], [0, 8]]], [[[5, 1]], [[45, 2], [0, 1]], [[46, 3], [0, 2]], [[45, 4]], [[46, 5], [0, 4]], [[45, 6]], [[0, 6]]], [[[20, 1]], [[72, 2], [0, 1]], [[0, 2]]], [[[138, 1]], [[139, 0], [137, 0], [0, 1]]], [[[140, 1]], [[2, 2], [141, 3]], [[0, 2]], [[140, 1], [2, 2]]], [[[70, 1]], [[45, 2], [0, 1]], [[0, 2]]], [[[142, 1], [143, 1], [144, 1], [145, 1], [146, 1], [147, 1], [148, 1], [149, 1], [150, 1], [151, 1]], [[0, 1]]], [[[1, 1], [3, 1]], [[0, 1]]], [[[45, 1], [70, 2], [102, 3]], [[70, 2], [0, 1]], [[45, 4], [152, 5], [0, 2]], [[102, 6]], [[152, 5], [0, 4]], [[0, 5]], [[102, 5]]], [[[153, 1]], [[46, 2], [0, 1]], [[153, 1], [0, 2]]], [[[1, 1], [2, 2]], [[0, 1]], [[154, 3]], [[110, 4]], [[155, 1], [110, 4]]], [[[109, 1]], [[156, 0], [42, 0], [157, 0], [158, 0], [0, 1]]], [[[75, 1], [159, 2]], [[32, 3], [0, 1]], [[0, 2]], [[75, 4]], [[116, 5]], [[45, 2]]], [[[45, 1]], [[46, 2], [0, 1]], [[45, 1], [0, 2]]], [[[45, 1]], [[46, 0], [0, 1]]], [[[45, 1]], [[48, 2], [46, 3], [0, 1]], [[0, 2]], [[45, 4], [0, 3]], [[46, 3], [0, 4]]], [[[77, 1]], [[46, 2], [0, 1]], [[77, 3]], [[46, 4], [0, 3]], [[77, 3], [0, 4]]], [[[30, 1], [102, 2], [14, 3]], [[52, 4], [98, 5]], [[22, 4]], [[160, 6]], [[0, 4]], [[52, 4]], [[51, 4]]], [[[16, 1]], [[70, 2]], [[71, 3]], [[161, 4], [162, 5]], [[70, 6]], [[70, 7]], [[71, 8]], [[71, 9]], [[161, 4], [116, 10], [162, 5], [0, 8]], [[0, 9]], [[70, 11]], [[71, 12]], [[162, 5], [0, 12]]], [[[42, 1], [118, 2], [44, 3]], [[22, 4]], [[47, 5], [46, 6], [0, 2]], [[22, 7]], [[46, 8], [0, 4]], [[45, 9]], [[42, 1], [118, 2], [44, 3], [0, 6]], [[0, 7]], [[44, 3]], [[46, 6], [0, 9]]], [[[18, 1]], [[45, 2]], [[70, 3]], [[71, 4]], [[116, 5], [0, 4]], [[70, 6]], [[71, 7]], [[0, 7]]], [[[45, 1]], [[100, 2], [0, 1]], [[86, 3]], [[0, 3]]], [[[36, 1]], [[163, 2]], [[70, 3], [46, 1]], [[71, 4]], [[0, 4]]], [[[164, 1]], [[165, 0], [0, 1]]], [[[27, 1]], [[72, 2], [0, 1]], [[0, 2]]], [[[53, 1]], [[0, 1]]]],
  labels: [[0, 'EMPTY'], [320, null], [4, null], [272, null], [1, 'def'], [1, 'raise'], [32, null], [1, 'not'], [2, null], [26, null], [1, 'class'], [1, 'lambda'], [1, 'print'], [1, 'debugger'], [9, null], [25, null], [1, 'try'], [1, 'exec'], [1, 'while'], [3, null], [1, 'return'], [1, 'assert'], [1, null], [1, 'del'], [1, 'pass'], [1, 'import'], [15, null], [1, 'yield'], [1, 'global'], [1, 'for'], [7, null], [1, 'from'], [1, 'if'], [1, 'break'], [1, 'continue'], [50, null], [1, 'with'], [14, null], [319, null], [19, null], [309, null], [1, 'and'], [16, null], [260, null], [36, null], [328, null], [12, null], [22, null], [267, null], [327, null], [308, null], [10, null], [8, null], [340, null], [331, null], [27, null], [279, null], [330, null], [46, null], [39, null], [41, null], [47, null], [42, null], [43, null], [37, null], [44, null], [49, null], [45, null], [38, null], [40, null], [11, null], [326, null], [329, null], [289, null], [1, 'in'], [312, null], [269, null], [311, null], [268, null], [29, null], [21, null], [28, null], [30, null], [1, 'is'], [31, null], [20, null], [287, null], [270, null], [334, null], [298, null], [293, null], [266, null], [338, null], [336, null], [296, null], [275, null], [277, null], [282, null], [259, null], [276, null], [1, 'as'], [280, null], [23, null], [0, null], [1, 'except'], [339, null], [18, null], [264, null], [315, null], [290, null], [323, null], [265, null], [273, null], [317, null], [318, null], [341, null], [1, 'else'], [295, null], [294, null], [313, null], [1, 'elif'], [299, null], [300, null], [281, null], [302, null], [301, null], [335, null], [332, null], [307, null], [305, null], [306, null], [271, null], [310, null], [258, null], [1, 'or'], [263, null], [333, null], [35, null], [261, null], [34, null], [322, null], [13, null], [292, null], [278, null], [288, null], [314, null], [316, null], [262, null], [286, null], [297, null], [303, null], [274, null], [321, null], [324, null], [5, null], [6, null], [48, null], [17, null], [24, null], [304, null], [325, null], [285, null], [1, 'finally'], [337, null], [257, null], [33, null]],
  keywords: {
    'and': 41,
    'as': 100,
    'assert': 21,
    'break': 33,
    'class': 10,
    'continue': 34,
    'debugger': 13,
    'def': 4,
    'del': 23,
    'elif': 120,
    'else': 116,
    'except': 104,
    'exec': 17,
    'finally': 162,
    'for': 29,
    'from': 31,
    'global': 28,
    'if': 32,
    'import': 25,
    'in': 74,
    'is': 83,
    'lambda': 11,
    'not': 7,
    'or': 134,
    'pass': 24,
    'print': 12,
    'raise': 5,
    'return': 20,
    'try': 16,
    'while': 18,
    'with': 36,
    'yield': 27
  },
  tokens: {
    0: 103,
    1: 22,
    2: 8,
    3: 19,
    4: 2,
    5: 154,
    6: 155,
    7: 30,
    8: 52,
    9: 14,
    10: 51,
    11: 70,
    12: 46,
    13: 141,
    14: 37,
    15: 26,
    16: 42,
    17: 157,
    18: 106,
    19: 39,
    20: 85,
    21: 80,
    22: 47,
    23: 102,
    24: 158,
    25: 15,
    26: 9,
    27: 55,
    28: 81,
    29: 79,
    30: 82,
    31: 84,
    32: 6,
    33: 165,
    34: 139,
    35: 137,
    36: 44,
    37: 64,
    38: 68,
    39: 59,
    40: 69,
    41: 60,
    42: 62,
    43: 63,
    44: 65,
    45: 67,
    46: 58,
    47: 61,
    48: 156,
    49: 66,
    50: 35
  },
  start: 256
};

/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/parser.js ---- */

// low level parser to a concrete syntax tree, derived from cpython's lib2to3

/**
 *
 * @constructor
 * @param {Object} grammar
 *
 * p = new Parser(grammar);
 * p.setup([start]);
 * foreach input token:
 *     if p.addtoken(...):
 *         break
 * root = p.rootnode
 *
 * can throw SyntaxError
 */
function Parser(filename, grammar) {
  this.filename = filename;
  this.grammar = grammar;
  this.p_flags = 0;
  return this;
}

// all possible parser flags
Parser.FUTURE_PRINT_FUNCTION = "print_function";
Parser.FUTURE_UNICODE_LITERALS = "unicode_literals";
Parser.FUTURE_DIVISION = "division";
Parser.FUTURE_ABSOLUTE_IMPORT = "absolute_import";
Parser.FUTURE_WITH_STATEMENT = "with_statement";
Parser.FUTURE_NESTED_SCOPES = "nested_scopes";
Parser.FUTURE_GENERATORS = "generators";
Parser.CO_FUTURE_PRINT_FUNCTION = 0x10000;
Parser.CO_FUTURE_UNICODE_LITERALS = 0x20000;
Parser.CO_FUTURE_DIVISON = 0x2000;
Parser.CO_FUTURE_ABSOLUTE_IMPORT = 0x4000;
Parser.CO_FUTURE_WITH_STATEMENT = 0x8000;
Parser.prototype.setup = function (start) {
  var stackentry;
  var newnode;
  start = start || this.grammar.start;
  //print("START:"+start);

  newnode = {
    type: start,
    value: null,
    context: null,
    children: []
  };
  stackentry = {
    dfa: this.grammar.dfas[start],
    state: 0,
    node: newnode
  };
  this.stack = [stackentry];
  this.used_names = {};
};
function findInDfa(a, obj) {
  var i = a.length;
  while (i--) {
    if (a[i][0] === obj[0] && a[i][1] === obj[1]) {
      return true;
    }
  }
  return false;
}

// Add a token; return true if we're done
Parser.prototype.addtoken = function (type, value, context) {
  var errline;
  var itsfirst;
  var itsdfa;
  var state;
  var v;
  var t;
  var newstate;
  var i;
  var a;
  var arcs;
  var first;
  var states;
  var tp;
  var ilabel = this.classify(type, value, context);
  //print("ilabel:"+ilabel);

  OUTERWHILE: while (true) {
    tp = this.stack[this.stack.length - 1];
    states = tp.dfa[0];
    first = tp.dfa[1];
    arcs = states[tp.state];

    // look for a state with this label
    for (a = 0; a < arcs.length; ++a) {
      i = arcs[a][0];
      newstate = arcs[a][1];
      t = this.grammar.labels[i][0];
      v = this.grammar.labels[i][1];
      if (ilabel === i) {
        // look it up in the list of labels
        goog.asserts.assert(t < 256);
        // shift a token; we're done with it
        this.shift(type, value, newstate, context);
        // pop while we are in an accept-only state
        state = newstate;
        //print("before:"+JSON.stringify(states[state]) + ":state:"+state+":"+JSON.stringify(states[state]));
        /* jshint ignore:start */
        while (states[state].length === 1 && states[state][0][0] === 0 && states[state][0][1] === state) {
          // states[state] == [(0, state)])
          this.pop();
          //print("in after pop:"+JSON.stringify(states[state]) + ":state:"+state+":"+JSON.stringify(states[state]));
          if (this.stack.length === 0) {
            // done!
            return true;
          }
          tp = this.stack[this.stack.length - 1];
          state = tp.state;
          states = tp.dfa[0];
          first = tp.dfa[1];
          //print(JSON.stringify(states), JSON.stringify(first));
          //print("bottom:"+JSON.stringify(states[state]) + ":state:"+state+":"+JSON.stringify(states[state]));
        }
        /* jshint ignore:end */
        // done with this token
        //print("DONE, return false");
        return false;
      } else if (t >= 256) {
        itsdfa = this.grammar.dfas[t];
        itsfirst = itsdfa[1];
        if (itsfirst.hasOwnProperty(ilabel)) {
          // push a symbol
          this.push(t, this.grammar.dfas[t], newstate, context);
          continue OUTERWHILE;
        }
      }
    }

    //print("findInDfa: " + JSON.stringify(arcs)+" vs. " + tp.state);
    if (findInDfa(arcs, [0, tp.state])) {
      // an accepting state, pop it and try somethign else
      //print("WAA");
      this.pop();
      if (this.stack.length === 0) {
        throw new Sk.builtin.SyntaxError("too much input", this.filename);
      }
    } else {
      // no transition
      errline = context[0][0];
      var that = this;
      var ar = arcs.map(function (a) {
        var i = a[0];
        var t = that.grammar.labels[i][0];
        return Sk.nameForToken(t);
      });
      var extra = {
        kind: "DAG_MISS",
        expected: ar,
        found: Sk.nameForToken(type),
        found_val: value,
        inside: Sk.nameForToken(tp.node.type),
        node: tp.node,
        parent: this.stack.length > 1 ? this.stack[this.stack.length - 2].node : undefined
      };
      var reason = "expected " + ar.join(', ') + " but found " + extra.found + " while parsing " + extra.inside;
      throw new Sk.builtin.SyntaxError(reason, this.filename, errline, context, extra);
    }
  }
};

// turn a token into a label
Parser.prototype.classify = function (type, value, context) {
  var ilabel;
  if (type === Sk.Tokenizer.Tokens.T_NAME) {
    this.used_names[value] = true;
    ilabel = this.grammar.keywords.hasOwnProperty(value) && this.grammar.keywords[value];

    /* Check for handling print as an builtin function */
    if (value === "print" && (this.p_flags & Parser.CO_FUTURE_PRINT_FUNCTION || Sk.python3 === true)) {
      ilabel = false; // ilabel determines if the value is a keyword
    }

    if (ilabel) {
      //print("is keyword");
      return ilabel;
    }
  }
  ilabel = this.grammar.tokens.hasOwnProperty(type) && this.grammar.tokens[type];
  if (!ilabel) {
    // throw new Sk.builtin.SyntaxError("bad token", type, value, context);
    // Questionable modification to put line number in position 2
    // like everywhere else and filename in position 1.
    var extra = {
      kind: "CLASSIFY",
      type: type,
      value: value
    };
    throw new Sk.builtin.SyntaxError("bad token", this.filename, context[0][0], context, extra);
  }
  return ilabel;
};

// shift a token
Parser.prototype.shift = function (type, value, newstate, context) {
  var dfa = this.stack[this.stack.length - 1].dfa;
  var state = this.stack[this.stack.length - 1].state;
  var node = this.stack[this.stack.length - 1].node;
  //print("context", context);
  var newnode = {
    type: type,
    value: value,
    lineno: context[0][0],
    // throwing away end here to match cpython
    col_offset: context[0][1],
    children: null
  };
  if (newnode) {
    node.children.push(newnode);
  }
  this.stack[this.stack.length - 1] = {
    dfa: dfa,
    state: newstate,
    node: node
  };
};

// push a nonterminal
Parser.prototype.push = function (type, newdfa, newstate, context) {
  var dfa = this.stack[this.stack.length - 1].dfa;
  var node = this.stack[this.stack.length - 1].node;
  var newnode = {
    type: type,
    value: null,
    lineno: context[0][0],
    // throwing away end here to match cpython
    col_offset: context[0][1],
    children: []
  };
  this.stack[this.stack.length - 1] = {
    dfa: dfa,
    state: newstate,
    node: node
  };
  this.stack.push({
    dfa: newdfa,
    state: 0,
    node: newnode
  });
};

//var ac = 0;
//var bc = 0;

// pop a nonterminal
Parser.prototype.pop = function () {
  var node;
  var pop = this.stack.pop();
  var newnode = pop.node;
  //print("POP");
  if (newnode) {
    //print("A", ac++, newnode.type);
    //print("stacklen:"+this.stack.length);
    if (this.stack.length !== 0) {
      //print("B", bc++);
      node = this.stack[this.stack.length - 1].node;
      node.children.push(newnode);
    } else {
      //print("C");
      this.rootnode = newnode;
      this.rootnode.used_names = this.used_names;
    }
  }
};

/**
 * parser for interactive input. returns a function that should be called with
 * lines of input as they are entered. the function will return false
 * until the input is complete, when it will return the rootnode of the parse.
 *
 * @param {string} filename
 * @param {string=} style root of parse tree (optional)
 */
function makeParser(filename, style) {
  var tokenizer;
  var T_OP;
  var T_NL;
  var T_COMMENT;
  var prefix;
  var column;
  var lineno;
  var p;
  if (style === undefined) {
    style = "file_input";
  }
  p = new Parser(filename, Sk.ParseTables);
  // for closure's benefit
  if (style === "file_input") {
    p.setup(Sk.ParseTables.sym.file_input);
  } else {
    goog.asserts.fail("todo;");
  }
  lineno = 1;
  column = 0;
  prefix = "";
  T_COMMENT = Sk.Tokenizer.Tokens.T_COMMENT;
  T_NL = Sk.Tokenizer.Tokens.T_NL;
  T_OP = Sk.Tokenizer.Tokens.T_OP;
  tokenizer = new Sk.Tokenizer(filename, style === "single_input", function (type, value, start, end, line) {
    var s_lineno = start[0];
    var s_column = start[1];
    /*
     if (s_lineno !== lineno && s_column !== column)
     {
     // todo; update prefix and line/col
     }
     */
    if (type === T_COMMENT || type === T_NL) {
      prefix += value;
      lineno = end[0];
      column = end[1];
      if (value[value.length - 1] === "\n") {
        lineno += 1;
        column = 0;
      }
      //print("  not calling addtoken");
      return undefined;
    }
    if (type === T_OP) {
      type = Sk.OpMap[value];
    }
    if (p.addtoken(type, value, [start, end, line])) {
      return true;
    }
  });

  // create parser function
  var parseFunc = function (line) {
    var ret = tokenizer.generateTokens(line);
    //print("tok:"+ret);
    if (ret) {
      if (ret !== "done") {
        throw new Sk.builtin.SyntaxError("incomplete input", this.filename);
      }
      return p.rootnode;
    }
    return false;
  };

  // set flags, and return
  parseFunc.p_flags = p.p_flags;
  return parseFunc;
}
Sk.parse = function parse(filename, input) {
  var i;
  var ret;
  var lines;
  var parseFunc = makeParser(filename);
  if (input.substr(input.length - 1, 1) !== "\n") {
    input += "\n";
  }
  //print("input:"+input);
  lines = input.split("\n");
  for (i = 0; i < lines.length; ++i) {
    ret = parseFunc(lines[i] + (i === lines.length - 1 ? "" : "\n"));
  }

  /*
   * Small adjustments here in order to return th flags and the cst
   */
  return {
    "cst": ret,
    "flags": parseFunc.p_flags
  };
};
Sk.parseTreeDump = function parseTreeDump(n, indent) {
  //return JSON.stringify(n, null, 2);
  var i;
  var ret;
  indent = indent || "";
  ret = "";
  ret += indent;
  if (n.type >= 256) {
    // non-term
    ret += Sk.ParseTables.number2symbol[n.type] + "\n";
    for (i = 0; i < n.children.length; ++i) {
      ret += Sk.parseTreeDump(n.children[i], indent + "  ");
    }
  } else {
    ret += Sk.Tokenizer.tokenNames[n.type] + ": " + new Sk.builtin.str(n.value)["$r"]().v + "\n";
  }
  return ret;
};
goog.exportSymbol("Sk.parse", Sk.parse);
goog.exportSymbol("Sk.parseTreeDump", Sk.parseTreeDump);

/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/gen/astnodes.js ---- */

/* File automatically generated by ./asdl_js.py. */

/* ----- expr_context ----- */
/** @constructor */
function Load() {}
/** @constructor */
function Store() {}
/** @constructor */
function Del() {}
/** @constructor */
function AugLoad() {}
/** @constructor */
function AugStore() {}
/** @constructor */
function Param() {}

/* ----- boolop ----- */
/** @constructor */
function And() {}
/** @constructor */
function Or() {}

/* ----- operator ----- */
/** @constructor */
function Add() {}
/** @constructor */
function Sub() {}
/** @constructor */
function Mult() {}
/** @constructor */
function Div() {}
/** @constructor */
function Mod() {}
/** @constructor */
function Pow() {}
/** @constructor */
function LShift() {}
/** @constructor */
function RShift() {}
/** @constructor */
function BitOr() {}
/** @constructor */
function BitXor() {}
/** @constructor */
function BitAnd() {}
/** @constructor */
function FloorDiv() {}

/* ----- unaryop ----- */
/** @constructor */
function Invert() {}
/** @constructor */
function Not() {}
/** @constructor */
function UAdd() {}
/** @constructor */
function USub() {}

/* ----- cmpop ----- */
/** @constructor */
function Eq() {}
/** @constructor */
function NotEq() {}
/** @constructor */
function Lt() {}
/** @constructor */
function LtE() {}
/** @constructor */
function Gt() {}
/** @constructor */
function GtE() {}
/** @constructor */
function Is() {}
/** @constructor */
function IsNot() {}
/** @constructor */
function In_() {}
/** @constructor */
function NotIn() {}

/* ---------------------- */
/* constructors for nodes */
/* ---------------------- */

/** @constructor */
function Module( /* {asdl_seq *} */body) {
  this.body = body;
  return this;
}

/** @constructor */
function Interactive( /* {asdl_seq *} */body) {
  this.body = body;
  return this;
}

/** @constructor */
function Expression( /* {expr_ty} */body) {
  goog.asserts.assert(body !== null && body !== undefined);
  this.body = body;
  return this;
}

/** @constructor */
function Suite( /* {asdl_seq *} */body) {
  this.body = body;
  return this;
}

/** @constructor */
function FunctionDef( /* {identifier} */name, /* {arguments__ty} */args,
/*
{asdl_seq *} */
body, /* {asdl_seq *} */
decorator_list, /* {int} */lineno, /* {int} */
col_offset) {
  goog.asserts.assert(name !== null && name !== undefined);
  goog.asserts.assert(args !== null && args !== undefined);
  this.name = name;
  this.args = args;
  this.body = body;
  this.decorator_list = decorator_list;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function ClassDef( /* {identifier} */name, /* {asdl_seq *} */bases,
/*
{asdl_seq *} */
body, /* {asdl_seq *} */decorator_list, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(name !== null && name !== undefined);
  this.name = name;
  this.bases = bases;
  this.body = body;
  this.decorator_list = decorator_list;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Return_( /* {expr_ty} */value, /* {int} */lineno, /* {int} */
col_offset) {
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Delete_( /* {asdl_seq *} */targets, /* {int} */lineno, /* {int} */
col_offset) {
  this.targets = targets;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Assign( /* {asdl_seq *} */targets, /* {expr_ty} */value, /* {int} */
lineno, /* {int} */col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  this.targets = targets;
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function AugAssign( /* {expr_ty} */target, /* {operator_ty} */op,
/* {expr_ty}
*/
value, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(target !== null && target !== undefined);
  goog.asserts.assert(op !== null && op !== undefined);
  goog.asserts.assert(value !== null && value !== undefined);
  this.target = target;
  this.op = op;
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Print( /* {expr_ty} */dest, /* {asdl_seq *} */values, /* {bool} */
nl, /* {int} */lineno, /* {int} */col_offset) {
  this.dest = dest;
  this.values = values;
  this.nl = nl;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function For_( /* {expr_ty} */target, /* {expr_ty} */iter, /* {asdl_seq *} */
body, /* {asdl_seq *} */orelse, /* {int} */lineno,
/*
{int} */
col_offset) {
  goog.asserts.assert(target !== null && target !== undefined);
  goog.asserts.assert(iter !== null && iter !== undefined);
  this.target = target;
  this.iter = iter;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function While_( /* {expr_ty} */test, /* {asdl_seq *} */body,
/* {asdl_seq *}
*/
orelse, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(test !== null && test !== undefined);
  this.test = test;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function If_( /* {expr_ty} */test, /* {asdl_seq *} */body, /* {asdl_seq *} */
orelse, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(test !== null && test !== undefined);
  this.test = test;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function With_( /* {expr_ty} */context_expr, /* {expr_ty} */optional_vars,
/*
{asdl_seq *} */
body, /* {int} */lineno, /* {int} */
col_offset) {
  goog.asserts.assert(context_expr !== null && context_expr !== undefined);
  this.context_expr = context_expr;
  this.optional_vars = optional_vars;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Raise( /* {expr_ty} */type, /* {expr_ty} */inst, /* {expr_ty} */
tback, /* {int} */lineno, /* {int} */col_offset) {
  this.type = type;
  this.inst = inst;
  this.tback = tback;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function TryExcept( /* {asdl_seq *} */body, /* {asdl_seq *} */handlers,
/*
{asdl_seq *} */
orelse, /* {int} */lineno, /* {int} */
col_offset) {
  this.body = body;
  this.handlers = handlers;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function TryFinally( /* {asdl_seq *} */body, /* {asdl_seq *} */finalbody,
/*
{int} */
lineno, /* {int} */col_offset) {
  this.body = body;
  this.finalbody = finalbody;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Assert( /* {expr_ty} */test, /* {expr_ty} */msg, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(test !== null && test !== undefined);
  this.test = test;
  this.msg = msg;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Import_( /* {asdl_seq *} */names, /* {int} */lineno, /* {int} */
col_offset) {
  this.names = names;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function ImportFrom( /* {identifier} */module, /* {asdl_seq *} */names,
/*
{int} */
level, /* {int} */lineno, /* {int} */
col_offset) {
  goog.asserts.assert(module !== null && module !== undefined);
  this.module = module;
  this.names = names;
  this.level = level;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Exec( /* {expr_ty} */body, /* {expr_ty} */globals, /* {expr_ty} */
locals, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(body !== null && body !== undefined);
  this.body = body;
  this.globals = globals;
  this.locals = locals;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Global( /* {asdl_seq *} */names, /* {int} */lineno, /* {int} */
col_offset) {
  this.names = names;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Expr( /* {expr_ty} */value, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Pass( /* {int} */lineno, /* {int} */col_offset) {
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Break_( /* {int} */lineno, /* {int} */col_offset) {
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Continue_( /* {int} */lineno, /* {int} */col_offset) {
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Debugger_( /* {int} */lineno, /* {int} */col_offset) {
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function BoolOp( /* {boolop_ty} */op, /* {asdl_seq *} */values, /* {int} */
lineno, /* {int} */col_offset) {
  goog.asserts.assert(op !== null && op !== undefined);
  this.op = op;
  this.values = values;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function BinOp( /* {expr_ty} */left, /* {operator_ty} */op, /* {expr_ty} */
right, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(left !== null && left !== undefined);
  goog.asserts.assert(op !== null && op !== undefined);
  goog.asserts.assert(right !== null && right !== undefined);
  this.left = left;
  this.op = op;
  this.right = right;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function UnaryOp( /* {unaryop_ty} */op, /* {expr_ty} */operand, /* {int} */
lineno, /* {int} */col_offset) {
  goog.asserts.assert(op !== null && op !== undefined);
  goog.asserts.assert(operand !== null && operand !== undefined);
  this.op = op;
  this.operand = operand;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Lambda( /* {arguments__ty} */args, /* {expr_ty} */body, /* {int} */
lineno, /* {int} */col_offset) {
  goog.asserts.assert(args !== null && args !== undefined);
  goog.asserts.assert(body !== null && body !== undefined);
  this.args = args;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function IfExp( /* {expr_ty} */test, /* {expr_ty} */body, /* {expr_ty} */
orelse, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(test !== null && test !== undefined);
  goog.asserts.assert(body !== null && body !== undefined);
  goog.asserts.assert(orelse !== null && orelse !== undefined);
  this.test = test;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Dict( /* {asdl_seq *} */keys, /* {asdl_seq *} */values, /* {int} */
lineno, /* {int} */col_offset) {
  this.keys = keys;
  this.values = values;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Set( /* {asdl_seq *} */elts, /* {int} */lineno, /* {int} */
col_offset) {
  this.elts = elts;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function ListComp( /* {expr_ty} */elt, /* {asdl_seq *} */generators,
/* {int}
*/
lineno, /* {int} */col_offset) {
  goog.asserts.assert(elt !== null && elt !== undefined);
  this.elt = elt;
  this.generators = generators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function SetComp( /* {expr_ty} */elt, /* {asdl_seq *} */generators,
/* {int}
*/
lineno, /* {int} */col_offset) {
  goog.asserts.assert(elt !== null && elt !== undefined);
  this.elt = elt;
  this.generators = generators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function DictComp( /* {expr_ty} */key, /* {expr_ty} */value,
/* {asdl_seq *}
*/
generators, /* {int} */lineno, /* {int} */
col_offset) {
  goog.asserts.assert(key !== null && key !== undefined);
  goog.asserts.assert(value !== null && value !== undefined);
  this.key = key;
  this.value = value;
  this.generators = generators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function GeneratorExp( /* {expr_ty} */elt, /* {asdl_seq *} */generators,
/*
{int} */
lineno, /* {int} */col_offset) {
  goog.asserts.assert(elt !== null && elt !== undefined);
  this.elt = elt;
  this.generators = generators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Yield( /* {expr_ty} */value, /* {int} */lineno, /* {int} */
col_offset) {
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Compare( /* {expr_ty} */left, /* {asdl_int_seq *} */ops,
/* {asdl_seq
*} */
comparators, /* {int} */lineno, /* {int} */
col_offset) {
  goog.asserts.assert(left !== null && left !== undefined);
  this.left = left;
  this.ops = ops;
  this.comparators = comparators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Call( /* {expr_ty} */func, /* {asdl_seq *} */args, /* {asdl_seq *} */
keywords, /* {expr_ty} */starargs, /* {expr_ty} */kwargs, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(func !== null && func !== undefined);
  this.func = func;
  this.args = args;
  this.keywords = keywords;
  this.starargs = starargs;
  this.kwargs = kwargs;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Repr( /* {expr_ty} */value, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Num( /* {object} */n, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(n !== null && n !== undefined);
  this.n = n;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Str( /* {string} */s, /* {int} */lineno, /* {int} */col_offset) {
  goog.asserts.assert(s !== null && s !== undefined);
  this.s = s;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Attribute( /* {expr_ty} */value, /* {identifier} */attr,
/*
{expr_context_ty} */
ctx, /* {int} */lineno,
/* {int}
*/
col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  goog.asserts.assert(attr !== null && attr !== undefined);
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.value = value;
  this.attr = attr;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Subscript( /* {expr_ty} */value, /* {slice_ty} */slice,
/*
{expr_context_ty} */
ctx, /* {int} */lineno,
/* {int}
*/
col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  goog.asserts.assert(slice !== null && slice !== undefined);
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.value = value;
  this.slice = slice;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Name( /* {identifier} */id, /* {expr_context_ty} */ctx, /* {int} */
lineno, /* {int} */col_offset) {
  goog.asserts.assert(id !== null && id !== undefined);
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.id = id;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function List( /* {asdl_seq *} */elts, /* {expr_context_ty} */ctx, /* {int} */
lineno, /* {int} */col_offset) {
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.elts = elts;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Tuple( /* {asdl_seq *} */elts, /* {expr_context_ty} */ctx,
/* {int}
*/
lineno, /* {int} */col_offset) {
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.elts = elts;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function Ellipsis() {
  return this;
}

/** @constructor */
function Slice( /* {expr_ty} */lower, /* {expr_ty} */upper, /* {expr_ty} */
step) {
  this.lower = lower;
  this.upper = upper;
  this.step = step;
  return this;
}

/** @constructor */
function ExtSlice( /* {asdl_seq *} */dims) {
  this.dims = dims;
  return this;
}

/** @constructor */
function Index( /* {expr_ty} */value) {
  goog.asserts.assert(value !== null && value !== undefined);
  this.value = value;
  return this;
}

/** @constructor */
function comprehension( /* {expr_ty} */target, /* {expr_ty} */iter,
/*
{asdl_seq *} */
ifs) {
  goog.asserts.assert(target !== null && target !== undefined);
  goog.asserts.assert(iter !== null && iter !== undefined);
  this.target = target;
  this.iter = iter;
  this.ifs = ifs;
  return this;
}

/** @constructor */
function ExceptHandler( /* {expr_ty} */type, /* {expr_ty} */name,
/* {asdl_seq
*} */
body, /* {int} */lineno, /* {int} */
col_offset) {
  this.type = type;
  this.name = name;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}

/** @constructor */
function arguments_( /* {asdl_seq *} */args, /* {identifier} */vararg,
/*
{identifier} */
kwarg, /* {asdl_seq *} */defaults) {
  this.args = args;
  this.vararg = vararg;
  this.kwarg = kwarg;
  this.defaults = defaults;
  return this;
}

/** @constructor */
function keyword( /* {identifier} */arg, /* {expr_ty} */value) {
  goog.asserts.assert(arg !== null && arg !== undefined);
  goog.asserts.assert(value !== null && value !== undefined);
  this.arg = arg;
  this.value = value;
  return this;
}

/** @constructor */
function alias( /* {identifier} */name, /* {identifier} */asname) {
  goog.asserts.assert(name !== null && name !== undefined);
  this.name = name;
  this.asname = asname;
  return this;
}
Module.prototype._astname = "Module";
Module.prototype._fields = ["body", function (n) {
  return n.body;
}];
Interactive.prototype._astname = "Interactive";
Interactive.prototype._fields = ["body", function (n) {
  return n.body;
}];
Expression.prototype._astname = "Expression";
Expression.prototype._fields = ["body", function (n) {
  return n.body;
}];
Suite.prototype._astname = "Suite";
Suite.prototype._fields = ["body", function (n) {
  return n.body;
}];
FunctionDef.prototype._astname = "FunctionDef";
FunctionDef.prototype._fields = ["name", function (n) {
  return n.name;
}, "args", function (n) {
  return n.args;
}, "body", function (n) {
  return n.body;
}, "decorator_list", function (n) {
  return n.decorator_list;
}];
ClassDef.prototype._astname = "ClassDef";
ClassDef.prototype._fields = ["name", function (n) {
  return n.name;
}, "bases", function (n) {
  return n.bases;
}, "body", function (n) {
  return n.body;
}, "decorator_list", function (n) {
  return n.decorator_list;
}];
Return_.prototype._astname = "Return";
Return_.prototype._fields = ["value", function (n) {
  return n.value;
}];
Delete_.prototype._astname = "Delete";
Delete_.prototype._fields = ["targets", function (n) {
  return n.targets;
}];
Assign.prototype._astname = "Assign";
Assign.prototype._fields = ["targets", function (n) {
  return n.targets;
}, "value", function (n) {
  return n.value;
}];
AugAssign.prototype._astname = "AugAssign";
AugAssign.prototype._fields = ["target", function (n) {
  return n.target;
}, "op", function (n) {
  return n.op;
}, "value", function (n) {
  return n.value;
}];
Print.prototype._astname = "Print";
Print.prototype._fields = ["dest", function (n) {
  return n.dest;
}, "values", function (n) {
  return n.values;
}, "nl", function (n) {
  return n.nl;
}];
For_.prototype._astname = "For";
For_.prototype._fields = ["target", function (n) {
  return n.target;
}, "iter", function (n) {
  return n.iter;
}, "body", function (n) {
  return n.body;
}, "orelse", function (n) {
  return n.orelse;
}];
While_.prototype._astname = "While";
While_.prototype._fields = ["test", function (n) {
  return n.test;
}, "body", function (n) {
  return n.body;
}, "orelse", function (n) {
  return n.orelse;
}];
If_.prototype._astname = "If";
If_.prototype._fields = ["test", function (n) {
  return n.test;
}, "body", function (n) {
  return n.body;
}, "orelse", function (n) {
  return n.orelse;
}];
With_.prototype._astname = "With";
With_.prototype._fields = ["context_expr", function (n) {
  return n.context_expr;
}, "optional_vars", function (n) {
  return n.optional_vars;
}, "body", function (n) {
  return n.body;
}];
Raise.prototype._astname = "Raise";
Raise.prototype._fields = ["type", function (n) {
  return n.type;
}, "inst", function (n) {
  return n.inst;
}, "tback", function (n) {
  return n.tback;
}];
TryExcept.prototype._astname = "TryExcept";
TryExcept.prototype._fields = ["body", function (n) {
  return n.body;
}, "handlers", function (n) {
  return n.handlers;
}, "orelse", function (n) {
  return n.orelse;
}];
TryFinally.prototype._astname = "TryFinally";
TryFinally.prototype._fields = ["body", function (n) {
  return n.body;
}, "finalbody", function (n) {
  return n.finalbody;
}];
Assert.prototype._astname = "Assert";
Assert.prototype._fields = ["test", function (n) {
  return n.test;
}, "msg", function (n) {
  return n.msg;
}];
Import_.prototype._astname = "Import";
Import_.prototype._fields = ["names", function (n) {
  return n.names;
}];
ImportFrom.prototype._astname = "ImportFrom";
ImportFrom.prototype._fields = ["module", function (n) {
  return n.module;
}, "names", function (n) {
  return n.names;
}, "level", function (n) {
  return n.level;
}];
Exec.prototype._astname = "Exec";
Exec.prototype._fields = ["body", function (n) {
  return n.body;
}, "globals", function (n) {
  return n.globals;
}, "locals", function (n) {
  return n.locals;
}];
Global.prototype._astname = "Global";
Global.prototype._fields = ["names", function (n) {
  return n.names;
}];
Expr.prototype._astname = "Expr";
Expr.prototype._fields = ["value", function (n) {
  return n.value;
}];
Pass.prototype._astname = "Pass";
Pass.prototype._fields = [];
Break_.prototype._astname = "Break";
Break_.prototype._fields = [];
Continue_.prototype._astname = "Continue";
Continue_.prototype._fields = [];
Debugger_.prototype._astname = "Debugger";
Debugger_.prototype._fields = [];
BoolOp.prototype._astname = "BoolOp";
BoolOp.prototype._fields = ["op", function (n) {
  return n.op;
}, "values", function (n) {
  return n.values;
}];
BinOp.prototype._astname = "BinOp";
BinOp.prototype._fields = ["left", function (n) {
  return n.left;
}, "op", function (n) {
  return n.op;
}, "right", function (n) {
  return n.right;
}];
UnaryOp.prototype._astname = "UnaryOp";
UnaryOp.prototype._fields = ["op", function (n) {
  return n.op;
}, "operand", function (n) {
  return n.operand;
}];
Lambda.prototype._astname = "Lambda";
Lambda.prototype._fields = ["args", function (n) {
  return n.args;
}, "body", function (n) {
  return n.body;
}];
IfExp.prototype._astname = "IfExp";
IfExp.prototype._fields = ["test", function (n) {
  return n.test;
}, "body", function (n) {
  return n.body;
}, "orelse", function (n) {
  return n.orelse;
}];
Dict.prototype._astname = "Dict";
Dict.prototype._fields = ["keys", function (n) {
  return n.keys;
}, "values", function (n) {
  return n.values;
}];
Set.prototype._astname = "Set";
Set.prototype._fields = ["elts", function (n) {
  return n.elts;
}];
ListComp.prototype._astname = "ListComp";
ListComp.prototype._fields = ["elt", function (n) {
  return n.elt;
}, "generators", function (n) {
  return n.generators;
}];
SetComp.prototype._astname = "SetComp";
SetComp.prototype._fields = ["elt", function (n) {
  return n.elt;
}, "generators", function (n) {
  return n.generators;
}];
DictComp.prototype._astname = "DictComp";
DictComp.prototype._fields = ["key", function (n) {
  return n.key;
}, "value", function (n) {
  return n.value;
}, "generators", function (n) {
  return n.generators;
}];
GeneratorExp.prototype._astname = "GeneratorExp";
GeneratorExp.prototype._fields = ["elt", function (n) {
  return n.elt;
}, "generators", function (n) {
  return n.generators;
}];
Yield.prototype._astname = "Yield";
Yield.prototype._fields = ["value", function (n) {
  return n.value;
}];
Compare.prototype._astname = "Compare";
Compare.prototype._fields = ["left", function (n) {
  return n.left;
}, "ops", function (n) {
  return n.ops;
}, "comparators", function (n) {
  return n.comparators;
}];
Call.prototype._astname = "Call";
Call.prototype._fields = ["func", function (n) {
  return n.func;
}, "args", function (n) {
  return n.args;
}, "keywords", function (n) {
  return n.keywords;
}, "starargs", function (n) {
  return n.starargs;
}, "kwargs", function (n) {
  return n.kwargs;
}];
Repr.prototype._astname = "Repr";
Repr.prototype._fields = ["value", function (n) {
  return n.value;
}];
Num.prototype._astname = "Num";
Num.prototype._fields = ["n", function (n) {
  return n.n;
}];
Str.prototype._astname = "Str";
Str.prototype._fields = ["s", function (n) {
  return n.s;
}];
Attribute.prototype._astname = "Attribute";
Attribute.prototype._fields = ["value", function (n) {
  return n.value;
}, "attr", function (n) {
  return n.attr;
}, "ctx", function (n) {
  return n.ctx;
}];
Subscript.prototype._astname = "Subscript";
Subscript.prototype._fields = ["value", function (n) {
  return n.value;
}, "slice", function (n) {
  return n.slice;
}, "ctx", function (n) {
  return n.ctx;
}];
Name.prototype._astname = "Name";
Name.prototype._fields = ["id", function (n) {
  return n.id;
}, "ctx", function (n) {
  return n.ctx;
}];
List.prototype._astname = "List";
List.prototype._fields = ["elts", function (n) {
  return n.elts;
}, "ctx", function (n) {
  return n.ctx;
}];
Tuple.prototype._astname = "Tuple";
Tuple.prototype._fields = ["elts", function (n) {
  return n.elts;
}, "ctx", function (n) {
  return n.ctx;
}];
Load.prototype._astname = "Load";
Load.prototype._isenum = true;
Store.prototype._astname = "Store";
Store.prototype._isenum = true;
Del.prototype._astname = "Del";
Del.prototype._isenum = true;
AugLoad.prototype._astname = "AugLoad";
AugLoad.prototype._isenum = true;
AugStore.prototype._astname = "AugStore";
AugStore.prototype._isenum = true;
Param.prototype._astname = "Param";
Param.prototype._isenum = true;
Ellipsis.prototype._astname = "Ellipsis";
Ellipsis.prototype._fields = [];
Slice.prototype._astname = "Slice";
Slice.prototype._fields = ["lower", function (n) {
  return n.lower;
}, "upper", function (n) {
  return n.upper;
}, "step", function (n) {
  return n.step;
}];
ExtSlice.prototype._astname = "ExtSlice";
ExtSlice.prototype._fields = ["dims", function (n) {
  return n.dims;
}];
Index.prototype._astname = "Index";
Index.prototype._fields = ["value", function (n) {
  return n.value;
}];
And.prototype._astname = "And";
And.prototype._isenum = true;
Or.prototype._astname = "Or";
Or.prototype._isenum = true;
Add.prototype._astname = "Add";
Add.prototype._isenum = true;
Sub.prototype._astname = "Sub";
Sub.prototype._isenum = true;
Mult.prototype._astname = "Mult";
Mult.prototype._isenum = true;
Div.prototype._astname = "Div";
Div.prototype._isenum = true;
Mod.prototype._astname = "Mod";
Mod.prototype._isenum = true;
Pow.prototype._astname = "Pow";
Pow.prototype._isenum = true;
LShift.prototype._astname = "LShift";
LShift.prototype._isenum = true;
RShift.prototype._astname = "RShift";
RShift.prototype._isenum = true;
BitOr.prototype._astname = "BitOr";
BitOr.prototype._isenum = true;
BitXor.prototype._astname = "BitXor";
BitXor.prototype._isenum = true;
BitAnd.prototype._astname = "BitAnd";
BitAnd.prototype._isenum = true;
FloorDiv.prototype._astname = "FloorDiv";
FloorDiv.prototype._isenum = true;
Invert.prototype._astname = "Invert";
Invert.prototype._isenum = true;
Not.prototype._astname = "Not";
Not.prototype._isenum = true;
UAdd.prototype._astname = "UAdd";
UAdd.prototype._isenum = true;
USub.prototype._astname = "USub";
USub.prototype._isenum = true;
Eq.prototype._astname = "Eq";
Eq.prototype._isenum = true;
NotEq.prototype._astname = "NotEq";
NotEq.prototype._isenum = true;
Lt.prototype._astname = "Lt";
Lt.prototype._isenum = true;
LtE.prototype._astname = "LtE";
LtE.prototype._isenum = true;
Gt.prototype._astname = "Gt";
Gt.prototype._isenum = true;
GtE.prototype._astname = "GtE";
GtE.prototype._isenum = true;
Is.prototype._astname = "Is";
Is.prototype._isenum = true;
IsNot.prototype._astname = "IsNot";
IsNot.prototype._isenum = true;
In_.prototype._astname = "In";
In_.prototype._isenum = true;
NotIn.prototype._astname = "NotIn";
NotIn.prototype._isenum = true;
comprehension.prototype._astname = "comprehension";
comprehension.prototype._fields = ["target", function (n) {
  return n.target;
}, "iter", function (n) {
  return n.iter;
}, "ifs", function (n) {
  return n.ifs;
}];
ExceptHandler.prototype._astname = "ExceptHandler";
ExceptHandler.prototype._fields = ["type", function (n) {
  return n.type;
}, "name", function (n) {
  return n.name;
}, "body", function (n) {
  return n.body;
}];
arguments_.prototype._astname = "arguments";
arguments_.prototype._fields = ["args", function (n) {
  return n.args;
}, "vararg", function (n) {
  return n.vararg;
}, "kwarg", function (n) {
  return n.kwarg;
}, "defaults", function (n) {
  return n.defaults;
}];
keyword.prototype._astname = "keyword";
keyword.prototype._fields = ["arg", function (n) {
  return n.arg;
}, "value", function (n) {
  return n.value;
}];
alias.prototype._astname = "alias";
alias.prototype._fields = ["name", function (n) {
  return n.name;
}, "asname", function (n) {
  return n.asname;
}];

/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/ast.js ---- */

//
// This is pretty much a straight port of ast.c from CPython 2.6.5.
//
// The previous version was easier to work with and more JS-ish, but having a
// somewhat different ast structure than cpython makes testing more difficult.
//
// This way, we can use a dump from the ast module on any arbitrary python
// code and know that we're the same up to ast level, at least.
//

var SYM = Sk.ParseTables.sym;
var TOK = Sk.Tokenizer.Tokens;
var COMP_GENEXP = 0;
var COMP_SETCOMP = 1;

/** @constructor */
function Compiling(encoding, filename, c_flags) {
  this.c_encoding = encoding;
  this.c_filename = filename;
  this.c_flags = c_flags || 0;
}

/**
 * @return {number}
 */
function NCH(n) {
  goog.asserts.assert(n !== undefined);
  if (n.children === null) {
    return 0;
  }
  return n.children.length;
}
function CHILD(n, i) {
  goog.asserts.assert(n !== undefined);
  goog.asserts.assert(i !== undefined);
  return n.children[i];
}
function REQ(n, type) {
  goog.asserts.assert(n.type === type, "node wasn't expected type");
}
function strobj(s) {
  goog.asserts.assert(typeof s === "string", "expecting string, got " + typeof s);
  return new Sk.builtin.str(s);
}

/** @return {number} */
function numStmts(n) {
  var ch;
  var i;
  var cnt;
  switch (n.type) {
    case SYM.single_input:
      if (CHILD(n, 0).type === TOK.T_NEWLINE) {
        return 0;
      } else {
        return numStmts(CHILD(n, 0));
      }
    case SYM.file_input:
      cnt = 0;
      for (i = 0; i < NCH(n); ++i) {
        ch = CHILD(n, i);
        if (ch.type === SYM.stmt) {
          cnt += numStmts(ch);
        }
      }
      return cnt;
    case SYM.stmt:
      return numStmts(CHILD(n, 0));
    case SYM.compound_stmt:
      return 1;
    case SYM.simple_stmt:
      return Math.floor(NCH(n) / 2);
    // div 2 is to remove count of ;s
    case SYM.suite:
      if (NCH(n) === 1) {
        return numStmts(CHILD(n, 0));
      } else {
        cnt = 0;
        for (i = 2; i < NCH(n) - 1; ++i) {
          cnt += numStmts(CHILD(n, i));
        }
        return cnt;
      }
      break;
    default:
      goog.asserts.fail("Non-statement found");
  }
  return 0;
}
function forbiddenCheck(c, n, x, lineno) {
  if (x === "None") {
    throw new Sk.builtin.SyntaxError("assignment to None", c.c_filename, lineno, [], {
      node: n
    });
  }
  if (x === "True" || x === "False") {
    throw new Sk.builtin.SyntaxError("assignment to True or False is forbidden", c.c_filename, lineno, [], {
      node: n
    });
  }
}

/**
 * Set the context ctx for e, recursively traversing e.
 *
 * Only sets context for expr kinds that can appear in assignment context as
 * per the asdl file.
 */
function setContext(c, e, ctx, n) {
  var i;
  var exprName;
  var s;
  goog.asserts.assert(ctx !== AugStore && ctx !== AugLoad);
  s = null;
  exprName = null;
  switch (e.constructor) {
    case Attribute:
    case Name:
      if (ctx === Store) {
        forbiddenCheck(c, n, e.attr, n.lineno);
      }
      e.ctx = ctx;
      break;
    case Subscript:
      e.ctx = ctx;
      break;
    case List:
      e.ctx = ctx;
      s = e.elts;
      break;
    case Tuple:
      if (e.elts.length === 0) {
        throw new Sk.builtin.SyntaxError("can't assign to ()", c.c_filename, n.lineno, ctx, {
          node: n
        });
      }
      e.ctx = ctx;
      s = e.elts;
      break;
    case Lambda:
      exprName = "lambda";
      break;
    case Call:
      exprName = "function call";
      break;
    case BoolOp:
    case BinOp:
    case UnaryOp:
      exprName = "operator";
      break;
    case GeneratorExp:
      exprName = "generator expression";
      break;
    case Yield:
      exprName = "yield expression";
      break;
    case ListComp:
      exprName = "list comprehension";
      break;
    case SetComp:
      exprName = "set comprehension";
      break;
    case DictComp:
      exprName = "dict comprehension";
      break;
    case Dict:
    case Set:
    case Num:
    case Str:
      exprName = "literal";
      break;
    case Compare:
      exprName = "comparison";
      break;
    case Repr:
      exprName = "repr";
      break;
    case IfExp:
      exprName = "conditional expression";
      break;
    default:
      goog.asserts.fail("unhandled expression in assignment");
  }
  if (exprName) {
    throw new Sk.builtin.SyntaxError("can't " + (ctx === Store ? "assign to" : "delete") + " " + exprName, c.c_filename, n.lineno, [], {
      node: n
    });
  }
  if (s) {
    for (i = 0; i < s.length; ++i) {
      setContext(c, s[i], ctx, n);
    }
  }
}
var operatorMap = {};
(function () {
  operatorMap[TOK.T_VBAR] = BitOr;
  operatorMap[TOK.T_CIRCUMFLEX] = BitXor;
  operatorMap[TOK.T_AMPER] = BitAnd;
  operatorMap[TOK.T_LEFTSHIFT] = LShift;
  operatorMap[TOK.T_RIGHTSHIFT] = RShift;
  operatorMap[TOK.T_PLUS] = Add;
  operatorMap[TOK.T_MINUS] = Sub;
  operatorMap[TOK.T_STAR] = Mult;
  operatorMap[TOK.T_SLASH] = Div;
  operatorMap[TOK.T_DOUBLESLASH] = FloorDiv;
  operatorMap[TOK.T_PERCENT] = Mod;
})();
function getOperator(n) {
  goog.asserts.assert(operatorMap[n.type] !== undefined);
  return operatorMap[n.type];
}
function astForCompOp(c, n) {
  /* comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'
   |'is' 'not'
   */
  REQ(n, SYM.comp_op);
  if (NCH(n) === 1) {
    n = CHILD(n, 0);
    switch (n.type) {
      case TOK.T_LESS:
        return Lt;
      case TOK.T_GREATER:
        return Gt;
      case TOK.T_EQEQUAL:
        return Eq;
      case TOK.T_LESSEQUAL:
        return LtE;
      case TOK.T_GREATEREQUAL:
        return GtE;
      case TOK.T_NOTEQUAL:
        return NotEq;
      case TOK.T_NAME:
        if (n.value === "in") {
          return In_;
        }
        if (n.value === "is") {
          return Is;
        }
    }
  } else if (NCH(n) === 2) {
    if (CHILD(n, 0).type === TOK.T_NAME) {
      if (CHILD(n, 1).value === "in") {
        return NotIn;
      }
      if (CHILD(n, 0).value === "is") {
        return IsNot;
      }
    }
  }
  goog.asserts.fail("invalid comp_op");
}
function seqForTestlist(c, n) {
  /* testlist: test (',' test)* [','] */
  var i;
  var seq = [];
  goog.asserts.assert(n.type === SYM.testlist || n.type === SYM.listmaker || n.type === SYM.testlist_comp || n.type === SYM.testlist_safe || n.type === SYM.testlist1);
  for (i = 0; i < NCH(n); i += 2) {
    goog.asserts.assert(CHILD(n, i).type === SYM.test || CHILD(n, i).type === SYM.old_test);
    seq[i / 2] = astForExpr(c, CHILD(n, i));
  }
  return seq;
}
function astForSuite(c, n) {
  /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */
  var j;
  var num;
  var i;
  var end;
  var ch;
  var pos;
  var seq;
  REQ(n, SYM.suite);
  seq = [];
  pos = 0;
  if (CHILD(n, 0).type === SYM.simple_stmt) {
    n = CHILD(n, 0);
    /* simple_stmt always ends with an NEWLINE and may have a trailing
     * SEMI. */
    end = NCH(n) - 1;
    if (CHILD(n, end - 1).type === TOK.T_SEMI) {
      end -= 1;
    }
    for (i = 0; i < end; i += 2)
    // by 2 to skip ;
    {
      seq[pos++] = astForStmt(c, CHILD(n, i));
    }
  } else {
    for (i = 2; i < NCH(n) - 1; ++i) {
      ch = CHILD(n, i);
      REQ(ch, SYM.stmt);
      num = numStmts(ch);
      if (num === 1) {
        // small_stmt or compound_stmt w/ only 1 child
        seq[pos++] = astForStmt(c, ch);
      } else {
        ch = CHILD(ch, 0);
        REQ(ch, SYM.simple_stmt);
        for (j = 0; j < NCH(ch); j += 2) {
          if (NCH(CHILD(ch, j)) === 0) {
            goog.asserts.assert(j + 1 === NCH(ch));
            break;
          }
          seq[pos++] = astForStmt(c, CHILD(ch, j));
        }
      }
    }
  }
  goog.asserts.assert(pos === numStmts(n));
  return seq;
}
function astForExceptClause(c, exc, body) {
  /* except_clause: 'except' [test [(',' | 'as') test]] */
  var e;
  REQ(exc, SYM.except_clause);
  REQ(body, SYM.suite);
  if (NCH(exc) === 1) {
    return new ExceptHandler(null, null, astForSuite(c, body), exc.lineno, exc.col_offset);
  } else if (NCH(exc) === 2) {
    return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), null, astForSuite(c, body), exc.lineno, exc.col_offset);
  } else if (NCH(exc) === 4) {
    e = astForExpr(c, CHILD(exc, 3));
    setContext(c, e, Store, CHILD(exc, 3));
    return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), e, astForSuite(c, body), exc.lineno, exc.col_offset);
  }
  goog.asserts.fail("wrong number of children for except clause");
}
function astForTryStmt(c, n) {
  var exceptSt;
  var i;
  var handlers;
  var nc = NCH(n);
  var nexcept = (nc - 3) / 3;
  var body,
    orelse = [],
    finally_ = null;
  REQ(n, SYM.try_stmt);
  body = astForSuite(c, CHILD(n, 2));
  if (CHILD(n, nc - 3).type === TOK.T_NAME) {
    if (CHILD(n, nc - 3).value === "finally") {
      if (nc >= 9 && CHILD(n, nc - 6).type === TOK.T_NAME) {
        /* we can assume it's an "else",
         because nc >= 9 for try-else-finally and
         it would otherwise have a type of except_clause */
        orelse = astForSuite(c, CHILD(n, nc - 4));
        nexcept--;
      }
      finally_ = astForSuite(c, CHILD(n, nc - 1));
      nexcept--;
    } else {
      /* we can assume it's an "else",
       otherwise it would have a type of except_clause */
      orelse = astForSuite(c, CHILD(n, nc - 1));
      nexcept--;
    }
  } else if (CHILD(n, nc - 3).type !== SYM.except_clause) {
    throw new Sk.builtin.SyntaxError("malformed 'try' statement", c.c_filename, n.lineno);
  }
  if (nexcept > 0) {
    handlers = [];
    for (i = 0; i < nexcept; ++i) {
      handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));
    }
    exceptSt = new TryExcept(body, handlers, orelse, n.lineno, n.col_offset);
    if (!finally_) {
      return exceptSt;
    }

    /* if a 'finally' is present too, we nest the TryExcept within a
     TryFinally to emulate try ... except ... finally */
    body = [exceptSt];
  }
  goog.asserts.assert(finally_ !== null);
  return new TryFinally(body, finally_, n.lineno, n.col_offset);
}
function astForDottedName(c, n) {
  var i;
  var e;
  var id;
  var col_offset;
  var lineno;
  REQ(n, SYM.dotted_name);
  lineno = n.lineno;
  col_offset = n.col_offset;
  id = strobj(CHILD(n, 0).value);
  e = new Name(id, Load, lineno, col_offset);
  for (i = 2; i < NCH(n); i += 2) {
    id = strobj(CHILD(n, i).value);
    e = new Attribute(e, id, Load, lineno, col_offset);
  }
  return e;
}
function astForDecorator(c, n) {
  /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */
  var nameExpr;
  REQ(n, SYM.decorator);
  REQ(CHILD(n, 0), TOK.T_AT);
  REQ(CHILD(n, NCH(n) - 1), TOK.T_NEWLINE);
  nameExpr = astForDottedName(c, CHILD(n, 1));
  if (NCH(n) === 3)
    // no args
    {
      return nameExpr;
    } else if (NCH(n) === 5)
    // call with no args
    {
      return new Call(nameExpr, [], [], null, null, n.lineno, n.col_offset);
    } else {
    return astForCall(c, CHILD(n, 3), nameExpr);
  }
}
function astForDecorators(c, n) {
  var i;
  var decoratorSeq;
  REQ(n, SYM.decorators);
  decoratorSeq = [];
  for (i = 0; i < NCH(n); ++i) {
    decoratorSeq[i] = astForDecorator(c, CHILD(n, i));
  }
  return decoratorSeq;
}
function astForDecorated(c, n) {
  var thing;
  var decoratorSeq;
  REQ(n, SYM.decorated);
  decoratorSeq = astForDecorators(c, CHILD(n, 0));
  goog.asserts.assert(CHILD(n, 1).type === SYM.funcdef || CHILD(n, 1).type === SYM.classdef);
  thing = null;
  if (CHILD(n, 1).type === SYM.funcdef) {
    thing = astForFuncdef(c, CHILD(n, 1), decoratorSeq);
  } else if (CHILD(n, 1) === SYM.classdef) {
    thing = astForClassdef(c, CHILD(n, 1), decoratorSeq);
  }
  if (thing) {
    thing.lineno = n.lineno;
    thing.col_offset = n.col_offset;
  }
  return thing;
}

//note: with statements need to be updated to 2.7
//see: ast.c lines: 3127 -> 3185

function astForWithVar(c, n) {
  REQ(n, SYM.with_item);
  return astForExpr(c, CHILD(n, 1));
}
function astForWithStmt(c, n) {
  /* with_stmt: 'with' test [ with_var ] ':' suite */
  var optionalVars;
  var contextExpr;
  var suiteIndex = 3; // skip with, test, :
  goog.asserts.assert(n.type === SYM.with_stmt);
  contextExpr = astForExpr(c, CHILD(n, 1));
  if (CHILD(n, 2).type === SYM.with_item) {
    optionalVars = astForWithVar(c, CHILD(n, 2));
    setContext(c, optionalVars, Store, n);
    suiteIndex = 4;
  }
  return new With_(contextExpr, optionalVars, astForSuite(c, CHILD(n, suiteIndex)), n.lineno, n.col_offset);
}
function astForExecStmt(c, n) {
  var expr1,
    globals = null,
    locals = null;
  var nchildren = NCH(n);
  goog.asserts.assert(nchildren === 2 || nchildren === 4 || nchildren === 6);

  /* exec_stmt: 'exec' expr ['in' test [',' test]] */
  REQ(n, SYM.exec_stmt);
  expr1 = astForExpr(c, CHILD(n, 1));
  if (nchildren >= 4) {
    globals = astForExpr(c, CHILD(n, 3));
  }
  if (nchildren === 6) {
    locals = astForExpr(c, CHILD(n, 5));
  }
  return new Exec(expr1, globals, locals, n.lineno, n.col_offset);
}
function astForIfStmt(c, n) {
  /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*
   ['else' ':' suite]
   */
  var off;
  var i;
  var orelse;
  var hasElse;
  var nElif;
  var decider;
  var s;
  REQ(n, SYM.if_stmt);
  if (NCH(n) === 4) {
    return new If_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);
  }
  s = CHILD(n, 4).value;
  decider = s.charAt(2); // elSe or elIf
  if (decider === "s") {
    return new If_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);
  } else if (decider === "i") {
    nElif = NCH(n) - 4;
    hasElse = false;
    orelse = [];

    /* must reference the child nElif+1 since 'else' token is third, not
     * fourth child from the end. */
    if (CHILD(n, nElif + 1).type === TOK.T_NAME && CHILD(n, nElif + 1).value.charAt(2) === "s") {
      hasElse = true;
      nElif -= 3;
    }
    nElif /= 4;
    if (hasElse) {
      orelse = [new If_(astForExpr(c, CHILD(n, NCH(n) - 6)), astForSuite(c, CHILD(n, NCH(n) - 4)), astForSuite(c, CHILD(n, NCH(n) - 1)), CHILD(n, NCH(n) - 6).lineno, CHILD(n, NCH(n) - 6).col_offset)];
      nElif--;
    }
    for (i = 0; i < nElif; ++i) {
      off = 5 + (nElif - i - 1) * 4;
      orelse = [new If_(astForExpr(c, CHILD(n, off)), astForSuite(c, CHILD(n, off + 2)), orelse, CHILD(n, off).lineno, CHILD(n, off).col_offset)];
    }
    return new If_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), orelse, n.lineno, n.col_offset);
  }
  goog.asserts.fail("unexpected token in 'if' statement");
}
function astForExprlist(c, n, context) {
  var e;
  var i;
  var seq;
  REQ(n, SYM.exprlist);
  seq = [];
  for (i = 0; i < NCH(n); i += 2) {
    e = astForExpr(c, CHILD(n, i));
    seq[i / 2] = e;
    if (context) {
      setContext(c, e, context, CHILD(n, i));
    }
  }
  return seq;
}
function astForDelStmt(c, n) {
  /* del_stmt: 'del' exprlist */
  REQ(n, SYM.del_stmt);
  return new Delete_(astForExprlist(c, CHILD(n, 1), Del), n.lineno, n.col_offset);
}
function astForGlobalStmt(c, n) {
  /* global_stmt: 'global' NAME (',' NAME)* */
  var i;
  var s = [];
  REQ(n, SYM.global_stmt);
  for (i = 1; i < NCH(n); i += 2) {
    s[(i - 1) / 2] = strobj(CHILD(n, i).value);
  }
  return new Global(s, n.lineno, n.col_offset);
}
function astForAssertStmt(c, n) {
  /* assert_stmt: 'assert' test [',' test] */
  REQ(n, SYM.assert_stmt);
  if (NCH(n) === 2) {
    return new Assert(astForExpr(c, CHILD(n, 1)), null, n.lineno, n.col_offset);
  } else if (NCH(n) === 4) {
    return new Assert(astForExpr(c, CHILD(n, 1)), astForExpr(c, CHILD(n, 3)), n.lineno, n.col_offset);
  }
  goog.asserts.fail("improper number of parts to assert stmt");
}
function aliasForImportName(c, n) {
  /*
   import_as_name: NAME ['as' NAME]
   dotted_as_name: dotted_name ['as' NAME]
   dotted_name: NAME ('.' NAME)*
   */

  var i;
  var a;
  var name;
  var str;
  loop: while (true) {
    switch (n.type) {
      case SYM.import_as_name:
        str = null;
        name = strobj(CHILD(n, 0).value);
        if (NCH(n) === 3) {
          str = CHILD(n, 2).value;
        }
        return new alias(name, str == null ? null : strobj(str));
      case SYM.dotted_as_name:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue loop;
        } else {
          a = aliasForImportName(c, CHILD(n, 0));
          goog.asserts.assert(!a.asname);
          a.asname = strobj(CHILD(n, 2).value);
          return a;
        }
        break;
      case SYM.dotted_name:
        if (NCH(n) === 1) {
          return new alias(strobj(CHILD(n, 0).value), null);
        } else {
          // create a string of the form a.b.c
          str = "";
          for (i = 0; i < NCH(n); i += 2) {
            str += CHILD(n, i).value + ".";
          }
          return new alias(strobj(str.substr(0, str.length - 1)), null);
        }
        break;
      case TOK.T_STAR:
        return new alias(strobj("*"), null);
      default:
        throw new Sk.builtin.SyntaxError("unexpected import name", c.c_filename, n.lineno);
    }
    break;
  }
}
function astForImportStmt(c, n) {
  /*
   import_stmt: import_name | import_from
   import_name: 'import' dotted_as_names
   import_from: 'from' ('.'* dotted_name | '.') 'import'
   ('*' | '(' import_as_names ')' | import_as_names)
   */
  var modname;
  var idx;
  var nchildren;
  var ndots;
  var mod;
  var i;
  var aliases;
  var col_offset;
  var lineno;
  REQ(n, SYM.import_stmt);
  lineno = n.lineno;
  col_offset = n.col_offset;
  n = CHILD(n, 0);
  if (n.type === SYM.import_name) {
    n = CHILD(n, 1);
    REQ(n, SYM.dotted_as_names);
    aliases = [];
    for (i = 0; i < NCH(n); i += 2) {
      aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
    }
    return new Import_(aliases, lineno, col_offset);
  } else if (n.type === SYM.import_from) {
    mod = null;
    ndots = 0;
    for (idx = 1; idx < NCH(n); ++idx) {
      if (CHILD(n, idx).type === SYM.dotted_name) {
        mod = aliasForImportName(c, CHILD(n, idx));
        idx++;
        break;
      } else if (CHILD(n, idx).type !== TOK.T_DOT) {
        break;
      }
      ndots++;
    }
    ++idx; // skip the import keyword
    switch (CHILD(n, idx).type) {
      case TOK.T_STAR:
        // from ... import
        n = CHILD(n, idx);
        nchildren = 1;
        break;
      case TOK.T_LPAR:
        // from ... import (x, y, z)
        n = CHILD(n, idx + 1);
        nchildren = NCH(n);
        break;
      case SYM.import_as_names:
        // from ... import x, y, z
        n = CHILD(n, idx);
        nchildren = NCH(n);
        if (nchildren % 2 === 0) {
          throw new Sk.builtin.SyntaxError("trailing comma not allowed without surrounding parentheses", c.c_filename, n.lineno);
        }
        break;
      default:
        throw new Sk.builtin.SyntaxError("Unexpected node-type in from-import", c.c_filename, n.lineno);
    }
    aliases = [];
    if (n.type === TOK.T_STAR) {
      aliases[0] = aliasForImportName(c, n);
    } else {
      for (i = 0; i < NCH(n); i += 2) {
        aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
      }
    }
    modname = mod ? mod.name.v : "";
    return new ImportFrom(strobj(modname), aliases, ndots, lineno, col_offset);
  }
  throw new Sk.builtin.SyntaxError("unknown import statement", c.c_filename, n.lineno);
}
function astForTestlistComp(c, n) {
  /* testlist_comp: test ( comp_for | (',' test)* [','] ) */
  /* argument: test [comp_for] */
  goog.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);
  if (NCH(n) > 1 && CHILD(n, 1).type === SYM.comp_for) {
    return astForGenExpr(c, n);
  }
  return astForTestlist(c, n);
}
function astForListcomp(c, n) {
  /* listmaker: test ( list_for | (',' test)* [','] )
   list_for: 'for' exprlist 'in' testlist_safe [list_iter]
   list_iter: list_for | list_if
   list_if: 'if' test [list_iter]
   testlist_safe: test [(',' test)+ [',']]
   */

  function countListFors(c, n) {
    var nfors = 0;
    var ch = CHILD(n, 1);
    count_list_for: while (true) {
      nfors++;
      REQ(ch, SYM.list_for);
      if (NCH(ch) === 5) {
        ch = CHILD(ch, 4);
      } else {
        return nfors;
      }
      count_list_iter: while (true) {
        REQ(ch, SYM.list_iter);
        ch = CHILD(ch, 0);
        if (ch.type === SYM.list_for) {
          continue count_list_for;
        } else if (ch.type === SYM.list_if) {
          if (NCH(ch) === 3) {
            ch = CHILD(ch, 2);
            continue count_list_iter;
          } else {
            return nfors;
          }
        }
        break;
      }
      break;
    }
  }
  function countListIfs(c, n) {
    var nifs = 0;
    while (true) {
      REQ(n, SYM.list_iter);
      if (CHILD(n, 0).type === SYM.list_for) {
        return nifs;
      }
      n = CHILD(n, 0);
      REQ(n, SYM.list_if);
      nifs++;
      if (NCH(n) == 2) {
        return nifs;
      }
      n = CHILD(n, 2);
    }
  }
  var j;
  var ifs;
  var nifs;
  var lc;
  var expression;
  var t;
  var forch;
  var i;
  var ch;
  var listcomps;
  var nfors;
  var elt;
  REQ(n, SYM.listmaker);
  goog.asserts.assert(NCH(n) > 1);
  elt = astForExpr(c, CHILD(n, 0));
  nfors = countListFors(c, n);
  listcomps = [];
  ch = CHILD(n, 1);
  for (i = 0; i < nfors; ++i) {
    REQ(ch, SYM.list_for);
    forch = CHILD(ch, 1);
    t = astForExprlist(c, forch, Store);
    expression = astForTestlist(c, CHILD(ch, 3));
    if (NCH(forch) === 1) {
      lc = new comprehension(t[0], expression, []);
    } else {
      lc = new comprehension(new Tuple(t, Store, ch.lineno, ch.col_offset), expression, []);
    }
    if (NCH(ch) === 5) {
      ch = CHILD(ch, 4);
      nifs = countListIfs(c, ch);
      ifs = [];
      for (j = 0; j < nifs; ++j) {
        REQ(ch, SYM.list_iter);
        ch = CHILD(ch, 0);
        REQ(ch, SYM.list_if);
        ifs[j] = astForExpr(c, CHILD(ch, 1));
        if (NCH(ch) === 3) {
          ch = CHILD(ch, 2);
        }
      }
      if (ch.type === SYM.list_iter) {
        ch = CHILD(ch, 0);
      }
      lc.ifs = ifs;
    }
    listcomps[i] = lc;
  }
  return new ListComp(elt, listcomps, n.lineno, n.col_offset);
}
function astForFactor(c, n) {
  /* some random peephole thing that cpy does */
  var expression;
  var pnum;
  var patom;
  var ppower;
  var pfactor;
  if (CHILD(n, 0).type === TOK.T_MINUS && NCH(n) === 2) {
    pfactor = CHILD(n, 1);
    if (pfactor.type === SYM.factor && NCH(pfactor) === 1) {
      ppower = CHILD(pfactor, 0);
      if (ppower.type === SYM.power && NCH(ppower) === 1) {
        patom = CHILD(ppower, 0);
        if (patom.type === SYM.atom) {
          pnum = CHILD(patom, 0);
          if (pnum.type === TOK.T_NUMBER) {
            pnum.value = "-" + pnum.value;
            return astForAtom(c, patom);
          }
        }
      }
    }
  }
  expression = astForExpr(c, CHILD(n, 1));
  switch (CHILD(n, 0).type) {
    case TOK.T_PLUS:
      return new UnaryOp(UAdd, expression, n.lineno, n.col_offset);
    case TOK.T_MINUS:
      return new UnaryOp(USub, expression, n.lineno, n.col_offset);
    case TOK.T_TILDE:
      return new UnaryOp(Invert, expression, n.lineno, n.col_offset);
  }
  goog.asserts.fail("unhandled factor");
}
function astForForStmt(c, n) {
  /* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] */
  var target;
  var _target;
  var nodeTarget;
  var seq = [];
  REQ(n, SYM.for_stmt);
  if (NCH(n) === 9) {
    seq = astForSuite(c, CHILD(n, 8));
  }
  nodeTarget = CHILD(n, 1);
  _target = astForExprlist(c, nodeTarget, Store);
  if (NCH(nodeTarget) === 1) {
    target = _target[0];
  } else {
    target = new Tuple(_target, Store, n.lineno, n.col_offset);
  }
  return new For_(target, astForTestlist(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 5)), seq, n.lineno, n.col_offset);
}
function astForCall(c, n, func) {
  /*
    arglist: (argument ',')* (argument [',']| '*' test [',' '**' test]
             | '**' test)
    argument: test [comp_for] | test '=' test       # Really [keyword '='] test
  */
  var tmp;
  var k;
  var key;
  var e;
  var kwarg;
  var vararg;
  var keywords;
  var args;
  var ch;
  var i;
  var ngens;
  var nkeywords;
  var nargs;
  REQ(n, SYM.arglist);
  nargs = 0;
  nkeywords = 0;
  ngens = 0;
  for (i = 0; i < NCH(n); i++) {
    ch = CHILD(n, i);
    if (ch.type === SYM.argument) {
      if (NCH(ch) === 1) {
        nargs++;
      } else if (CHILD(ch, 1).type === SYM.comp_for) {
        ngens++;
      } else {
        nkeywords++;
      }
    }
  }
  if (ngens > 1 || ngens && (nargs || nkeywords)) {
    throw new Sk.builtin.SyntaxError("Generator expression must be parenthesized if not sole argument", c.c_filename, n.lineno);
  }
  if (nargs + nkeywords + ngens > 255) {
    throw new Sk.builtin.SyntaxError("more than 255 arguments", c.c_filename, n.lineno);
  }
  args = [];
  keywords = [];
  nargs = 0;
  nkeywords = 0;
  vararg = null;
  kwarg = null;
  for (i = 0; i < NCH(n); i++) {
    ch = CHILD(n, i);
    if (ch.type === SYM.argument) {
      if (NCH(ch) === 1) {
        if (nkeywords) {
          throw new Sk.builtin.SyntaxError("non-keyword arg after keyword arg", c.c_filename, n.lineno);
        }
        if (vararg) {
          throw new Sk.builtin.SyntaxError("only named arguments may follow *expression", c.c_filename, n.lineno);
        }
        args[nargs++] = astForExpr(c, CHILD(ch, 0));
      } else if (CHILD(ch, 1).type === SYM.comp_for) {
        args[nargs++] = astForGenExpr(c, ch);
      } else {
        e = astForExpr(c, CHILD(ch, 0));
        if (e.constructor === Lambda) {
          throw new Sk.builtin.SyntaxError("lambda cannot contain assignment", c.c_filename, n.lineno);
        } else if (e.constructor !== Name) {
          throw new Sk.builtin.SyntaxError("keyword can't be an expression", c.c_filename, n.lineno);
        }
        key = e.id;
        forbiddenCheck(c, CHILD(ch, 0), key, n.lineno);
        for (k = 0; k < nkeywords; ++k) {
          tmp = keywords[k].arg;
          if (tmp === key) {
            throw new Sk.builtin.SyntaxError("keyword argument repeated", c.c_filename, n.lineno);
          }
        }
        keywords[nkeywords++] = new keyword(key, astForExpr(c, CHILD(ch, 2)));
      }
    } else if (ch.type === TOK.T_STAR) {
      vararg = astForExpr(c, CHILD(n, ++i));
    } else if (ch.type === TOK.T_DOUBLESTAR) {
      kwarg = astForExpr(c, CHILD(n, ++i));
    }
  }
  return new Call(func, args, keywords, vararg, kwarg, func.lineno, func.col_offset);
}
function astForTrailer(c, n, leftExpr) {
  /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
   subscriptlist: subscript (',' subscript)* [',']
   subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]
   */
  var e;
  var elts;
  var slc;
  var j;
  var slices;
  var simple;
  REQ(n, SYM.trailer);
  if (CHILD(n, 0).type === TOK.T_LPAR) {
    if (NCH(n) === 2) {
      return new Call(leftExpr, [], [], null, null, n.lineno, n.col_offset);
    } else {
      return astForCall(c, CHILD(n, 1), leftExpr);
    }
  } else if (CHILD(n, 0).type === TOK.T_DOT) {
    return new Attribute(leftExpr, strobj(CHILD(n, 1).value), Load, n.lineno, n.col_offset);
  } else {
    REQ(CHILD(n, 0), TOK.T_LSQB);
    REQ(CHILD(n, 2), TOK.T_RSQB);
    n = CHILD(n, 1);
    if (NCH(n) === 1) {
      return new Subscript(leftExpr, astForSlice(c, CHILD(n, 0)), Load, n.lineno, n.col_offset);
    } else {
      /* The grammar is ambiguous here. The ambiguity is resolved
       by treating the sequence as a tuple literal if there are
       no slice features.
       */
      simple = true;
      slices = [];
      for (j = 0; j < NCH(n); j += 2) {
        slc = astForSlice(c, CHILD(n, j));
        if (slc.constructor !== Index) {
          simple = false;
        }
        slices[j / 2] = slc;
      }
      if (!simple) {
        return new Subscript(leftExpr, new ExtSlice(slices), Load, n.lineno, n.col_offset);
      }
      elts = [];
      for (j = 0; j < slices.length; ++j) {
        slc = slices[j];
        goog.asserts.assert(slc.constructor === Index && slc.value !== null && slc.value !== undefined);
        elts[j] = slc.value;
      }
      e = new Tuple(elts, Load, n.lineno, n.col_offset);
      return new Subscript(leftExpr, new Index(e), Load, n.lineno, n.col_offset);
    }
  }
}
function astForFlowStmt(c, n) {
  /*
   flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt
   | yield_stmt
   break_stmt: 'break'
   continue_stmt: 'continue'
   return_stmt: 'return' [testlist]
   yield_stmt: yield_expr
   yield_expr: 'yield' testlist
   raise_stmt: 'raise' [test [',' test [',' test]]]
   */
  var ch;
  REQ(n, SYM.flow_stmt);
  ch = CHILD(n, 0);
  switch (ch.type) {
    case SYM.break_stmt:
      return new Break_(n.lineno, n.col_offset);
    case SYM.continue_stmt:
      return new Continue_(n.lineno, n.col_offset);
    case SYM.yield_stmt:
      return new Expr(astForExpr(c, CHILD(ch, 0)), n.lineno, n.col_offset);
    case SYM.return_stmt:
      if (NCH(ch) === 1) {
        return new Return_(null, n.lineno, n.col_offset);
      } else {
        return new Return_(astForTestlist(c, CHILD(ch, 1)), n.lineno, n.col_offset);
      }
      break;
    case SYM.raise_stmt:
      if (NCH(ch) === 1) {
        return new Raise(null, null, null, n.lineno, n.col_offset);
      } else if (NCH(ch) === 2) {
        return new Raise(astForExpr(c, CHILD(ch, 1)), null, null, n.lineno, n.col_offset);
      } else if (NCH(ch) === 4) {
        return new Raise(astForExpr(c, CHILD(ch, 1)), astForExpr(c, CHILD(ch, 3)), null, n.lineno, n.col_offset);
      } else if (NCH(ch) === 6) {
        return new Raise(astForExpr(c, CHILD(ch, 1)), astForExpr(c, CHILD(ch, 3)), astForExpr(c, CHILD(ch, 5)), n.lineno, n.col_offset);
      }
      break;
    default:
      goog.asserts.fail("unexpected flow_stmt");
  }
  goog.asserts.fail("unhandled flow statement");
}
function astForArguments(c, n) {
  /* parameters: '(' [varargslist] ')'
   varargslist: (fpdef ['=' test] ',')* ('*' NAME [',' '**' NAME]
   | '**' NAME) | fpdef ['=' test] (',' fpdef ['=' test])* [',']
   */
  var parenthesized;
  var id;
  var complexArgs;
  var k;
  var j;
  var i;
  var foundDefault;
  var defaults;
  var args;
  var ch;
  var vararg = null;
  var kwarg = null;
  if (n.type === SYM.parameters) {
    if (NCH(n) === 2)
      // () as arglist
      {
        return new arguments_([], null, null, []);
      }
    n = CHILD(n, 1);
  }
  REQ(n, SYM.varargslist);
  args = [];
  defaults = [];

  /* fpdef: NAME | '(' fplist ')'
   fplist: fpdef (',' fpdef)* [',']
   */
  foundDefault = false;
  i = 0;
  j = 0; // index for defaults
  k = 0; // index for args
  while (i < NCH(n)) {
    ch = CHILD(n, i);
    switch (ch.type) {
      case SYM.fpdef:
        complexArgs = 0;
        parenthesized = 0;
        handle_fpdef: while (true) {
          if (i + 1 < NCH(n) && CHILD(n, i + 1).type === TOK.T_EQUAL) {
            defaults[j++] = astForExpr(c, CHILD(n, i + 2));
            i += 2;
            foundDefault = true;
          } else if (foundDefault) {
            /* def f((x)=4): pass should raise an error.
             def f((x, (y))): pass will just incur the tuple unpacking warning. */
            if (parenthesized && !complexArgs) {
              throw new Sk.builtin.SyntaxError("parenthesized arg with default", c.c_filename, n.lineno);
            }
            throw new Sk.builtin.SyntaxError("non-default argument follows default argument", c.c_filename, n.lineno);
          }
          if (NCH(ch) === 3) {
            ch = CHILD(ch, 1);
            // def foo((x)): is not complex, special case.
            if (NCH(ch) !== 1) {
              throw new Sk.builtin.SyntaxError("tuple parameter unpacking has been removed", c.c_filename, n.lineno);
            } else {
              /* def foo((x)): setup for checking NAME below. */
              /* Loop because there can be many parens and tuple
               unpacking mixed in. */
              parenthesized = true;
              ch = CHILD(ch, 0);
              goog.asserts.assert(ch.type === SYM.fpdef);
              continue handle_fpdef;
            }
          }
          if (CHILD(ch, 0).type === TOK.T_NAME) {
            forbiddenCheck(c, n, CHILD(ch, 0).value, n.lineno);
            id = strobj(CHILD(ch, 0).value);
            args[k++] = new Name(id, Param, ch.lineno, ch.col_offset);
          }
          i += 2;
          if (parenthesized) {
            throw new Sk.builtin.SyntaxError("parenthesized argument names are invalid", c.c_filename, n.lineno);
          }
          break;
        }
        break;
      case TOK.T_STAR:
        forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);
        vararg = strobj(CHILD(n, i + 1).value);
        i += 3;
        break;
      case TOK.T_DOUBLESTAR:
        forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);
        kwarg = strobj(CHILD(n, i + 1).value);
        i += 3;
        break;
      default:
        goog.asserts.fail("unexpected node in varargslist");
    }
  }
  return new arguments_(args, vararg, kwarg, defaults);
}
function astForFuncdef(c, n, decoratorSeq) {
  /* funcdef: 'def' NAME parameters ':' suite */
  var body;
  var args;
  var name;
  REQ(n, SYM.funcdef);
  name = strobj(CHILD(n, 1).value);
  forbiddenCheck(c, CHILD(n, 1), CHILD(n, 1).value, n.lineno);
  args = astForArguments(c, CHILD(n, 2));
  body = astForSuite(c, CHILD(n, 4));
  return new FunctionDef(name, args, body, decoratorSeq, n.lineno, n.col_offset);
}
function astForClassBases(c, n) {
  /* testlist: test (',' test)* [','] */
  goog.asserts.assert(NCH(n) > 0);
  REQ(n, SYM.testlist);
  if (NCH(n) === 1) {
    return [astForExpr(c, CHILD(n, 0))];
  }
  return seqForTestlist(c, n);
}
function astForClassdef(c, n, decoratorSeq) {
  /* classdef: 'class' NAME ['(' testlist ')'] ':' suite */
  var s;
  var bases;
  var classname;
  REQ(n, SYM.classdef);
  forbiddenCheck(c, n, CHILD(n, 1).value, n.lineno);
  classname = strobj(CHILD(n, 1).value);
  if (NCH(n) === 4) {
    return new ClassDef(classname, [], astForSuite(c, CHILD(n, 3)), decoratorSeq, n.lineno, n.col_offset);
  }
  if (CHILD(n, 3).type === TOK.T_RPAR) {
    return new ClassDef(classname, [], astForSuite(c, CHILD(n, 5)), decoratorSeq, n.lineno, n.col_offset);
  }
  bases = astForClassBases(c, CHILD(n, 3));
  s = astForSuite(c, CHILD(n, 6));
  return new ClassDef(classname, bases, s, decoratorSeq, n.lineno, n.col_offset);
}
function astForLambdef(c, n) {
  /* lambdef: 'lambda' [varargslist] ':' test */
  var args;
  var expression;
  if (NCH(n) === 3) {
    args = new arguments_([], null, null, []);
    expression = astForExpr(c, CHILD(n, 2));
  } else {
    args = astForArguments(c, CHILD(n, 1));
    expression = astForExpr(c, CHILD(n, 3));
  }
  return new Lambda(args, expression, n.lineno, n.col_offset);
}
function astForComprehension(c, n) {
  /* testlist_comp: test ( comp_for | (',' test)* [','] )
     argument: test [comp_for] | test '=' test       # Really [keyword '='] test */

  var j;
  var ifs;
  var nifs;
  var ge;
  var expression;
  var t;
  var forch;
  var i;
  var ch;
  var genexps;
  var nfors;
  var elt;
  var comps;
  var comp;
  function countCompFors(c, n) {
    var nfors = 0;
    count_comp_for: while (true) {
      nfors++;
      REQ(n, SYM.comp_for);
      if (NCH(n) === 5) {
        n = CHILD(n, 4);
      } else {
        return nfors;
      }
      count_comp_iter: while (true) {
        REQ(n, SYM.comp_iter);
        n = CHILD(n, 0);
        if (n.type === SYM.comp_for) {
          continue count_comp_for;
        } else if (n.type === SYM.comp_if) {
          if (NCH(n) === 3) {
            n = CHILD(n, 2);
            continue count_comp_iter;
          } else {
            return nfors;
          }
        }
        break;
      }
      break;
    }
    goog.asserts.fail("logic error in countCompFors");
  }
  function countCompIfs(c, n) {
    var nifs = 0;
    while (true) {
      REQ(n, SYM.comp_iter);
      if (CHILD(n, 0).type === SYM.comp_for) {
        return nifs;
      }
      n = CHILD(n, 0);
      REQ(n, SYM.comp_if);
      nifs++;
      if (NCH(n) == 2) {
        return nifs;
      }
      n = CHILD(n, 2);
    }
  }
  nfors = countCompFors(c, n);
  comps = [];
  for (i = 0; i < nfors; ++i) {
    REQ(n, SYM.comp_for);
    forch = CHILD(n, 1);
    t = astForExprlist(c, forch, Store);
    expression = astForExpr(c, CHILD(n, 3));
    if (NCH(forch) === 1) {
      comp = new comprehension(t[0], expression, []);
    } else {
      comp = new comprehension(new Tuple(t, Store, n.lineno, n.col_offset), expression, []);
    }
    if (NCH(n) === 5) {
      n = CHILD(n, 4);
      nifs = countCompIfs(c, n);
      ifs = [];
      for (j = 0; j < nifs; ++j) {
        REQ(n, SYM.comp_iter);
        n = CHILD(n, 0);
        REQ(n, SYM.comp_if);
        expression = astForExpr(c, CHILD(n, 1));
        ifs[j] = expression;
        if (NCH(n) === 3) {
          n = CHILD(n, 2);
        }
      }
      if (n.type === SYM.comp_iter) {
        n = CHILD(n, 0);
      }
      comp.ifs = ifs;
    }
    comps[i] = comp;
  }
  return comps;
}
function astForIterComp(c, n, type) {
  var elt, comps;
  goog.asserts.assert(NCH(n) > 1);
  elt = astForExpr(c, CHILD(n, 0));
  comps = astForComprehension(c, CHILD(n, 1));
  if (type === COMP_GENEXP) {
    return new GeneratorExp(elt, comps, n.lineno, n.col_offset);
  } else if (type === COMP_SETCOMP) {
    return new SetComp(elt, comps, n.lineno, n.col_offset);
  }
}
function astForDictComp(c, n) {
  var key, value;
  var comps = [];
  goog.asserts.assert(NCH(n) > 3);
  REQ(CHILD(n, 1), TOK.T_COLON);
  key = astForExpr(c, CHILD(n, 0));
  value = astForExpr(c, CHILD(n, 2));
  comps = astForComprehension(c, CHILD(n, 3));
  return new DictComp(key, value, comps, n.lineno, n.col_offset);
}
function astForGenExpr(c, n) {
  goog.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);
  return astForIterComp(c, n, COMP_GENEXP);
}
function astForSetComp(c, n) {
  goog.asserts.assert(n.type === SYM.dictorsetmaker);
  return astForIterComp(c, n, COMP_SETCOMP);
}
function astForWhileStmt(c, n) {
  /* while_stmt: 'while' test ':' suite ['else' ':' suite] */
  REQ(n, SYM.while_stmt);
  if (NCH(n) === 4) {
    return new While_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);
  } else if (NCH(n) === 7) {
    return new While_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);
  }
  goog.asserts.fail("wrong number of tokens for 'while' stmt");
}
function astForAugassign(c, n) {
  REQ(n, SYM.augassign);
  n = CHILD(n, 0);
  switch (n.value.charAt(0)) {
    case "+":
      return Add;
    case "-":
      return Sub;
    case "/":
      if (n.value.charAt(1) === "/") {
        return FloorDiv;
      }
      return Div;
    case "%":
      return Mod;
    case "<":
      return LShift;
    case ">":
      return RShift;
    case "&":
      return BitAnd;
    case "^":
      return BitXor;
    case "|":
      return BitOr;
    case "*":
      if (n.value.charAt(1) === "*") {
        return Pow;
      }
      return Mult;
    default:
      goog.asserts.fail("invalid augassign");
  }
}
function astForBinop(c, n) {
  /* Must account for a sequence of expressions.
   How should A op B op C by represented?
   BinOp(BinOp(A, op, B), op, C).
   */
  var tmp;
  var newoperator;
  var nextOper;
  var i;
  var result = new BinOp(astForExpr(c, CHILD(n, 0)), getOperator(CHILD(n, 1)), astForExpr(c, CHILD(n, 2)), n.lineno, n.col_offset);
  var nops = (NCH(n) - 1) / 2;
  for (i = 1; i < nops; ++i) {
    nextOper = CHILD(n, i * 2 + 1);
    newoperator = getOperator(nextOper);
    tmp = astForExpr(c, CHILD(n, i * 2 + 2));
    result = new BinOp(result, newoperator, tmp, nextOper.lineno, nextOper.col_offset);
  }
  return result;
}
function astForTestlist(c, n) {
  /* this doesn't show up in Grammar.txt never did: testlist_gexp: test (',' test)* [','] */
  /* testlist_comp: test (',' test)* [','] */
  /* testlist: test (',' test)* [','] */
  /* testlist_safe: test (',' test)+ [','] */
  /* testlist1: test (',' test)* */
  goog.asserts.assert(NCH(n) > 0);
  if (n.type === SYM.testlist_comp) {
    if (NCH(n) > 1) {
      goog.asserts.assert(CHILD(n, 1).type !== SYM.comp_for);
    }
  } else {
    goog.asserts.assert(n.type === SYM.testlist || n.type === SYM.testlist_safe || n.type === SYM.testlist1);
  }
  if (NCH(n) === 1) {
    return astForExpr(c, CHILD(n, 0));
  } else {
    return new Tuple(seqForTestlist(c, n), Load, n.lineno, n.col_offset);
  }
}
function astForExprStmt(c, n) {
  var expression;
  var value;
  var e;
  var i;
  var targets;
  var expr2;
  var varName;
  var expr1;
  var ch;
  REQ(n, SYM.expr_stmt);
  /* expr_stmt: testlist (augassign (yield_expr|testlist)
   | ('=' (yield_expr|testlist))*)
   testlist: test (',' test)* [',']
   augassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^='
   | '<<=' | '>>=' | '**=' | '//='
   test: ... here starts the operator precendence dance
   */
  if (NCH(n) === 1) {
    return new Expr(astForTestlist(c, CHILD(n, 0)), n.lineno, n.col_offset);
  } else if (CHILD(n, 1).type === SYM.augassign) {
    ch = CHILD(n, 0);
    expr1 = astForTestlist(c, ch);
    switch (expr1.constructor) {
      case GeneratorExp:
        throw new Sk.builtin.SyntaxError("augmented assignment to generator expression not possible", c.c_filename, n.lineno);
      case Yield:
        throw new Sk.builtin.SyntaxError("augmented assignment to yield expression not possible", c.c_filename, n.lineno);
      case Name:
        varName = expr1.id;
        forbiddenCheck(c, ch, varName, n.lineno);
        break;
      case Attribute:
      case Subscript:
        break;
      default:
        throw new Sk.builtin.SyntaxError("illegal expression for augmented assignment", c.c_filename, n.lineno);
    }
    setContext(c, expr1, Store, ch);
    ch = CHILD(n, 2);
    if (ch.type === SYM.testlist) {
      expr2 = astForTestlist(c, ch);
    } else {
      expr2 = astForExpr(c, ch);
    }
    return new AugAssign(expr1, astForAugassign(c, CHILD(n, 1)), expr2, n.lineno, n.col_offset);
  } else {
    // normal assignment
    REQ(CHILD(n, 1), TOK.T_EQUAL);
    targets = [];
    for (i = 0; i < NCH(n) - 2; i += 2) {
      ch = CHILD(n, i);
      if (ch.type === SYM.yield_expr) {
        throw new Sk.builtin.SyntaxError("assignment to yield expression not possible", c.c_filename, n.lineno);
      }
      e = astForTestlist(c, ch);
      setContext(c, e, Store, CHILD(n, i));
      targets[i / 2] = e;
    }
    value = CHILD(n, NCH(n) - 1);
    if (value.type === SYM.testlist) {
      expression = astForTestlist(c, value);
    } else {
      expression = astForExpr(c, value);
    }
    return new Assign(targets, expression, n.lineno, n.col_offset);
  }
}
function astForIfexpr(c, n) {
  /* test: or_test 'if' or_test 'else' test */
  goog.asserts.assert(NCH(n) === 5);
  return new IfExp(astForExpr(c, CHILD(n, 2)), astForExpr(c, CHILD(n, 0)), astForExpr(c, CHILD(n, 4)), n.lineno, n.col_offset);
}

/**
 * s is a python-style string literal, including quote characters and u/r/b
 * prefixes. Returns decoded string object.
 */
function parsestr(c, s) {
  var encodeUtf8 = function (s) {
    return unescape(encodeURIComponent(s));
  };
  var decodeUtf8 = function (s) {
    return decodeURIComponent(escape(s));
  };
  var decodeEscape = function (s, quote) {
    var d3;
    var d2;
    var d1;
    var d0;
    var c;
    var i;
    var len = s.length;
    var ret = "";
    for (i = 0; i < len; ++i) {
      c = s.charAt(i);
      if (c === "\\") {
        ++i;
        c = s.charAt(i);
        if (c === "n") {
          ret += "\n";
        } else if (c === "\\") {
          ret += "\\";
        } else if (c === "t") {
          ret += "\t";
        } else if (c === "r") {
          ret += "\r";
        } else if (c === "b") {
          ret += "\b";
        } else if (c === "f") {
          ret += "\f";
        } else if (c === "v") {
          ret += "\v";
        } else if (c === "0") {
          ret += "\0";
        } else if (c === '"') {
          ret += '"';
        } else if (c === '\'') {
          ret += '\'';
        } else if (c === "\n") /* escaped newline, join lines */{} else if (c === "x") {
          d0 = s.charAt(++i);
          d1 = s.charAt(++i);
          ret += String.fromCharCode(parseInt(d0 + d1, 16));
        } else if (c === "u" || c === "U") {
          d0 = s.charAt(++i);
          d1 = s.charAt(++i);
          d2 = s.charAt(++i);
          d3 = s.charAt(++i);
          ret += String.fromCharCode(parseInt(d0 + d1, 16), parseInt(d2 + d3, 16));
        } else {
          // Leave it alone
          ret += "\\" + c;
          // goog.asserts.fail("unhandled escape: '" + c.charCodeAt(0) + "'");
        }
      } else {
        ret += c;
      }
    }
    return ret;
  };

  //print("parsestr", s);

  var quote = s.charAt(0);
  var rawmode = false;
  var unicode = false;

  // treats every sequence as unicodes even if they are not treated with uU prefix
  // kinda hacking though working for most purposes
  if (c.c_flags & Parser.CO_FUTURE_UNICODE_LITERALS || Sk.python3 === true) {
    unicode = true;
  }
  if (quote === "u" || quote === "U") {
    s = s.substr(1);
    quote = s.charAt(0);
    unicode = true;
  } else if (quote === "r" || quote === "R") {
    s = s.substr(1);
    quote = s.charAt(0);
    rawmode = true;
  }
  goog.asserts.assert(quote !== "b" && quote !== "B", "todo; haven't done b'' strings yet");
  goog.asserts.assert(quote === "'" || quote === '"' && s.charAt(s.length - 1) === quote);
  s = s.substr(1, s.length - 2);
  if (unicode) {
    s = encodeUtf8(s);
  }
  if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {
    goog.asserts.assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);
    s = s.substr(2, s.length - 4);
  }
  if (rawmode || s.indexOf("\\") === -1) {
    return strobj(decodeUtf8(s));
  }
  return strobj(decodeEscape(s, quote));
}
function parsestrplus(c, n) {
  var i;
  var ret;
  REQ(CHILD(n, 0), TOK.T_STRING);
  ret = new Sk.builtin.str("");
  for (i = 0; i < NCH(n); ++i) {
    try {
      ret = ret.sq$concat(parsestr(c, CHILD(n, i).value));
    } catch (x) {
      throw new Sk.builtin.SyntaxError("invalid string (possibly contains a unicode character)", c.c_filename, CHILD(n, i).lineno);
    }
  }
  return ret;
}
function parsenumber(c, s, lineno) {
  var neg;
  var val;
  var tmp;
  var end = s.charAt(s.length - 1);

  // call internal complex type constructor for complex strings
  if (end === "j" || end === "J") {
    return Sk.builtin.complex.complex_subtype_from_string(s);
  }

  // Handle longs
  if (end === "l" || end === "L") {
    return Sk.longFromStr(s.substr(0, s.length - 1), 0);
  }

  // todo; we don't currently distinguish between int and float so
  // str is wrong for these.
  if (s.indexOf(".") !== -1) {
    return new Sk.builtin.float_(parseFloat(s));
  }

  // Handle integers of various bases
  tmp = s;
  neg = false;
  if (s.charAt(0) === "-") {
    tmp = s.substr(1);
    neg = true;
  }
  if (tmp.charAt(0) === "0" && (tmp.charAt(1) === "x" || tmp.charAt(1) === "X")) {
    // Hex
    tmp = tmp.substring(2);
    val = parseInt(tmp, 16);
  } else if (s.indexOf("e") !== -1 || s.indexOf("E") !== -1) {
    // Float with exponent (needed to make sure e/E wasn't hex first)
    return new Sk.builtin.float_(parseFloat(s));
  } else if (tmp.charAt(0) === "0" && (tmp.charAt(1) === "b" || tmp.charAt(1) === "B")) {
    // Binary
    tmp = tmp.substring(2);
    val = parseInt(tmp, 2);
  } else if (tmp.charAt(0) === "0") {
    if (tmp === "0") {
      // Zero
      val = 0;
    } else {
      // Octal
      tmp = tmp.substring(1);
      if (tmp.charAt(0) === "o" || tmp.charAt(0) === "O") {
        tmp = tmp.substring(1);
      }
      val = parseInt(tmp, 8);
    }
  } else {
    // Decimal
    val = parseInt(tmp, 10);
  }

  // Convert to long
  if (val > Sk.builtin.int_.threshold$ && Math.floor(val) === val && s.indexOf("e") === -1 && s.indexOf("E") === -1) {
    return Sk.longFromStr(s, 0);
  }

  // Small enough, return parsed number
  if (neg) {
    return new Sk.builtin.int_(-val);
  } else {
    return new Sk.builtin.int_(val);
  }
}
function astForSlice(c, n) {
  var n2;
  var step;
  var upper;
  var lower;
  var ch;
  REQ(n, SYM.subscript);

  /*
   subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]
   sliceop: ':' [test]
   */
  ch = CHILD(n, 0);
  lower = null;
  upper = null;
  step = null;
  if (ch.type === TOK.T_DOT) {
    return new Ellipsis();
  }
  if (NCH(n) === 1 && ch.type === SYM.test) {
    return new Index(astForExpr(c, ch));
  }
  if (ch.type === SYM.test) {
    lower = astForExpr(c, ch);
  }
  if (ch.type === TOK.T_COLON) {
    if (NCH(n) > 1) {
      n2 = CHILD(n, 1);
      if (n2.type === SYM.test) {
        upper = astForExpr(c, n2);
      }
    }
  } else if (NCH(n) > 2) {
    n2 = CHILD(n, 2);
    if (n2.type === SYM.test) {
      upper = astForExpr(c, n2);
    }
  }
  ch = CHILD(n, NCH(n) - 1);
  if (ch.type === SYM.sliceop) {
    if (NCH(ch) === 1) {
      ch = CHILD(ch, 0);
      step = new Name(strobj("None"), Load, ch.lineno, ch.col_offset);
    } else {
      ch = CHILD(ch, 1);
      if (ch.type === SYM.test) {
        step = astForExpr(c, ch);
      }
    }
  }
  return new Slice(lower, upper, step);
}
function astForAtom(c, n) {
  /* atom: ('(' [yield_expr|testlist_comp] ')' |
     '[' [listmaker] ']' |
     '{' [dictorsetmaker] '}' |
     '`' testlist1 '`' |
     NAME | NUMBER | STRING+)
  */
  var i;
  var values;
  var keys;
  var size;
  var ch = CHILD(n, 0);
  var elts;
  switch (ch.type) {
    case TOK.T_NAME:
      // All names start in Load context, but may be changed later
      return new Name(strobj(ch.value), Load, n.lineno, n.col_offset);
    case TOK.T_STRING:
      return new Str(parsestrplus(c, n), n.lineno, n.col_offset);
    case TOK.T_NUMBER:
      return new Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset);
    case TOK.T_LPAR:
      // various uses for parens
      ch = CHILD(n, 1);
      if (ch.type === TOK.T_RPAR) {
        return new Tuple([], Load, n.lineno, n.col_offset);
      }
      if (ch.type === SYM.yield_expr) {
        return astForExpr(c, ch);
      }
      //            if (NCH(ch) > 1 && CHILD(ch, 1).type === SYM.comp_for) {
      //                return astForComprehension(c, ch);
      //            }
      return astForTestlistComp(c, ch);
    case TOK.T_LSQB:
      // list or listcomp
      ch = CHILD(n, 1);
      if (ch.type === TOK.T_RSQB) {
        return new List([], Load, n.lineno, n.col_offset);
      }
      REQ(ch, SYM.listmaker);
      if (NCH(ch) === 1 || CHILD(ch, 1).type === TOK.T_COMMA) {
        return new List(seqForTestlist(c, ch), Load, n.lineno, n.col_offset);
      }
      return astForListcomp(c, ch);
    case TOK.T_LBRACE:
      /* dictorsetmaker:
       *     (test ':' test (comp_for : (',' test ':' test)* [','])) |
       *     (test (comp_for | (',' test)* [',']))
       */
      keys = [];
      values = [];
      ch = CHILD(n, 1);
      if (n.type === TOK.T_RBRACE) {
        //it's an empty dict
        return new Dict([], null, n.lineno, n.col_offset);
      } else if (NCH(ch) === 1 || NCH(ch) !== 0 && CHILD(ch, 1).type === TOK.T_COMMA) {
        //it's a simple set
        elts = [];
        size = Math.floor((NCH(ch) + 1) / 2);
        for (i = 0; i < NCH(ch); i += 2) {
          var expression = astForExpr(c, CHILD(ch, i));
          elts[i / 2] = expression;
        }
        return new Set(elts, n.lineno, n.col_offset);
      } else if (NCH(ch) !== 0 && CHILD(ch, 1).type == SYM.comp_for) {
        //it's a set comprehension
        return astForSetComp(c, ch);
      } else if (NCH(ch) > 3 && CHILD(ch, 3).type === SYM.comp_for) {
        //it's a dict compr. I think.
        return astForDictComp(c, ch);
      } else {
        size = Math.floor((NCH(ch) + 1) / 4); // + 1 for no trailing comma case
        for (i = 0; i < NCH(ch); i += 4) {
          keys[i / 4] = astForExpr(c, CHILD(ch, i));
          values[i / 4] = astForExpr(c, CHILD(ch, i + 2));
        }
        return new Dict(keys, values, n.lineno, n.col_offset);
      }
    case TOK.T_BACKQUOTE:
      //throw new Sk.builtin.SyntaxError("backquote not supported, use repr()", c.c_filename, n.lineno);
      return new Repr(astForTestlist(c, CHILD(n, 1)), n.lineno, n.col_offset);
    default:
      goog.asserts.fail("unhandled atom", ch.type);
  }
}
function astForPower(c, n) {
  /* power: atom trailer* ('**' factor)*
   */
  var f;
  var tmp;
  var ch;
  var i;
  var e;
  REQ(n, SYM.power);
  e = astForAtom(c, CHILD(n, 0));
  if (NCH(n) === 1) {
    return e;
  }
  for (i = 1; i < NCH(n); ++i) {
    ch = CHILD(n, i);
    if (ch.type !== SYM.trailer) {
      break;
    }
    tmp = astForTrailer(c, ch, e);
    tmp.lineno = e.lineno;
    tmp.col_offset = e.col_offset;
    e = tmp;
  }
  if (CHILD(n, NCH(n) - 1).type === SYM.factor) {
    f = astForExpr(c, CHILD(n, NCH(n) - 1));
    e = new BinOp(e, Pow, f, n.lineno, n.col_offset);
  }
  return e;
}
function astForExpr(c, n) {
  /* handle the full range of simple expressions
   test: or_test ['if' or_test 'else' test] | lambdef
   or_test: and_test ('or' and_test)*
   and_test: not_test ('and' not_test)*
   not_test: 'not' not_test | comparison
   comparison: expr (comp_op expr)*
   expr: xor_expr ('|' xor_expr)*
   xor_expr: and_expr ('^' and_expr)*
   and_expr: shift_expr ('&' shift_expr)*
   shift_expr: arith_expr (('<<'|'>>') arith_expr)*
   arith_expr: term (('+'|'-') term)*
   term: factor (('*'|'/'|'%'|'//') factor)*
   factor: ('+'|'-'|'~') factor | power
   power: atom trailer* ('**' factor)*
    As well as modified versions that exist for backward compatibility,
   to explicitly allow:
   [ x for x in lambda: 0, lambda: 1 ]
   (which would be ambiguous without these extra rules)
    old_test: or_test | old_lambdef
   old_lambdef: 'lambda' [vararglist] ':' old_test
    */

  var exp;
  var cmps;
  var ops;
  var i;
  var seq;
  LOOP: while (true) {
    switch (n.type) {
      case SYM.test:
      case SYM.old_test:
        if (CHILD(n, 0).type === SYM.lambdef || CHILD(n, 0).type === SYM.old_lambdef) {
          return astForLambdef(c, CHILD(n, 0));
        } else if (NCH(n) > 1) {
          return astForIfexpr(c, n);
        }
      // fallthrough
      case SYM.or_test:
      case SYM.and_test:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        }
        seq = [];
        for (i = 0; i < NCH(n); i += 2) {
          seq[i / 2] = astForExpr(c, CHILD(n, i));
        }
        if (CHILD(n, 1).value === "and") {
          return new BoolOp(And, seq, n.lineno, n.col_offset);
        }
        goog.asserts.assert(CHILD(n, 1).value === "or");
        return new BoolOp(Or, seq, n.lineno, n.col_offset);
      case SYM.not_test:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        } else {
          return new UnaryOp(Not, astForExpr(c, CHILD(n, 1)), n.lineno, n.col_offset);
        }
        break;
      case SYM.comparison:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        } else {
          ops = [];
          cmps = [];
          for (i = 1; i < NCH(n); i += 2) {
            ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));
            cmps[(i - 1) / 2] = astForExpr(c, CHILD(n, i + 1));
          }
          return new Compare(astForExpr(c, CHILD(n, 0)), ops, cmps, n.lineno, n.col_offset);
        }
        break;
      case SYM.expr:
      case SYM.xor_expr:
      case SYM.and_expr:
      case SYM.shift_expr:
      case SYM.arith_expr:
      case SYM.term:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        }
        return astForBinop(c, n);
      case SYM.yield_expr:
        exp = null;
        if (NCH(n) === 2) {
          exp = astForTestlist(c, CHILD(n, 1));
        }
        return new Yield(exp, n.lineno, n.col_offset);
      case SYM.factor:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        }
        return astForFactor(c, n);
      case SYM.power:
        return astForPower(c, n);
      default:
        goog.asserts.fail("unhandled expr", "n.type: %d", n.type);
    }
    break;
  }
}
function astForPrintStmt(c, n) {
  /* print_stmt: 'print' ( [ test (',' test)* [','] ]
   | '>>' test [ (',' test)+ [','] ] )
   */
  var nl;
  var i, j;
  var seq;
  var start = 1;
  var dest = null;
  REQ(n, SYM.print_stmt);
  if (NCH(n) >= 2 && CHILD(n, 1).type === TOK.T_RIGHTSHIFT) {
    dest = astForExpr(c, CHILD(n, 2));
    start = 4;
  }
  seq = [];
  for (i = start, j = 0; i < NCH(n); i += 2, ++j) {
    seq[j] = astForExpr(c, CHILD(n, i));
  }
  nl = CHILD(n, NCH(n) - 1).type === TOK.T_COMMA ? false : true;
  return new Print(dest, seq, nl, n.lineno, n.col_offset);
}
function astForStmt(c, n) {
  var ch;
  if (n.type === SYM.stmt) {
    goog.asserts.assert(NCH(n) === 1);
    n = CHILD(n, 0);
  }
  if (n.type === SYM.simple_stmt) {
    goog.asserts.assert(numStmts(n) === 1);
    n = CHILD(n, 0);
  }
  if (n.type === SYM.small_stmt) {
    REQ(n, SYM.small_stmt);
    n = CHILD(n, 0);
    /* small_stmt: expr_stmt | print_stmt  | del_stmt | pass_stmt
     | flow_stmt | import_stmt | global_stmt | exec_stmt
     | assert_stmt
     */
    switch (n.type) {
      case SYM.expr_stmt:
        return astForExprStmt(c, n);
      case SYM.print_stmt:
        return astForPrintStmt(c, n);
      case SYM.del_stmt:
        return astForDelStmt(c, n);
      case SYM.pass_stmt:
        return new Pass(n.lineno, n.col_offset);
      case SYM.flow_stmt:
        return astForFlowStmt(c, n);
      case SYM.import_stmt:
        return astForImportStmt(c, n);
      case SYM.global_stmt:
        return astForGlobalStmt(c, n);
      case SYM.exec_stmt:
        return astForExecStmt(c, n);
      case SYM.assert_stmt:
        return astForAssertStmt(c, n);
      case SYM.debugger_stmt:
        return new Debugger_(n.lineno, n.col_offset);
      default:
        goog.asserts.fail("unhandled small_stmt");
    }
  } else {
    /* compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt
     | funcdef | classdef | decorated
     */
    ch = CHILD(n, 0);
    REQ(n, SYM.compound_stmt);
    switch (ch.type) {
      case SYM.if_stmt:
        return astForIfStmt(c, ch);
      case SYM.while_stmt:
        return astForWhileStmt(c, ch);
      case SYM.for_stmt:
        return astForForStmt(c, ch);
      case SYM.try_stmt:
        return astForTryStmt(c, ch);
      case SYM.with_stmt:
        return astForWithStmt(c, ch);
      case SYM.funcdef:
        return astForFuncdef(c, ch, []);
      case SYM.classdef:
        return astForClassdef(c, ch, []);
      case SYM.decorated:
        return astForDecorated(c, ch);
      default:
        goog.asserts.assert("unhandled compound_stmt");
    }
  }
}
Sk.astFromParse = function (n, filename, c_flags) {
  var j;
  var num;
  var ch;
  var i;
  var c = new Compiling("utf-8", filename, c_flags);
  var stmts = [];
  var k = 0;
  switch (n.type) {
    case SYM.file_input:
      for (i = 0; i < NCH(n) - 1; ++i) {
        ch = CHILD(n, i);
        if (n.type === TOK.T_NEWLINE) {
          continue;
        }
        REQ(ch, SYM.stmt);
        num = numStmts(ch);
        if (num === 1) {
          stmts[k++] = astForStmt(c, ch);
        } else {
          ch = CHILD(ch, 0);
          REQ(ch, SYM.simple_stmt);
          for (j = 0; j < num; ++j) {
            stmts[k++] = astForStmt(c, CHILD(ch, j * 2));
          }
        }
      }
      return new Module(stmts);
    case SYM.eval_input:
      goog.asserts.fail("todo;");
    case SYM.single_input:
      goog.asserts.fail("todo;");
    default:
      goog.asserts.fail("todo;");
  }
};
Sk.astDump = function (node) {
  var spaces = function (n)
  // todo; blurgh
  {
    var i;
    var ret = "";
    for (i = 0; i < n; ++i) {
      ret += " ";
    }
    return ret;
  };
  var _format = function (node, indent) {
    var ret;
    var elemsstr;
    var x;
    var elems;
    var fieldstr;
    var field;
    var attrs;
    var fieldlen;
    var b;
    var a;
    var i;
    var fields;
    var namelen;
    if (node === null) {
      return indent + "None";
    } else if (node.prototype && node.prototype._astname !== undefined && node.prototype._isenum) {
      return indent + node.prototype._astname + "()";
    } else if (node._astname !== undefined) {
      namelen = spaces(node._astname.length + 1);
      fields = [];
      for (i = 0; i < node._fields.length; i += 2)
      // iter_fields
      {
        a = node._fields[i]; // field name
        b = node._fields[i + 1](node); // field getter func
        fieldlen = spaces(a.length + 1);
        fields.push([a, _format(b, indent + namelen + fieldlen)]);
      }
      attrs = [];
      for (i = 0; i < fields.length; ++i) {
        field = fields[i];
        attrs.push(field[0] + "=" + field[1].replace(/^\s+/, ""));
      }
      fieldstr = attrs.join(",\n" + indent + namelen);
      return indent + node._astname + "(" + fieldstr + ")";
    } else if (goog.isArrayLike(node)) {
      //Sk.debugout("arr", node.length);
      elems = [];
      for (i = 0; i < node.length; ++i) {
        x = node[i];
        elems.push(_format(x, indent + " "));
      }
      elemsstr = elems.join(",\n");
      return indent + "[" + elemsstr.replace(/^\s+/, "") + "]";
    } else {
      if (node === true) {
        ret = "True";
      } else if (node === false) {
        ret = "False";
      } else if (node instanceof Sk.builtin.lng) {
        ret = node.tp$str().v;
      } else if (node instanceof Sk.builtin.str) {
        ret = node["$r"]().v;
      } else {
        ret = "" + node;
      }
      return indent + ret;
    }
  };
  return _format(node, "");
};
goog.exportSymbol("Sk.astFromParse", Sk.astFromParse);
goog.exportSymbol("Sk.astDump", Sk.astDump);

/* ---- /Users/rob/skulpty/lib/afterword.js ---- */

function wrapAstThing(fx, argpos, debug) {
  argpos = argpos || 2;
  return function (x) {
    var n = arguments[argpos - 1];
    var result = fx.apply(undefined, arguments);
    result.range = n.range;
    result.str = n.str;
    result.loc = n.loc;
    if (debug) {
      console.log(n);
      console.log(result);
    }
    return result;
  };
}
astForAtom = wrapAstThing(astForAtom);
astForCompOp = wrapAstThing(astForCompOp);
astForSuite = wrapAstThing(astForSuite);
astForExceptClause = wrapAstThing(astForExceptClause);
astForDottedName = wrapAstThing(astForDottedName);
astForDecorator = wrapAstThing(astForDecorator);
astForDecorators = wrapAstThing(astForDecorators);
astForDecorated = wrapAstThing(astForDecorated);
astForWithVar = wrapAstThing(astForWithVar);
astForWithStmt = wrapAstThing(astForWithStmt);
astForExecStmt = wrapAstThing(astForExecStmt);
astForIfStmt = wrapAstThing(astForIfStmt);
astForExprlist = wrapAstThing(astForExprlist);
astForDelStmt = wrapAstThing(astForDelStmt);
astForGlobalStmt = wrapAstThing(astForGlobalStmt);
astForAssertStmt = wrapAstThing(astForAssertStmt);
astForImportStmt = wrapAstThing(astForImportStmt);
astForTestlistComp = wrapAstThing(astForTestlistComp);
astForListcomp = wrapAstThing(astForListcomp);
astForFactor = wrapAstThing(astForFactor);
astForForStmt = wrapAstThing(astForForStmt);
astForTrailer = wrapAstThing(astForTrailer);
astForFlowStmt = wrapAstThing(astForFlowStmt);
astForArguments = wrapAstThing(astForArguments);
astForFuncdef = wrapAstThing(astForFuncdef);
astForClassBases = wrapAstThing(astForClassBases);
astForClassdef = wrapAstThing(astForClassdef);
astForLambdef = wrapAstThing(astForLambdef);
astForComprehension = wrapAstThing(astForComprehension);
astForIterComp = wrapAstThing(astForIterComp);
astForDictComp = wrapAstThing(astForDictComp);
astForGenExpr = wrapAstThing(astForGenExpr);
astForSetComp = wrapAstThing(astForSetComp);
astForWhileStmt = wrapAstThing(astForWhileStmt);
astForAugassign = wrapAstThing(astForAugassign);
astForBinop = wrapAstThing(astForBinop);
astForTestlist = wrapAstThing(astForTestlist);
astForExprStmt = wrapAstThing(astForExprStmt);
astForIfexpr = wrapAstThing(astForIfexpr);
astForExpr = wrapAstThing(astForExpr);
Sk.astFromParse = wrapAstThing(Sk.astFromParse, 1);
Sk.nameForToken = function (v) {
  if (typeof v === "string") return v;
  for (var name in Sk.Tokenizer.Tokens) {
    if (Sk.Tokenizer.Tokens[name] == v) return name;
  }
  if (v in Sk.ParseTables.number2symbol) {
    return Sk.ParseTables.number2symbol[v];
  }
  return '???:' + v;
};

//Sk.python3 = true;
Sk.Parser = Parser;
Sk.builtin.str.prototype.valueOf = function () {
  return this.v;
};
Sk.builtin.str.prototype.toString = function () {
  return this.v;
};
Sk.builtin.SyntaxError = function (str, file, line, ctx, extra) {
  var err = new SyntaxError(str, file, line);
  err.context = ctx;
  err.extra = extra;
  err.line = line;
  return err;
};
Sk.builtin.IndentationError = function (str, file, line, row, extra) {
  var err = new SyntaxError('Indentation Error: ' + str, file, line);
  err.context = [[line, row], [line, row]];
  err.extra = {};
  err.line = line;
  return err;
};

// module.exports = Sk;

// var Sk = require('../lib/skulpt.js');
// var transform = require('./transform.js');
// var improveError = require('./errors.js');

// 'use strict';

// var Sk = require('../lib/skulpt.js');

function splat(e) {
  console.log("GOT ERROR!");
  console.log(e, e.extra);
  console.log(JSON.stringify(e.extra.node, function (k, o) {
    if (k == 'type') return Sk.nameForToken(o);else if (k == 'children') return o;else if (k === '') return o;else if (!isNaN(parseInt(k))) return o;else return undefined;
  }, '  '));
}
function improveError(e, options, code) {
  var r;
  if (e.context && e.context.length > 0) {
    r = e.context[0];
  }
  if (e.extra && e.extra.node) {
    if (!r) {
      r = [e.extra.node.loc.start.line, e.extra.node.loc.start.column];
    }
  }
  if (r) {
    setErrorPos(e, r[0], r[1]);
  }
  if (options.friendlyErrors && e.extra) {
    e.message = makeErrorFriendly(e, code);
  }
}
function setErrorPos(e, line, col) {
  e.loc = {
    line: line,
    column: col
  };
  e.line = line;
  e.column = col;
}
function friendlyString(s) {
  switch (s) {
    case 'if_stmt':
      return 'if statement';
    case 'while_stmt':
      return 'while statement';
    case 'funcdef':
      return 'function';
    default:
      return '?' + s + '?';
  }
}
function nodeToType(n) {
  var type = Sk.nameForToken(n.type);
  if (type === 'suite') return nodeToType(n.children[0]);
  return friendlyString(type);
}
function makeErrorFriendly(e, code) {
  //console.log("EX", e.message, e.extra);
  if (e.extra.kind == "DAG_MISS") {
    if (e.extra.expected.indexOf('T_COLON') !== -1) {
      //We might be missing a colon.
      var after = (e.context && e.context[2] ? e.context[2] : e.extra.found_val).replace(/\s+$/, '');
      var lc = e.extra.node.children[e.extra.node.children.length - 1];
      if (lc.value === 'else') after = 'else';
      if (e.extra.found == 'T_SEMI') {
        return "Replace the `;` at the end of `" + after + "` with a `:`";
      } else if (e.extra.found == 'T_NEWLINE') {
        return "Need a `:` on the end of the line following `" + after + "`.";
      } else if (e.extra.found == 'T_NAME') {
        return "Need a `:` after `" + after + "`.";
      } else if (e.extra.found == 'T_EQUAL') {
        return "Can't assign to a variable within the condition of an " + friendlyString(e.extra.inside) + ".  Did you mean to use `==` instead of `=`?";
      }
    }
    if (e.extra.expected.indexOf('T_DEDENT') !== -1) {
      if (e.extra.found_val.toLowerCase() === 'else') {
        return "`else` needs to line up with its `if`.";
      } else {
        return "Indentation error.";
      }
    }
    if (e.extra.expected.indexOf('T_INDENT') !== -1) {
      var lc = e.extra.parent || e.extra.node;
      var name = nodeToType(lc);
      if (name === 'if statement') {
        //Scan for the most recent part of the ifstatement.
        for (var i = 0; i < lc.children.length; ++i) {
          if (["if", "elif", "else"].indexOf(lc.children[i].value) !== -1) {
            name = lc.children[i].value + ' statement';
          }
        }
      }
      if (lc.value === 'else') name = 'else statement';
      return 'Empty ' + name + '. Put 4 spaces in front of statements inside the ' + name + '.';
    }
    if (e.extra.found === 'T_NAME') {
      switch (e.extra.found_val) {
        case 'else':
        case 'elif':
          return '`' + e.extra.found_val + '` must be paired with an `if`';
        case 'elseif':
          return '`elseif` should be shortened to `elif`';
      }
    }
    if (e.extra.found === 'T_AMPER' && e.extra.inside == 'and_expr') {
      return 'Python uses the word `and` instead of `&&` for boolean AND expressions.';
    }
    if (e.extra.inside === 'trailer') {
      //We are parsing either an arglist or a subscript.
      if (e.extra.expected.indexOf('T_RPAR') === 0) {
        //Expected ), must be a arglsit;
        if (e.line > e.extra.node.lineno) {
          //Our arglist is incomplete, and we have made it to the next line,.
          //Likely they just forgot to close their ()'s
          setErrorPos(e, e.extra.node.lineno, e.extra.node.col_offset);
          var t = e.extra.node.loc;
          e.context = [[t.start.line, t.start.column], [t.end.line, t.end.column]];
          return 'Unclosed `(` in function arguments.' + e.extra.node.lineno;
        }
        return 'Function calls paramaters must be seperated by `,`s';
      }
    }
    if (e.extra.found === 'T_INDENT') {
      if (e.extra.expected.indexOf('stmt') !== -1) {
        return 'Too much indentation at the beginning of this line.';
      }
    }
    if (e.extra.expected.indexOf('subscriptlist') === 0) {
      return "Malformed subscript";
    }
    if (e.extra.expected.indexOf('T_NEWLINE') !== -1) {
      var n = e.extra.node;
      if (e.extra.node.children[0]) {
        var n = e.extra.node.children[0];
        var previousType = Sk.nameForToken(n.type);
        if (previousType == 'small_stmt') {
          while (n.children && n.children.length == 1) n = n.children[0];
          var what = code.substring(n.range[0], n.range[1]);
          return 'If you want to call `' + what + '` as function, you need `()`\'s';
        }
      }
    }
    return 'Unexpected token: ' + e.message;
  } else if (e.extra.kind == "CLASSIFY") {
    if (e.extra.value === '"') return 'Unterminated string. Add a matching `"` at the end of your string.';
    return 'Unterminated `' + e.extra.value + '`';
  } else if (e.extra.kind == "STRING_EOF") {
    return 'Unterminated muti-line string. Add a matching `"""` at the end of your string.';
  } else if (e.extra.kind == "STATEMENT_EOF") {
    if (e.extra.parenlev > 0) {
      var top = e.extra.parenstack[e.extra.parenstack.length - 1];
      var kind = top[0];
      var types = '([{';
      var pair = ')]}';
      var close = pair[types.indexOf(kind)];
      setErrorPos(e, top[1], top[2] - 1);
      return 'Unmatched `' + kind + '`.  Every opening `' + kind + '` needs a closing `' + close + '` to match it.';
    }
    return e.message;
  }
  return e.message;
}

//module.exports = improveError;

var defaultOptions = {
  locations: true,
  ranges: true,
  sippets: true,
  filename: 'file.py',
  useLet: false,
  friendlyErrors: true
};
function rangeToLoc(x, offsets) {
  var best = -1;
  for (var i = 0; i < offsets.length; ++i) {
    if (offsets[i] > x) break;
    best = i;
  }
  var off = best >= 0 ? offsets[best] : 0;
  return {
    line: best + 2,
    column: x - off,
    pos: x
  };
}
function locToRange(line, col, offsets) {
  var loff = 0;
  if (line >= 2 && line - 2 < offsets.length) loff = offsets[line - 2];
  return loff + col;
}
function decorate(n, code, offsets, options) {
  var numrange = locToRange(n.lineno, n.col_offset, offsets);
  var range = [numrange === numrange ? numrange : Infinity, numrange === numrange ? numrange : -Infinity];
  if (n.value) range[1] += n.value.length;
  if (n.children) for (var i = 0; i < n.children.length; ++i) {
    var r = decorate(n.children[i], code, offsets, options);
    range[0] = Math.min(range[0], r[0]);
    range[1] = Math.max(range[1], r[1]);
  }
  if (options.ranges) n.range = range;
  if (options.locations) {
    n.loc = {
      start: rangeToLoc(range[0], offsets),
      end: rangeToLoc(range[1], offsets)
    };
  }
  if (options.snippets) n.str = code.substring(range[0], range[1]);
  return range;
}
function parser(code, options) {
  var lineOffsets = [];
  var idx = -1;
  var parse, ast;
  options = options || {};
  for (var opt in defaultOptions) {
    if (!(opt in options)) options[opt] = defaultOptions[opt];
  }
  while (true) {
    idx = code.indexOf("\n", idx + 1);
    if (idx < 0) break;
    lineOffsets.push(idx + 1);
  }
  try {
    parse = Sk.parse(options.filename, code);
    decorate(parse.cst, code, lineOffsets, options);
    parse.flags = parse.flags | Sk.Parser.CO_FUTURE_UNICODE_LITERALS; //Enable future unicode literals
    ast = Sk.astFromParse(parse.cst, options.filename, parse.flags);
  } catch (e) {
    if (e.extra && e.extra.node) decorate(e.extra.node, code, lineOffsets, options);
    improveError(e, options, code);
    if (e.loc) {
      e.pos = locToRange(e.loc.line, e.loc.column, lineOffsets);
    }
    throw e;
  }

  //console.log(JSON.stringify(ast, null, "  "));
  var ctx = {
    varType: options.useLet ? 'let' : 'var'
  };
  var js = transform(ast, ctx);
  return js;
}

// module.exports = {
// 	parse: parser,
// 	pythonRuntime: require('../lib/stdlib.js'),
// 	defaultOptions: {runtimeParamName: '__pythonRuntime'}
// };

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cppWriter = cppWriter;
var ir = _interopRequireWildcard(require("./IR.js"));
var _std = require("./templates/std.js");
var _blit = require("./templates/blit.js");
var _pico = require("./templates/pico.js");
var _galuni = require("./templates/galuni.js");
var _pokitto = require("./templates/pokitto.js");
var _meta = require("./templates/meta.js");
var _espboy = require("./templates/espboy.js");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const platform = {
  std: _std.std,
  blit: _blit.blit,
  pico: _pico.pico,
  galuni: _galuni.galuni,
  pokitto: _pokitto.pokitto,
  espboy: _espboy.espboy,
  meta: _meta.meta
};
const binOpName = {
  "+": "add",
  "-": "sub",
  "*": "mul",
  "%": "mod",
  "/": "div",
  "<": "lt",
  "<=": "leq",
  ">": "gt",
  ">=": "geq",
  "!=": "neq",
  "==": "eq",
  "===": "seq",
  "!==": "sneq",
  "|": "or",
  "&": "and",
  "^": "xor",
  "<<": "shl",
  ">>": "shr",
  ">>>": "sru",
  "N": "next",
  "n": "kai",
  "in": "in",
  "+=": "add",
  "-=": "sub",
  "*=": "mul",
  "%=": "mod",
  "/=": "div",
  "|=": "or",
  "&=": "and",
  "^=": "xor",
  "<<=": "shl",
  ">>=": "shr",
  ">>>=": "sru"
};
let cpp;
function literalToString(value, reg) {
  let ret = value + '';
  let pos = -1;
  if (typeof value == 'string' || reg) {
    pos = cpp.stringTable.indexOf(ret);
    if (pos == -1) {
      pos = cpp.stringTable.length;
      cpp.stringTable.push(ret);
    }
    ret = `js::BufferRef{stringTable[${pos}]}`;
  } else if (value === null) {
    ret = '(js::Object*){}';
  } else if ((value | 0) != value) {
    ret = `js::Float(${ret}f)`;
  } else {
    ret = `int32_t(${ret})`;
  }
  if (reg) {
    let safe = "V_" + (value + '').replace(/([^a-zA-Z_0-9])/g, (_, ch) => ch.charCodeAt(0));
    if (!(safe in cpp.minStringTable)) {
      cpp.minStringTable[safe] = ret;
    }
    ret = safe;
  }
  return ret;
}
function local(node) {
  // if (node instanceof ir.Literal)
  //     return `${encode(node)}`;
  return encode(node);
}
function encode(node, write) {
  switch (node.constructor.name) {
    case "Method":
      if (node.isNative) return node.isNative;
    // if (node.captures)
    //     node = node.parent.method.capturers[node.id].ctx; // cpp.method.capturers[node.id].ctx;

    case "Var":
      if (cpp.globals[node.id]) return node.name;
      return node.hasCTV && !write ? `${literalToString(node.CTV)}/*${node.name}*/` : node.name ? `_${node.id}/*${node.name}*/` : `_${node.id}`;
    case "Literal":
      return literalToString(node.value);
    case "LookUp":
      const ctx = node.container || node.parent;
      if (ctx instanceof ir.Var) {
        ctx.read++;
        if (node.variable instanceof ir.Literal) {
          ctx.addDeref(node.variable.value);
          if (ctx == cpp.program.resources) {
            if (!(node.variable.value in cpp.program.resourceData)) throw `No resource named ${node.variable.value}`;
            return `RESOURCEREF(${node.variable.value})`;
          }
        }
        return `js::get(${encode(ctx, true)}, ${encode(node.variable, false)})`;
      } else if (ctx instanceof ir.Scope) {
        if (node.variable === "undefined") return 'js::Undefined::Undefined';
        const child = ctx.find(node.variable, true);
        if (!child) throw `No variable named ${JSON.stringify(node)}`;
        return encode(child, write);
      }
  }
  return node.constructor.name;
}
class CPP {
  constructor() {
    this.minStringTable = {};
    this.globals = {};
    this.stringTable = [];
    this.header = [];
    this.out = [];
    this.method = null;
    this.indent = 0;
    this.stack = [];
    this.main = null;
    this.program = null;
    cpp = this;
    ["", "buffer", "length", "__proto__", "this", "undefined", "[Object]", "[Resource]", "[Array]", "[Function]", "null", "true", "false", "this", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "//new", "//method"].forEach(str => literalToString(str, true));
  }
  error(msg, location) {
    throw new ir.Error(msg, location);
  }
  write(node) {
    const writer = this[node.constructor.name];
    if (!writer) {
      this.error("No writer for " + node.constructor.name, node.location);
    } else {
      // this.stack.forEach((e, i) => console.log(i + ") " + JSON.stringify(e)));
      // console.log(node.constructor.name);
      return writer.call(this, node);
    }
  }
  Program(node) {
    cpp = this;
    this.program = node;
    this.main = node.main;
    this.out.push(this.write(node.main));
    this.writeStringTable();
  }
  writeStringTable() {
    this.out.unshift(['', `js::Buffer* const stringTable[] = `, `{`, this.stringTable.map((s, index) => `(js::Buffer*) _str${index}.data()`).join(",\n  "), `};`, '', `const uint32_t stringTableSize = ${this.stringTable.length};`, '']);
    this.out.unshift([this.stringTable.map((s, index) => {
      let str = JSON.stringify(s);
      let size = s.length + 1;
      return `STRDECL(_str${index}, ${size}, ${str});`;
    })]);
  }
  Inline(node) {
    if (node.backend === "cpp") {
      if (node.target == "inline") {
        return node.code;
      }
      if (node.target == "header") {
        this.header.push(node.code);
      }
    }
  }
  Break(node) {
    return `goto ${node.target.label('failEnter')}; // break`;
  }
  Continue(node) {
    return `goto ${node.target.label('preLoop')}; // continue`;
  }
  Return(node) {
    return [this.Deref(), node.hasValue ? `return {${encode(this.stack.pop())}};` : `return {};`];
  }
  Method(node) {
    this.out.unshift(`js::Local ${encode(node, true)}(js::Local&, bool);`);
    if (node.isNative) return;
    const oldMethod = this.method;
    this.method = node;
    const method = ['', `js::Local ${encode(node, true)}(js::Local& ${encode(node.args, true)}, bool isNew)`];
    this.out.push(method);
    method.push(this.Scope(node, true));
    this.method = oldMethod;
  }
  declare(v) {
    return v.kind == "capture" ? `js::Tagged& ${encode(v, true)} = *js::getTaggedPtr(js::to<js::Object*>(${encode(this.method.args)}), ${literalToString(v.name, true)}, true);` : v.kind == "cache" ? `js::Tagged& ${encode(v, true)} = *js::getTaggedPtr(${encode(this.method.index["this"])}.object(), ${literalToString(v.name, true)}, true, true);` : v.isCaptured() ? `js::Tagged& ${encode(v, true)} = *js::set(${encode(this.method.context)}, ${literalToString(v.name, true)}, {});` : v.kind == "const" && v.hasCTV ? `// const ${encode(v, true)} = ${encode(v)};` : v.declType == "int32_t" ? `int32_t ${encode(v, true)}; // ${v.kind}` : v.declType == "uint32_t" ? `uint32_t ${encode(v, true)}; // ${v.kind}` : v.declType == "Float" ? `js::Float ${encode(v, true)}; // ${v.kind}` : v.declType == "string" ? `js::BufferRef ${encode(v, true)}; // ${v.kind}` : `js::Local ${encode(v, true)}; // ${v.kind} ${v.declType}`;
  }
  Scope(node, endWithReturn) {
    const decls = [];
    const setup = [];
    const before = [`// begin ${node.debug}`, node.transparent ? '' : '{', setup, decls];
    const after = [node.transparent ? '' : '}', `// end ${node.debug}`];
    const children = [];
    node.children.forEach(child => {
      if (!(child instanceof ir.Method)) children.push(this.write(child));
    });
    node.children.forEach(child => {
      if (child instanceof ir.Method) children.push(this.write(child));
    });
    if (endWithReturn) {
      const lastChild = node.children[node.children.length - 1];
      let hasReturn = lastChild && lastChild instanceof ir.Return;
      if (!hasReturn) {
        children.push(`return {};`);
      }
    }
    if (node.preEnter) {
      before.push(this.Scope(node.preEnter, false));
    }
    if (node.loopCondition) {
      // while, do/while, for
      const enterCondition = node.label('enterCondition');
      const failEnter = node.label('failEnter');
      const preLoop = node.label('preLoop');
      before.push(enterCondition + ':;');
      if (node.enterCondition) {
        before.push(this.write(node.enterCondition));
        before.push(this.Deref());
        before.push(`if (!js::to<bool>(${encode(this.stack.pop())})) goto ${failEnter};`);
      }
      if (node.hasContinue) children.push(preLoop + ':;');
      if (node.preLoop) {
        children.push(this.write(node.preLoop));
        this.stack.pop();
      }
      if (node.loopCondition && node.loopCondition.children[0]) {
        let firstChild = node.loopCondition.children[0];
        if (firstChild instanceof ir.Literal && firstChild.value) {
          children.push(`goto ${enterCondition};`);
        } else if (firstChild instanceof ir.Literal && !firstChild.value) {} else {
          children.push(this.write(node.loopCondition));
          children.push(`if (js::to<bool>(${encode(this.stack.pop())})) goto ${enterCondition};`);
        }
      }
      after.unshift(failEnter + ':;');
    } else {
      // if, block
      if (node.enterCondition) {
        before.push(this.write(node.enterCondition));
        before.push(this.Deref());
        const failEnter = node.label('failEnter');
        before.push(`if (!js::to<bool>(${encode(this.stack.pop())})) goto ${failEnter};`);
        if (node.failEnter) {
          let afterFail = node.label('afterFail');
          after.unshift([`goto ${afterFail};`, failEnter + ':;', this.write(node.failEnter), afterFail + ':;']);
        } else {
          after.push(failEnter + ':;');
        }
      }
    }
    const varindex = {};
    varindex[node.method.args.id] = node.method.args;
    if (node.context) {
      varindex[node.context.id] = node.context;
      setup.push(this.declare(node.context));
      setup.push(`${encode(node.context, true)} = js::alloc(${Object.keys(node.captured).length});`);
      for (let capture of Object.values(node.capturers)) {
        varindex[capture.ctx.id] = capture.ctx;
        const strcaptures = encode(capture.capturer, true);
        setup.push(`js::Local ${strcaptures} = js::alloc(1, ${encode(node.context)});`);
        setup.push(`js::set(${strcaptures}, V_4747method, ::${encode(capture.capturer)});`);
      }
    }
    if (node.that) {
      setup.unshift(`PROFILER_NAMED("${this.method.name}");`);
      const that = node.that;
      varindex[that.id] = that;
      if (that.read || that.write) {
        setup.push(this.declare(that));
        decls.push(`js::initThis(${encode(that)}, ${encode(node.args)}, ${node.guessObjectSize()}, isNew);`);
      }
    }
    const locals = node.index;
    for (let key in locals) {
      let v = locals[key];
      if (v.id in varindex || !(v instanceof ir.Var)) continue;
      varindex[v.id] = v;
      let decl = this.declare(v);
      if (v.kind != "const") v.hasCTV = false;
      if (node == this.main && v.name) {
        this.out.unshift(decl);
      } else {
        decls.push(decl);
      }
    }
    return [before, children, after];
  }
  LookUp(node) {
    this.stack.push(node);
  }
  Literal(node) {
    this.stack.push(node);
  }
  Deref() {
    const lookup = this.stack.pop();
    if (lookup instanceof ir.LookUp) {
      const ctx = lookup.container || lookup.parent;
      if (ctx === this.method.that && lookup.variable instanceof ir.Literal) {
        ctx.read++;
        this.stack.push(this.method.cached(lookup.variable.value));
      } else if (ctx instanceof ir.Var || ctx instanceof ir.Literal) {
        const variable = new ir.Var();
        this.method.add(variable);
        this.stack.push(variable);
        return `${encode(variable, true)} = ${encode(lookup)};`;
      } else if (ctx instanceof ir.Scope) {
        const variable = ctx.find(lookup.variable, true);
        if (!variable) this.error(`ReferenceError: ${lookup.variable} is not defined`, lookup.location);
        this.stack.push(variable);
        if (variable instanceof ir.Method) return this.Deref();
        return;
      } else {
        this.error('Null context in lookup');
      }
    } else {
      this.stack.push(lookup);
      return;
    }
  }
  Pop() {
    this.stack.pop();
  }
  AssignmentExpression(node) {
    let right = this.stack.pop();
    if (!right) this.error(`Missing right-hand side for ${node.operator}`);
    const lookup = this.stack.pop();
    if (!lookup) this.error(`Missing left-hand side for ${node.operator}${encode(right, true)}`);
    if (!(lookup instanceof ir.LookUp)) this.error(`Invalid assignment left-hand side ${encode(lookup, true)}`);
    const ctx = lookup.container || lookup.parent;
    let ret = [];
    if (node.operator != "=") {
      this.stack.push(lookup);
      ret.push(this.Deref());
      this.stack.push(right);
      ret.push(this.BinaryExpression(node));
      right = this.stack.pop();
    }
    if (ctx instanceof ir.Var) {
      ctx.read++;
      if (lookup.variable instanceof ir.Literal) {
        ctx.addDeref(lookup.variable.value);
        if (ctx == this.method.that) {
          ctx.read++;
          let v = this.method.cached(lookup.variable.value);
          // v.setType(right.declType || right.type);
          ret.push(`${encode(v, true)} = ${encode(right)};`);
          ret.push(`if (auto obj = std::get_if<js::Object*>(&${encode(v)}); obj && *obj) (*obj)->setMark();`);
        } else {
          ret.push(`js::set(${encode(ctx, true)}, ${encode(lookup.variable)}, ${encode(right)});`);
        }
      } else {
        ret.push(`js::set(${encode(ctx, true)}, ${encode(lookup.variable)}, ${encode(right)});`);
      }
    } else if (ctx instanceof ir.Scope) {
      let v = ctx.find(lookup.variable, true, true);
      if (!v) this.error(`Variable ${lookup.variable} not defined`);
      if (v.kind == "const") {
        v.setDeclType(right.type);
        if (right.hasCTV) {
          v.CTV = right.CTV;
        }
      }
      if (v.kind != "const" || !right.hasCTV) {
        ret.push(`${encode(v, true)} = ${encode(right)};`);
      } else {
        ret.push(`// const ${encode(v, true)} = ${encode(right)};`);
      }
      v.write++;
    }
    this.stack.push(right);
    return ret; // `// assign ${lookup.variable} ${node.operator} ${right.constructor.name}`;
  }

  UnaryExpression(node) {
    const lookup = this.stack.pop();
    const opName = {
      true: {
        "++": "preinc",
        "--": "predec",
        "!": "not",
        "~": "bitnot",
        "-": "neg",
        "+": "pos"
      },
      false: {
        "++": "inc",
        "--": "dec"
      }
    }[node.prefix === false ? false : true][node.operator];
    let tmp = new ir.Var();
    if (opName == "bitnot") {
      if (lookup.hasCTV) {
        tmp = new ir.Literal(~lookup.value);
      } else {
        tmp.setDeclType("int32_t");
      }
    } else if (opName == "not") {
      if (lookup.hasCTV) {
        tmp = new ir.Literal(!lookup.value);
      } else {
        tmp.setDeclType("bool");
      }
    } else if (opName == "neg") {
      if (lookup.hasCTV) {
        tmp = new ir.Literal(-lookup.value);
      } else {
        tmp.setDeclType("Float");
      }
    } else {
      tmp.setDeclType("Float");
    }
    this.stack.push(tmp);
    if (tmp instanceof ir.Var) {
      node.parent.method.add(tmp);
      let ret = `js::op_${opName}(${encode(tmp, true)}, ${encode(lookup)}); // ${node.operator}`;
      lookup.type = tmp.type;
      return ret;
    }
  }
  BinaryExpression(node) {
    let out = [];
    const right = this.stack.pop();
    out.push(this.Deref());
    const left = this.stack.pop();
    switch (node.operator) {
      case ".":
      case "[]":
        const lookup = new ir.LookUp(right);
        lookup.container = left;
        this.stack.push(lookup);
        return out;
    }
    let tmp = new ir.Var();
    const op = binOpName[node.operator] || node.operator;
    switch (op) {
      case "add":
        // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  + ", right.hasCTV, right.name, "(", right.CTV, ")");

        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV + right.CTV);
        } else {
          tmp.hasCTV = false;
          if (left.declType == "Object*" || right.declType == "Object*" || !left.declType || !right.declType) {
            // tmp.setDeclType("js::Local");
          } else if (left.declType == "string" || right.declType == "string") {
            tmp.setDeclType("string");
          } else if (left.declType == "Undefined" || right.declType == "Undefined") {
            tmp.setDeclType("Undefined");
          } else if (left.declType == "Float" || right.declType == "Float") {
            tmp.setDeclType("Float");
          } else {
            tmp.setDeclType("int32_t");
          }
        }
        break;
      case "sub":
        // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  - ", right.hasCTV, right.name, "(", right.CTV, ")");

        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV - right.CTV);
        } else {
          tmp.hasCTV = false;
          if (left.declType == "int32_t" && right.declType == "int32_t") {
            tmp.setDeclType("int32_t");
          } else if (left.declType == "uint32_t" && right.declType == "uint32_t") {
            tmp.setDeclType("uint32_t");
          } else {
            tmp.setDeclType("Float");
          }
        }
        break;
      case "mul":
        // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  * ", right.hasCTV, right.name, "(", right.CTV, ")");

        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV * right.CTV);
        } else {
          tmp.hasCTV = false;
          if (left.declType == "int32_t" && right.declType == "int32_t") {
            tmp.setDeclType("int32_t");
          } else if (left.declType == "uint32_t" && right.declType == "uint32_t") {
            tmp.setDeclType("uint32_t");
          } else {
            tmp.setDeclType("Float");
          }
        }
        break;
      case "mod":
        // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  - ", right.hasCTV, right.name, "(", right.CTV, ")");

        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV % right.CTV);
        } else {
          tmp.hasCTV = false;
          if (left.declType == "int32_t" && right.declType == "int32_t") {
            tmp.setDeclType("int32_t");
          } else if (left.declType == "uint32_t" && right.declType == "uint32_t") {
            tmp.setDeclType("uint32_t");
          } else {
            tmp.setDeclType("Float");
          }
        }
        break;
      case "div":
        // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  - ", right.hasCTV, right.name, "(", right.CTV, ")");

        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV / right.CTV);
        } else {
          tmp.hasCTV = false;
          if (left.declType == "int32_t" && right.declType == "int32_t") {
            tmp.setDeclType("int32_t");
          } else if (left.declType == "uint32_t" && right.declType == "uint32_t") {
            tmp.setDeclType("uint32_t");
          } else {
            tmp.setDeclType("Float");
          }
        }
        break;
      case "next":
        tmp.setDeclType("int32_t");
        break;
      case "kai":
        break;
      case "lt":
        tmp.setDeclType("int32_t");
        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV < right.CTV);
        }
        break;
      case "leq":
        tmp.setDeclType("int32_t");
        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV <= right.CTV);
        }
        break;
      case "gt":
        tmp.setDeclType("int32_t");
        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV > right.CTV);
        }
        break;
      case "geq":
        tmp.setDeclType("int32_t");
        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV >= right.CTV);
        }
        break;
      case "neq":
        tmp.setDeclType("int32_t");
        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV != right.CTV);
        }
        break;
      case "eq":
        tmp.setDeclType("int32_t");
        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV == right.CTV);
        }
        break;
      case "seq":
        tmp.setDeclType("int32_t");
        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV === right.CTV);
        }
        break;
      case "sneq":
        tmp.setDeclType("int32_t");
        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV !== right.CTV);
        }
        break;
      case "in":
        tmp.setDeclType("int32_t");
        break;
      case "or":
        // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  | ", right.hasCTV, right.name, "(", right.CTV, ")");

        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV | right.CTV);
        } else {
          tmp.setDeclType("int32_t");
        }
        break;
      case "and":
        // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  | ", right.hasCTV, right.name, "(", right.CTV, ")");

        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV & right.CTV);
        } else {
          tmp.setDeclType("int32_t");
        }
        break;
      case "xor":
        // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  ^ ", right.hasCTV, right.name, "(", right.CTV, ")");

        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV ^ right.CTV);
        } else {
          tmp.setDeclType("int32_t");
        }
        break;
      case "shl":
        // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  | ", right.hasCTV, right.name, "(", right.CTV, ")");

        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV << right.CTV);
        } else {
          tmp.setDeclType("int32_t");
        }
        break;
      case "shr":
        // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  | ", right.hasCTV, right.name, "(", right.CTV, ")");

        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV >> right.CTV);
        } else {
          tmp.setDeclType("int32_t");
        }
        break;
      case "sru":
        // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  | ", right.hasCTV, right.name, "(", right.CTV, ")");

        if (left.hasCTV && right.hasCTV) {
          tmp = new ir.Literal(left.CTV >>> right.CTV);
        } else {
          tmp.setDeclType("int32_t");
        }
        break;
    }
    node.parent.add(tmp);
    this.stack.push(tmp);
    if (tmp instanceof ir.Var) {
      tmp.write++;
      out.push(`js::op_${op}(${encode(tmp, true)}, ${encode(left)}, ${encode(right)});`);
    }
    return out;
  }
  Array(node) {
    const array = new ir.Var();
    array.setDeclType("Object*");
    this.method.add(array);
    array.write++;
    const out = [];
    const values = [];
    const strarray = encode(array);
    out.push(`${strarray} = js::arguments(${node.length});`);
    out.push(values);
    for (let i = 0; i < node.length; ++i) {
      values[node.length - i - 1] = `js::set(${strarray}, ${literalToString(node.length - i - 1, true)}, ${encode(this.stack.pop())});`;
    }
    this.stack.push(array);
    return out;
  }
  Objekt(node) {
    const obj = new ir.Var();
    obj.setDeclType("Object*");
    this.method.add(obj);
    obj.write++;
    const out = [];
    const values = [];
    const strobj = encode(obj);
    out.push(`${strobj} = js::alloc(${node.length});`);
    out.push(values);
    for (let i = 0; i < node.length; ++i) {
      let value = this.stack.pop();
      let key = this.stack.pop();
      if (key instanceof ir.LookUp) key = key.variable;else if (key instanceof ir.Literal) key = key.value;
      values[node.length - i - 1] = `js::set(${strobj}, ${literalToString(key, true)}, ${encode(value)});`;
    }
    this.stack.push(obj);
    return out;
  }
  CallExpression(node) {
    if (node.isForward) {
      const calleeLU = this.stack.pop();
      const strcallee = encode(calleeLU, true);
      return `js::call(${strcallee}, ${encode(this.method.args)});`;
    }
    var args = this.method.temporaries.pop();
    if (!args) {
      args = new ir.Var();
      this.method.add(args);
    }
    var ret;
    if (!node.discardResult) {
      ret = new ir.Var();
      ret.hasCTV = false;
      this.method.add(ret);
    }
    const argv = [];
    const strargs = encode(args, true);
    for (let i = 0; i < node.argc; ++i) {
      argv[node.argc - i - 1] = `js::set(${strargs}, ${literalToString(node.argc - i - 1, true)}, ${encode(this.stack.pop())});`;
    }
    const calleeLU = this.stack.pop();
    this.stack.push(calleeLU);
    argv.push(this.Deref());
    let argc = node.argc;
    const callee = this.stack.pop();
    const strcallee = encode(callee, true);
    if (node.isNew) {
      argc++;
    } else if (calleeLU.container) {
      argv.push(`js::set(${strargs}, V_this, ${encode(calleeLU.container)});`);
      argc++;
    }
    this.stack.push(ret);
    this.method.temporaries.push(args);
    const assign = ret ? `${encode(ret, true)} = ` : '';
    return [`${strargs} = js::arguments(${argc});`, argv, callee instanceof ir.Method && !node.isNew ? `${assign}${strcallee}(${strargs}, false);` : `${assign}js::${node.isNew ? 'create' : 'call'}(${strcallee}, ${strargs});`, `${strargs}.reset();`];
  }
  toString(platformName) {
    let minStringTable = Object.keys(this.minStringTable).map(s => `#define ${s} ${this.minStringTable[s]}`).join('\n');
    let translated = '';
    toString.call(this, this.out);
    let str = (platform[platformName] || platform.std).replace(/\$\[\[([^\]]+)\]\]/g, (m, key) => {
      if (key == 'minStringTable') return minStringTable;
      if (key == 'translated') return translated;
      if (key == 'resources') {
        const acc = [];
        const resources = Object.keys(this.program.resourceData).sort((l, r) => typeof l < typeof r ? -1 : 1); // objects after strings

        for (let res of resources) {
          const src = this.program.resourceData[res];
          if (!src || typeof src == "string") continue;
          if (!Array.isArray(src)) continue;
          const type = src.type || 'uintptr_t';
          acc.push(`extern RESOURCEDECL_T(${type}, ${res});`);
        }
        for (let res of resources) {
          const src = this.program.resourceData[res];
          if (!src) continue; // `// RESOURCEDECL(${res}); // built-in`;
          if (typeof src == "string") {
            const out = [];
            for (let i = 0, len = src.length; i < len; i += 2) out.push(parseInt(src.substr(i, 2), 16));
            acc.push(`RESOURCEDECL(${res}) = {${out.join(',')}};`);
            continue;
          }
          if (Array.isArray(src)) {
            const type = src.type || 'uintptr_t';
            const out = [];
            for (let el of src) {
              if (typeof el == 'object' && el) {
                if ('h' in el) {
                  out.push(`js::hash(${JSON.stringify(el.h)})`);
                  continue;
                }
                if (typeof el.r == 'string') {
                  const name = el.r.split('/').pop().split('.')[0].replace(/^[^a-zA-Z_]+|[^a-zA-Z0-9_]+/gi, '');
                  let val = typeof el.o === 'number' ? `(${name} + ${el.o | 0})` : name;
                  if (type === 'uint32_t' || type == 'uintptr_t') {
                    out.push(`${type}(${val})`);
                  } else if (type === 'uint8_t') {
                    out.push(`${type}(uintptr_t(${val}) >>  0)`);
                    out.push(`${type}(uintptr_t(${val}) >>  8)`);
                    out.push(`${type}(uintptr_t(${val}) >> 16)`);
                    out.push(`${type}(uintptr_t(${val}) >> 24)`);
                  }
                  continue;
                }
              }
              if (typeof el === 'number') {
                out.push('0x' + (el >>> 0).toString(16));
                continue;
              }
            }
            acc.push(`RESOURCEDECL_T(${type}, ${res}) = {${out.join(',')}};`);
          }
        }
        return acc.join('\n');
      }
      let sym = this.main;
      if (key != 'main') sym = this.main.find(key, true);
      if (!sym) this.error(`Could not find ${key}`);
      return encode(sym);
    });
    return this.header.join('\n') + '\n' + str;
    function toString(arr) {
      for (let i = 0, max = arr.length; i < max; ++i) {
        const v = arr[i];
        if (typeof v == "string") {
          if (v[0] == "}") this.indent--;
          translated += "    ".repeat(this.indent);
          translated += v;
          translated += "\n";
          if (v == "{") this.indent++;
        } else if (v === undefined) {} else {
          toString.call(this, v);
        }
      }
    }
  }
}
function cppWriter(program, opts) {
  const cpp = new CPP();
  if (Array.isArray(opts.strings)) {
    opts.strings.forEach(str => literalToString(str, true));
  }
  if (Array.isArray(opts.globals)) {
    opts.globals.forEach(name => {
      let v = program.main.index[name];
      if (!v) {
        v = new ir.Var("var", name);
        program.main.add(v);
      }
      cpp.globals[v.id] = v;
    });
  }
  if (Array.isArray(opts.strings)) {
    opts.strings.forEach(str => {
      literalToString(str, true);
    });
  }
  cpp.write(program);
  return cpp.toString(opts.platform);
}

},{"./IR.js":1,"./templates/blit.js":29,"./templates/espboy.js":30,"./templates/galuni.js":31,"./templates/meta.js":32,"./templates/pico.js":33,"./templates/pokitto.js":34,"./templates/std.js":35}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dataProg = dataProg;
function dataProg(ast, program, filename, jsc) {
  const name = filename.split('/').pop().split('.')[0].replace(/^[^a-zA-Z_]+|[^a-zA-Z0-9_]+/gi, '');
  // console.log('Adding resource ', name, ast);
  program.resourceData[name] = ast;
  return program;
}

},{}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.esAST = esAST;
exports.esProg = esProg;
var _esprima = _interopRequireWildcard(require("./node_modules/esprima/dist/esprima.js"));
var ir = _interopRequireWildcard(require("./IR.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
let JSC;
class ProgramParser {
  constructor(program) {
    this.program = program;
    this.scope = null;
    this.location = new ir.Location();
    this.node = null;
    this.discardResult = 0;
    this.scopeStack = [];
    this.parse = (node, ...args) => {
      const func = this[node.type];
      if (!func) {
        console.error("Don't know how to parse " + node.type + " inside", this.node ? this.node.type : "null");
        console.log(JSON.stringify(node, 0, 4));
        throw new ir.Error("Internal error", this.location);
      }
      const prev = this.node;
      this.setNode(node);
      const ret = func.call(this, node, ...args);
      this.setNode(prev);
      return ret;
    };
  }
  getNodeLocation(node) {
    if (node && node.loc && node.loc.start) {
      return new ir.Location(this.location.file, node.loc.start.line, node.loc.start.column);
    }
    return this.location.clone();
  }
  setNode(node) {
    this.node = node;
    if (node && node.loc && node.loc.start) {
      this.location.column = node.loc.start.column;
      this.location.line = node.loc.start.line;
    }
  }
  error(msg) {
    throw new ir.Error(msg, this.location);
  }
  push(scope, cb) {
    this.scopeStack.push(scope);
    const oldScope = this.scope;
    this.scope = scope;
    cb(scope);
    this.scope = oldScope;
    this.scopeStack.pop();
  }
  Program(node) {
    this.push(this.program.main, _ => {
      node.body.forEach(b => this.parse(b));
    });
  }
  BreakStatement(node) {
    for (let i = this.scopeStack.length - 1; i > -1; --i) {
      let target = this.scopeStack[i];
      if (!target.breakable) continue;
      if (node.label && target.name != node.label.name) continue;
      target.hasBreak = true;
      this.scope.add(new ir.Break(target));
      return;
    }
  }
  ContinueStatement(node) {
    for (let i = this.scopeStack.length - 1; i > -1; --i) {
      let target = this.scopeStack[i];
      if (!target.continuable) continue;
      if (node.label && target.name != node.label.name) continue;
      target.hasContinue = true;
      this.scope.add(new ir.Continue(target));
      return;
    }
  }
  BlockStatement(node, child = null) {
    this.discardResult = 1;
    if (!child) {
      child = new ir.Scope();
      this.scope.add(child);
    }
    this.push(child, _ => {
      for (let b of node.body) {
        this.parse(b);
        if (JSC.opts.cancel) {
          JSC.opts.cancel = false;
          node.body.splice(node.body.indexOf(b) - 1, node.body.length);
          break;
        }
      }
      ;
    });
  }
  LabeledStatement(node, child) {
    this.discardResult = 1;
    if (!child) child = new ir.Scope();
    child.name = node.label.name;
    this.parse(node.body, child);
  }
  IfStatement(node, block) {
    block = block || new ir.Scope();
    this.scope.add(block);
    block.debug = 'if';
    this.push(block.addEnterCondition(), _ => {
      this.discardResult = 0;
      this.parse(node.test);
      this.discardResult = 1;
    });
    if (node.alternate) {
      this.push(block.addFailEnter(), _ => {
        this.parse(node.alternate);
      });
    }
    this.push(block, _ => {
      this.parse(node.consequent); // , node.consequent.type == "BlockStatement" ? block : null);
    });
  }

  WhileStatement(node, block) {
    block = block || new ir.Scope();
    this.scope.add(block);
    block.continuable = true;
    block.breakable = true;
    this.push(block.addEnterCondition(), _ => {
      this.discardResult = 0;
      this.parse(node.test);
      this.discardResult = 1;
    });
    this.push(block.addLoopCondition(), _ => {
      this.scope.add(new ir.Literal(true));
    });
    this.push(block, _ => {
      this.parse(node.body); // , node.body.type == "BlockStatement" ? block : null);
    });
  }

  ForInStatement(node, block) {
    block = block || new ir.Scope();
    this.scope.add(block);
    block.continuable = true;
    block.breakable = true;
    block.debug = 'forIn';
    this.push(block, _ => {
      const arr = new ir.Var();
      block.add(arr);
      const it = new ir.Var();
      it.setDeclType("int32_t");
      block.add(it);
      let val;
      this.push(block.addPreEnter(), preEnter => {
        preEnter.add(new ir.LookUp(arr.id));
        this.parse(node.right);
        preEnter.add(new ir.AssignmentExpression('='));
        preEnter.add(new ir.Pop());
        preEnter.add(new ir.LookUp(it.id));
        preEnter.add(new ir.Literal(-1));
        preEnter.add(new ir.AssignmentExpression('='));
        preEnter.add(new ir.Pop());
        this.parse(node.left);
        val = preEnter.find(node.left.declarations[0].id.name, true);
        if (!val) this.error("Could not find iterator " + node.left.declarations[0].id.name);
      });
      this.push(block.addEnterCondition(), cond => {
        cond.add(new ir.LookUp(arr.id));
        cond.add(new ir.LookUp(it.id));
        cond.add(new ir.BinaryExpression("N"));
      });
      this.push(block.addPreLoop(), preLoop => {});
      this.push(block.addLoopCondition(), cond => {
        cond.add(new ir.Literal(true));
      });
      block.add(new ir.LookUp(val.id));
      block.add(new ir.LookUp(arr.id));
      block.add(new ir.Deref());
      block.add(new ir.LookUp(it.id));
      block.add(new ir.Deref());
      block.add(new ir.BinaryExpression("n"));
      block.add(new ir.AssignmentExpression("="));
      this.parse(node.body, node.body.type == "BlockStatement" ? block : null);
    });
  }
  ForOfStatement(node, block) {
    block = block || new ir.Scope();
    this.scope.add(block);
    block.continuable = true;
    block.breakable = true;
    block.debug = 'forOf';
    this.push(block, _ => {
      const arr = new ir.Var();
      block.add(arr);
      const it = new ir.Var();
      // it.setDeclType("int32_t");
      block.add(it);
      const max = new ir.Var();
      // max.setDeclType("int32_t");
      block.add(max);
      let val;
      this.push(block.addPreEnter(), preEnter => {
        preEnter.add(new ir.LookUp(it.id));
        preEnter.add(new ir.Literal(0));
        preEnter.add(new ir.AssignmentExpression('='));
        preEnter.add(new ir.Pop());
        preEnter.add(new ir.LookUp(arr.id));
        this.parse(node.right);
        preEnter.add(new ir.AssignmentExpression('='));
        preEnter.add(new ir.Pop());
        this.parse(node.left);
        val = preEnter.find(node.left.declarations[0].id.name, true);
        if (!val) this.error("Could not find iterator " + node.left.declarations[0].id.name);
        preEnter.add(new ir.LookUp(max.id));
        preEnter.add(new ir.LookUp(arr.id));
        preEnter.add(new ir.Deref());
        preEnter.add(new ir.Literal("length"));
        preEnter.add(new ir.BinaryExpression("."));
        preEnter.add(new ir.AssignmentExpression("="));
        preEnter.add(new ir.Pop());
      });
      this.push(block.addEnterCondition(), cond => {
        cond.add(new ir.LookUp(it.id));
        cond.add(new ir.LookUp(max.id));
        cond.add(new ir.BinaryExpression("<"));
      });
      this.push(block.addPreLoop(), preLoop => {
        preLoop.add(new ir.LookUp(it.id));
        preLoop.add(new ir.Literal(1));
        preLoop.add(new ir.AssignmentExpression("+="));
        preLoop.add(new ir.Pop());
      });
      this.push(block.addLoopCondition(), cond => {
        cond.add(new ir.Literal(true));
      });
      block.add(new ir.LookUp(val.id));
      block.add(new ir.LookUp(arr.id));
      block.add(new ir.Deref());
      block.add(new ir.LookUp(it.id));
      block.add(new ir.Deref());
      block.add(new ir.BinaryExpression("."));
      block.add(new ir.AssignmentExpression("="));
      this.parse(node.body, node.body.type == "BlockStatement" ? block : null);
    });
  }
  ForStatement(node, block) {
    block = block || new ir.Scope();
    this.scope.add(block);
    block.continuable = true;
    block.breakable = true;
    this.push(block, _ => {
      if (node.init) {
        this.push(block.addPreEnter(), _ => {
          this.parse(node.init);
        });
      }
      if (node.test) {
        this.push(block.addEnterCondition(), _ => {
          this.discardResult = 0;
          this.parse(node.test);
          this.discardResult = 1;
        });
      }
      if (node.update) {
        this.push(block.addPreLoop(), _ => {
          this.parse(node.update);
        });
      }
      this.push(block.addLoopCondition(), _ => {
        this.scope.add(new ir.Literal(true));
      });
      this.parse(node.body, node.body.type == "BlockStatement" ? block : null);
    });
  }
  DoWhileStatement(node, block) {
    block = block || new ir.Scope();
    this.scope.add(block);
    block.continuable = true;
    block.breakable = true;
    this.push(block.addLoopCondition(), _ => {
      this.discardResult = 0;
      this.parse(node.test);
      this.discardResult = 1;
    });
    this.push(block, _ => {
      this.parse(node.body, node.body.type == "BlockStatement" ? block : null);
    });
  }
  VariableDeclaration(node) {
    node.declarations.forEach(child => this.parse(child, node.kind));
  }
  VariableDeclarator(node, kind) {
    const id = node.id;
    if (id.type != "Identifier") this.error("Unsupported initializer type: " + id.type);
    var scope = kind == "var" ? this.scope.method : this.scope;
    var prevInst = scope.find(id.name, false);
    if (!prevInst) {
      scope.add(new ir.Var(kind, id.name, this.location.clone()));
    } else if (kind != "var" || prevInst.kind != "var") {
      this.error("redeclaration of " + prevInst.kind + " " + prevInst.name);
    }
    if (node.init) {
      this.discardResult = 0;
      this.parse({
        type: "AssignmentExpression",
        operator: "=",
        left: {
          type: "Identifier",
          name: id.name
        },
        right: node.init
      });
      this.scope.add(new ir.Pop());
      this.discardResult = 1;
    }
  }
  ClassDeclaration(node) {
    const clazz = new ir.Method(node.id ? node.id.name : undefined);
    clazz.isClass = true;
    this.scope.add(clazz);
    this.push(clazz, _ => {
      this.parse(node.body);
    });
    const THIS = clazz.index["this"];
    const reg = {};
    for (let key in clazz.index) {
      const method = clazz.index[key];
      if (method.id in reg || !(method instanceof ir.Method)) continue;
      reg[method.id] = method;
      let that = method.index["this"];
      THIS.addDeref(method.name);
      clazz.add(new ir.LookUp("this"));
      clazz.add(new ir.Deref());
      clazz.add(new ir.Literal(method.name));
      clazz.add(new ir.BinaryExpression("."));
      if (method.name == "constructor") {
        clazz.add(new ir.LookUp(clazz.id));
      } else {
        clazz.add(new ir.LookUp(method.id));
      }
      clazz.add(new ir.AssignmentExpression("="));
      clazz.add(new ir.Pop());
    }
    if (clazz.index["constructor"]) {
      const ctor = new ir.LookUp("constructor");
      ctor.container = clazz;
      clazz.add(ctor);
      clazz.add(new ir.CallExpression(0, true, true, this.discardResult));
    }
  }
  ClassBody(node) {
    node.body.forEach(method => this.parse(method));
  }
  EmptyStatement(node) {}
  AssignmentExpression(node) {
    this.discardResult = 0;
    this.parse(node.left);
    this.parse(node.right);
    this.scope.add(new ir.Deref());
    this.scope.add(new ir.AssignmentExpression(node.operator));
  }
  ConditionalExpression(node) {
    let result = new ir.Var();
    this.scope.add(result);
    let block = new ir.Scope();
    this.scope.add(block);
    block.debug = 'op_?';
    this.push(block.addEnterCondition(), _ => {
      this.discardResult = 0;
      this.parse(node.test);
      this.discardResult = 1;
    });
    this.push(block.addFailEnter(), _ => {
      this.discardResult = 0;
      this.scope.add(new ir.LookUp(result.id));
      this.parse(node.alternate);
      this.scope.add(new ir.AssignmentExpression("="));
      this.scope.add(new ir.Pop());
      this.discardResult = 1;
    });
    this.push(block, _ => {
      this.discardResult = 0;
      this.scope.add(new ir.LookUp(result.id));
      this.parse(node.consequent, block);
      this.scope.add(new ir.AssignmentExpression("="));
      this.scope.add(new ir.Pop());
      this.discardResult = 1;
    });
    this.scope.add(new ir.LookUp(result.id));
  }
  ExpressionStatement(node) {
    if (node.expression.type == "Literal" && typeof node.expression.value == "string") {
      JSC.pragma(node.expression.value);
      if (JSC.opts["inline-cpp"]) {
        this.scope.add(new ir.Inline("cpp", JSC.opts["inline-cpp"], "inline"));
        JSC.opts["inline-cpp"] = null;
      }
      if (JSC.opts["header-cpp"]) {
        this.scope.add(new ir.Inline("cpp", JSC.opts["header-cpp"], "header"));
        JSC.opts["header-cpp"] = null;
      }
      return;
    }
    this.discardResult = 1;
    this.parse(node.expression);
    this.scope.add(new ir.Pop());
  }
  ReturnStatement(node) {
    this.discardResult = 0;
    if (node.argument) this.parse(node.argument);
    this.scope.add(new ir.Return(!!node.argument));
  }
  Identifier(node) {
    this.scope.add(new ir.LookUp(node.name));
  }
  ThisExpression(node) {
    this.scope.add(new ir.LookUp("this"));
  }
  ObjectExpression(node) {
    node.properties.forEach(prop => {
      this.parse(prop.key);
      this.parse(prop.value);
    });
    this.scope.add(new ir.Objekt(node.properties.length, false));
  }
  ArrayExpression(node) {
    node.elements.forEach(element => {
      this.parse(element);
    });
    this.scope.add(new ir.Array(node.elements.length));
  }
  Literal(node) {
    this.scope.add(new ir.Literal(node.value));
  }
  UnaryExpression(node) {
    this.parse(node.argument);
    this.scope.add(new ir.UnaryExpression(node.operator, node.prefix));
  }
  UpdateExpression(node) {
    this.discardResult = 0;
    this.parse(node.argument);
    this.scope.add(new ir.UnaryExpression(node.operator, node.prefix));
  }
  BinaryExpression(node) {
    this.parse(node.left);
    this.scope.add(new ir.Deref());
    this.parse(node.right);
    this.scope.add(new ir.Deref());
    this.scope.add(new ir.BinaryExpression(node.operator));
    if (node.operator == '.') console.log(node);
  }
  LogicalExpression(node) {
    if (node.operator != "&&" && node.operator != "||") this.error("Unimplemented operator " + node.operator);
    const tmp = new ir.Var("var");
    this.scope.add(tmp);
    this.scope.add(new ir.LookUp(tmp.id));
    this.parse(node.left);
    this.scope.add(new ir.AssignmentExpression("="));
    this.scope.add(new ir.Pop());
    const ifst = new ir.Scope();
    ifst.debug = node.operator;
    this.scope.add(ifst);
    this.push(ifst, _ => {
      this.push(ifst.addEnterCondition(), _ => {
        this.scope.add(new ir.LookUp(tmp.id));
      });
      this.push(node.operator == "&&" ? ifst : ifst.addFailEnter(), _ => {
        this.scope.add(new ir.LookUp(tmp.id));
        this.parse(node.right);
        this.scope.add(new ir.AssignmentExpression("="));
        this.scope.add(new ir.Pop());
      });
    });
    this.scope.add(new ir.LookUp(tmp.id));
  }
  MemberExpression(node) {
    this.parse(node.object);
    this.scope.add(new ir.Deref());
    if (node.computed) {
      this.parse(node.property);
    } else {
      this.scope.add(new ir.Literal(node.property.name));
    }
    this.scope.add(new ir.BinaryExpression(node.computed ? "[]" : "."));
  }
  CallExpression(node, isNew) {
    let discardResult = this.discardResult;
    this.discardResult = 0;
    this.parse(node.callee);
    node.arguments.forEach(arg => {
      this.parse(arg);
      this.scope.add(new ir.Deref());
    });
    this.scope.add(new ir.CallExpression(node.arguments.length, !!isNew, false, discardResult));
  }
  NewExpression(node) {
    this.CallExpression(node, true);
  }
  ArrowFunctionExpression(node) {
    const method = this.FunctionDeclaration(node, true);
    this.scope.add(new ir.LookUp(method.id));
  }
  FunctionExpression(node) {
    const method = this.FunctionDeclaration(node);
    this.scope.add(new ir.LookUp(method.id));
  }
  MethodDefinition(node) {
    this.FunctionDeclaration(node.value, node.key.name);
  }
  FunctionDeclaration(node, name) {
    const method = new ir.Method(name || (node.id ? node.id.name : undefined));
    this.scope.add(method);
    this.push(method, _ => {
      let needsArgc = false;
      let needsArgs = false;
      node.params.forEach((param, index) => {
        if (param.type == "AssignmentPattern") {
          needsArgc = true;
        }
        if (param.name == "arguments") {
          needsArgs = true;
        }
      });
      let args = method.args;

      // if (needsArgs) {
      //     args = new ir.Var("var", "arguments");
      //     this.scope.add(args);
      // }

      const argc = needsArgc ? new ir.Var("var") : null;
      if (argc) {
        this.scope.add(argc);
        this.scope.add(new ir.LookUp(argc.id));
        this.scope.add(new ir.LookUp(args.id));
        if (needsArgs) {
          this.scope.add(new ir.LookUp(method.args.id));
          this.scope.add(new ir.AssignmentExpression("="));
        }
        this.scope.add(new ir.Literal("length"));
        this.scope.add(new ir.BinaryExpression("."));
        this.scope.add(new ir.AssignmentExpression("="));
        this.scope.add(new ir.Pop());
      } else if (needsArgs) {
        this.scope.add(new ir.LookUp(args.id));
        this.scope.add(new ir.LookUp(method.args.id));
        this.scope.add(new ir.AssignmentExpression("="));
        this.scope.add(new ir.Pop());
      }
      node.params.forEach((param, index) => {
        const variable = new ir.Var("var", param.name, this.getNodeLocation(param));
        if (param.type == "Identifier") {
          this.scope.add(new ir.LookUp(variable.id));
          this.scope.add(new ir.LookUp(args.id));
          this.scope.add(new ir.Deref());
          this.scope.add(new ir.Literal(index));
          this.scope.add(new ir.BinaryExpression("."));
          this.scope.add(new ir.AssignmentExpression("="));
          this.scope.add(new ir.Pop());
        } else if (param.type == "AssignmentPattern") {
          variable.rename(param.left.name);
          this.scope.add(new ir.LookUp(variable.id));
          this.scope.add(new ir.LookUp(method.args.id));
          this.scope.add(new ir.Literal(index));
          this.scope.add(new ir.BinaryExpression("."));
          this.scope.add(new ir.AssignmentExpression("="));
          this.scope.add(new ir.Pop());
          const ifst = new ir.Scope();
          this.scope.add(ifst);
          this.push(ifst.addEnterCondition(), _ => {
            this.scope.add(new ir.LookUp(argc.id));
            this.scope.add(new ir.Literal(index));
            this.scope.add(new ir.BinaryExpression("<="));
          });
          this.push(ifst, _ => {
            this.scope.add(new ir.LookUp(variable.id));
            this.parse(param.right);
            this.scope.add(new ir.AssignmentExpression("="));
            this.scope.add(new ir.Pop());
          });
        }
        this.scope.add(variable);
      });
      this.discardResult = 0;
      this.parse(node.body, method);
      if (node.expression) {
        this.scope.add(new ir.Deref());
        this.scope.add(new ir.Return(true));
      }
    });
    return method;
  }
}
function esAST(source, program, path) {
  const esprima = typeof exports === "object" && exports.esprima ? exports.esprima : _esprima;
  const ast = esprima.parse(source, {
    loc: true
  });
  ast.file = path;
  return ast;
}
function esProg(ast, program, filename, jsc) {
  JSC = jsc;
  const parser = new ProgramParser(program);
  parser.location.file = ast.file;
  parser.parse(ast);
  program.sourceAST.unshift(ast);
  return program;
}

},{"./IR.js":1,"./node_modules/esprima/dist/esprima.js":11}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.jsWriter = jsWriter;
var ir = _interopRequireWildcard(require("./IR.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/* */

function toString(ast) {
  const escodegen = require('escodegen');
  return escodegen.generate(ast, {
    format: {
      indent: {
        style: ''
      },
      quotes: 'auto',
      compact: true
    }
  });
}
function jsWriter(program, opts) {
  const R = Object.keys(program.resourceData).map(res => {
    const src = program.resourceData[res];
    const clean = res.replace(/^[^a-zA-Z_]+|[^a-zA-Z0-9_]+/gi, '');
    if (typeof src == 'string') {
      if (!src) {
        return `//R.${clean}; // built-in`;
      }
      const out = [];
      for (let i = 0, len = src.length; i < len; i += 2) out.push(parseInt(src.substr(i, 2), 16));
      return `R.${clean} = Uint8Array.from([${out.join(',')}]);`;
    } else if (src) {
      if (Array.isArray(src)) {
        for (let el of src) {
          if (el && typeof el == "object" && el.r) el.r = el.r.split('.')[0].replace(/^[^a-zA-Z_]+|[^a-zA-Z0-9_]+/gi, '');
        }
      }
      return `R.${clean} = ` + JSON.stringify(src);
    }
  }).join('\n');
  return R + '\n' + program.sourceAST.map(ast => toString(ast)).join('\n');
}

/*/

import * as ir from './IR.js'

const platform = {
    std:`$[[resources]]
$[[translated]]`
};

const binOpName = {
    "+":"add",
    "-":"sub",
    "*":"mul",
    "%":"mod",
    "/":"div",
    "<":"lt",
    "<=":"leq",
    ">":"gt",
    ">=":"geq",
    "!=":"neq",
    "==":"eq",
    "===":"seq",
    "!==":"sneq",
    "|":"or",
    "&":"and",
    "^":"xor",
    "<<":"shl",
    ">>":"shr",
    ">>>":"sru",

    "N":"next",
    "n":"kai",

    "in":"in",
    "+=":"add",
    "-=":"sub",
    "*=":"mul",
    "%=":"mod",
    "/=":"div",
    "|=":"or",
    "&=":"and",
    "^=":"xor",
    "<<=":"shl",
    ">>=":"shr",
    ">>>=":"sru"
};

let cpp;

function literalToString(value, reg) {
    let ret = value + '';
    let pos = -1;

    if (typeof value == 'string' || reg) {
        ret = JSON.stringify(value);
    } else if (value === null) {
        ret = 'null';
    }
    return ret;
}

function encode(node, write)  {
    switch(node.constructor.name) {
    case "Method":
        if (node.isNative)
            return node.isNative;
        // if (node.captures)
        //     node = node.parent.method.capturers[node.id].ctx; // cpp.method.capturers[node.id].ctx;

    case "Var":
        if (cpp.globals[node.id])
            return node.name;

        return node.hasCTV && !write ?
            `${literalToString(node.CTV)}`
            : node.name ?
            `_${node.id}`
            : `_${node.id}`;

    case "Literal":
        return literalToString(node.value);
    case "LookUp":
        const ctx = node.container || node.parent;
        if (ctx instanceof ir.Var) {
            ctx.read++;
            if (node.variable instanceof ir.Literal) {
                ctx.addDeref(node.variable.value);
                if (ctx == cpp.program.resources) {
                    if (!(node.variable.value in cpp.program.resourceData))
                        throw `No resource named ${node.variable.value}`;
                    return `R.${node.variable.value}`;
                }
            }
            return `${encode(ctx, true)}[${encode(node.variable, false)}]`;
        } else if (ctx instanceof ir.Scope) {
            if (node.variable === "undefined")
                return 'undefined';
            const child = ctx.find(node.variable, true);
            if (!child)
                throw `No variable named ${JSON.stringify(node)}`;
            return encode(child, write);
        }
    }
    return node.constructor.name;
}

class CPP {
    constructor() {
        this.globals = {};
        this.header = [];
        this.out = [];
        this.method = null;
        this.indent = 0;
        this.stack = [];
        this.main = null;
        this.program = null;

        cpp = this;
    }

    error(msg, location) {
        throw new ir.Error(msg, location);
    }

    write(node) {
        const writer = this[node.constructor.name];
        if (!writer) {
            this.error("No writer for " + node.constructor.name, node.location);
        } else {
            // this.stack.forEach((e, i) => console.log(i + ") " + JSON.stringify(e)));
            // console.log(node.constructor.name);
            return writer.call(this, node);
        }
    }

    Program(node) {
        cpp = this;
        this.program = node;
        this.main = node.main;
        this.out.push(this.write(node.main));
    }

    Inline(node) {
        if (node.backend === "cpp") {
            if (node.target == "inline") {
                return node.code;
            }
            if (node.target == "header") {
                this.header.push(node.code);
            }
        }
    }

    Break(node) {
        return `break ${node.target.label('failEnter')}; // break`;
    }

    Continue(node) {
        return `continue ${node.target.label('preLoop')}; // continue`;
    }

    Return(node) {
        return [
            this.Deref(),
            node.hasValue
                ? `return ${encode(this.stack.pop())};`
                : `return;`
        ];
    }

    Method(node) {
        if (node.isNative)
            return;
        const oldMethod = this.method;
        this.method = node;
        const method = ['', `function ${encode(node, true)}(...${encode(node.args, true)})`];
        this.out.push(method);
        method.push(this.Scope(node, true));
        this.method = oldMethod;
    }

    declare(v) {
        return v.kind == "capture"
            ? `// capture ${encode(v, true)}`

            : v.kind == "cache"
            ? `// cache ${encode(v, true)}`

            : `js::Local ${encode(v, true)};`
    }

    Scope(node, endWithReturn) {
        const decls = [];
        const setup = [];
        const before = [`// begin ${node.debug}`, (node.transparent ? '' : '{'), setup, decls];
        const after = [(node.transparent ? '' : '}'), `// end ${node.debug}`];
        const children = [];

        node.children.forEach(child => {if (!(child instanceof ir.Method)) children.push(this.write(child))});
        node.children.forEach(child => {if ((child instanceof ir.Method)) children.push(this.write(child))});

        if (node.preEnter) {
            before.push(this.Scope(node.preEnter, false));
        }

        if (node.loopCondition) { // while, do/while, for
            const enterCondition = node.label('enterCondition');
            const failEnter = node.label('failEnter');
            const preLoop = node.label('preLoop');

            before.push(enterCondition + ':;');

            if (node.enterCondition) {
                before.push(this.write(node.enterCondition));
                before.push(this.Deref());
                before.push(`if (!js::to<bool>(${encode(this.stack.pop())})) goto ${failEnter};`);
            }

            if (node.hasContinue)
                children.push(preLoop + ':;');
            if (node.preLoop) {
                children.push(this.write(node.preLoop));
                this.stack.pop();
            }

            if (node.loopCondition && node.loopCondition.children[0]) {
                let firstChild = node.loopCondition.children[0];
                if ((firstChild instanceof ir.Literal) && firstChild.value) {
                    children.push(`goto ${enterCondition};`);
                } else if ((firstChild instanceof ir.Literal) && !firstChild.value) {
                } else {
                    children.push(this.write(node.loopCondition));
                    children.push(`if (js::to<bool>(${encode(this.stack.pop())})) goto ${enterCondition};`);
                }
            }

            after.unshift(failEnter + ':;');
        } else { // if, block
            if (node.enterCondition) {
                before.push(this.write(node.enterCondition));
                before.push(this.Deref());
                const failEnter = node.label('failEnter');
                before.push(`if (!js::to<bool>(${encode(this.stack.pop())})) goto ${failEnter};`);
                if (node.failEnter) {
                    let afterFail = node.label('afterFail');
                    after.unshift([
                        `goto ${afterFail};`,
                        failEnter + ':;',
                        this.write(node.failEnter),
                        afterFail + ':;',
                    ]);
                } else {
                    after.push(failEnter + ':;');
                }
            }
        }

        const varindex = {};
        varindex[node.method.args.id] = node.method.args;

        const locals = node.index;
        for (let key in locals) {
            let v = locals[key];
            if ((v.id in varindex) || !(v instanceof ir.Var))
                continue;
            varindex[v.id] = v;
            let decl = this.declare(v);
            if (v.kind != "const")
                v.hasCTV = false;
            if (node == this.main && v.name) {
                this.out.unshift(decl);
            } else {
                decls.push(decl);
            }
        }

        return [before, children, after];
    }

    LookUp(node) {
        this.stack.push(node);
    }

    Literal(node) {
        this.stack.push(node);
    }

    Deref() {
        const lookup = this.stack.pop();
        if (lookup instanceof ir.LookUp) {
            const ctx = lookup.container || lookup.parent;
            if (ctx === this.method.that && (lookup.variable instanceof ir.Literal)) {
                ctx.read++;
                this.stack.push(this.method.cached(lookup.variable.value));
            } else if ((ctx instanceof ir.Var) || (ctx instanceof ir.Literal)) {
                const variable = new ir.Var();
                this.method.add(variable);
                this.stack.push(variable);
                return `${encode(variable, true)} = ${encode(lookup)};`;
            } else if (ctx instanceof ir.Scope) {
                const variable = ctx.find(lookup.variable, true);
                if (!variable)
                    this.error(`ReferenceError: ${lookup.variable} is not defined`, lookup.location);
                this.stack.push(variable);
                if (variable instanceof ir.Method)
                    return this.Deref();
                return;
            } else {
                this.error('Null context in lookup');
            }
        } else {
            this.stack.push(lookup);
            return;
        }
    }

    Pop() {
        this.stack.pop();
    }

    AssignmentExpression(node) {
        let right = this.stack.pop();
        if (!right)
            this.error(`Missing right-hand side for ${node.operator}`);

        const lookup = this.stack.pop();
        if (!lookup)
            this.error(`Missing left-hand side for ${node.operator}${encode(right, true)}`);
        if (!(lookup instanceof ir.LookUp))
            this.error(`Invalid assignment left-hand side ${encode(lookup, true)}`);

        const ctx = lookup.container || lookup.parent;
        let ret = [];
        if (node.operator != "=") {
            this.stack.push(lookup);
            ret.push(this.Deref());
            this.stack.push(right);
            ret.push(this.BinaryExpression(node));
            right = this.stack.pop();
        }
        if (ctx instanceof ir.Var) {
            ctx.read++;
            if (lookup.variable instanceof ir.Literal) {
                ctx.addDeref(lookup.variable.value);
                if (ctx == this.method.that) {
                    ctx.read++;
                    let v = this.method.cached(lookup.variable.value);
                    // v.setType(right.declType || right.type);
                    ret.push(`${encode(v, true)} = ${encode(right)};`);
                    ret.push(`if (auto obj = std::get_if<js::Object*>(&${encode(v)}); obj && *obj) (*obj)->setMark();`);
                } else {
                    ret.push(`js::set(${encode(ctx, true)}, ${encode(lookup.variable)}, ${encode(right)});`);
                }
            } else {
                ret.push(`js::set(${encode(ctx, true)}, ${encode(lookup.variable)}, ${encode(right)});`);
            }
        } else if (ctx instanceof ir.Scope) {
            let v = ctx.find(lookup.variable, true, true);
            if (!v)
                this.error(`Variable ${lookup.variable} not defined`);

            if (v.kind == "const") {
                v.setDeclType(right.type);
                if (right.hasCTV) {
                    v.CTV = right.CTV;
                }
            }

            if (v.kind != "const" || !right.hasCTV) {
                ret.push(`${encode(v, true)} = ${encode(right)};`);
            } else {
                ret.push(`// const ${encode(v, true)} = ${encode(right)};`);
            }

            v.write++;
        }
        this.stack.push(right);
        return ret;// `// assign ${lookup.variable} ${node.operator} ${right.constructor.name}`;
    }

    UnaryExpression(node) {
        const lookup = this.stack.pop();
        const opName = {
            true:{
                "++":"preinc",
                "--":"predec",
                "!":"not",
                "~":"bitnot",
                "-":"neg",
                "+":"pos"
            },
            false:{
                "++":"inc",
                "--":"dec"
            }
        }[node.prefix === false ? false : true][node.operator];

        let tmp = new ir.Var();

        if (opName == "bitnot") {
            if (lookup.hasCTV) {
                tmp = new ir.Literal(~lookup.value);
            } else {
                tmp.setDeclType("int32_t");
            }
        } else if (opName == "not") {
            if (lookup.hasCTV) {
                tmp = new ir.Literal(!lookup.value);
            } else {
                tmp.setDeclType("bool");
            }
        } else if (opName == "neg") {
            if (lookup.hasCTV) {
                tmp = new ir.Literal(-lookup.value);
            } else {
                tmp.setDeclType("Float");
            }
        } else {
            tmp.setDeclType("Float");
        }

        this.stack.push(tmp);

        if (tmp instanceof ir.Var) {
            node.parent.method.add(tmp);
            let ret = `js::op_${opName}(${encode(tmp, true)}, ${encode(lookup)}); // ${node.operator}`;
            lookup.type = tmp.type;
            return ret;
        }
    }

    BinaryExpression(node) {
        let out = [];
        const right = this.stack.pop();
        out.push(this.Deref());
        const left = this.stack.pop();
        switch (node.operator) {
        case ".":
        case "[]":
            const lookup = new ir.LookUp(right);
            lookup.container = left;
            this.stack.push(lookup);
            return out;
        }

        let tmp = new ir.Var();
        const op = binOpName[node.operator] || node.operator;

        switch (op) {
        case "add":
            // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  + ", right.hasCTV, right.name, "(", right.CTV, ")");

            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV + right.CTV);
            } else {
                tmp.hasCTV = false;
                if (left.declType == "Object*" || right.declType == "Object*" || !left.declType || !right.declType) {
                    // tmp.setDeclType("js::Local");
                } else if (left.declType == "string" || right.declType == "string") {
                    tmp.setDeclType("string");
                } else if (left.declType == "Undefined" || right.declType == "Undefined") {
                    tmp.setDeclType("Undefined");
                } else if (left.declType == "Float" || right.declType == "Float") {
                    tmp.setDeclType("Float");
                } else {
                    tmp.setDeclType("int32_t");
                }
            }

            break;

        case "sub":
            // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  - ", right.hasCTV, right.name, "(", right.CTV, ")");

            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV - right.CTV);
            } else {
                tmp.hasCTV = false;
                if (left.declType == "int32_t" && right.declType == "int32_t") {
                    tmp.setDeclType("int32_t");
                } else if (left.declType == "uint32_t" && right.declType == "uint32_t") {
                    tmp.setDeclType("uint32_t");
                } else {
                    tmp.setDeclType("Float");
                }
            }

            break;

        case "mul":
            // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  * ", right.hasCTV, right.name, "(", right.CTV, ")");

            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV * right.CTV);
            } else {
                tmp.hasCTV = false;
                if (left.declType == "int32_t" && right.declType == "int32_t") {
                    tmp.setDeclType("int32_t");
                } else if (left.declType == "uint32_t" && right.declType == "uint32_t") {
                    tmp.setDeclType("uint32_t");
                } else {
                    tmp.setDeclType("Float");
                }
            }

            break;

        case "mod":
            // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  - ", right.hasCTV, right.name, "(", right.CTV, ")");

            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV % right.CTV);
            } else {
                tmp.hasCTV = false;
                if (left.declType == "int32_t" && right.declType == "int32_t") {
                    tmp.setDeclType("int32_t");
                } else if (left.declType == "uint32_t" && right.declType == "uint32_t") {
                    tmp.setDeclType("uint32_t");
                } else {
                    tmp.setDeclType("Float");
                }
            }

            break;

        case "div":
            // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  - ", right.hasCTV, right.name, "(", right.CTV, ")");

            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV / right.CTV);
            } else {
                tmp.hasCTV = false;
                if (left.declType == "int32_t" && right.declType == "int32_t") {
                    tmp.setDeclType("int32_t");
                } else if (left.declType == "uint32_t" && right.declType == "uint32_t") {
                    tmp.setDeclType("uint32_t");
                } else {
                    tmp.setDeclType("Float");
                }
            }

            break;

        case "next":
            tmp.setDeclType("int32_t");
            break;

        case "kai":
            break;

        case "lt":
            tmp.setDeclType("int32_t");
            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV < right.CTV);
            }
            break;

        case "leq":
            tmp.setDeclType("int32_t");
            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV <= right.CTV);
            }
            break;

        case "gt":
            tmp.setDeclType("int32_t");
            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV > right.CTV);
            }
            break;

        case "geq":
            tmp.setDeclType("int32_t");
            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV >= right.CTV);
            }
            break;

        case "neq":
            tmp.setDeclType("int32_t");
            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV != right.CTV);
            }
            break;

        case "eq":
            tmp.setDeclType("int32_t");
            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV == right.CTV);
            }
            break;

        case "seq":
            tmp.setDeclType("int32_t");
            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV === right.CTV);
            }
            break;

        case "sneq":
            tmp.setDeclType("int32_t");
            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV !== right.CTV);
            }
            break;

        case "in":
            tmp.setDeclType("int32_t");
            break;

        case "or":
            // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  | ", right.hasCTV, right.name, "(", right.CTV, ")");

            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV | right.CTV);
            } else {
                tmp.setDeclType("int32_t");
            }

            break;

        case "and":
            // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  | ", right.hasCTV, right.name, "(", right.CTV, ")");

            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV & right.CTV);
            } else {
                tmp.setDeclType("int32_t");
            }

            break;

        case "xor":
            // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  ^ ", right.hasCTV, right.name, "(", right.CTV, ")");

            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV ^ right.CTV);
            } else {
                tmp.setDeclType("int32_t");
            }

            break;

        case "shl":
            // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  | ", right.hasCTV, right.name, "(", right.CTV, ")");

            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV << right.CTV);
            } else {
                tmp.setDeclType("int32_t");
            }

            break;

        case "shr":
            // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  | ", right.hasCTV, right.name, "(", right.CTV, ")");

            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV >> right.CTV);
            } else {
                tmp.setDeclType("int32_t");
            }

            break;

        case "sru":
            // console.log("CTV ", left.hasCTV, left.name, "(", left.CTV, ")  | ", right.hasCTV, right.name, "(", right.CTV, ")");

            if (left.hasCTV && right.hasCTV) {
                tmp = new ir.Literal(left.CTV >>> right.CTV);
            } else {
                tmp.setDeclType("int32_t");
            }

            break;
        }

        node.parent.add(tmp);
        this.stack.push(tmp);

        if (tmp instanceof ir.Var) {
            tmp.write++;
            out.push(`js::op_${op}(${encode(tmp, true)}, ${encode(left)}, ${encode(right)});`);
        }

        return out;
    }

    Array(node) {
        const array = new ir.Var();
        array.setDeclType("Object*");
        this.method.add(array);
        array.write++;
        const out = [];
        const values = [];
        const strarray = encode(array);
        out.push(`${strarray} = js::arguments(${node.length});`);
        out.push(values);

        for (let i = 0; i < node.length; ++i) {
            values[node.length - i - 1] = `js::set(${strarray}, ${literalToString(node.length - i - 1, true)}, ${encode(this.stack.pop())});`;
        }

        this.stack.push(array);
        return out;
    }

    Objekt(node) {
        const obj = new ir.Var();
        obj.setDeclType("Object*");
        this.method.add(obj);
        obj.write++;
        const out = [];
        const values = [];
        const strobj = encode(obj);
        out.push(`${strobj} = js::alloc(${node.length});`);
        out.push(values);

        for (let i = 0; i < node.length; ++i) {
            let value = this.stack.pop();
            let key = this.stack.pop();
            if (key instanceof ir.LookUp)
                key = key.variable;
            else if (key instanceof ir.Literal)
                key = key.value;
            values[node.length - i - 1] = `js::set(${strobj}, ${literalToString(key, true)}, ${encode(value)});`;
        }

        this.stack.push(obj);
        return out;
    }

    CallExpression(node) {
        if (node.isForward) {
            const calleeLU = this.stack.pop();
            const strcallee = encode(calleeLU, true);
            return `js::call(${strcallee}, ${encode(this.method.args)});`;
        }

        var args = this.method.temporaries.pop();
        if (!args) {
            args = new ir.Var();
            this.method.add(args);
        }

        var ret;
        if (!node.discardResult) {
            ret = new ir.Var();
            ret.hasCTV = false;
            this.method.add(ret);
        }

        const argv  = [];
        const strargs = encode(args, true);
        for (let i = 0; i < node.argc; ++i) {
            argv[node.argc - i - 1] = `js::set(${strargs}, ${literalToString(node.argc - i - 1, true)}, ${encode(this.stack.pop())});`;
        }
        const calleeLU = this.stack.pop();
        this.stack.push(calleeLU);
        argv.push(this.Deref());

        let argc = node.argc;
        const callee = this.stack.pop();
        const strcallee = encode(callee, true);
        if (node.isNew) {
            argc++;
        } else if (calleeLU.container) {
            argv.push(`js::set(${strargs}, V_this, ${encode(calleeLU.container)});`);
            argc++;
        }

        this.stack.push(ret);

        this.method.temporaries.push(args);

        const assign = ret ? `${encode(ret, true)} = ` : '';

        return [
            `${strargs} = js::arguments(${argc});`,
            argv,
            (
                callee instanceof ir.Method && !node.isNew ?
                    `${assign}${strcallee}(${strargs}, false);` :
                    `${assign}js::${node.isNew ? 'create' : 'call'}(${strcallee}, ${strargs});`
            ),
            `${strargs}.reset();`
        ];
    }

    toString(platformName) {
        let minStringTable = Object.keys(this.minStringTable).map(s => `#define ${s} ${this.minStringTable[s]}`).join('\n');

        let translated = '';
        toString.call(this, this.out);

        let str = (platform[platformName] || platform.std).replace(/\$\[\[([^\]]+)\]\]/g, (m, key)=>{
            if (key == 'minStringTable')
                return minStringTable;
            if (key == 'translated')
                return translated;
            if (key == 'resources') {
                const acc = [];
                const resources = Object.keys(this.program.resourceData)
                      .sort((l, r) => (typeof l) < (typeof r) ? -1 : 1); // objects after strings

                for (let res of resources) {
                    const src = this.program.resourceData[res];
                    if (!src || typeof src == "string")
                        continue;

                    if (!Array.isArray(src))
                        continue;

                    const type = src.type || 'uintptr_t';
                    acc.push(`extern RESOURCEDECL_T(${type}, ${res});`);
                }

                for (let res of resources) {
                    const src = this.program.resourceData[res];
                    if (!src)
                        continue;// `// RESOURCEDECL(${res}); // built-in`;
                    if (typeof src == "string") {
                        const out = [];
                        for (let i = 0, len = src.length; i < len; i += 2)
                            out.push(parseInt(src.substr(i, 2), 16));
                        acc.push(`RESOURCEDECL(${res}) = {${out.join(',')}};`);
                        continue;
                    }
                    if (Array.isArray(src)) {
                        const type = src.type || 'uintptr_t';
                        const out = [];
                        for (let el of src) {
                            if (typeof el == 'object' && el) {
                                if ('h' in el) {
                                    out.push(`js::hash(${JSON.stringify(el.h)})`);
                                    continue;
                                }

                                if (typeof el.r == 'string') {
                                    const name = el.r.split('/').pop().split('.')[0].replace(/^[^a-zA-Z_]+|[^a-zA-Z0-9_]+/gi, '');
                                    let val = typeof el.o === 'number' ? `(${name} + ${el.o|0})` : name;
                                    if (type === 'uint32_t' || type == 'uintptr_t') {
                                        out.push(`${type}(${val})`);
                                    } else if (type === 'uint8_t') {
                                        out.push(`${type}(uintptr_t(${val}) >>  0)`);
                                        out.push(`${type}(uintptr_t(${val}) >>  8)`);
                                        out.push(`${type}(uintptr_t(${val}) >> 16)`);
                                        out.push(`${type}(uintptr_t(${val}) >> 24)`);
                                    }
                                    continue;
                                }
                            }
                            if (typeof el === 'number') {
                                out.push('0x' + (el >>> 0).toString(16));
                                continue;
                            }
                        }
                        acc.push(`RESOURCEDECL_T(${type}, ${res}) = {${out.join(',')}};`);
                    }
                }
                return acc.join('\n');
            }
            let sym = this.main;
            if (key != 'main')
                sym = this.main.find(key, true);
            if (!sym)
                this.error(`Could not find ${key}`);
            return encode(sym);
        });

        return this.header.join('\n') + '\n' + str;

        function toString(arr) {
            for (let i = 0, max = arr.length; i < max; ++i) {
                const v = arr[i];
                if (typeof v == "string") {
                    if (v[0] == "}") this.indent--;
                    translated += "    ".repeat(this.indent);
                    translated += v;
                    translated += "\n"
                    if (v == "{") this.indent++;
                } else if (v === undefined) {
                } else {
                    toString.call(this, v);
                }
            }
        }
    }
}

export function jsWriter(program, opts) {
    const cpp = new CPP();

    if (Array.isArray(opts.strings)) {
        opts.strings.forEach(str => literalToString(str, true));
    }

    if (Array.isArray(opts.globals)) {
        opts.globals.forEach(name => {
            let v = program.main.index[name];
            if (!v) {
                v = new ir.Var("var", name);
                program.main.add(v);
            }
            cpp.globals[v.id] = v;
        });
    }

    if (Array.isArray(opts.strings)) {
        opts.strings.forEach(str => {
            literalToString(str, true);
        });
    }

    cpp.write(program);
    return cpp.toString(opts.platform);
}
/* */

},{"./IR.js":1,"escodegen":9}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JSC = void 0;
var _esProg = require("./esProg.js");
var _pyProg = require("./pyProg.js");
var _dataProg = require("./dataProg.js");
var _cppWriter = require("./cppWriter.js");
var _jsWriter = require("./jsWriter.js");
var _jsonWriter = require("./jsonWriter.js");
var ir = _interopRequireWildcard(require("./IR.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const writers = {
  cpp: _cppWriter.cppWriter,
  json: _jsonWriter.jsonWriter,
  js: _jsWriter.jsWriter
};
const transformers = {
  js: [_esProg.esAST, _esProg.esProg],
  py: [_pyProg.pyAST, _esProg.esProg],
  raw: [_dataProg.dataProg],
  u32: [JSON.parse, obj => {
    obj.type = 'uint32_t';
    return obj;
  }, _dataProg.dataProg],
  u8: [JSON.parse, obj => {
    obj.type = 'uint8_t';
    return obj;
  }, _dataProg.dataProg]
};
class JSC {
  constructor(reader) {
    this.program = new ir.Program();
    this.opts = {};
    this.dependencies = {};
    this.reader = reader;
    this.lock = false;
    const stdcalls = `
                debug, Array,
                rand,
                abs, sign::int32_t, floor, round, ceil, sqrt,
                cos, sin, atan2, tan,
                clamp, min, max, hash:hashjs,
                vectorLength, angleDifference
                `.trim().split(/\s*,\s*/);
    for (let name of stdcalls) this.addSysCall(name);
  }
  write(format, opts = {}) {
    const writer = writers[format];
    if (!writer) throw new Error("No writer for format " + format);
    return writer(this.program, Object.assign({}, opts, this.opts));
  }
  process() {
    if (this.lock) return;
    this.lock++;
    let redo;
    do {
      redo = false;
      for (let k in this.dependencies) {
        let v = this.dependencies[k];
        if (typeof v == "string") {
          console.log("Dependency ", k);
          redo = true;
          this.add(k, v);
          this.dependencies[k] = null;
        }
      }
    } while (redo);
    this.lock--;
  }
  add(filename, source) {
    const type = filename.split(".").pop().toLowerCase();
    const transformer = transformers[type];
    if (!transformer) throw new Error("No transformer queue for " + type, new ir.Location(filename));
    let ast = source;
    transformer.forEach(func => ast = func(ast, this.program, filename, this) || ast);
  }
  pragma(str) {
    let args = str.trim().split(" ");
    let method = this[args[0]];
    if (method) {
      args.shift();
      method.apply(this, args);
    }
  }
  include(path) {
    if (path in this.dependencies) return;
    const v = this.reader(path);
    ;
    this.dependencies[path] = null;
    this.add(path, v);
  }
  ifeq(key, val) {
    this.set("cancel", this.opts[key] != val);
  }
  ifneq(key, val) {
    this.set("cancel", this.opts[key] == val);
  }
  getOpt(flag) {
    return this.opts[flag];
  }
  set(flag, val) {
    this.opts[flag] = val;
  }
  push(flag, ...val) {
    let arr = this.opts[flag];
    if (!arr || !Array.isArray(arr)) {
      arr = [];
      this.opts[flag] = arr;
    }
    arr.push(...val);
  }
  registerBuiltinResource(...names) {
    names.forEach(name => {
      this.program.resourceData[name] = null;
    });
  }
  addSysCall(...names) {
    names.forEach(name => {
      let parts = name.split(':');
      const func = new ir.Method(parts[0]);
      func.isNative = parts[1] || parts[0];
      func.returnType = parts[2];
      this.program.main.add(func);
    });
  }
}
exports.JSC = JSC;
function print(ast) {
  console.log(JSON.stringify(ast, 0, 4));
}

},{"./IR.js":1,"./cppWriter.js":3,"./dataProg.js":4,"./esProg.js":5,"./jsWriter.js":6,"./jsonWriter.js":8,"./pyProg.js":28}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.jsonWriter = jsonWriter;
function jsonWriter(program) {
  return JSON.stringify(program, 0, 2);
}

},{}],9:[function(require,module,exports){
(function (global){(function (){
/*
  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        SourceNode,
        estraverse,
        esutils,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        sourceCode,
        preserveBlankLines,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    estraverse = require('estraverse');
    esutils = require('esutils');

    Syntax = estraverse.Syntax;

    // Generation is done by generateExpression.
    function isExpression(node) {
        return CodeGenerator.Expression.hasOwnProperty(node.type);
    }

    // Generation is done by generateStatement.
    function isStatement(node) {
        return CodeGenerator.Statement.hasOwnProperty(node.type);
    }

    Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Exponentiation: 13,
        Await: 14,
        Unary: 14,
        Postfix: 15,
        OptionalChaining: 16,
        Call: 17,
        New: 18,
        TaggedTemplate: 19,
        Member: 20,
        Primary: 21
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative,
        '**': Precedence.Exponentiation
    };

    //Flags
    var F_ALLOW_IN = 1,
        F_ALLOW_CALL = 1 << 1,
        F_ALLOW_UNPARATH_NEW = 1 << 2,
        F_FUNC_BODY = 1 << 3,
        F_DIRECTIVE_CTX = 1 << 4,
        F_SEMICOLON_OPT = 1 << 5;

    //Expression flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_ALLOW_CALL
    // F_ALLOW_UNPARATH_NEW
    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TTF = F_ALLOW_IN | F_ALLOW_CALL,
        E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TFF = F_ALLOW_IN,
        E_FFT = F_ALLOW_UNPARATH_NEW,
        E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;

    //Statement flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_FUNC_BODY
    // F_DIRECTIVE_CTX
    // F_SEMICOLON_OPT
    var S_TFFF = F_ALLOW_IN,
        S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,
        S_FFFF = 0x00,
        S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,
        S_TTFF = F_ALLOW_IN | F_FUNC_BODY;

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false,
                preserveBlankLines: false
            },
            moz: {
                comprehensionExpressionStartsWithAssignment: false,
                starlessGenerator: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            raw: true,
            verbatim: null,
            sourceCode: null
        };
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }

    function merge(target, override) {
        var key;
        for (key in override) {
            if (override.hasOwnProperty(key)) {
                target[key] = override[key];
            }
        }
        return target;
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
            --pos;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(code, next) {
        var hex;

        if (code === 0x08  /* \b */) {
            return '\\b';
        }

        if (code === 0x0C  /* \f */) {
            return '\\f';
        }

        if (code === 0x09  /* \t */) {
            return '\\t';
        }

        hex = code.toString(16).toUpperCase();
        if (json || code > 0xFF) {
            return '\\u' + '0000'.slice(hex.length) + hex;
        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
            return '\\0';
        } else if (code === 0x000B  /* \v */) { // '\v'
            return '\\x0B';
        } else {
            return '\\x' + '00'.slice(hex.length) + hex;
        }
    }

    function escapeDisallowedCharacter(code) {
        if (code === 0x5C  /* \ */) {
            return '\\\\';
        }

        if (code === 0x0A  /* \n */) {
            return '\\n';
        }

        if (code === 0x0D  /* \r */) {
            return '\\r';
        }

        if (code === 0x2028) {
            return '\\u2028';
        }

        if (code === 0x2029) {
            return '\\u2029';
        }

        throw new Error('Incorrectly classified character');
    }

    function escapeDirective(str) {
        var i, iz, code, quote;

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = str.length; i < iz; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                quote = '"';
                break;
            } else if (code === 0x22  /* " */) {
                quote = '\'';
                break;
            } else if (code === 0x5C  /* \ */) {
                ++i;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                ++singleQuotes;
            } else if (code === 0x22  /* " */) {
                ++doubleQuotes;
            } else if (code === 0x2F  /* / */ && json) {
                result += '\\';
            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                result += escapeDisallowedCharacter(code);
                continue;
            } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20  /* SP */ || !json && !escapeless && (code < 0x20  /* SP */ || code > 0x7E  /* ~ */))) {
                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                continue;
            }
            result += String.fromCharCode(code);
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        quote = single ? '\'' : '"';

        if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
        }

        str = result;
        result = quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                result += '\\';
            }
            result += String.fromCharCode(code);
        }

        return result + quote;
    }

    /**
     * flatten an array to a string, where the array can contain
     * either strings or nested arrays
     */
    function flattenToString(arr) {
        var i, iz, elem, result = '';
        for (i = 0, iz = arr.length; i < iz; ++i) {
            elem = arr[i];
            result += Array.isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
    }

    /**
     * convert generated to a SourceNode when source maps are enabled.
     */
    function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
            // with no source maps, generated is either an
            // array or a string.  if an array, flatten it.
            // if a string, just return it
            if (Array.isArray(generated)) {
                return flattenToString(generated);
            } else {
                return generated;
            }
        }
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource,
            rightSource,
            leftCharCode,
            rightCharCode;

        leftSource = toSourceNodeWhenNeeded(left).toString();
        if (leftSource.length === 0) {
            return [right];
        }

        rightSource = toSourceNodeWhenNeeded(right).toString();
        if (rightSource.length === 0) {
            return [left];
        }

        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
        rightCharCode = rightSource.charCodeAt(0);

        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
            esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) ||
            leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase;
        previousBase = base;
        base += indent;
        fn(base);
        base = previousBase;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; ++i) {
            line = array[i];
            j = 0;
            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                ++j;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                --spaces;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; ++i) {
            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
            array[i] = sourceMap ? sn.join('') : sn;
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                var result = '//' + comment.value;
                if (!preserveBlankLines) {
                    result += '\n';
                }
                return result;
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addComments(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment,
            extRange, range, prevRange, prefix, infix, suffix, count;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            if (preserveBlankLines) {
                comment = stmt.leadingComments[0];
                result = [];

                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;
                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }

                prevRange = range;

                for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
                    comment = stmt.leadingComments[i];
                    range = comment.range;

                    infix = sourceCode.substring(prevRange[1], range[0]);
                    count = (infix.match(/\n/g) || []).length;
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));

                    prevRange = range;
                }

                suffix = sourceCode.substring(range[1], extRange[1]);
                count = (suffix.match(/\n/g) || []).length;
                result.push(stringRepeat('\n', count));
            } else {
                comment = stmt.leadingComments[0];
                result = [];
                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                    result.push('\n');
                }
                result.push(generateComment(comment));
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push('\n');
                }

                for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                    comment = stmt.leadingComments[i];
                    fragment = [generateComment(comment)];
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        fragment.push('\n');
                    }
                    result.push(addIndent(fragment));
                }
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {

            if (preserveBlankLines) {
                comment = stmt.trailingComments[0];
                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;

                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }
            } else {
                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
                specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
                for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                    comment = stmt.trailingComments[i];
                    if (tailingToStatement) {
                        // We assume target like following script
                        //
                        // var t = 20;  /**
                        //               * This is comment of t
                        //               */
                        if (i === 0) {
                            // first case
                            result = [result, indent];
                        } else {
                            result = [result, specialBase];
                        }
                        result.push(generateComment(comment, specialBase));
                    } else {
                        result = [result, addIndent(generateComment(comment))];
                    }
                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result = [result, '\n'];
                    }
                }
            }
        }

        return result;
    }

    function generateBlankLines(start, end, result) {
        var j, newlineCount = 0;

        for (j = start; j < end; j++) {
            if (sourceCode[j] === '\n') {
                newlineCount++;
            }
        }

        for (j = 1; j < newlineCount; j++) {
            result.push(newline);
        }
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function generateVerbatimString(string) {
        var i, iz, result;
        result = string.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i < iz; i++) {
            result[i] = newline + base + result[i];
        }
        return result;
    }

    function generateVerbatim(expr, precedence) {
        var verbatim, result, prec;
        verbatim = expr[extra.verbatim];

        if (typeof verbatim === 'string') {
            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
        } else {
            // verbatim is object
            result = generateVerbatimString(verbatim.content);
            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
            result = parenthesize(result, prec, precedence);
        }

        return toSourceNodeWhenNeeded(result, expr);
    }

    function CodeGenerator() {
    }

    // Helpers.

    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
        var result, noLeadingComment, that = this;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, this.generateStatement(stmt, flags)];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [
                newline,
                addIndent(that.generateStatement(stmt, flags))
            ];
        });

        return result;
    };

    CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    };

    function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
    }

    function generateAsyncPrefix(node, spaceRequired) {
        return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';
    }

    function generateStarSuffix(node) {
        var isGenerator = node.generator && !extra.moz.starlessGenerator;
        return isGenerator ? '*' + space : '';
    }

    function generateMethodPrefix(prop) {
        var func = prop.value, prefix = '';
        if (func.async) {
            prefix += generateAsyncPrefix(func, !prop.computed);
        }
        if (func.generator) {
            // avoid space before method name
            prefix += generateStarSuffix(func) ? '*' : '';
        }
        return prefix;
    }

    CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
        if (node.type === Syntax.Identifier) {
            return generateIdentifier(node);
        }
        return this.generateExpression(node, precedence, flags);
    };

    CodeGenerator.prototype.generateFunctionParams = function (node) {
        var i, iz, result, hasDefault;

        hasDefault = false;

        if (node.type === Syntax.ArrowFunctionExpression &&
                !node.rest && (!node.defaults || node.defaults.length === 0) &&
                node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
        } else {
            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
            result.push('(');
            if (node.defaults) {
                hasDefault = true;
            }
            for (i = 0, iz = node.params.length; i < iz; ++i) {
                if (hasDefault && node.defaults[i]) {
                    // Handle default values.
                    result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));
                } else {
                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
                }
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }

            if (node.rest) {
                if (node.params.length) {
                    result.push(',' + space);
                }
                result.push('...');
                result.push(generateIdentifier(node.rest));
            }

            result.push(')');
        }

        return result;
    };

    CodeGenerator.prototype.generateFunctionBody = function (node) {
        var result, expr;

        result = this.generateFunctionParams(node);

        if (node.type === Syntax.ArrowFunctionExpression) {
            result.push(space);
            result.push('=>');
        }

        if (node.expression) {
            result.push(space);
            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(this.maybeBlock(node.body, S_TTFF));
        }

        return result;
    };

    CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
        var result = ['for' + (stmt.await ? noEmptySpace() + 'await' : '') + space + '('], that = this;
        withIndent(function () {
            if (stmt.left.type === Syntax.VariableDeclaration) {
                withIndent(function () {
                    result.push(stmt.left.kind + noEmptySpace());
                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
                });
            } else {
                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
            }

            result = join(result, operator);
            result = [join(
                result,
                that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)
            ), ')'];
        });
        result.push(this.maybeBlock(stmt.body, flags));
        return result;
    };

    CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
        var result = [];

        if (computed) {
            result.push('[');
        }

        result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));

        if (computed) {
            result.push(']');
        }

        return result;
    };

    CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
        if (Precedence.Assignment < precedence) {
            flags |= F_ALLOW_IN;
        }

        return parenthesize(
            [
                this.generateExpression(left, Precedence.Call, flags),
                space + operator + space,
                this.generateExpression(right, Precedence.Assignment, flags)
            ],
            Precedence.Assignment,
            precedence
        );
    };

    CodeGenerator.prototype.semicolon = function (flags) {
        if (!semicolons && flags & F_SEMICOLON_OPT) {
            return '';
        }
        return ';';
    };

    // Statements.

    CodeGenerator.Statement = {

        BlockStatement: function (stmt, flags) {
            var range, content, result = ['{', newline], that = this;

            withIndent(function () {
                // handle functions without any code
                if (stmt.body.length === 0 && preserveBlankLines) {
                    range = stmt.range;
                    if (range[1] - range[0] > 2) {
                        content = sourceCode.substring(range[0] + 1, range[1] - 1);
                        if (content[0] === '\n') {
                            result = ['{'];
                        }
                        result.push(content);
                    }
                }

                var i, iz, fragment, bodyFlags;
                bodyFlags = S_TFFF;
                if (flags & F_FUNC_BODY) {
                    bodyFlags |= F_DIRECTIVE_CTX;
                }

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    if (preserveBlankLines) {
                        // handle spaces before the first line
                        if (i === 0) {
                            if (stmt.body[0].leadingComments) {
                                range = stmt.body[0].leadingComments[0].extendedRange;
                                content = sourceCode.substring(range[0], range[1]);
                                if (content[0] === '\n') {
                                    result = ['{'];
                                }
                            }
                            if (!stmt.body[0].leadingComments) {
                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                            }
                        }

                        // handle spaces between lines
                        if (i > 0) {
                            if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {
                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                            }
                        }
                    }

                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }

                    if (stmt.body[i].leadingComments && preserveBlankLines) {
                        fragment = that.generateStatement(stmt.body[i], bodyFlags);
                    } else {
                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
                    }

                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        if (preserveBlankLines && i < iz - 1) {
                            // don't add a new line if there are leading coments
                            // in the next statement
                            if (!stmt.body[i + 1].leadingComments) {
                                result.push(newline);
                            }
                        } else {
                            result.push(newline);
                        }
                    }

                    if (preserveBlankLines) {
                        // handle spaces after the last line
                        if (i === iz - 1) {
                            if (!stmt.body[i].trailingComments) {
                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                            }
                        }
                    }
                }
            });

            result.push(addIndent('}'));
            return result;
        },

        BreakStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'break ' + stmt.label.name + this.semicolon(flags);
            }
            return 'break' + this.semicolon(flags);
        },

        ContinueStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'continue ' + stmt.label.name + this.semicolon(flags);
            }
            return 'continue' + this.semicolon(flags);
        },

        ClassBody: function (stmt, flags) {
            var result = [ '{', newline], that = this;

            withIndent(function (indent) {
                var i, iz;

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    result.push(indent);
                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(newline);
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        ClassDeclaration: function (stmt, flags) {
            var result, fragment;
            result  = ['class'];
            if (stmt.id) {
                result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
            }
            if (stmt.superClass) {
                fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(stmt.body, S_TFFT));
            return result;
        },

        DirectiveStatement: function (stmt, flags) {
            if (extra.raw && stmt.raw) {
                return stmt.raw + this.semicolon(flags);
            }
            return escapeDirective(stmt.directive) + this.semicolon(flags);
        },

        DoWhileStatement: function (stmt, flags) {
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            var result = join('do', this.maybeBlock(stmt.body, S_TFFF));
            result = this.maybeBlockSuffix(stmt.body, result);
            return join(result, [
                'while' + space + '(',
                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                ')' + this.semicolon(flags)
            ]);
        },

        CatchClause: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                var guard;

                if (stmt.param) {
                    result = [
                        'catch' + space + '(',
                        that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                        ')'
                    ];

                    if (stmt.guard) {
                        guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                        result.splice(2, 0, ' if ', guard);
                    }
                } else {
                    result = ['catch'];
                }
            });
            result.push(this.maybeBlock(stmt.body, S_TFFF));
            return result;
        },

        DebuggerStatement: function (stmt, flags) {
            return 'debugger' + this.semicolon(flags);
        },

        EmptyStatement: function (stmt, flags) {
            return ';';
        },

        ExportDefaultDeclaration: function (stmt, flags) {
            var result = [ 'export' ], bodyFlags;

            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

            // export default HoistableDeclaration[Default]
            // export default AssignmentExpression[In] ;
            result = join(result, 'default');
            if (isStatement(stmt.declaration)) {
                result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
            } else {
                result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
            }
            return result;
        },

        ExportNamedDeclaration: function (stmt, flags) {
            var result = [ 'export' ], bodyFlags, that = this;

            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

            // export VariableStatement
            // export Declaration[Default]
            if (stmt.declaration) {
                return join(result, this.generateStatement(stmt.declaration, bodyFlags));
            }

            // export ExportClause[NoReference] FromClause ;
            // export ExportClause ;
            if (stmt.specifiers) {
                if (stmt.specifiers.length === 0) {
                    result = join(result, '{' + space + '}');
                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
                } else {
                    result = join(result, '{');
                    withIndent(function (indent) {
                        var i, iz;
                        result.push(newline);
                        for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                            result.push(indent);
                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                            if (i + 1 < iz) {
                                result.push(',' + newline);
                            }
                        }
                    });
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result.push(newline);
                    }
                    result.push(base + '}');
                }

                if (stmt.source) {
                    result = join(result, [
                        'from' + space,
                        // ModuleSpecifier
                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                        this.semicolon(flags)
                    ]);
                } else {
                    result.push(this.semicolon(flags));
                }
            }
            return result;
        },

        ExportAllDeclaration: function (stmt, flags) {
            // export * FromClause ;
            return [
                'export' + space,
                '*' + space,
                'from' + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ];
        },

        ExpressionStatement: function (stmt, flags) {
            var result, fragment;

            function isClassPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 5) !== 'class') {
                    return false;
                }
                code = fragment.charCodeAt(5);
                return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
            }

            function isFunctionPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            function isAsyncPrefixed(fragment) {
                var code, i, iz;
                if (fragment.slice(0, 5) !== 'async') {
                    return false;
                }
                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
                    return false;
                }
                for (i = 6, iz = fragment.length; i < iz; ++i) {
                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
                        break;
                    }
                }
                if (i === iz) {
                    return false;
                }
                if (fragment.slice(i, i + 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(i + 8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
            // 12.4 '{', 'function', 'class' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression
                    isClassPrefixed(fragment) ||
                    isFunctionPrefixed(fragment) ||
                    isAsyncPrefixed(fragment) ||
                    (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + this.semicolon(flags)];
            } else {
                result.push(this.semicolon(flags));
            }
            return result;
        },

        ImportDeclaration: function (stmt, flags) {
            // ES6: 15.2.1 valid import declarations:
            //     - import ImportClause FromClause ;
            //     - import ModuleSpecifier ;
            var result, cursor, that = this;

            // If no ImportClause is present,
            // this should be `import ModuleSpecifier` so skip `from`
            // ModuleSpecifier is StringLiteral.
            if (stmt.specifiers.length === 0) {
                // import ModuleSpecifier ;
                return [
                    'import',
                    space,
                    // ModuleSpecifier
                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                    this.semicolon(flags)
                ];
            }

            // import ImportClause FromClause ;
            result = [
                'import'
            ];
            cursor = 0;

            // ImportedBinding
            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
                result = join(result, [
                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                ]);
                ++cursor;
            }

            if (stmt.specifiers[cursor]) {
                if (cursor !== 0) {
                    result.push(',');
                }

                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
                    // NameSpaceImport
                    result = join(result, [
                            space,
                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                    ]);
                } else {
                    // NamedImports
                    result.push(space + '{');

                    if ((stmt.specifiers.length - cursor) === 1) {
                        // import { ... } from "...";
                        result.push(space);
                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                        result.push(space + '}' + space);
                    } else {
                        // import {
                        //    ...,
                        //    ...,
                        // } from "...";
                        withIndent(function (indent) {
                            var i, iz;
                            result.push(newline);
                            for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                                result.push(indent);
                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                                if (i + 1 < iz) {
                                    result.push(',' + newline);
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base + '}' + space);
                    }
                }
            }

            result = join(result, [
                'from' + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ]);
            return result;
        },

        VariableDeclarator: function (stmt, flags) {
            var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;
            if (stmt.init) {
                return [
                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
                    space,
                    '=',
                    space,
                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
                ];
            }
            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
        },

        VariableDeclaration: function (stmt, flags) {
            // VariableDeclarator is typed as Statement,
            // but joined with comma (not LineTerminator).
            // So if comment is attached to target node, we should specialize.
            var result, i, iz, node, bodyFlags, that = this;

            result = [ stmt.kind ];

            bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;

            function block() {
                node = stmt.declarations[0];
                if (extra.comment && node.leadingComments) {
                    result.push('\n');
                    result.push(addIndent(that.generateStatement(node, bodyFlags)));
                } else {
                    result.push(noEmptySpace());
                    result.push(that.generateStatement(node, bodyFlags));
                }

                for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
                    node = stmt.declarations[i];
                    if (extra.comment && node.leadingComments) {
                        result.push(',' + newline);
                        result.push(addIndent(that.generateStatement(node, bodyFlags)));
                    } else {
                        result.push(',' + space);
                        result.push(that.generateStatement(node, bodyFlags));
                    }
                }
            }

            if (stmt.declarations.length > 1) {
                withIndent(block);
            } else {
                block();
            }

            result.push(this.semicolon(flags));

            return result;
        },

        ThrowStatement: function (stmt, flags) {
            return [join(
                'throw',
                this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
            ), this.semicolon(flags)];
        },

        TryStatement: function (stmt, flags) {
            var result, i, iz, guardedHandlers;

            result = ['try', this.maybeBlock(stmt.block, S_TFFF)];
            result = this.maybeBlockSuffix(stmt.block, result);

            if (stmt.handlers) {
                // old interface
                for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                guardedHandlers = stmt.guardedHandlers || [];

                for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
                    }
                }

                // new interface
                if (stmt.handler) {
                    if (Array.isArray(stmt.handler)) {
                        for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                            if (stmt.finalizer || i + 1 !== iz) {
                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                            }
                        }
                    } else {
                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                        if (stmt.finalizer) {
                            result = this.maybeBlockSuffix(stmt.handler.body, result);
                        }
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);
            }
            return result;
        },

        SwitchStatement: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                bodyFlags = S_TFFF;
                for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            return result;
        },

        SwitchCase: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                iz = stmt.consequent.length;
                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }

                bodyFlags = S_TFFF;
                for (; i < iz; ++i) {
                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
                    result.push(fragment);
                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            return result;
        },

        IfStatement: function (stmt, flags) {
            var result, bodyFlags, semicolonOptional, that = this;
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            semicolonOptional = flags & F_SEMICOLON_OPT;
            bodyFlags = S_TFFF;
            if (semicolonOptional) {
                bodyFlags |= F_SEMICOLON_OPT;
            }
            if (stmt.alternate) {
                result.push(this.maybeBlock(stmt.consequent, S_TFFF));
                result = this.maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);
                } else {
                    result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));
                }
            } else {
                result.push(this.maybeBlock(stmt.consequent, bodyFlags));
            }
            return result;
        },

        ForStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(that.generateStatement(stmt.init, S_FFFF));
                    } else {
                        // F_ALLOW_IN becomes false.
                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                        result.push(';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
                    result.push(';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
                    result.push(')');
                } else {
                    result.push(')');
                }
            });

            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        ForInStatement: function (stmt, flags) {
            return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        ForOfStatement: function (stmt, flags) {
            return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        LabeledStatement: function (stmt, flags) {
            return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
        },

        Program: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags;
            iz = stmt.body.length;
            result = [safeConcatenation && iz > 0 ? '\n' : ''];
            bodyFlags = S_TFTF;
            for (i = 0; i < iz; ++i) {
                if (!safeConcatenation && i === iz - 1) {
                    bodyFlags |= F_SEMICOLON_OPT;
                }

                if (preserveBlankLines) {
                    // handle spaces before the first line
                    if (i === 0) {
                        if (!stmt.body[0].leadingComments) {
                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                        }
                    }

                    // handle spaces between lines
                    if (i > 0) {
                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                        }
                    }
                }

                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
                result.push(fragment);
                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    if (preserveBlankLines) {
                        if (!stmt.body[i + 1].leadingComments) {
                            result.push(newline);
                        }
                    } else {
                        result.push(newline);
                    }
                }

                if (preserveBlankLines) {
                    // handle spaces after the last line
                    if (i === iz - 1) {
                        if (!stmt.body[i].trailingComments) {
                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                        }
                    }
                }
            }
            return result;
        },

        FunctionDeclaration: function (stmt, flags) {
            return [
                generateAsyncPrefix(stmt, true),
                'function',
                generateStarSuffix(stmt) || noEmptySpace(),
                stmt.id ? generateIdentifier(stmt.id) : '',
                this.generateFunctionBody(stmt)
            ];
        },

        ReturnStatement: function (stmt, flags) {
            if (stmt.argument) {
                return [join(
                    'return',
                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
                ), this.semicolon(flags)];
            }
            return ['return' + this.semicolon(flags)];
        },

        WhileStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        WithStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        }

    };

    merge(CodeGenerator.prototype, CodeGenerator.Statement);

    // Expressions.

    CodeGenerator.Expression = {

        SequenceExpression: function (expr, precedence, flags) {
            var result, i, iz;
            if (Precedence.Sequence < precedence) {
                flags |= F_ALLOW_IN;
            }
            result = [];
            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            return parenthesize(result, Precedence.Sequence, precedence);
        },

        AssignmentExpression: function (expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
        },

        ArrowFunctionExpression: function (expr, precedence, flags) {
            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
        },

        ConditionalExpression: function (expr, precedence, flags) {
            if (Precedence.Conditional < precedence) {
                flags |= F_ALLOW_IN;
            }
            return parenthesize(
                [
                    this.generateExpression(expr.test, Precedence.LogicalOR, flags),
                    space + '?' + space,
                    this.generateExpression(expr.consequent, Precedence.Assignment, flags),
                    space + ':' + space,
                    this.generateExpression(expr.alternate, Precedence.Assignment, flags)
                ],
                Precedence.Conditional,
                precedence
            );
        },

        LogicalExpression: function (expr, precedence, flags) {
            return this.BinaryExpression(expr, precedence, flags);
        },

        BinaryExpression: function (expr, precedence, flags) {
            var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
            currentPrecedence = BinaryPrecedence[expr.operator];
            leftPrecedence = expr.operator === '**' ? Precedence.Postfix : currentPrecedence;
            rightPrecedence = expr.operator === '**' ? currentPrecedence : currentPrecedence + 1;

            if (currentPrecedence < precedence) {
                flags |= F_ALLOW_IN;
            }

            fragment = this.generateExpression(expr.left, leftPrecedence, flags);

            leftSource = fragment.toString();

            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = this.generateExpression(expr.right, rightPrecedence, flags);

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace());
                result.push(fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, currentPrecedence, precedence);
        },

        CallExpression: function (expr, precedence, flags) {
            var result, i, iz;

            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];

            if (expr.optional) {
                result.push('?.');
            }

            result.push('(');
            for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {
                result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!(flags & F_ALLOW_CALL)) {
                return ['(', result, ')'];
            }

            return parenthesize(result, Precedence.Call, precedence);
        },

        ChainExpression: function (expr, precedence, flags) {
            if (Precedence.OptionalChaining < precedence) {
                flags |= F_ALLOW_CALL;
            }

            var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);

            return parenthesize(result, Precedence.OptionalChaining, precedence);
        },

        NewExpression: function (expr, precedence, flags) {
            var result, length, i, iz, itemFlags;
            length = expr['arguments'].length;

            // F_ALLOW_CALL becomes false.
            // F_ALLOW_UNPARATH_NEW may become false.
            itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;

            result = join(
                'new',
                this.generateExpression(expr.callee, Precedence.New, itemFlags)
            );

            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
                result.push('(');
                for (i = 0, iz = length; i < iz; ++i) {
                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            return parenthesize(result, Precedence.New, precedence);
        },

        MemberExpression: function (expr, precedence, flags) {
            var result, fragment;

            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];

            if (expr.computed) {
                if (expr.optional) {
                    result.push('?.');
                }

                result.push('[');
                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
                result.push(']');
            } else {
                if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNodeWhenNeeded(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push(' ');
                    }
                }
                result.push(expr.optional ? '?.' : '.');
                result.push(generateIdentifier(expr.property));
            }

            return parenthesize(result, Precedence.Member, precedence);
        },

        MetaProperty: function (expr, precedence, flags) {
            var result;
            result = [];
            result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
            result.push('.');
            result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
            return parenthesize(result, Precedence.Member, precedence);
        },

        UnaryExpression: function (expr, precedence, flags) {
            var result, fragment, rightCharCode, leftSource, leftCharCode;
            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNodeWhenNeeded(result).toString();
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = fragment.toString().charCodeAt(0);

                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                            (esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode))) {
                        result.push(noEmptySpace());
                        result.push(fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            return parenthesize(result, Precedence.Unary, precedence);
        },

        YieldExpression: function (expr, precedence, flags) {
            var result;
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
                );
            }
            return parenthesize(result, Precedence.Yield, precedence);
        },

        AwaitExpression: function (expr, precedence, flags) {
            var result = join(
                expr.all ? 'await*' : 'await',
                this.generateExpression(expr.argument, Precedence.Await, E_TTT)
            );
            return parenthesize(result, Precedence.Await, precedence);
        },

        UpdateExpression: function (expr, precedence, flags) {
            if (expr.prefix) {
                return parenthesize(
                    [
                        expr.operator,
                        this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
                    ],
                    Precedence.Unary,
                    precedence
                );
            }
            return parenthesize(
                [
                    this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
                    expr.operator
                ],
                Precedence.Postfix,
                precedence
            );
        },

        FunctionExpression: function (expr, precedence, flags) {
            var result = [
                generateAsyncPrefix(expr, true),
                'function'
            ];
            if (expr.id) {
                result.push(generateStarSuffix(expr) || noEmptySpace());
                result.push(generateIdentifier(expr.id));
            } else {
                result.push(generateStarSuffix(expr) || space);
            }
            result.push(this.generateFunctionBody(expr));
            return result;
        },

        ArrayPattern: function (expr, precedence, flags) {
            return this.ArrayExpression(expr, precedence, flags, true);
        },

        ArrayExpression: function (expr, precedence, flags, isPattern) {
            var result, multiline, that = this;
            if (!expr.elements.length) {
                return '[]';
            }
            multiline = isPattern ? false : expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.elements.length; i < iz; ++i) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === iz) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '');
                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
                    }
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push(']');
            return result;
        },

        RestElement: function(expr, precedence, flags) {
            return '...' + this.generatePattern(expr.argument);
        },

        ClassExpression: function (expr, precedence, flags) {
            var result, fragment;
            result = ['class'];
            if (expr.id) {
                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
            }
            if (expr.superClass) {
                fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(expr.body, S_TFFT));
            return result;
        },

        MethodDefinition: function (expr, precedence, flags) {
            var result, fragment;
            if (expr['static']) {
                result = ['static' + space];
            } else {
                result = [];
            }
            if (expr.kind === 'get' || expr.kind === 'set') {
                fragment = [
                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
                    this.generateFunctionBody(expr.value)
                ];
            } else {
                fragment = [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }
            return join(result, fragment);
        },

        Property: function (expr, precedence, flags) {
            if (expr.kind === 'get' || expr.kind === 'set') {
                return [
                    expr.kind, noEmptySpace(),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }

            if (expr.shorthand) {
                if (expr.value.type === "AssignmentPattern") {
                    return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
                }
                return this.generatePropertyKey(expr.key, expr.computed);
            }

            if (expr.method) {
                return [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }

            return [
                this.generatePropertyKey(expr.key, expr.computed),
                ':' + space,
                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
            ];
        },

        ObjectExpression: function (expr, precedence, flags) {
            var multiline, result, fragment, that = this;

            if (!expr.properties.length) {
                return '{}';
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    return [ '{', space, fragment, space, '}' ];
                }
            }

            withIndent(function (indent) {
                var i, iz;
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                        result.push(indent);
                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                        if (i + 1 < iz) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        AssignmentPattern: function(expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);
        },

        ObjectPattern: function (expr, precedence, flags) {
            var result, i, iz, multiline, property, that = this;
            if (!expr.properties.length) {
                return '{}';
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (
                    property.type === Syntax.Property
                    && property.value.type !== Syntax.Identifier
                ) {
                    multiline = true;
                }
            } else {
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    property = expr.properties[i];
                    if (
                        property.type === Syntax.Property
                        && !property.shorthand
                    ) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    result.push(multiline ? indent : '');
                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push('}');
            return result;
        },

        ThisExpression: function (expr, precedence, flags) {
            return 'this';
        },

        Super: function (expr, precedence, flags) {
            return 'super';
        },

        Identifier: function (expr, precedence, flags) {
            return generateIdentifier(expr);
        },

        ImportDefaultSpecifier: function (expr, precedence, flags) {
            return generateIdentifier(expr.id || expr.local);
        },

        ImportNamespaceSpecifier: function (expr, precedence, flags) {
            var result = ['*'];
            var id = expr.id || expr.local;
            if (id) {
                result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));
            }
            return result;
        },

        ImportSpecifier: function (expr, precedence, flags) {
            var imported = expr.imported;
            var result = [ imported.name ];
            var local = expr.local;
            if (local && local.name !== imported.name) {
                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));
            }
            return result;
        },

        ExportSpecifier: function (expr, precedence, flags) {
            var local = expr.local;
            var result = [ local.name ];
            var exported = expr.exported;
            if (exported && exported.name !== local.name) {
                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));
            }
            return result;
        },

        Literal: function (expr, precedence, flags) {
            var raw;
            if (expr.hasOwnProperty('raw') && parse && extra.raw) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            return expr.raw;
                        }
                    }
                } catch (e) {
                    // not use raw property
                }
            }

            if (expr.regex) {
              return '/' + expr.regex.pattern + '/' + expr.regex.flags;
            }

            if (expr.value === null) {
                return 'null';
            }

            if (typeof expr.value === 'string') {
                return escapeString(expr.value);
            }

            if (typeof expr.value === 'number') {
                return generateNumber(expr.value);
            }

            if (typeof expr.value === 'boolean') {
                return expr.value ? 'true' : 'false';
            }

            return generateRegExp(expr.value);
        },

        GeneratorExpression: function (expr, precedence, flags) {
            return this.ComprehensionExpression(expr, precedence, flags);
        },

        ComprehensionExpression: function (expr, precedence, flags) {
            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6

            var result, i, iz, fragment, that = this;
            result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];

            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
                result.push(fragment);
            }

            if (expr.blocks) {
                withIndent(function () {
                    for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                            result = join(result, fragment);
                        } else {
                            result.push(fragment);
                        }
                    }
                });
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
                result = join(result, [ '(', fragment, ')' ]);
            }

            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);

                result = join(result, fragment);
            }

            result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');
            return result;
        },

        ComprehensionBlock: function (expr, precedence, flags) {
            var fragment;
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    this.generateStatement(expr.left.declarations[0], S_FFFF)
                ];
            } else {
                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));

            return [ 'for' + space + '(', fragment, ')' ];
        },

        SpreadElement: function (expr, precedence, flags) {
            return [
                '...',
                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
            ];
        },

        TaggedTemplateExpression: function (expr, precedence, flags) {
            var itemFlags = E_TTF;
            if (!(flags & F_ALLOW_CALL)) {
                itemFlags = E_TFF;
            }
            var result = [
                this.generateExpression(expr.tag, Precedence.Call, itemFlags),
                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
            ];
            return parenthesize(result, Precedence.TaggedTemplate, precedence);
        },

        TemplateElement: function (expr, precedence, flags) {
            // Don't use "cooked". Since tagged template can use raw template
            // representation. So if we do so, it breaks the script semantics.
            return expr.value.raw;
        },

        TemplateLiteral: function (expr, precedence, flags) {
            var result, i, iz;
            result = [ '`' ];
            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
                if (i + 1 < iz) {
                    result.push('${' + space);
                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
                    result.push(space + '}');
                }
            }
            result.push('`');
            return result;
        },

        ModuleSpecifier: function (expr, precedence, flags) {
            return this.Literal(expr, precedence, flags);
        },

        ImportExpression: function(expr, precedence, flag) {
            return parenthesize([
                'import(',
                this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
                ')'
            ], Precedence.Call, precedence);
        }
    };

    merge(CodeGenerator.prototype, CodeGenerator.Expression);

    CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
        var result, type;

        type = expr.type || Syntax.Property;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, precedence);
        }

        result = this[type](expr, precedence, flags);


        if (extra.comment) {
            result = addComments(expr, result);
        }
        return toSourceNodeWhenNeeded(result, expr);
    };

    CodeGenerator.prototype.generateStatement = function (stmt, flags) {
        var result,
            fragment;

        result = this[stmt.type](stmt, flags);

        // Attach comments

        if (extra.comment) {
            result = addComments(stmt, result);
        }

        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
        }

        return toSourceNodeWhenNeeded(result, stmt);
    };

    function generateInternal(node) {
        var codegen;

        codegen = new CodeGenerator();
        if (isStatement(node)) {
            return codegen.generateStatement(node, S_TFFF);
        }

        if (isExpression(node)) {
            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
        }

        throw new Error('Unknown node type: ' + node.type);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        sourceCode = options.sourceCode;
        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                SourceNode = require('source-map').SourceNode;
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        }

        result = generateInternal(node);

        if (!sourceMap) {
            pair = {code: result.toString(), map: null};
            return options.sourceMapWithCode ? pair : pair.code;
        }


        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap,
                                      options.sourceContent);
        }

        if (options.sourceMapWithCode) {
            return pair;
        }

        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    exports.version = require('./package.json').version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.Precedence = updateDeeply({}, Precedence);
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./package.json":10,"estraverse":12,"esutils":16,"source-map":27}],10:[function(require,module,exports){
module.exports={
    "name": "escodegen",
    "description": "ECMAScript code generator",
    "homepage": "http://github.com/estools/escodegen",
    "main": "escodegen.js",
    "bin": {
        "esgenerate": "./bin/esgenerate.js",
        "escodegen": "./bin/escodegen.js"
    },
    "files": [
        "LICENSE.BSD",
        "README.md",
        "bin",
        "escodegen.js",
        "package.json"
    ],
    "version": "2.0.0",
    "engines": {
        "node": ">=6.0"
    },
    "maintainers": [
        {
            "name": "Yusuke Suzuki",
            "email": "utatane.tea@gmail.com",
            "web": "http://github.com/Constellation"
        }
    ],
    "repository": {
        "type": "git",
        "url": "http://github.com/estools/escodegen.git"
    },
    "dependencies": {
        "estraverse": "^5.2.0",
        "esutils": "^2.0.2",
        "esprima": "^4.0.1",
        "optionator": "^0.8.1"
    },
    "optionalDependencies": {
        "source-map": "~0.6.1"
    },
    "devDependencies": {
        "acorn": "^7.3.1",
        "bluebird": "^3.4.7",
        "bower-registry-client": "^1.0.0",
        "chai": "^4.2.0",
        "chai-exclude": "^2.0.2",
        "commonjs-everywhere": "^0.9.7",
        "gulp": "^3.8.10",
        "gulp-eslint": "^3.0.1",
        "gulp-mocha": "^3.0.1",
        "semver": "^5.1.0"
    },
    "license": "BSD-2-Clause",
    "scripts": {
        "test": "gulp travis",
        "unit-test": "gulp test",
        "lint": "gulp lint",
        "release": "node tools/release.js",
        "build-min": "./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
        "build": "./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"
    }
}

},{}],11:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
/* istanbul ignore next */
	else if(typeof exports === 'object')
		exports["esprima"] = factory();
	else
		root["esprima"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __webpack_require__(1);
	var jsx_parser_1 = __webpack_require__(3);
	var parser_1 = __webpack_require__(8);
	var tokenizer_1 = __webpack_require__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __webpack_require__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.1';


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __webpack_require__(4);
	var JSXNode = __webpack_require__(5);
	var jsx_syntax_1 = __webpack_require__(6);
	var Node = __webpack_require__(7);
	var parser_1 = __webpack_require__(8);
	var token_1 = __webpack_require__(13);
	var xhtml_entities_1 = __webpack_require__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __webpack_require__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var error_handler_1 = __webpack_require__(10);
	var messages_1 = __webpack_require__(11);
	var Node = __webpack_require__(7);
	var scanner_1 = __webpack_require__(12);
	var syntax_1 = __webpack_require__(2);
	var token_1 = __webpack_require__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token, lastLineStart) {
	        if (lastLineStart === void 0) { lastLineStart = 0; }
	        var column = token.start - token.lineStart;
	        var line = token.lineNumber;
	        if (column < 0) {
	            column += lastLineStart;
	            line--;
	        }
	        return {
	            index: token.start,
	            line: line,
	            column: column
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements  AssignmentTargets  AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            var lastMarker = markers.pop();
	            while (i > 1) {
	                var marker = markers.pop();
	                var lastLineStart = lastMarker && lastMarker.lineStart;
	                var node = this.startNode(marker, lastLineStart);
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	                lastMarker = marker;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = (!this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */) ||
	            this.lookahead.type === 8 /* StringLiteral */ ||
	            this.lookahead.type === 10 /* Template */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */ && token.value === 'constructor') {
	                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        this.scanner.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var character_1 = __webpack_require__(4);
	var messages_1 = __webpack_require__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.isModule = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C && !this.isModule) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __webpack_require__(10);
	var scanner_1 = __webpack_require__(12);
	var token_1 = __webpack_require__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;
},{}],12:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true*/
(function clone(exports) {
    'use strict';

    var Syntax,
        VisitorOption,
        VisitorKeys,
        BREAK,
        SKIP,
        REMOVE;

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ChainExpression: 'ChainExpression',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportExpression: 'ImportExpression',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        PrivateIdentifier: 'PrivateIdentifier',
        Program: 'Program',
        Property: 'Property',
        PropertyDefinition: 'PropertyDefinition',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        AssignmentPattern: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ChainExpression: ['expression'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'superClass', 'body'],
        ClassExpression: ['id', 'superClass', 'body'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['exported', 'local'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportExpression: ['source'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: ['imported', 'local'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MetaProperty: ['meta', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        PrivateIdentifier: [],
        Program: ['body'],
        Property: ['key', 'value'],
        PropertyDefinition: ['key', 'value'],
        RestElement: [ 'argument' ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handler', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (Array.isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (Array.isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === 'iteration') {
            this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === 'function') {
            this.__fallback = visitor.fallback;
        }

        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }
  
    function candidateExistsInLeaveList(leavelist, candidate) {
        for (var i = leavelist.length - 1; i >= 0; --i) {
            if (leavelist[i].node === candidate) {
                return true;
            }
        }
        return false;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = node.type || element.wrap;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = this.__fallback(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (Array.isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }

                            if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                              continue;
                            }

                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        if (candidateExistsInLeaveList(leavelist, candidate)) {
                          continue;
                        }

                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = this.__fallback(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (Array.isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}(exports));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],13:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],14:[function(require,module,exports){
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    // See `tools/generate-identifier-regex.js`.
    ES5Regex = {
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    // 7.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],15:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) { return false; }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) { return false; }

        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) { return false; }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":14}],16:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = require('./ast');
    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./ast":13,"./code":14,"./keyword":15}],17:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":26}],18:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

},{"./base64":19}],19:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

},{}],20:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

},{}],21:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

},{"./util":26}],22:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],23:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":17,"./base64-vlq":18,"./binary-search":20,"./quick-sort":22,"./util":26}],24:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":17,"./base64-vlq":18,"./mapping-list":21,"./util":26}],25:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":24,"./util":26}],26:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   sources entry.  This value is prepended to the individual
    //   entries in the source field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

},{}],27:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":23,"./lib/source-map-generator":24,"./lib/source-node":25}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pyAST = pyAST;
var _PythonParser = require("./PythonParser.js");
function pyAST(source, program, path) {
  const ast = (0, _PythonParser.parser)(source, {
    filename: path
  });
  ast.file = path;
  console.log(JSON.stringify(ast, 0, 4));
  return ast;
}

},{"./PythonParser.js":2}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.blit = void 0;
const blit = `
#define RESOURCEREF(x) ((js::ResourceRef*)res::x)
#define RESOURCEDECL_T(T, x) const T x[]
#define RESOURCEDECL(x) RESOURCEDECL_T(uint8_t, x)
#define PRINT(str) blit::debug((const char*)(str))
#define PRINTLN() blit::debug("\\n\\r");
#define STRDECL(VAR, LEN, STR) __attribute__ ((aligned)) const std::array<uint8_t, sizeof(js::Buffer) + LEN> VAR = js::bufferFrom<LEN>(STR);

$[[minStringTable]]

#include "blit.h"

namespace res {
$[[resources]]
}

$[[translated]]

void JSinit() {
  {
    js::Local args = js::arguments(0);
    js::call($[[main]], args);
    js::call($[[init]], args);
  }
  js::gc();
}

void JSrender(uint32_t time) {
  PROFILER;
  js::Local args = js::arguments(1);
  js::set(args, V_0, time);
  js::call($[[render]], args);
}

void JSupdate(uint32_t time, uint32_t updateCount) {
  PROFILER;
  {
    js::Local args = js::arguments(1);
    js::set(args, V_0, time);
    for (uint32_t i = 0; i < updateCount; ++i)
      js::call($[[update]], args);
  }
}
`;
exports.blit = blit;

},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.espboy = void 0;
const espboy = `
#define RESOURCEREF(x) ((js::ResourceRef*)res::x)
#define RESOURCEDECL_T(T, x) const T PROGMEM x[]
#define RESOURCEDECL(x) RESOURCEDECL_T(uint8_t, x)
#define PRINT(str) Serial.print((const char*)str)
#define PRINTLN() Serial.print("\\n");
#define STRDECL(VAR, LEN, STR) __attribute__ ((aligned)) const std::array<uint8_t, sizeof(js::Buffer) + LEN> VAR = js::bufferFrom<LEN>(STR);
$[[minStringTable]]

#include "espboy.hpp"

namespace res {
$[[resources]]
}

$[[translated]]

void JSinit() {
  {
    js::Local args = js::arguments(0);
    js::call($[[main]], args);
    js::call($[[init]], args);
  }
  js::gc();
}

void JSupdate(uint32_t time, uint32_t updateCount) {
  {
    js::Local args = js::arguments(1);
    js::set(args, V_0, time);
    for (uint32_t i = 0; i < updateCount; ++i)
      js::call($[[update]], args);
    js::call($[[render]], args);
  }
}
`;
exports.espboy = espboy;

},{}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.galuni = void 0;
const galuni = `
#define RESOURCEREF(x) ((js::ResourceRef*)res::x)
#define RESOURCEDECL_T(T, x) const T x[]
#define RESOURCEDECL(x) RESOURCEDECL_T(uint8_t, x)
#define PRINT(str) do {} while (0)
#define PRINTLN() do {} while (0)
#define STRDECL(VAR, LEN, STR) __attribute__ ((aligned)) const std::array<uint8_t, sizeof(js::Buffer) + LEN> VAR = js::bufferFrom<LEN>(STR);

$[[minStringTable]]

#include "galuni.h"

namespace res {
$[[resources]]
}

$[[translated]]

void JSinit() {
  {
    js::Local args = js::arguments(0);
    js::call($[[main]], args);
    js::call($[[init]], args);
  }
  js::gc();
}

void JSrender(uint32_t time) {
  PROFILER;
  js::Local args = js::arguments(1);
  js::set(args, V_0, time);
  js::call($[[render]], args);
}

void JSupdate(uint32_t time, uint32_t updateCount) {
  PROFILER;
  {
    js::Local args = js::arguments(1);
    js::set(args, V_0, time);
    for (uint32_t i = 0; i < updateCount; ++i)
      js::call($[[update]], args);
  }
}
`;
exports.galuni = galuni;

},{}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.meta = void 0;
const meta = `
#define RESOURCEREF(x) ((js::ResourceRef*)res::x)
#define RESOURCEDECL_T(T, x) const T x[]
#define RESOURCEDECL(x) RESOURCEDECL_T(uint8_t, x)
#define PRINT(str) SerialUSB.print((const char*)str)
#define PRINTLN() SerialUSB.print("\\n");
#define STRDECL(VAR, LEN, STR) __attribute__ ((aligned)) const std::array<uint8_t, sizeof(js::Buffer) + LEN> VAR = js::bufferFrom<LEN>(STR);
$[[minStringTable]]

#include "meta.hpp"

namespace res {
$[[resources]]
}

$[[translated]]

void JSinit() {
  {
    js::Local args = js::arguments(0);
    js::call($[[main]], args);
    js::call($[[init]], args);
  }
  js::gc();
}

void JSupdate(uint32_t time, uint32_t updateCount) {
  PROFILER;
  {
    js::Local args = js::arguments(1);
    js::set(args, V_0, time);
    for (uint32_t i = 0; i < updateCount; ++i)
      js::call($[[update]], args);
    js::call($[[render]], args);
  }
}
`;
exports.meta = meta;

},{}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pico = void 0;
const pico = `
#define RESOURCEREF(x) ((js::ResourceRef*)res::x)
#define RESOURCEDECL_T(T, x) const T x[]
#define RESOURCEDECL(x) RESOURCEDECL_T(uint8_t, x)
#define PRINT(str) blit::debug((const char*)(str))
#define PRINTLN() blit::debug("\\n\\r");
#define STRDECL(VAR, LEN, STR) __attribute__ ((aligned)) const std::array<uint8_t, sizeof(js::Buffer) + LEN> VAR = js::bufferFrom<LEN>(STR);

$[[minStringTable]]

#include "pico.h"

namespace res {
$[[resources]]
}

$[[translated]]

void JSinit() {
  {
    js::Local args = js::arguments(0);
    js::call($[[main]], args);
    js::call($[[init]], args);
  }
  js::gc();
}

void JSrender(uint32_t time) {
  PROFILER;
  js::Local args = js::arguments(1);
  js::set(args, V_0, time);
  js::call($[[render]], args);
}

void JSupdate(uint32_t time, uint32_t updateCount) {
  PROFILER;
  {
    js::Local args = js::arguments(1);
    js::set(args, V_0, time);
    for (uint32_t i = 0; i < updateCount; ++i)
      js::call($[[update]], args);
  }
}
`;
exports.pico = pico;

},{}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pokitto = void 0;
const pokitto = `
#define RESOURCEREF(x) ((js::ResourceRef*)resource::x)
#define RESOURCEDECL_T(T, x) const T x[]
#define RESOURCEDECL(x) RESOURCEDECL_T(uint8_t, x)
#define PRINT(str) LOG((const char*)(str))
#define PRINTLN() LOG("\\n");
#define STRDECL(VAR, LEN, STR) __attribute__ ((aligned)) const std::array<uint8_t, sizeof(js::Buffer) + LEN> VAR = js::bufferFrom<LEN>(STR);

$[[minStringTable]]

#include "api.h"

namespace resource {
$[[resources]]
}

$[[translated]]

void JSinit() {
  {
    js::Local args = js::arguments(0);
    js::call($[[main]], args);
    js::call($[[init]], args);
  }
  js::gc();
}

void JSupdate() {
  {
    js::Local args = js::arguments(1);
    js::set(args, V_0, Pokitto::Core::getTime());
    js::call($[[update]], args);
    js::call($[[render]], args);
  }
}
`;
exports.pokitto = pokitto;

},{}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.std = void 0;
const std = `$[[minStringTable]]

#define PRINT(str) printf("%s", str)
#define PRINTLN() printf("\\n");
#define STRDECL(VAR, LEN, STR) __attribute__ ((aligned)) const std::array<uint8_t, sizeof(js::Buffer) + LEN> VAR = js::bufferFrom<LEN>(STR);

#include "js.hpp"

$[[translated]]

int main() {
  {
    js::Local args = js::arguments(0);
    $[[main]](args, false);
  }
  js::gc();
  return 0;
}`;
exports.std = std;

},{}],36:[function(require,module,exports){
const {Flasher} = require('./Flasher.js');

async function getport() {
    console.log('Looking for port');
    return navigator.serial.getPorts()
        .then(ports => {
            for (var port of ports) {
                console.log("pre-authorized");
                return port;
            }
            const filters = [
                { usbVendorId: 0x0483, usbProductId: 0x5740 },
            ];
            return navigator.serial.requestPort({filters});
        })
}


function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function run(data) {
    const port = await getport();
    await port.open({'baudRate': 115200, 'flowControl': 'hardware'});
    console.log("port open");
    const writer = await port.writable.getWriter();
    await writer.write(data);
    await timeout(1000);
    await writer.close();
    await port.close();
    console.log("port closed");
}

class BlitFlasher extends Flasher {
    async upload() {
        const binary = this.data;
        await this.showConnectPopup();
        const enc = new TextEncoder("ascii");
        const cmd = "32BLPROG" + this.name + "\x00" + binary.byteLength + "\x00";
        const header = enc.encode(cmd);
        const data = new Uint8Array(header.byteLength + binary.byteLength);
        data.set(header, 0);
        data.set(binary, header.byteLength);
        await run(data);
    }
}

module.exports.upload = async function(binary, name = "micojs") {
    const flasher = new BlitFlasher(name + ".blit", new Uint8Array(binary));
    await flasher.upload();
}

},{"./Flasher.js":42}],37:[function(require,module,exports){
const {dom, index} = require('./dom.js');
const {palette} = require('./PreBuild.js');

const toolbox = {
    "kind": "categoryToolbox",
    "contents": [
        {
            "kind":"category",
            "name":"Logic",
            "categorystyle":"logic_category",
            "contents":[
                {"kind":"block", "type":'controls_if'},
                {
                    "kind":"block",
                    "type":"controls_repeat_ext",
                    "inputs":{
                        "TIMES":{
                            "block":{
                                "type":"math_number",
                                "fields":{
                                    "NUM":10
                                }
                            }
                        }
                    }
                },
                {"kind":"block", "type":'controls_repeat'},
                {"kind":"block", "type":'controls_whileUntil'},
                {"kind":"block", "type":'controls_for'},
                {"kind":"block", "type":'controls_forEach'},
                {"kind":"block", "type":'controls_flow_statements'},
                {"kind":"block", "type":"logic_compare" },
                {"kind":"block", "type":"logic_operation" },
                {"kind":"block", "type":"logic_negate" },
                {"kind":"block", "type":"logic_boolean" },
                {"kind":"block", "type":"logic_null" },
                {"kind":"block", "type":"logic_ternary" }
            ]
        },

        {
            "kind":"category",
            "name":"Lists",
            "categorystyle":"list_category",
            "contents":[
                {"kind":"block", "type":'lists_create_empty'},
                {"kind":"block", "type":'lists_length'},
                {"kind":"block", "type":'lists_create_with'},
                {"kind":"block", "type":'lists_getIndex'},
                {"kind":"block", "type":'lists_setIndex'}
            ]
        },

        {
            "kind": "CATEGORY",
            "name": "Variables",
            "custom": "VARIABLE",
            "colour": "%{BKY_VARIABLES_HUE}",
        },
        {
            "kind": "CATEGORY",
            "name": "Functions",
            "custom": "PROCEDURE",
            "colour": "%{BKY_PROCEDURES_HUE}",
        },

        {
            "kind":"category",
            "name":"Math",
            "categorystyle":"math_category",
            "contents":[
                {
                    "kind":"block",
                    "type":"math_number",
                    "fields":{
                        "NUM":123
                    }
                },
                {"kind":"block", "type":"math_arithmetic"},
                {"kind":"block", "type":"math_single"},
                {"kind":"block", "type":"math_trig"},
                {"kind":"block", "type":"math_constant"},
                {"kind":"block", "type":"math_number_property"},
                {"kind":"block", "type":"math_round"},
                {"kind":"block", "type":"math_modulo"},
                {"kind":"block", "type":"math_constrain"},
                {"kind":"block", "type":"math_random_int"},
                {"kind":"block", "type":"math_random_float"},
                {"kind":"block", "type":"math_atan2"}
            ]
        },

        {
            "kind":"category",
            "name":"Text",
            "categorystyle":"text_category",
            "contents":[
                {
                    "kind":"block",
                    "type":"text"
                },
                {
                    "kind":"block",
                    "type":"text_length"
                }
            ]
        }
    ]
};

(function(){

    const JavaScript = Blockly.JavaScript;
    const NameType = Blockly.Names.NameType;
    const valueToCode = JavaScript.valueToCode.bind(JavaScript);

    Blockly.FieldColour.COLUMNS = 8;
    Blockly.FieldColour.COLOURS = "#000000 #0f0f0f #1e1e1e #3d3b00 #00023d #2d2d2d #164420 #201644 #442016 #5b4100 #005b41 #41005b #3f3f3f #2a4254 #542a42 #42542a #196915 #155d69 #331569 #69153b #695415 #7f3b00 #047f00 #00437f #7b007f #4f4f4f #543b62 #62543b #3b6254 #276976 #442776 #762749 #766427 #2a7627 #398a13 #138a54 #135a8a #33138a #8a137c #8a1317 #8a7613 #9e1f00 #5e9e00 #009e5e #001f9e #9e009e #5e5e5e #714b4f #4f714b #4b4f71 #563884 #843856 #847438 #388438 #387484 #25968d #254096 #6d2596 #962560 #964d25 #809625 #25962d #68a912 #12a921 #12a986 #1268a9 #2112a9 #8612a9 #a91268 #a92112 #a98612 #bc0009 #67bc00 #00bcb3 #5400bc #6d6d6d #7e8357 #577e83 #83577e #994161 #998a41 #419944 #418599 #674199 #3f2baf #af2baf #af2b3d #af8a2b #64af2b #2baf64 #2b8aaf #15c58a #158ac5 #1515c5 #8a15c5 #c5158a #c51515 #c58a15 #8ac515 #15c515 #b3db00 #20db00 #00db71 #00b3db #0020db #7100db #db00b3 #db0020 #db7100 #7f7f7f #6b9379 #796b93 #93796b #a99e55 #55a95b #5593a9 #7c55a9 #a95571 #bf3f8e #bf5d3f #b4bf3f #46bf3f #3fbfa5 #3f6abf #813fbf #2b3cd3 #8a2bd3 #d32bac #d32b3c #d38a2b #acd32b #3cd32b #2bd38a #2bacd3 #15e96d #15e9de #157fe9 #2015e9 #9115e9 #e915cd #e91558 #e94715 #e9b715 #a6e915 #31e915 #ffee00 #8e8e8e #788ba5 #a5788b #8ba578 #61bb69 #61a2bb #8d61bb #bb617e #bbb161 #d29c4b #93d24b #4bd276 #4bb9d2 #4f4bd2 #c24bd2 #d24b6d #e835d3 #e8355b #e88535 #d3e835 #5be835 #35e885 #35d3e8 #355be8 #8535e8 #1e70ff #611eff #f71eff #ff1e70 #ff611e #fff71e #70ff1e #1eff61 #1efff7 #9e9e9e #a98ab1 #b1a98a #8ab1a9 #77acc4 #9f77c4 #c4778d #c4be77 #77c480 #77d863 #63d8b3 #6398d8 #9263d8 #d863b9 #d87163 #d8d663 #eb8650 #e9eb50 #81eb50 #50eb86 #50e9eb #5081eb #8650eb #eb50e9 #eb5081 #e53dff #ff843d #57ff3d #3db7ff #adadad #c19a99 #99c19a #9a99c1 #b184d6 #d68499 #d6d284 #84d690 #84b9d6 #70e2ea #707aea #d070ea #ea709d #eaab70 #bfea70 #70ea88 #9fff5b #5bffdb #5b5eff #ff5be1 #ff9a5b #bfbfbf #c9d4aa #aac9d4 #d4aac9 #e995a7 #e9e795 #95e9a4 #95c9e9 #c695e9 #a57fff #ff7f99 #d8ff7f #7fffe5 #cecece #b6e6cd #cdb6e6 #e6cdb6 #ffff9e #9effff #ff9eff #dddddd #bccfff #ffecbc #ededed #ffffff".split(" ");

    JavaScript['math_single'] = function(block) {
        // Math operators with single operand.
        const operator = block.getFieldValue('OP');
        let code;
        let arg;
        if (operator === 'NEG') {
            // Negation is a special case given its different operator precedence.
            arg = JavaScript.valueToCode(block, 'NUM',
                                         JavaScript.ORDER_UNARY_NEGATION) || '0';
            if (arg[0] === '-') {
                // --3 is not legal in JS.
                arg = ' ' + arg;
            }
            code = '-' + arg;
            return [code, JavaScript.ORDER_UNARY_NEGATION];
        }
        if (operator === 'SIN' || operator === 'COS' || operator === 'TAN') {
            arg = JavaScript.valueToCode(block, 'NUM', JavaScript.ORDER_DIVISION) || '0';
        } else {
            arg = JavaScript.valueToCode(block, 'NUM', JavaScript.ORDER_NONE) || '0';
        }
        // First, handle cases which generate values that don't need parentheses
        // wrapping the code.
        switch (operator) {
        case 'ABS':
            code = 'abs(' + arg + ')';
            break;
        case 'ROOT':
            code = 'sqrt(' + arg + ')';
            break;
        case 'LN':
            code = 'log(' + arg + ')';
            break;
        case 'EXP':
            code = 'exp(' + arg + ')';
            break;
        case 'POW10':
            code = 'pow(10,' + arg + ')';
            break;
        case 'ROUND':
            code = 'round(' + arg + ')';
            break;
        case 'ROUNDUP':
            code = 'ceil(' + arg + ')';
            break;
        case 'ROUNDDOWN':
            code = 'floor(' + arg + ')';
            break;
        case 'SIN':
            code = `sin((${arg}) * ${1 / (180 * Math.PI)}`;
            break;
        case 'COS':
            code = `cos((${arg}) * ${1 / (180 * Math.PI)}`;
            break;
        case 'TAN':
            code = `tan((${arg}) * ${1 / (180 * Math.PI)}`;
            break;
        }
        if (code) {
            return [code, JavaScript.ORDER_FUNCTION_CALL];
        }
        // Second, handle cases which generate values that may need parentheses
        // wrapping the code.
        switch (operator) {
        case 'LOG10':
            code = `log(${arg}) * ${1 / (Math.log(10))}`;
            break;
        case 'ASIN':
            code = `asin(${arg}) * ${1 / (Math.PI * 180)}`;
            break;
        case 'ACOS':
            code = `acos(${arg}) * ${1 / (Math.PI * 180)}`;
            break;
        case 'ATAN':
            code = `atan(${arg}) * ${1 / (Math.PI * 180)}`;
            break;
        default:
            throw Error('Unknown math operator: ' + operator);
        }
        return [code, JavaScript.ORDER_DIVISION];
    };

    JavaScript['math_round'] = JavaScript['math_single'];

    JavaScript['math_constant'] = function(block) {
        // Constants: PI, E, the Golden Ratio, sqrt(2), 1/sqrt(2), INFINITY.
        const CONSTANTS = {
            'PI': ['' + Math.PI, JavaScript.ORDER_MEMBER],
            'E': ['' + Math.E, JavaScript.ORDER_MEMBER],
            'GOLDEN_RATIO': ['' + ((1 + Math.sqrt(5)) / 2), JavaScript.ORDER_DIVISION],
            'SQRT2': ['' + Math.SQRT2, JavaScript.ORDER_MEMBER],
            'SQRT1_2': ['' + Math.SQRT1_2, JavaScript.ORDER_MEMBER],
            'INFINITY': ['Infinity', JavaScript.ORDER_ATOMIC],
        };
        return CONSTANTS[block.getFieldValue('CONSTANT')];
    };

    JavaScript['math_random_int'] = function(block) {
        // Random integer between [X] and [Y].
        const argument0 = JavaScript.valueToCode(block, 'FROM', JavaScript.ORDER_NONE) || '0';
        const argument1 = JavaScript.valueToCode(block, 'TO', JavaScript.ORDER_NONE) || '0';
        const code = `rand(${argument0}, ${argument1}, true)`;
        return [code, JavaScript.ORDER_FUNCTION_CALL];
    };

    JavaScript['math_random_float'] = function(block) {
        // Random fraction between 0 and 1.
        return ['rand()', JavaScript.ORDER_FUNCTION_CALL];
    };

    JavaScript['math_atan2'] = function(block) {
        // Arctangent of point (X, Y) in degrees from -180 to 180.
        const argument0 = JavaScript.valueToCode(block, 'X',
                                                 JavaScript.ORDER_NONE) || '0';
        const argument1 = JavaScript.valueToCode(block, 'Y',
                                                 JavaScript.ORDER_NONE) || '0';
        return [`atan2(${argument1}, ${argument0}) * ${1 / (Math.PI * 180)}`, JavaScript.ORDER_DIVISION];
    };

    JavaScript['controls_forEach'] = function(block) {
        const variable0 = JavaScript.nameDB_.getName(block.getFieldValue('VAR'), NameType.VARIABLE);
        const argument0 = JavaScript.valueToCode(block, 'LIST', JavaScript.ORDER_ASSIGNMENT) || '[]';
        let branch = JavaScript.statementToCode(block, 'DO');
        branch = JavaScript.addLoopTrap(branch, block);
        return `for (${variable0} of ${argument0}) {\n${branch}}\n`;
    };

    JavaScript['colour_picker'] = function(block) {
        const color = parseInt((block.getFieldValue('COLOUR') || '#FF0000').substr(1), 16);
        const R = color >> 24;
        const G = (color >> 16) & 0xFF;
        const B = color & 0xFF;
        let closest = 0;
        let closestDist = -1 >>> 0;
        for (let i = 1; i < palette.length; ++i) {
            let tr = palette[i][0] - R;
            let tg = palette[i][1] - G;
            let tb = palette[i][2] - B;
            let d = tr*tr + tg*tg + tb*tb;
            if (d < closestDist) {
                closestDist = d;
                closest = i;
            }
        }
        return ['' + closest, JavaScript.ORDER_ATOMIC];
    };

    JavaScript['math_change'] = function(block) {
        const argument0 = JavaScript.valueToCode(block, 'DELTA', JavaScript.ORDER_ADDITION) || '0';
        const varName = JavaScript.nameDB_.getName(block.getFieldValue('VAR'), NameType.VARIABLE);
        return `${varName} += ${argument0};\n`;
    };

    const components = {
        "MicoJS.debug":{
            message0: "debug %1",
            args0: [
                {
                    "type": "input_value",
                    "name": "TEXT"
                }
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 19,
            tooltip: "prints a value in the console",
            helpUrl: "https://github.com/micojs/micojs.github.io/wiki/API#debugargsvoid",
            javascript: block => `debug(${valueToCode(block, 'TEXT', JavaScript.ORDER_NONE) || "''"});\n`
        },

        "MicoJS.resource":{
            message0: "file: %1",
            args0: [
                {
                    "type": "field_input",
                    "name": "TEXT",
                    "text": "file.png"
                }
            ],
            output: null,
            colour: 131,
            tooltip: "For image, tilemap or sound files",
            helpUrl: "https://github.com/micojs/micojs.github.io/wiki/API#debugargsvoid",
            javascript: block => [`R.${(block.getFieldValue("TEXT") || '').split('/').pop().split('.')[0].replace(/^[^a-zA-Z_]+|[^a-zA-Z0-9_]+/gi, '')}`, JavaScript.ORDER_FUNCTION_CALL]
        },

        "MicoJS.clear":{
            message0: "clear screen",
            args0: [],
            previousStatement: null,
            nextStatement: null,
            colour: 230,
            tooltip: "Clears the screen with the active color",
            helpUrl: "https://github.com/micojs/micojs.github.io/wiki/API#debugargsvoid",
            javascript: block => `clear();\n`
        },

        "MicoJS.setPen":{
            message0: "set pen %1",
            args0: [
                {
                    "type": "input_value", "name": "COLOR",
                    "block":{"type":"colour_picker"}
                }
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 230,
            tooltip: "Sets the active color",
            helpUrl: "https://github.com/micojs/micojs.github.io/wiki/API#textmessagestring-xnumber-ynumbervoid",
            javascript: block => `setPen(${valueToCode(block, 'COLOR', JavaScript.ORDER_NONE) || "''"});\n`
        },

        "MicoJS.clearPen":{
            message0: "reset pen",
            args0: [],
            previousStatement: null,
            nextStatement: null,
            colour: 230,
            tooltip: "Clears the active color",
            helpUrl: "https://github.com/micojs/micojs.github.io/wiki/API#textmessagestring-xnumber-ynumbervoid",
            javascript: block => `setPen(0);\n`
        },

        "MicoJS.setFont":{
            message0: "set font: %1",
            args0: [
                {
                    "type": "field_dropdown",
                    "name": "FONT",
                    "options": [
                        ['Mini', 'fontMini'],
                        ['TIC806x6', 'fontTIC806x6'],
                        ['ZXSpec', 'fontZXSpec'],
                        ['Adventurer', 'fontAdventurer'],
                        ['Donut', 'fontDonut'],
                        ['Dragon', 'fontDragon'],
                        ['C64', 'fontC64'],
                        ['64UIGfx', 'fntC64UIGfx'],
                        ['Monkey', 'fontMonkey'],
                        ['Karateka', 'fontKarateka'],
                        ['Koubit', 'fontKoubit'],
                        ['Runes', 'fontRunes'],
                        ['Tight', 'fontTight'],
                        ['Tiny', 'fontTiny']
                    ]
                }
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 230,
            tooltip: "Sets the active font",
            helpUrl: "https://github.com/micojs/micojs.github.io/wiki/API#textmessagestring-xnumber-ynumbervoid",
            javascript: block => `setFont(R.${block.getFieldValue("FONT") || 'Mini'});\n`
        },

        "MicoJS.button":{
            message0: "button %1 pressed",
            args0: [
                {
                    "type": "field_dropdown",
                    "name": "BUTTON",
                    "options": [
                        ['A', 'A'],
                        ['B', 'B'],
                        ['C', 'C'],
                        ['D', 'D'],
                        ['UP', 'UP'],
                        ['DOWN', 'DOWN'],
                        ['LEFT', 'LEFT'],
                        ['RIGHT', 'RIGHT']
                    ]
                }
            ],
            output: null,
            colour: 230,
            tooltip: "TRUE if button is held down",
            helpUrl: "https://github.com/micojs/micojs.github.io/wiki/API#textmessagestring-xnumber-ynumbervoid",
            javascript: block => [block.getFieldValue("BUTTON") || 'A', JavaScript.ORDER_FUNCTION_CALL]
        },

        "MicoJS.showText":{
            message0: "show text: %1 X: %2 Y: %3",
            args0: [
                {
                    "type": "input_value",
                    "name": "TEXT",
                    "block":{"type":"text"}
                },
                {
                    "type": "input_value",
                    "name": "X",
                    "block":{"type":"math_number"}
                },
                {
                    "type": "input_value",
                    "name": "Y",
                    "block":{"type":"math_number"}
                }
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 230,
            tooltip: "prints a value in the screen",
            helpUrl: "https://github.com/micojs/micojs.github.io/wiki/API#textmessagestring-xnumber-ynumbervoid",
            javascript: block => `text(${valueToCode(block, 'TEXT', JavaScript.ORDER_NONE) || "''"}, ${valueToCode(block, 'X', JavaScript.ORDER_NONE) || "0"}, ${valueToCode(block, 'Y', JavaScript.ORDER_NONE) || "0"});\n`
        },

        "MicoJS.showImage":{
            message0: "show image: %1 X: %2 Y: %3 ANGLE: %4 SCALE: %5",
            args0: [
                {
                    "type": "input_value",
                    "name": "TEXT",
                    "block":{"type":"resource"}
                },
                {
                    "type": "input_value",
                    "name": "X",
                    "block":{"type":"math_number"}
                },
                {
                    "type": "input_value",
                    "name": "Y",
                    "block":{"type":"math_number"}
                },
                {
                    "type": "input_value",
                    "name": "ANGLE",
                    "block":{"type":"math_number"}
                },
                {
                    "type": "input_value",
                    "name": "SCALE",
                    "block":{"type":"math_number", "fields":{"NUM":1}}
                }
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 231,
            tooltip: "draws an image on the screen",
            helpUrl: "https://github.com/micojs/micojs.github.io/wiki/API#textmessagestring-xnumber-ynumbervoid",
            javascript: block => `image(${valueToCode(block, 'TEXT', JavaScript.ORDER_NONE) || "''"}, ${valueToCode(block, 'X', JavaScript.ORDER_NONE) || "0"}, ${valueToCode(block, 'Y', JavaScript.ORDER_NONE) || "0"}, (${valueToCode(block, 'ANGLE', JavaScript.ORDER_NONE) || "0"}) * ${1 / (180 * Math.PI)}, ${valueToCode(block, 'SCALE', JavaScript.ORDER_NONE) || "1"});\n`
        }

    };

    for (let path in components) {
        const parts = path.split('.');
        const type = parts.pop();
        const component = Object.assign({}, components[path]);
        let container = toolbox;
        while (parts.length) {
            const name = parts.shift();
            let index = container.contents.findIndex(c => c.name == name);
            if (index == -1) {
                container.contents.push({
                    name,
                    kind:'category',
                    categorystyle:"colour_category",
                    contents:[]
                });
                index = container.contents.length - 1;
            }
            container = container.contents[index];
        }

        const toolboxItem = {
            type,
            name:type.toUpperCase(),
            kind:'block'
        };

        if (component.args0) {
            component.args0 = component.args0.map(arg => {
                if ("block" in arg) {
                    if (!toolboxItem.inputs)
                        toolboxItem.inputs = {};
                    toolboxItem.inputs[arg.name] = {block:arg.block};
                }
                if ("fields" in arg) {
                    if (!toolboxItem.fields)
                        toolboxItem.fields = {};
                    toolboxItem.fields[arg.name] = arg.fields;
                }
                return arg;
            });
        }

        component.type = type;
        JavaScript[type] = component.javascript;
        delete component.javascript;
        Blockly.defineBlocksWithJsonArray([component]);
        container.contents.push(toolboxItem);
    }

})();

const theme = {
  'base': Blockly.Themes.Classic,
  'componentStyles': {
    'workspaceBackgroundColour': '#1e1e1e',
    'toolboxBackgroundColour': 'blackBackground',
    'toolboxForegroundColour': '#fff',
    'flyoutBackgroundColour': '#252526',
    'flyoutForegroundColour': '#ccc',
    'flyoutOpacity': 1,
    'scrollbarColour': '#797979',
    'insertionMarkerColour': '#fff',
    'insertionMarkerOpacity': 0.3,
    'scrollbarOpacity': 0.4,
    'cursorColour': '#d0d0d0',
    'blackBackground': '#333',
  },
};

class BlockEditor {
    #dom;
    #fs;
    #workspace;

    path;

    constructor(parentElement, path, contents, fs) {
        this.path = path;
        this.#fs = fs;
        this.#workspace = Blockly.inject(parentElement, {theme, toolbox});
        this.contents = '';

        this.#workspace.addChangeListener(event => {
            const code = Blockly.JavaScript.workspaceToCode(this.#workspace);
            this.#fs.writeFile(this.path.replace(/\.block$/i, '.js'), code);
            this.commit();
        });

        this.reload();
    }

    reload() {
        const contents = this.#fs.readFile(this.path);
        if (contents != this.contents) {
            const state = JSON.parse(contents);
            Blockly.serialization.workspaces.load(state, this.#workspace)
            this.contents = contents;
        }
    }

    commit() {
        const contents = JSON.stringify(Blockly.serialization.workspaces.save(this.#workspace));
        if (contents != this.contents) {
            this.#fs.writeFile(this.path, contents);
            this.contents = contents;
        }
    }
};

module.exports.BlockEditor = BlockEditor;

},{"./PreBuild.js":46,"./dom.js":62}],38:[function(require,module,exports){
const {JSC} = require('../JSC/jsc.js');
const {dom, index} = require('./dom.js');

let assets;
let browser;

async function buildHTML(code, [width, height]) {
    return `<!doctype html>
<html>
<head>
<style>
html, body, canvas {
width: 100%;
height: 100%;
position: absolute;
overflow: hidden;
margin: 0;
border: 0;
padding: 0;
left: 0;
right: 0;
top: 0;
bottom: 0;
}
canvas {
margin: auto;
image-rendering: pixelated;
}
</style>
<script>
${code}
</script>
</head>
<body>
<canvas id=canvas width=${width} height=${height}></canvas>
</body>
</html>`
}

const decompressor = u => {
var i,c,e=new Image,s=String.fromCharCode,a='';
e.onload=_=>{
u=document.createElement('canvas');
u.width=i=e.naturalWidth|0;
u.height=c=e.naturalHeight|0;
u=u.getContext('2d');
u.drawImage(e,0,0);
u=u.getImageData(0,0,i,c).data;
i=0;
while(i<u.length){a+=s(u[i++]||32);a+=s(u[i++]||32);a+=s(u[i]||32);i+=2;}
eval(a);
};
e.src=u;
};

function compress(src) {
    const dim = Math.ceil(Math.sqrt(Math.ceil(src.length/3)));
    const img = dom('canvas', {width:dim, height:dim});
    const ctx = img.getContext('2d');
    const id = ctx.getImageData(0, 0, dim, dim);
    const data = id.data;
    let j = 0;
    for (let i = 0; i < src.length;) {
        data[j++] = src.charCodeAt(i++);
        data[j++] = src.charCodeAt(i++);
        data[j++] = src.charCodeAt(i++);
        data[j++] = 255;
    }
    ctx.putImageData(id, 0, 0);
    const url = img.toDataURL();
    const out = `(${decompressor})('${url}')`;
    return out;
}

async function build(fs, size) {
    if (!assets)
        assets = await (await fetch('assets.js?nc=' + Math.random())).text();
    if (!browser)
        browser = await (await fetch('browser.js?nc=' + Math.random())).text();
    const compiler = new JSC(path => fs.readFile(path));
    compiler.include('/std.js');
    fs.ls('/.R/')?.forEach?.(entry => {
        if (entry.isFile())
            compiler.include('/.R/' + entry.name);
    });
    compiler.process();
    const code = assets + browser + compiler.write('js');
    const compressed = compress(code);
    return await buildHTML(compressed, size);
}

module.exports.build = build;

},{"../JSC/jsc.js":7,"./dom.js":62}],39:[function(require,module,exports){
const {dom} = require('./dom.js');

class Console {
    maxLines = 1000;
    #prevLine = {
        text:null,
        count:0,
        el:null
    };
    onAppend;

    #tweens = 0;
    #interval;

    constructor(filter) {
        this.el = dom('div', {className:'console'});

        if (typeof filter == 'string')
            filter = ((filter, msg) => msg[filter]).bind(this, filter);

        window.addEventListener('message', event => {
            let msgs = filter(event.data);
            if (!Array.isArray(msgs)) {
                if (typeof msgs == 'object' && msgs) {
                    for (let key in msgs) {
                        this[key](msgs[key]);
                    }
                }
                return;
            }

            let top = this.el.scrollTop;

            for (let msg of msgs) {
                this.append(msg);
            }

            setTimeout(_=>this.el.scrollTop = top, 0);
            this.tween();

            if (this.onAppend)
                this.onAppend();
        });
    }

    clear() {
        while (this.el.children.length)
            this.el.children[0].remove();
    }

    tween() {
        this.#tweens = 30;
        if (this.#interval)
            return;
        this.#interval = setInterval(_=>{
            this.el.scrollTop = (this.el.scrollTop * 13 + this.el.scrollHeight) / 14;
            this.#tweens--;
            if (this.#tweens <= 0) {
                clearInterval(this.#interval);
                this.#interval = 0;
            }
        }, 1000 / this.#tweens);
    }

    append(msg) {
        if (Array.isArray(msg))
            msg = msg.join(' ');

        const line = (msg + '');

        if (line === this.#prevLine.text) {
            this.#prevLine.count++;
            this.#prevLine.el.classList.add('repeat');
            this.#prevLine.el.setAttribute('repeat', this.#prevLine.count);
        } else {
            while (this.el.children.length >= this.maxLines)
                this.el.children[0].remove();
            this.#prevLine.text = line;
            this.#prevLine.count = 1;
            this.#prevLine.el = dom(this.el, 'pre', {
                className:'line',
                textContent:line,
                attr:{
                    time:(new Date()).toLocaleString()
                }
            });
        }
    }
}

module.exports.Console = Console;

},{"./dom.js":62}],40:[function(require,module,exports){
const esptool = require('./esptool.js');
const {Flasher} = require('./Flasher.js');


class ESPBoyFlasher extends Flasher {
    stub;

    async disconnect() {
        if (!this.stub)
            return;
        await this.stub.disconnect();
        await this.stub.port.close();
        this.stub = undefined;
    }

    async connect() {
        if (this.stub)
            return;

        const esploader = await esptool.connect({
            log: this.log,
            debug: this.log,
            error: this.log
        });

        try {
            await esploader.initialize();

            this.log("Connected to " + esploader.chipName);

            this.stub = await esploader.runStub();
            this.stub.addEventListener("disconnect", () => {
                this.stub = false;
            });
        } finally {
            // esploader.disconnect();
        }
    }

    async upload() {
        const binary = this.data.buffer;
        if (!this.stub) {
            await this.showConnectPopup();
            await this.connect();
        }
        if (this.stub) {
            await this.stub.flashData(
                binary,
                (bytesWritten, totalBytes) => {
                    postMessage({build:["Uploading: " + Math.floor((bytesWritten / totalBytes) * 100) + "%"]}, '*');
                },
                0
            );
            await this.disconnect();
        }
    }
}

module.exports.upload = async function(binary, name = "micojs") {
    const flasher = new ESPBoyFlasher(name + ".bin", new Uint8Array(binary));
    await flasher.upload();
}

},{"./Flasher.js":42,"./esptool.js":63}],41:[function(require,module,exports){
const JSZip = require('jszip');
const {saveAs} = require('file-saver');

module.exports.FS2Zip = async function(fs) {
    const zip = new JSZip();

    fs.recurse((entity, path) => {
        const strpath = path.join('/');
        if (entity.isDirectory()) {
            if (strpath)
                zip.folder(strpath);
        } else if (entity.isFile()) {
            let data = entity.node.data;
            let opt = {};
            if (/^data:[^;]+;base64,/.test(data)) {
                data = data.substr(data.indexOf(',') + 1);
                opt.base64 = true;
            }
            zip.file(strpath, data, opt);
        }
    });

    const content = await zip.generateAsync({type:"blob"})
    saveAs(content, "micojs-project.zip");
};

function getFileExtension(name) {
    return (name.match(/\.[^./\\]+$/) || [""])[0];
}

module.exports.Zip2FS = async function(fr, fs) {
    const zip = await JSZip.loadAsync(fr.result);
    const promises = [];
    zip.forEach(recurse);
    await Promise.all(promises);

    async function recurse(relativePath, file) {
        console.log("Recurse ", relativePath, file);
        if (file.dir) {
            fs.mkdir(relativePath.substr(0, relativePath.length - 1));
            zip.folder(file.name).forEach(recurse);
            return;
        }

        let ready;
        promises.push(new Promise((resolve) => {ready = resolve;}));

        let contents;
        const extension = getFileExtension(file.name);
        const mime = getMimeType(extension);
        if (mime.indexOf('text') != -1 || mime == 'application/javascript' || mime == 'application/json' || extension == '.meta') {
            contents = await zip.file(file.name).async('string');
        } else {
            contents = await zip.file(file.name).async('base64');
            const str = atob(contents);
            let ascii = true;
            for (let i = 0, max = str.length; i < max; ++i) {
                let code = str.charCodeAt(i);
                if (code == 0 || code >= 128) {
                    ascii = false;
                    break;
                }
            }
            if (ascii) {
                contents = str;
            } else {
                contents = 'data:' + mime + ';base64,' + contents;
            }
        }

        fs.writeFile(file.name, contents);
        ready();
    }
};

module.exports.getMimeType = getMimeType;

function getMimeType(ext) {
    ext = getFileExtension(ext).toLowerCase();

    return ({
	".123"			: "application/vnd.lotus-1-2-3",
	".3dml"			: "text/vnd.in3d.3dml",
	".3g2"			: "video/3gpp2",
	".3gp"			: "video/3gpp",
	".a"			: "application/octet-stream",
	".aab"			: "application/x-authorware-bin",
	".aac"			: "audio/x-aac",
	".aam"			: "application/x-authorware-map",
	".aas"			: "application/x-authorware-seg",
	".abw"			: "application/x-abiword",
	".acc"			: "application/vnd.americandynamics.acc",
	".ace"			: "application/x-ace-compressed",
	".acu"			: "application/vnd.acucobol",
	".acutc"		: "application/vnd.acucorp",
	".adp"			: "audio/adpcm",
	".aep"			: "application/vnd.audiograph",
	".afm"			: "application/x-font-type1",
	".afp"			: "application/vnd.ibm.modcap",
	".ai"			: "application/postscript",
	".aif"			: "audio/x-aiff",
	".aifc"			: "audio/x-aiff",
	".aiff"			: "audio/x-aiff",
	".air"			: "application/vnd.adobe.air-application-installer-package+zip",
	".ami"			: "application/vnd.amiga.ami",
	".apk"			: "application/vnd.android.package-archive",
	".application"		: "application/x-ms-application",
	".apr"			: "application/vnd.lotus-approach",
	".asc"			: "application/pgp-signature",
	".asf"			: "video/x-ms-asf",
	".asm"			: "text/x-asm",
	".aso"			: "application/vnd.accpac.simply.aso",
	".asx"			: "video/x-ms-asf",
	".atc"			: "application/vnd.acucorp",
	".atom"			: "application/atom+xml",
	".atomcat"		: "application/atomcat+xml",
	".atomsvc"		: "application/atomsvc+xml",
	".atx"			: "application/vnd.antix.game-component",
	".au"			: "audio/basic",
	".avi"			: "video/x-msvideo",
	".aw"			: "application/applixware",
	".azf"			: "application/vnd.airzip.filesecure.azf",
	".azs"			: "application/vnd.airzip.filesecure.azs",
	".azw"			: "application/vnd.amazon.ebook",
	".bat"			: "application/x-msdownload",
	".bcpio"		: "application/x-bcpio",
	".bdf"			: "application/x-font-bdf",
	".bdm"			: "application/vnd.syncml.dm+wbxml",
	".bh2"			: "application/vnd.fujitsu.oasysprs",
	".bin"			: "application/octet-stream",
	".bmi"			: "application/vnd.bmi",
	".bmp"			: "image/bmp",
	".book"			: "application/vnd.framemaker",
	".box"			: "application/vnd.previewsystems.box",
	".boz"			: "application/x-bzip2",
	".bpk"			: "application/octet-stream",
	".btif"			: "image/prs.btif",
	".bz"			: "application/x-bzip",
	".bz2"			: "application/x-bzip2",
	".c"			: "text/x-c",
	".c4d"			: "application/vnd.clonk.c4group",
	".c4f"			: "application/vnd.clonk.c4group",
	".c4g"			: "application/vnd.clonk.c4group",
	".c4p"			: "application/vnd.clonk.c4group",
	".c4u"			: "application/vnd.clonk.c4group",
	".cab"			: "application/vnd.ms-cab-compressed",
	".car"			: "application/vnd.curl.car",
	".cat"			: "application/vnd.ms-pki.seccat",
	".cc"			: "text/x-c",
	".cct"			: "application/x-director",
	".ccxml"		: "application/ccxml+xml",
	".cdbcmsg"		: "application/vnd.contact.cmsg",
	".cdf"			: "application/x-netcdf",
	".cdkey"		: "application/vnd.mediastation.cdkey",
	".cdx"			: "chemical/x-cdx",
	".cdxml"		: "application/vnd.chemdraw+xml",
	".cdy"			: "application/vnd.cinderella",
	".cer"			: "application/pkix-cert",
	".cgm"			: "image/cgm",
	".chat"			: "application/x-chat",
	".chm"			: "application/vnd.ms-htmlhelp",
	".chrt"			: "application/vnd.kde.kchart",
	".cif"			: "chemical/x-cif",
	".cii"			: "application/vnd.anser-web-certificate-issue-initiation",
	".cil"			: "application/vnd.ms-artgalry",
	".cla"			: "application/vnd.claymore",
	".class"		: "application/java-vm",
	".clkk"			: "application/vnd.crick.clicker.keyboard",
	".clkp"			: "application/vnd.crick.clicker.palette",
	".clkt"			: "application/vnd.crick.clicker.template",
	".clkw"			: "application/vnd.crick.clicker.wordbank",
	".clkx"			: "application/vnd.crick.clicker",
	".clp"			: "application/x-msclip",
	".cmc"			: "application/vnd.cosmocaller",
	".cmdf"			: "chemical/x-cmdf",
	".cml"			: "chemical/x-cml",
	".cmp"			: "application/vnd.yellowriver-custom-menu",
	".cmx"			: "image/x-cmx",
	".cod"			: "application/vnd.rim.cod",
	".com"			: "application/x-msdownload",
	".conf"			: "text/plain",
	".cpio"			: "application/x-cpio",
	".cpp"			: "text/x-c",
	".cpt"			: "application/mac-compactpro",
	".crd"			: "application/x-mscardfile",
	".crl"			: "application/pkix-crl",
	".crt"			: "application/x-x509-ca-cert",
	".csh"			: "application/x-csh",
	".csml"			: "chemical/x-csml",
	".csp"			: "application/vnd.commonspace",
	".css"			: "text/css",
	".cst"			: "application/x-director",
	".csv"			: "text/csv",
	".cu"			: "application/cu-seeme",
	".curl"			: "text/vnd.curl",
	".cww"			: "application/prs.cww",
	".cxt"			: "application/x-director",
	".cxx"			: "text/x-c",
	".daf"			: "application/vnd.mobius.daf",
	".dataless"		: "application/vnd.fdsn.seed",
	".davmount"		: "application/davmount+xml",
	".dcr"			: "application/x-director",
	".dcurl"		: "text/vnd.curl.dcurl",
	".dd2"			: "application/vnd.oma.dd2+xml",
	".ddd"			: "application/vnd.fujixerox.ddd",
	".deb"			: "application/x-debian-package",
	".def"			: "text/plain",
	".deploy"		: "application/octet-stream",
	".der"			: "application/x-x509-ca-cert",
	".dfac"			: "application/vnd.dreamfactory",
	".dic"			: "text/x-c",
	".diff"			: "text/plain",
	".dir"			: "application/x-director",
	".dis"			: "application/vnd.mobius.dis",
	".dist"			: "application/octet-stream",
	".distz"		: "application/octet-stream",
	".djv"			: "image/vnd.djvu",
	".djvu"			: "image/vnd.djvu",
	".dll"			: "application/x-msdownload",
	".dmg"			: "application/octet-stream",
	".dms"			: "application/octet-stream",
	".dna"			: "application/vnd.dna",
	".doc"			: "application/msword",
	".docm"			: "application/vnd.ms-word.document.macroenabled.12",
	".docx"			: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
	".dot"			: "application/msword",
	".dotm"			: "application/vnd.ms-word.template.macroenabled.12",
	".dotx"			: "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
	".dp"			: "application/vnd.osgi.dp",
	".dpg"			: "application/vnd.dpgraph",
	".dsc"			: "text/prs.lines.tag",
	".dtb"			: "application/x-dtbook+xml",
	".dtd"			: "application/xml-dtd",
	".dts"			: "audio/vnd.dts",
	".dtshd"		: "audio/vnd.dts.hd",
	".dump"			: "application/octet-stream",
	".dvi"			: "application/x-dvi",
	".dwf"			: "model/vnd.dwf",
	".dwg"			: "image/vnd.dwg",
	".dxf"			: "image/vnd.dxf",
	".dxp"			: "application/vnd.spotfire.dxp",
	".dxr"			: "application/x-director",
	".ecelp4800"		: "audio/vnd.nuera.ecelp4800",
	".ecelp7470"		: "audio/vnd.nuera.ecelp7470",
	".ecelp9600"		: "audio/vnd.nuera.ecelp9600",
	".ecma"			: "application/ecmascript",
	".edm"			: "application/vnd.novadigm.edm",
	".edx"			: "application/vnd.novadigm.edx",
	".efif"			: "application/vnd.picsel",
	".ei6"			: "application/vnd.pg.osasli",
	".elc"			: "application/octet-stream",
	".eml"			: "message/rfc822",
	".emma"			: "application/emma+xml",
	".eol"			: "audio/vnd.digital-winds",
	".eot"			: "application/vnd.ms-fontobject",
	".eps"			: "application/postscript",
	".epub"			: "application/epub+zip",
	".es3"			: "application/vnd.eszigno3+xml",
	".esf"			: "application/vnd.epson.esf",
	".et3"			: "application/vnd.eszigno3+xml",
	".etx"			: "text/x-setext",
	".exe"			: "application/x-msdownload",
	".ext"			: "application/vnd.novadigm.ext",
	".ez"			: "application/andrew-inset",
	".ez2"			: "application/vnd.ezpix-album",
	".ez3"			: "application/vnd.ezpix-package",
	".f"			: "text/x-fortran",
	".f4v"			: "video/x-f4v",
	".f77"			: "text/x-fortran",
	".f90"			: "text/x-fortran",
	".fbs"			: "image/vnd.fastbidsheet",
	".fdf"			: "application/vnd.fdf",
	".fe_launch"		: "application/vnd.denovo.fcselayout-link",
	".fg5"			: "application/vnd.fujitsu.oasysgp",
	".fgd"			: "application/x-director",
	".fh"			: "image/x-freehand",
	".fh4"			: "image/x-freehand",
	".fh5"			: "image/x-freehand",
	".fh7"			: "image/x-freehand",
	".fhc"			: "image/x-freehand",
	".fig"			: "application/x-xfig",
	".fli"			: "video/x-fli",
	".flo"			: "application/vnd.micrografx.flo",
	".flv"			: "video/x-flv",
	".flw"			: "application/vnd.kde.kivio",
	".flx"			: "text/vnd.fmi.flexstor",
	".fly"			: "text/vnd.fly",
	".fm"			: "application/vnd.framemaker",
	".fnc"			: "application/vnd.frogans.fnc",
	".for"			: "text/x-fortran",
	".fpx"			: "image/vnd.fpx",
	".frame"		: "application/vnd.framemaker",
	".fsc"			: "application/vnd.fsc.weblaunch",
	".fst"			: "image/vnd.fst",
	".ftc"			: "application/vnd.fluxtime.clip",
	".fti"			: "application/vnd.anser-web-funds-transfer-initiation",
	".fvt"			: "video/vnd.fvt",
	".fzs"			: "application/vnd.fuzzysheet",
	".g3"			: "image/g3fax",
	".gac"			: "application/vnd.groove-account",
	".gdl"			: "model/vnd.gdl",
	".geo"			: "application/vnd.dynageo",
	".gex"			: "application/vnd.geometry-explorer",
	".ggb"			: "application/vnd.geogebra.file",
	".ggt"			: "application/vnd.geogebra.tool",
	".ghf"			: "application/vnd.groove-help",
	".gif"			: "image/gif",
	".gim"			: "application/vnd.groove-identity-message",
	".gmx"			: "application/vnd.gmx",
	".gnumeric"		: "application/x-gnumeric",
	".gph"			: "application/vnd.flographit",
	".gqf"			: "application/vnd.grafeq",
	".gqs"			: "application/vnd.grafeq",
	".gram"			: "application/srgs",
	".gre"			: "application/vnd.geometry-explorer",
	".grv"			: "application/vnd.groove-injector",
	".grxml"		: "application/srgs+xml",
	".gsf"			: "application/x-font-ghostscript",
	".gtar"			: "application/x-gtar",
	".gtm"			: "application/vnd.groove-tool-message",
	".gtw"			: "model/vnd.gtw",
	".gv"			: "text/vnd.graphviz",
	".gz"			: "application/x-gzip",
	".h"			: "text/x-c",
	".h261"			: "video/h261",
	".h263"			: "video/h263",
	".h264"			: "video/h264",
	".hbci"			: "application/vnd.hbci",
	".hdf"			: "application/x-hdf",
	".hh"			: "text/x-c",
	".hlp"			: "application/winhlp",
	".hpgl"			: "application/vnd.hp-hpgl",
	".hpid"			: "application/vnd.hp-hpid",
	".hps"			: "application/vnd.hp-hps",
	".hqx"			: "application/mac-binhex40",
	".htke"			: "application/vnd.kenameaapp",
	".htm"			: "text/html",
	".html"			: "text/html",
	".hvd"			: "application/vnd.yamaha.hv-dic",
	".hvp"			: "application/vnd.yamaha.hv-voice",
	".hvs"			: "application/vnd.yamaha.hv-script",
	".icc"			: "application/vnd.iccprofile",
	".ice"			: "x-conference/x-cooltalk",
	".icm"			: "application/vnd.iccprofile",
	".ico"			: "image/x-icon",
	".ics"			: "text/calendar",
	".ief"			: "image/ief",
	".ifb"			: "text/calendar",
	".ifm"			: "application/vnd.shana.informed.formdata",
	".iges"			: "model/iges",
	".igl"			: "application/vnd.igloader",
	".igs"			: "model/iges",
	".igx"			: "application/vnd.micrografx.igx",
	".iif"			: "application/vnd.shana.informed.interchange",
	".imp"			: "application/vnd.accpac.simply.imp",
	".ims"			: "application/vnd.ms-ims",
	".in"			: "text/plain",
	".ipk"			: "application/vnd.shana.informed.package",
	".irm"			: "application/vnd.ibm.rights-management",
	".irp"			: "application/vnd.irepository.package+xml",
	".iso"			: "application/octet-stream",
	".itp"			: "application/vnd.shana.informed.formtemplate",
	".ivp"			: "application/vnd.immervision-ivp",
	".ivu"			: "application/vnd.immervision-ivu",
	".jad"			: "text/vnd.sun.j2me.app-descriptor",
	".jam"			: "application/vnd.jam",
	".jar"			: "application/java-archive",
	".java"			: "text/x-java-source",
	".jisp"			: "application/vnd.jisp",
	".jlt"			: "application/vnd.hp-jlyt",
	".jnlp"			: "application/x-java-jnlp-file",
	".joda"			: "application/vnd.joost.joda-archive",
	".jpe"			: "image/jpeg",
	".jpeg"			: "image/jpeg",
	".jpg"			: "image/jpeg",
	".jpgm"			: "video/jpm",
	".jpgv"			: "video/jpeg",
	".jpm"			: "video/jpm",
	".js"			: "application/javascript",
	".json"			: "application/json",
	".block"		: "application/json",
	".tmj"			: "application/json",
	".kar"			: "audio/midi",
	".karbon"		: "application/vnd.kde.karbon",
	".kfo"			: "application/vnd.kde.kformula",
	".kia"			: "application/vnd.kidspiration",
	".kil"			: "application/x-killustrator",
	".kml"			: "application/vnd.google-earth.kml+xml",
	".kmz"			: "application/vnd.google-earth.kmz",
	".kne"			: "application/vnd.kinar",
	".knp"			: "application/vnd.kinar",
	".kon"			: "application/vnd.kde.kontour",
	".kpr"			: "application/vnd.kde.kpresenter",
	".kpt"			: "application/vnd.kde.kpresenter",
	".ksh"			: "text/plain",
	".ksp"			: "application/vnd.kde.kspread",
	".ktr"			: "application/vnd.kahootz",
	".ktz"			: "application/vnd.kahootz",
	".kwd"			: "application/vnd.kde.kword",
	".kwt"			: "application/vnd.kde.kword",
	".latex"		: "application/x-latex",
	".lbd"			: "application/vnd.llamagraphics.life-balance.desktop",
	".lbe"			: "application/vnd.llamagraphics.life-balance.exchange+xml",
	".les"			: "application/vnd.hhe.lesson-player",
	".lha"			: "application/octet-stream",
	".link66"		: "application/vnd.route66.link66+xml",
	".list"			: "text/plain",
	".list3820"		: "application/vnd.ibm.modcap",
	".listafp"		: "application/vnd.ibm.modcap",
	".log"			: "text/plain",
	".lostxml"		: "application/lost+xml",
	".lrf"			: "application/octet-stream",
	".lrm"			: "application/vnd.ms-lrm",
	".ltf"			: "application/vnd.frogans.ltf",
	".lvp"			: "audio/vnd.lucent.voice",
	".lwp"			: "application/vnd.lotus-wordpro",
	".lzh"			: "application/octet-stream",
	".m13"			: "application/x-msmediaview",
	".m14"			: "application/x-msmediaview",
	".m1v"			: "video/mpeg",
	".m2a"			: "audio/mpeg",
	".m2v"			: "video/mpeg",
	".m3a"			: "audio/mpeg",
	".m3u"			: "audio/x-mpegurl",
	".m4u"			: "video/vnd.mpegurl",
	".m4v"			: "video/x-m4v",
	".ma"			: "application/mathematica",
	".mag"			: "application/vnd.ecowin.chart",
	".maker"		: "application/vnd.framemaker",
	".man"			: "text/troff",
	".mathml"		: "application/mathml+xml",
	".mb"			: "application/mathematica",
	".mbk"			: "application/vnd.mobius.mbk",
	".mbox"			: "application/mbox",
	".mc1"			: "application/vnd.medcalcdata",
	".mcd"			: "application/vnd.mcd",
	".mcurl"		: "text/vnd.curl.mcurl",
	".mdb"			: "application/x-msaccess",
	".mdi"			: "image/vnd.ms-modi",
	".me"			: "text/troff",
	".mesh"			: "model/mesh",
	".mfm"			: "application/vnd.mfmp",
	".mgz"			: "application/vnd.proteus.magazine",
	".mht"			: "message/rfc822",
	".mhtml"		: "message/rfc822",
	".mid"			: "audio/midi",
	".midi"			: "audio/midi",
	".mif"			: "application/vnd.mif",
	".mime"			: "message/rfc822",
	".mj2"			: "video/mj2",
	".mjp2"			: "video/mj2",
	".mlp"			: "application/vnd.dolby.mlp",
	".mmd"			: "application/vnd.chipnuts.karaoke-mmd",
	".mmf"			: "application/vnd.smaf",
	".mmr"			: "image/vnd.fujixerox.edmics-mmr",
	".mny"			: "application/x-msmoney",
	".mobi"			: "application/x-mobipocket-ebook",
	".mov"			: "video/quicktime",
	".movie"		: "video/x-sgi-movie",
	".mp2"			: "audio/mpeg",
	".mp2a"			: "audio/mpeg",
	".mp3"			: "audio/mpeg",
	".mp4"			: "video/mp4",
	".mp4a"			: "audio/mp4",
	".mp4s"			: "application/mp4",
	".mp4v"			: "video/mp4",
	".mpa"			: "video/mpeg",
	".mpc"			: "application/vnd.mophun.certificate",
	".mpe"			: "video/mpeg",
	".mpeg"			: "video/mpeg",
	".mpg"			: "video/mpeg",
	".mpg4"			: "video/mp4",
	".mpga"			: "audio/mpeg",
	".mpkg"			: "application/vnd.apple.installer+xml",
	".mpm"			: "application/vnd.blueice.multipass",
	".mpn"			: "application/vnd.mophun.application",
	".mpp"			: "application/vnd.ms-project",
	".mpt"			: "application/vnd.ms-project",
	".mpy"			: "application/vnd.ibm.minipay",
	".mqy"			: "application/vnd.mobius.mqy",
	".mrc"			: "application/marc",
	".ms"			: "text/troff",
	".mscml"		: "application/mediaservercontrol+xml",
	".mseed"		: "application/vnd.fdsn.mseed",
	".mseq"			: "application/vnd.mseq",
	".msf"			: "application/vnd.epson.msf",
	".msh"			: "model/mesh",
	".msi"			: "application/x-msdownload",
	".msl"			: "application/vnd.mobius.msl",
	".msty"			: "application/vnd.muvee.style",
	".mts"			: "model/vnd.mts",
	".mus"			: "application/vnd.musician",
	".musicxml"		: "application/vnd.recordare.musicxml+xml",
	".mvb"			: "application/x-msmediaview",
	".mwf"			: "application/vnd.mfer",
	".mxf"			: "application/mxf",
	".mxl"			: "application/vnd.recordare.musicxml",
	".mxml"			: "application/xv+xml",
	".mxs"			: "application/vnd.triscape.mxs",
	".mxu"			: "video/vnd.mpegurl",
	".n-gage"		: "application/vnd.nokia.n-gage.symbian.install",
	".nb"			: "application/mathematica",
	".nc"			: "application/x-netcdf",
	".ncx"			: "application/x-dtbncx+xml",
	".ngdat"		: "application/vnd.nokia.n-gage.data",
	".nlu"			: "application/vnd.neurolanguage.nlu",
	".nml"			: "application/vnd.enliven",
	".nnd"			: "application/vnd.noblenet-directory",
	".nns"			: "application/vnd.noblenet-sealer",
	".nnw"			: "application/vnd.noblenet-web",
	".npx"			: "image/vnd.net-fpx",
	".nsf"			: "application/vnd.lotus-notes",
	".nws"			: "message/rfc822",
	".o"			: "application/octet-stream",
	".oa2"			: "application/vnd.fujitsu.oasys2",
	".oa3"			: "application/vnd.fujitsu.oasys3",
	".oas"			: "application/vnd.fujitsu.oasys",
	".obd"			: "application/x-msbinder",
	".obj"			: "application/octet-stream",
	".oda"			: "application/oda",
	".odb"			: "application/vnd.oasis.opendocument.database",
	".odc"			: "application/vnd.oasis.opendocument.chart",
	".odf"			: "application/vnd.oasis.opendocument.formula",
	".odft"			: "application/vnd.oasis.opendocument.formula-template",
	".odg"			: "application/vnd.oasis.opendocument.graphics",
	".odi"			: "application/vnd.oasis.opendocument.image",
	".odp"			: "application/vnd.oasis.opendocument.presentation",
	".ods"			: "application/vnd.oasis.opendocument.spreadsheet",
	".odt"			: "application/vnd.oasis.opendocument.text",
	".oga"			: "audio/ogg",
	".ogg"			: "audio/ogg",
	".ogv"			: "video/ogg",
	".ogx"			: "application/ogg",
	".onepkg"		: "application/onenote",
	".onetmp"		: "application/onenote",
	".onetoc"		: "application/onenote",
	".onetoc2"		: "application/onenote",
	".opf"			: "application/oebps-package+xml",
	".oprc"			: "application/vnd.palm",
	".org"			: "application/vnd.lotus-organizer",
	".osf"			: "application/vnd.yamaha.openscoreformat",
	".osfpvg"		: "application/vnd.yamaha.openscoreformat.osfpvg+xml",
	".otc"			: "application/vnd.oasis.opendocument.chart-template",
	".otf"			: "application/x-font-otf",
	".otg"			: "application/vnd.oasis.opendocument.graphics-template",
	".oth"			: "application/vnd.oasis.opendocument.text-web",
	".oti"			: "application/vnd.oasis.opendocument.image-template",
	".otm"			: "application/vnd.oasis.opendocument.text-master",
	".otp"			: "application/vnd.oasis.opendocument.presentation-template",
	".ots"			: "application/vnd.oasis.opendocument.spreadsheet-template",
	".ott"			: "application/vnd.oasis.opendocument.text-template",
	".oxt"			: "application/vnd.openofficeorg.extension",
	".p"			: "text/x-pascal",
	".p10"			: "application/pkcs10",
	".p12"			: "application/x-pkcs12",
	".p7b"			: "application/x-pkcs7-certificates",
	".p7c"			: "application/pkcs7-mime",
	".p7m"			: "application/pkcs7-mime",
	".p7r"			: "application/x-pkcs7-certreqresp",
	".p7s"			: "application/pkcs7-signature",
	".pas"			: "text/x-pascal",
	".pbd"			: "application/vnd.powerbuilder6",
	".pbm"			: "image/x-portable-bitmap",
	".pcf"			: "application/x-font-pcf",
	".pcl"			: "application/vnd.hp-pcl",
	".pclxl"		: "application/vnd.hp-pclxl",
	".pct"			: "image/x-pict",
	".pcurl"		: "application/vnd.curl.pcurl",
	".pcx"			: "image/x-pcx",
	".pdb"			: "application/vnd.palm",
	".pdf"			: "application/pdf",
	".pfa"			: "application/x-font-type1",
	".pfb"			: "application/x-font-type1",
	".pfm"			: "application/x-font-type1",
	".pfr"			: "application/font-tdpfr",
	".pfx"			: "application/x-pkcs12",
	".pgm"			: "image/x-portable-graymap",
	".pgn"			: "application/x-chess-pgn",
	".pgp"			: "application/pgp-encrypted",
	".pic"			: "image/x-pict",
	".pkg"			: "application/octet-stream",
	".pki"			: "application/pkixcmp",
	".pkipath"		: "application/pkix-pkipath",
	".pl"			: "text/plain",
	".plb"			: "application/vnd.3gpp.pic-bw-large",
	".plc"			: "application/vnd.mobius.plc",
	".plf"			: "application/vnd.pocketlearn",
	".pls"			: "application/pls+xml",
	".pml"			: "application/vnd.ctc-posml",
	".png"			: "image/png",
	".pnm"			: "image/x-portable-anymap",
	".portpkg"		: "application/vnd.macports.portpkg",
	".pot"			: "application/vnd.ms-powerpoint",
	".potm"			: "application/vnd.ms-powerpoint.template.macroenabled.12",
	".potx"			: "application/vnd.openxmlformats-officedocument.presentationml.template",
	".ppa"			: "application/vnd.ms-powerpoint",
	".ppam"			: "application/vnd.ms-powerpoint.addin.macroenabled.12",
	".ppd"			: "application/vnd.cups-ppd",
	".ppm"			: "image/x-portable-pixmap",
	".pps"			: "application/vnd.ms-powerpoint",
	".ppsm"			: "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
	".ppsx"			: "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
	".ppt"			: "application/vnd.ms-powerpoint",
	".pptm"			: "application/vnd.ms-powerpoint.presentation.macroenabled.12",
	".pptx"			: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
	".pqa"			: "application/vnd.palm",
	".prc"			: "application/x-mobipocket-ebook",
	".pre"			: "application/vnd.lotus-freelance",
	".prf"			: "application/pics-rules",
	".ps"			: "application/postscript",
	".psb"			: "application/vnd.3gpp.pic-bw-small",
	".psd"			: "image/vnd.adobe.photoshop",
	".psf"			: "application/x-font-linux-psf",
	".ptid"			: "application/vnd.pvi.ptid1",
	".pub"			: "application/x-mspublisher",
	".pvb"			: "application/vnd.3gpp.pic-bw-var",
	".pwn"			: "application/vnd.3m.post-it-notes",
	".pwz"			: "application/vnd.ms-powerpoint",
	".py"			: "text/x-python",
	".pya"			: "audio/vnd.ms-playready.media.pya",
	".pyc"			: "application/x-python-code",
	".pyo"			: "application/x-python-code",
	".pyv"			: "video/vnd.ms-playready.media.pyv",
	".qam"			: "application/vnd.epson.quickanime",
	".qbo"			: "application/vnd.intu.qbo",
	".qfx"			: "application/vnd.intu.qfx",
	".qps"			: "application/vnd.publishare-delta-tree",
	".qt"			: "video/quicktime",
	".qwd"			: "application/vnd.quark.quarkxpress",
	".qwt"			: "application/vnd.quark.quarkxpress",
	".qxb"			: "application/vnd.quark.quarkxpress",
	".qxd"			: "application/vnd.quark.quarkxpress",
	".qxl"			: "application/vnd.quark.quarkxpress",
	".qxt"			: "application/vnd.quark.quarkxpress",
	".ra"			: "audio/x-pn-realaudio",
	".ram"			: "audio/x-pn-realaudio",
	".rar"			: "application/x-rar-compressed",
	".ras"			: "image/x-cmu-raster",
	".rcprofile"		: "application/vnd.ipunplugged.rcprofile",
	".rdf"			: "application/rdf+xml",
	".rdz"			: "application/vnd.data-vision.rdz",
	".rep"			: "application/vnd.businessobjects",
	".res"			: "application/x-dtbresource+xml",
	".rgb"			: "image/x-rgb",
	".rif"			: "application/reginfo+xml",
	".rl"			: "application/resource-lists+xml",
	".rlc"			: "image/vnd.fujixerox.edmics-rlc",
	".rld"			: "application/resource-lists-diff+xml",
	".rm"			: "application/vnd.rn-realmedia",
	".rmi"			: "audio/midi",
	".rmp"			: "audio/x-pn-realaudio-plugin",
	".rms"			: "application/vnd.jcp.javame.midlet-rms",
	".rnc"			: "application/relax-ng-compact-syntax",
	".roff"			: "text/troff",
	".rpm"			: "application/x-rpm",
	".rpss"			: "application/vnd.nokia.radio-presets",
	".rpst"			: "application/vnd.nokia.radio-preset",
	".rq"			: "application/sparql-query",
	".rs"			: "application/rls-services+xml",
	".rsd"			: "application/rsd+xml",
	".rss"			: "application/rss+xml",
	".rtf"			: "application/rtf",
	".rtx"			: "text/richtext",
	".s"			: "text/x-asm",
	".saf"			: "application/vnd.yamaha.smaf-audio",
	".sbml"			: "application/sbml+xml",
	".sc"			: "application/vnd.ibm.secure-container",
	".scd"			: "application/x-msschedule",
	".scm"			: "application/vnd.lotus-screencam",
	".scq"			: "application/scvp-cv-request",
	".scs"			: "application/scvp-cv-response",
	".scurl"		: "text/vnd.curl.scurl",
	".sda"			: "application/vnd.stardivision.draw",
	".sdc"			: "application/vnd.stardivision.calc",
	".sdd"			: "application/vnd.stardivision.impress",
	".sdkd"			: "application/vnd.solent.sdkm+xml",
	".sdkm"			: "application/vnd.solent.sdkm+xml",
	".sdp"			: "application/sdp",
	".sdw"			: "application/vnd.stardivision.writer",
	".see"			: "application/vnd.seemail",
	".seed"			: "application/vnd.fdsn.seed",
	".sema"			: "application/vnd.sema",
	".semd"			: "application/vnd.semd",
	".semf"			: "application/vnd.semf",
	".ser"			: "application/java-serialized-object",
	".setpay"		: "application/set-payment-initiation",
	".setreg"		: "application/set-registration-initiation",
	".sfd-hdstx"		: "application/vnd.hydrostatix.sof-data",
	".sfs"			: "application/vnd.spotfire.sfs",
	".sgl"			: "application/vnd.stardivision.writer-global",
	".sgm"			: "text/sgml",
	".sgml"			: "text/sgml",
	".sh"			: "application/x-sh",
	".shar"			: "application/x-shar",
	".shf"			: "application/shf+xml",
	".si"			: "text/vnd.wap.si",
	".sic"			: "application/vnd.wap.sic",
	".sig"			: "application/pgp-signature",
	".silo"			: "model/mesh",
	".sis"			: "application/vnd.symbian.install",
	".sisx"			: "application/vnd.symbian.install",
	".sit"			: "application/x-stuffit",
	".sitx"			: "application/x-stuffitx",
	".skd"			: "application/vnd.koan",
	".skm"			: "application/vnd.koan",
	".skp"			: "application/vnd.koan",
	".skt"			: "application/vnd.koan",
	".sl"			: "text/vnd.wap.sl",
	".slc"			: "application/vnd.wap.slc",
	".sldm"			: "application/vnd.ms-powerpoint.slide.macroenabled.12",
	".sldx"			: "application/vnd.openxmlformats-officedocument.presentationml.slide",
	".slt"			: "application/vnd.epson.salt",
	".smf"			: "application/vnd.stardivision.math",
	".smi"			: "application/smil+xml",
	".smil"			: "application/smil+xml",
	".snd"			: "audio/basic",
	".snf"			: "application/x-font-snf",
	".so"			: "application/octet-stream",
	".spc"			: "application/x-pkcs7-certificates",
	".spf"			: "application/vnd.yamaha.smaf-phrase",
	".spl"			: "application/x-futuresplash",
	".spot"			: "text/vnd.in3d.spot",
	".spp"			: "application/scvp-vp-response",
	".spq"			: "application/scvp-vp-request",
	".spx"			: "audio/ogg",
	".src"			: "application/x-wais-source",
	".srx"			: "application/sparql-results+xml",
	".sse"			: "application/vnd.kodak-descriptor",
	".ssf"			: "application/vnd.epson.ssf",
	".ssml"			: "application/ssml+xml",
	".stc"			: "application/vnd.sun.xml.calc.template",
	".std"			: "application/vnd.sun.xml.draw.template",
	".stf"			: "application/vnd.wt.stf",
	".sti"			: "application/vnd.sun.xml.impress.template",
	".stk"			: "application/hyperstudio",
	".stl"			: "application/vnd.ms-pki.stl",
	".str"			: "application/vnd.pg.format",
	".stw"			: "application/vnd.sun.xml.writer.template",
	".sus"			: "application/vnd.sus-calendar",
	".susp"			: "application/vnd.sus-calendar",
	".sv4cpio"		: "application/x-sv4cpio",
	".sv4crc"		: "application/x-sv4crc",
	".svd"			: "application/vnd.svd",
	".svg"			: "image/svg+xml",
	".svgz"			: "image/svg+xml",
	".swa"			: "application/x-director",
	".swf"			: "application/x-shockwave-flash",
	".swi"			: "application/vnd.arastra.swi",
	".sxc"			: "application/vnd.sun.xml.calc",
	".sxd"			: "application/vnd.sun.xml.draw",
	".sxg"			: "application/vnd.sun.xml.writer.global",
	".sxi"			: "application/vnd.sun.xml.impress",
	".sxm"			: "application/vnd.sun.xml.math",
	".sxw"			: "application/vnd.sun.xml.writer",
	".t"			: "text/troff",
	".tao"			: "application/vnd.tao.intent-module-archive",
	".tar"			: "application/x-tar",
	".tcap"			: "application/vnd.3gpp2.tcap",
	".tcl"			: "application/x-tcl",
	".teacher"		: "application/vnd.smart.teacher",
	".tex"			: "application/x-tex",
	".texi"			: "application/x-texinfo",
	".texinfo"		: "application/x-texinfo",
	".text"			: "text/plain",
	".tfm"			: "application/x-tex-tfm",
	".tgz"			: "application/x-gzip",
	".tif"			: "image/tiff",
	".tiff"			: "image/tiff",
	".tmo"			: "application/vnd.tmobile-livetv",
	".torrent"		: "application/x-bittorrent",
	".tpl"			: "application/vnd.groove-tool-template",
	".tpt"			: "application/vnd.trid.tpt",
	".tr"			: "text/troff",
	".tra"			: "application/vnd.trueapp",
	".trm"			: "application/x-msterminal",
	".tsv"			: "text/tab-separated-values",
	".ttc"			: "application/x-font-ttf",
	".ttf"			: "application/x-font-ttf",
	".twd"			: "application/vnd.simtech-mindmapper",
	".twds"			: "application/vnd.simtech-mindmapper",
	".txd"			: "application/vnd.genomatix.tuxedo",
	".txf"			: "application/vnd.mobius.txf",
	".txt"			: "text/plain",
	".u32"			: "application/x-authorware-bin",
	".udeb"			: "application/x-debian-package",
	".ufd"			: "application/vnd.ufdl",
	".ufdl"			: "application/vnd.ufdl",
	".umj"			: "application/vnd.umajin",
	".unityweb"		: "application/vnd.unity",
	".uoml"			: "application/vnd.uoml+xml",
	".uri"			: "text/uri-list",
	".uris"			: "text/uri-list",
	".urls"			: "text/uri-list",
	".ustar"		: "application/x-ustar",
	".utz"			: "application/vnd.uiq.theme",
	".uu"			: "text/x-uuencode",
	".vcd"			: "application/x-cdlink",
	".vcf"			: "text/x-vcard",
	".vcg"			: "application/vnd.groove-vcard",
	".vcs"			: "text/x-vcalendar",
	".vcx"			: "application/vnd.vcx",
	".vis"			: "application/vnd.visionary",
	".viv"			: "video/vnd.vivo",
	".vor"			: "application/vnd.stardivision.writer",
	".vox"			: "application/x-authorware-bin",
	".vrml"			: "model/vrml",
	".vsd"			: "application/vnd.visio",
	".vsf"			: "application/vnd.vsf",
	".vss"			: "application/vnd.visio",
	".vst"			: "application/vnd.visio",
	".vsw"			: "application/vnd.visio",
	".vtu"			: "model/vnd.vtu",
	".vxml"			: "application/voicexml+xml",
	".w3d"			: "application/x-director",
	".wad"			: "application/x-doom",
	".wav"			: "audio/x-wav",
	".wax"			: "audio/x-ms-wax",
	".wbmp"			: "image/vnd.wap.wbmp",
	".wbs"			: "application/vnd.criticaltools.wbs+xml",
	".wbxml"		: "application/vnd.wap.wbxml",
	".wcm"			: "application/vnd.ms-works",
	".wdb"			: "application/vnd.ms-works",
	".wiz"			: "application/msword",
	".wks"			: "application/vnd.ms-works",
	".wm"			: "video/x-ms-wm",
	".wma"			: "audio/x-ms-wma",
	".wmd"			: "application/x-ms-wmd",
	".wmf"			: "application/x-msmetafile",
	".wml"			: "text/vnd.wap.wml",
	".wmlc"			: "application/vnd.wap.wmlc",
	".wmls"			: "text/vnd.wap.wmlscript",
	".wmlsc"		: "application/vnd.wap.wmlscriptc",
	".wmv"			: "video/x-ms-wmv",
	".wmx"			: "video/x-ms-wmx",
	".wmz"			: "application/x-ms-wmz",
	".wpd"			: "application/vnd.wordperfect",
	".wpl"			: "application/vnd.ms-wpl",
	".wps"			: "application/vnd.ms-works",
	".wqd"			: "application/vnd.wqd",
	".wri"			: "application/x-mswrite",
	".wrl"			: "model/vrml",
	".wsdl"			: "application/wsdl+xml",
	".wspolicy"		: "application/wspolicy+xml",
	".wtb"			: "application/vnd.webturbo",
	".wvx"			: "video/x-ms-wvx",
	".x32"			: "application/x-authorware-bin",
	".x3d"			: "application/vnd.hzn-3d-crossword",
	".xap"			: "application/x-silverlight-app",
	".xar"			: "application/vnd.xara",
	".xbap"			: "application/x-ms-xbap",
	".xbd"			: "application/vnd.fujixerox.docuworks.binder",
	".xbm"			: "image/x-xbitmap",
	".xdm"			: "application/vnd.syncml.dm+xml",
	".xdp"			: "application/vnd.adobe.xdp+xml",
	".xdw"			: "application/vnd.fujixerox.docuworks",
	".xenc"			: "application/xenc+xml",
	".xer"			: "application/patch-ops-error+xml",
	".xfdf"			: "application/vnd.adobe.xfdf",
	".xfdl"			: "application/vnd.xfdl",
	".xht"			: "application/xhtml+xml",
	".xhtml"		: "application/xhtml+xml",
	".xhvml"		: "application/xv+xml",
	".xif"			: "image/vnd.xiff",
	".xla"			: "application/vnd.ms-excel",
	".xlam"			: "application/vnd.ms-excel.addin.macroenabled.12",
	".xlb"			: "application/vnd.ms-excel",
	".xlc"			: "application/vnd.ms-excel",
	".xlm"			: "application/vnd.ms-excel",
	".xls"			: "application/vnd.ms-excel",
	".xlsb"			: "application/vnd.ms-excel.sheet.binary.macroenabled.12",
	".xlsm"			: "application/vnd.ms-excel.sheet.macroenabled.12",
	".xlsx"			: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
	".xlt"			: "application/vnd.ms-excel",
	".xltm"			: "application/vnd.ms-excel.template.macroenabled.12",
	".xltx"			: "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
	".xlw"			: "application/vnd.ms-excel",
	".xml"			: "application/xml",
	".xo"			: "application/vnd.olpc-sugar",
	".xop"			: "application/xop+xml",
	".xpdl"			: "application/xml",
	".xpi"			: "application/x-xpinstall",
	".xpm"			: "image/x-xpixmap",
	".xpr"			: "application/vnd.is-xpr",
	".xps"			: "application/vnd.ms-xpsdocument",
	".xpw"			: "application/vnd.intercon.formnet",
	".xpx"			: "application/vnd.intercon.formnet",
	".xsl"			: "application/xml",
	".xslt"			: "application/xslt+xml",
	".xsm"			: "application/vnd.syncml+xml",
	".xspf"			: "application/xspf+xml",
	".xul"			: "application/vnd.mozilla.xul+xml",
	".xvm"			: "application/xv+xml",
	".xvml"			: "application/xv+xml",
	".xwd"			: "image/x-xwindowdump",
	".xyz"			: "chemical/x-xyz",
	".zaz"			: "application/vnd.zzazz.deck+xml",
	".zip"			: "application/zip",
	".zir"			: "application/vnd.zul",
	".zirz"			: "application/vnd.zul",
	".zmm"			: "application/vnd.handheld-entertainment+xml"
    }[ext.toLowerCase().trim()] || "application/octet-stream");
}

},{"file-saver":73,"jszip":79}],42:[function(require,module,exports){
const {dom, index} = require('./dom.js');

function save(name, data) {
    const link = document.createElement( 'a' );
    link.style.display = 'none';
    document.body.appendChild( link );


    const blob = new Blob( [ data ], { type: 'application/octet-stream' } );
    link.href = URL.createObjectURL( blob );
    link.download =  name;
    link.click();
}

class Flasher {
    constructor(name, data) {
        this.name = name;
        this.data = data;
    }

    log(...args) {
        postMessage({log:[args]}, '*')
    }

    async showConnectPopup() {
        return new Promise((resolve, fail) => {
            const root = dom(document.body,
                             {
                                 style: {
                                     position: "absolute",
                                     width: "100%",
                                     height: "100%",
                                     margin:0,
                                     padding:0,
                                 }
                             }, [
                                 ['div', {
                                     style:{
                                         position: "absolute",
                                         width: "210px",
                                         height: "100px",
                                         margin: "auto",
                                         padding: "18px",
                                         boxSizing: "border-box",
                                         left: 0,
                                         right: 0,
                                         top: 0,
                                         bottom: 0,
                                         background: '#333',
                                         borderRadius: '10px',
                                         border: '1px solid #555'
                                     },
                                 }, [
                                     ['h1', {
                                         textContent:'Ready!',
                                         style:{
                                             textAlign:'center',
                                             fontFamily:'Menlo, Monaco, "Courier New", monospace',
                                             color:'white'
                                         }
                                     }],
                                     ['div', [
                                         ['button', {
                                             textContent:'Cancel',
                                             onclick:_=>{
                                                 root.remove();
                                                 fail();
                                             }
                                         }],
                                         ['button', {
                                             textContent:'Flash',
                                             onclick:_=>{
                                                 root.remove();
                                                 resolve('flash');
                                             }

                                         }],
                                         ['button', {
                                             textContent:'Save',
                                             onclick:_=>{
                                                 root.remove();
                                                 save(this.name, this.data);
                                                 fail();
                                             }
                                         }]
                                     ]]
                                 ]]
                             ]);
        });
    }

};

module.exports.Flasher = Flasher;

},{"./dom.js":62}],43:[function(require,module,exports){
"use strict";

const {
  dom,
  index
} = require('./dom.js');
const {
  Model
} = require('./Model.js');
const {
  TreeListNode
} = require('./TreeListNode.js');
const {
  TabContainer
} = require('./TabContainer.js');
const {
  Preview
} = require('./Preview.js');
const {
  ProjectControls
} = require('./ProjectControls.js');
const {
  Console
} = require('./Console.js');
const {
  PNGFS
} = require('./pngfs.js');
const {
  stdlib
} = require('./stdlib.js');
const {
  loadExample
} = require('./example.js');
const ESPboy = require('./ESPBoy.js');
const Blit = require('./Blit.js');
const SAMD = require('./SAMD.js');
const Browser = require('./Browser.js');
const {
  PreBuild
} = require('./PreBuild.js');
const {
  ImageEditor
} = require('./ImageEditor.js');
const {
  TileMapEditor
} = require('./TileMapEditor.js');
const {
  URLEditor
} = require('./URLEditor.js');
const {
  BlockEditor
} = require('./BlockEditor.js');
// const {MusicEditor} = require('./MusicEditor.js');
const {
  FS2Zip,
  Zip2FS,
  getMimeType
} = require('./FS2Zip.js');
const uploaders = {
  espboy: ESPboy,
  blit: Blit,
  meta: {
    upload: SAMD.upload.bind(null, 0x2000)
  },
  metro: {
    upload: SAMD.upload.bind(null, 0x4000)
  }
};
class IDE {
  el;
  parent;
  model;
  #view = null;
  #tabContainer = null;
  #consoleContainer = null;
  #fs = null;
  #projectModel = null;
  #editors = {};
  #treeNodes = {};
  #preview = null;
  #booted = false;
  constructor(el, parent, model) {
    this.el = el;
    this.parent = parent;
    this.model = model;
    model.watch('state', state => this.changeState(state));
    model.watch('windowSize', size => this.resize());
    model.watch('runSize', size => this.run(size));
  }
  resize() {
    if (!this.el.classList.contains('hidden')) {
      this.boot();
      for (let key in this.#editors) this.#editors[key]?.editor?.layout?.();
    }
  }
  async changeState(newState) {
    this.el.classList.toggle('hidden', newState != this.constructor.name);
    await this.closeProject();
    if (newState == this.constructor.name) {
      this.resize();
      this.openProject();
    }
    this.run(null);
  }
  async closeProject() {
    [...Object.values(this.#editors)].forEach(({
      editor
    }) => editor?.commit());
    if (this.model) {
      this.model.set('previewProject', '');
      this.model.set('previewHTML', '');
    }
    if (this.#projectModel) this.#projectModel.flush();
    this.#fs = null;
    this.#projectModel = null;
    [...Object.values(this.#editors)].forEach(({
      shortPath
    }) => this.#tabContainer.close(shortPath));
  }
  async openProject() {
    const projectId = this.model.get("projectId");
    const modelId = "project-" + projectId;
    let model = this.model.get(modelId, null);
    if (!model) {
      model = new Model();
      await model.useStorage(modelId);
      this.model.set(modelId, model);
    }
    let fs = new PNGFS(model.get('fs', null));
    fs.rm('.R');
    model.onBeforeSave = _ => {
      model.set('fs', fs.toJSON());
    };
    this.#projectModel = model;
    window.projectFS = fs;
    this.#fs = fs;
    this.#fs.onDirty = _ => model.dirty();
    if (this.#fs.ls().length == 0) loadExample(this.#fs, this.model.get("newProjectTemplate", "js"));
    this.emitStd(this.model.get('platform'));
    this.refreshTree();
    const activeFile = model.get('activeFile', '/source/main.js');
    const openFileList = model.get('openFileList', []);
    const copy = [...openFileList];
    openFileList.length = 0;
    copy.forEach(name => this.openFile(name));
    this.openFile(activeFile);
  }
  boot() {
    if (this.#booted) return;
    this.#booted = true;
    this.setupMonaco();
    this.#view = index(this.el, {}, this);
    this.model.watch('platform', platform => this.emitStd(platform));
    this.model.watch('projectName', name => {
      if (name != this.model.get('previewProject', '')) this.model.set('previewHTML', '');
    });
  }
  setupPreview(el) {
    this.#preview = new Preview(el, this, this.model);
    return false;
  }
  setupConsoleContainer(el) {
    const help = el.firstElementChild;
    help.remove();
    const cc = new TabContainer(el);
    this.#consoleContainer = cc;
    const logcon = new Console('log');
    logcon.onAppend = _ => cc.activate('debug');
    cc.add('debug', logcon.el);
    cc.activate('debug');
    const buildcon = new Console('build');
    buildcon.onAppend = _ => cc.activate('compilation');
    buildcon.maxLines = 1;
    cc.add('compilation', buildcon.el);
    cc.add('help', help);
    return false;
  }
  setupTabContainer(el) {
    this.#tabContainer = new TabContainer(el);
    this.#tabContainer.onClose = this.onCloseEditor.bind(this);
    this.#tabContainer.onActivate = this.onActivateFile.bind(this);
    return false;
  }
  setupProjectControls(el) {
    new ProjectControls(el, this.model);
    return false;
  }
  setupMonaco() {
    monaco.languages.typescript.javascriptDefaults.setEagerModelSync(true);
    monaco.languages.typescript.javascriptDefaults.setCompilerOptions({
      target: monaco.languages.typescript.ScriptTarget.ES6,
      allowNonTsExtensions: true,
      noLib: true,
      allowJs: true
    });
    var libUri = 'ts:filename/stdlib.d.ts';
    monaco.languages.typescript.javascriptDefaults.addExtraLib(stdlib, libUri);
    monaco.editor.createModel(stdlib, 'typescript', monaco.Uri.parse(libUri));
  }
  refreshTree() {
    const treelist = document.querySelector('#treelist');
    this.#treeNodes = {};
    while (treelist.childNodes.length) treelist.removeChild(treelist.childNodes[0]);
    for (let entry of this.#fs.ls("/")) treelist.appendChild(new TreeListNode(entry, "/", this.openFile.bind(this), this.#treeNodes).dom);
  }
  cancelEvent(event) {
    event.stopPropagation();
    event.preventDefault();
  }
  dropFile(event) {
    event.stopPropagation();
    event.preventDefault();
    let parentElement = event.target.closest('.treenode.Directory');
    if (!parentElement) {
      return;
    }
    let parentPath = null;
    for (let path in this.#treeNodes) {
      let node = this.#treeNodes[path];
      if (node.dom == parentElement) {
        parentPath = path;
        break;
      }
    }
    if (!parentPath) {
      return;
    }
    let files = event.dataTransfer?.files;
    if (!files?.length) {
      return;
    }
    let pending = files.length;
    for (let i = 0; i < files.length; ++i) {
      let file = files[i];
      let fr = new FileReader();
      if (/\.zip$/i.test(file.name)) {
        fr.onload = loadProject.bind(this, fr);
        fr.readAsArrayBuffer(file);
      } else {
        fr.onload = loadFile.bind(this, fr, file);
        const [left, right] = getMimeType(file.name).split("/");
        if (left == "text" || right == "json" || right == "javascript") fr.readAsText(file);else fr.readAsDataURL(file);
      }
    }
    async function loadProject(fr) {
      await Zip2FS(fr, this.#fs);
      for (let key in this.#editors) this.#editors[key].editor?.reload?.();
      this.refreshTree();
    }
    function loadFile(fr, file) {
      // console.log(parentPath + '/' + file.name, fr.result);
      this.#fs.writeFile(parentPath + '/' + file.name, fr.result);
      if (! --pending) this.refreshTree();
    }
  }
  editorFactories = {
    js(parentElement, path, contents) {
      const editor = monaco.editor.create(parentElement, {
        value: contents,
        language: 'javascript',
        theme: 'vs-dark'
      });
      let fs = this.#fs;
      editor.commit = _ => {
        let newval = editor.getValue();
        if (newval != contents) {
          contents = newval;
          fs.writeFile(path, contents);
          // console.log("NEWVAL", newval, newval == contents);
        }
      };

      editor.reload = _ => {
        editor.setValue(fs.readFile(path));
      };
      editor.onDidChangeModelContent(editor.commit);
      editor.addAction({
        id: 'save-action',
        label: 'Save File',
        keybindings: [monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS],
        precondition: null,
        keybindingContext: null,
        // contextMenuGroupId: 'navigation',
        // contextMenuOrder: 1.5,
        run(editor) {}
      });
      editor.addAction({
        id: 'execute',
        label: 'Execute',
        keybindings: [monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter],
        precondition: null,
        keybindingContext: null,
        // contextMenuGroupId: 'navigation',
        // contextMenuOrder: 1.5,
        run: () => {
          this.#preview.toggleRun();
        }
      });
      return editor;
    },
    meta: "js",
    json: "js",
    "https:"(parentElement, path) {
      return new URLEditor(parentElement, path);
    },
    block(parentElement, path, contents) {
      return new BlockEditor(parentElement, path, contents, this.#fs);
    },
    raw(parentElement, path, contents) {},
    tmj(parentElement, path, contents) {
      return new TileMapEditor(parentElement, path, contents, this.#fs);
    },
    png(parentElement, path, contents) {
      return new ImageEditor(parentElement, path, contents, this.#fs);
    },
    jpg: 'png'

    // mod(parentElement, path, contents) {
    //     return new MusicEditor(parentElement, path, contents, this.#fs);
    // },

    // xm:'mod'
  };

  openFile(path) {
    const pathParts = path.split('/');
    const shortPath = pathParts.pop();
    if (this.#tabContainer.activate(shortPath)) {
      this.#projectModel.set('activeFile', path);
      return;
    }
    let contents = false;
    let factory = (shortPath.match(/\.([^./]+)$/i)?.[1] + '').toLowerCase();
    if (pathParts?.[0]?.toLowerCase() === "https:") {
      factory = "https:";
    } else {
      try {
        contents = this.#fs.readFile(path);
      } catch (ex) {
        console.warn(ex);
      }
      if (contents === false) return;
    }
    let editorNode = dom('div', {
      style: {
        width: "100%",
        height: "100%",
        position: "absolute"
      }
    });
    const entry = {
      node: editorNode,
      shortPath,
      path,
      editor: null
    };
    this.#editors[path] = entry;
    const openFileList = this.#projectModel.get('openFileList', []);
    openFileList.push(path);
    this.#projectModel.dirty('openFileList');
    this.#tabContainer.add(shortPath, editorNode);
    this.#tabContainer.activate(shortPath);
    while (typeof factory == 'string') factory = this.editorFactories[factory];
    if (!factory) factory = this.editorFactories.raw;
    entry.editor = factory.call(this, editorNode, path, contents);
  }
  getEditor(container) {
    for (let path in this.#editors) {
      const entry = this.#editors[path];
      if (entry.node == container) return entry;
    }
    return null;
  }
  getActiveTreeNode() {
    for (let key in this.#treeNodes) {
      if (this.#treeNodes[key].isActive()) return this.#treeNodes[key];
    }
    return undefined;
  }
  onActivateFile(container) {
    if (!this.#projectModel) return;
    const path = this.getEditor(container)?.path;
    this.#editors[path]?.editor?.layout?.();
    this.#projectModel.set('activeFile', path);
    for (let key in this.#treeNodes) {
      this.#treeNodes[key].setActive(key == path);
    }
  }
  onCloseEditor(container) {
    for (let path in this.#editors) {
      const {
        node,
        editor
      } = this.#editors[path];
      if (node != container) continue;
      if (editor && editor.dispose) editor.dispose();
      delete this.#editors[path];
      if (this.#projectModel) {
        const openFileList = this.#projectModel.get('openFileList', []);
        openFileList.splice(openFileList.indexOf('path'), 1);
        this.#projectModel.dirty('openFileList');
      }
      break;
    }
    return true;
  }
  emitStd(platform) {
    if (!this.#fs || !platform) return;
    const code = `// Autogenerated file - DO NOT EDIT!
"set platform ${platform}";
"addSysCall setFPS setPen setFont setLED setTexture";
"addSysCall setMirrored setFlipped setTransparent";
"addSysCall setTileMap getTileProperty scanTileMap";
"addSysCall getWidth getHeight readByte getTime";
"addSysCall clear image text rect";
"push globals UP DOWN LEFT RIGHT A B C D FRAMETIME CAMERA_X CAMERA_Y PI HALF_PI TWO_PI";
"registerBuiltinResource fontMini fontTIC806x6 fontZXSpec fontAdventurer fontDonut fontDragon fontC64 fntC64UIGfx fontMonkey fontKarateka fontKoubit fontRunes fontTight fontTiny";
"include /source/main.js"
`;
    this.#fs?.writeFile('/std.js', code);
    this.#editors['/std.js']?.editor.setValue(code);
  }
  exportProject() {
    FS2Zip(this.#fs);
  }
  deleteFile() {
    const reference = this.getActiveTreeNode();
    if (!confirm(`Are you sure you want to delete ${reference.path}?`)) {
      return;
    }
    if (this.#fs.rm(reference.path)) {
      for (let path in this.#editors) {
        if (path == reference.path || path.startsWith(reference.path + '/')) {
          const editor = this.#editors[path];
          if (editor) this.#tabContainer.close(editor.shortPath);
        }
      }
      let node = this.#treeNodes[reference.path];
      if (node) {
        node.remove();
        delete this.#treeNodes[reference.path];
      }
    }
  }
  createFile() {
    const fs = this.#fs;
    const name = prompt("File Name:");
    if (!name) return;
    const reference = this.getActiveTreeNode();
    const path = reference.path.split('/');
    if (!reference.isDirectory()) path.pop();
    path.push(name);
    const strpath = path.join('/');
    if (fs.lookup(strpath)) {
      alert(`File ${name} already exists.`);
      return;
    }
    const [fileName, ext] = strpath.split('/').pop().split('.');
    if (!fileName || !ext) {
      alert("Invalid file name: " + name);
      return;
    }
    const source = ext.toLowerCase() !== 'js' ? '' : `// ${name}

class ${fileName} {
    constructor() {
    }

    update(time) {
    }

    render() {
    }
}

`;
    if (!fs.writeFile(strpath, source)) {
      alert(`Could not write file ${name}.`);
      return;
    }
    this.refreshTree();
    this.openFile(strpath);
  }
  createDir() {
    const fs = this.#fs;
    const name = prompt("Directory Name:");
    if (!name) return;
    const reference = this.getActiveTreeNode();
    const path = reference.path.split('/');
    if (!reference.isDirectory()) path.pop();
    path.push(name);
    const strpath = path.join('/');
    if (!fs.mkdir(strpath)) {
      alert(`Could not create directory ${name}.`);
    }
    this.refreshTree();
    if (reference.isFile()) {
      this.openFile(reference.path);
    }
  }
  async exportHTML() {
    const size = this.model.get('size', [220, 178]);
    function save(name, data) {
      const link = document.createElement('a');
      link.style.display = 'none';
      document.body.appendChild(link);
      const blob = new Blob([data], {
        type: 'text/html; charset=utf-8'
      });
      link.href = URL.createObjectURL(blob);
      link.download = name;
      link.click();
    }
    try {
      this.#projectModel.flush();
      const fs = await PreBuild(this.#fs);
      const html = await Browser.build(fs, size);
      save('game.html', html);
    } catch (ex) {
      console.log(ex);
      if (ex && typeof ex == 'object') {
        let msg = ex.description || ex.error || ex.message || ex + '';
        postMessage({
          build: [msg]
        }, '*');
      } else if (typeof ex == 'string') {
        postMessage({
          build: [ex]
        }, '*');
      }
    }
  }
  async run(size) {
    if (!this.#fs) return;
    if (!size) {
      this.model.set('previewProject', '');
      this.model.set('previewHTML', '');
    } else {
      try {
        this.#projectModel.flush();
        const fs = await PreBuild(this.#fs);
        const html = await Browser.build(fs, size);
        postMessage({
          log: {
            clear: true
          }
        }, '*');
        this.model.set('previewProject', this.model.get('projectName'));
        this.model.set('previewHTML', html);
      } catch (ex) {
        console.log(ex);
        if (ex && typeof ex == 'object') {
          let msg = ex.description || ex.error || ex.message || ex + '';
          postMessage({
            build: [msg]
          }, '*');
        } else if (typeof ex == 'string') {
          postMessage({
            build: [ex]
          }, '*');
        }
      }
    }
  }
  async export() {
    this.#preview.setExportVisibility(false);
    let img;
    try {
      postMessage({
        build: ["Building"]
      }, '*');
      const fs = await PreBuild(this.#fs);
      await Browser.build(fs, [0, 0]);
      const remote = this.parent.remote;
      let key = this.#projectModel.get('RPIN');
      if (!key) {
        key = await remote.requestKey();
        this.#projectModel.set('RPIN', key);
      }
      const result = await remote.requestBuild(key, {
        fs: fs.toJSON()
      });
      if (!result || typeof result != 'object') {
        console.log(result);
        throw 'Unexpected error';
      }
      if (result.error) throw result;
      if (result.url) {
        const url = result.url;
        const uploader = uploaders[this.model.get('platform')];
        if (uploader && navigator.serial) {
          const rsp = await fetch(url);
          if (rsp.headers.get('content-type') == "application/octet-stream") {
            uploader.upload(await rsp.arrayBuffer(), this.model.get('projectName'));
          } else {
            const errmsg = await rsp.text();
            console.error(errmsg);
          }
        } else {
          location.href = url;
        }
      }
      postMessage({
        build: ["Build complete"]
      }, '*');
    } catch (ex) {
      console.log(ex);
      if (ex && typeof ex == 'object') {
        if (ex.description)
          // esprima exception
          postMessage({
            build: [ex.description]
          }, '*');
        if (ex.error) postMessage({
          build: [ex.error]
        }, '*');
      } else if (typeof ex == 'string') {
        postMessage({
          build: [ex]
        }, '*');
      }
    } finally {
      if (img) img.remove();
      this.#preview.setExportVisibility(true);
    }
  }
}
module.exports.IDE = IDE;

},{"./Blit.js":36,"./BlockEditor.js":37,"./Browser.js":38,"./Console.js":39,"./ESPBoy.js":40,"./FS2Zip.js":41,"./ImageEditor.js":44,"./Model.js":45,"./PreBuild.js":46,"./Preview.js":47,"./ProjectControls.js":48,"./SAMD.js":50,"./TabContainer.js":55,"./TileMapEditor.js":56,"./TreeListNode.js":57,"./URLEditor.js":58,"./dom.js":62,"./example.js":64,"./pngfs.js":83,"./stdlib.js":85}],44:[function(require,module,exports){
const {dom, index} = require('./dom.js');
const {convertToU8, palette} = require('./PreBuild.js');

class ImageEditor {
    #fs;
    #dom;
    path;
    metadata;
    img;
    canvas;
    ctx;
    imgData;
    forceRedraw;

    selectedTID;

    tilesetPath;
    tilesetMeta;
    tilesetImg;

    constructor(parentElement, path, image, fs) {
        this.path = path;
        try {
            this.metadata = JSON.parse(fs.readFile(path + ".meta"));
        } catch(ex) {}

        if (!this.metadata || typeof this.metadata != "object") {
            this.metadata = {mode:"image"};
        }
        if (!this.metadata.image || typeof this.metadata.image != 'object')
            this.metadata.image = {};
        if (!this.metadata.tilemap || typeof this.metadata.tilemap != 'object')
            this.metadata.tilemap = {tileset:''};
        if (!this.metadata.tileset || typeof this.metadata.tileset != 'object')
            this.metadata.tileset = {tilewidth:8, tileheight:8};

        this.#fs = fs;
        this.#dom = index(dom('div', parentElement, {className:'imageEditor'}, [
            ['div', {id:'imgcontainer'}, [
                ['canvas', {id:'canvas', src:image, onload:this.onload.bind(this)}],
                ['img', {id:'img', src:image, onload:this.onload.bind(this)}]
            ]],
            ['div', {id:'sidebar'}, [
                // ['select', {id:'mode', onchange:this.changeMeta.bind(this)}, [
                //     ['option', {value:'image', textContent:'image'}],
                //     ['option', {value:'tilemap', textContent:'tilemap'}],
                //     ['option', {value:'tileset', textContent:'tileset'}]
                // ]],
                [{id:'imageSidebar'}, [
                    [{className:'row'}, [
                        ['span', {textContent:'Width:'}],
                        ['span', {id:'imgwidth'}]
                    ]],
                    [{className:'row'}, [
                        ['span', {textContent:'Height:'}],
                        ['span', {id:'imgheight'}]
                    ]]
                ]],
                // [{id:'tilemapSidebar'}, [
                //     [{className:'row'}, [
                //         ['span', {textContent:'Tile Set:'}],
                //         ['select', {id:'tileset', onchange:this.changeMeta.bind(this)}, this.getTilesets().map(path => [
                //             'option', {value:path, textContent:path.replace(/.*\/|\..*/g, '')}
                //         ])],
                //         ['button', {id:'refresh', onclick:this.refreshTileSets.bind(this), textContent:''}]
                //     ]]
                // ]],
                // [{id:'tilesetSidebar'}, [
                //     [{className:'row'}, [
                //         ['span', {textContent:'Tile Width:'}],
                //         ['input', {
                //             id:'tilewidth', type:"number", min:"8", max:"256",
                //             onchange:this.changeMeta.bind(this),
                //             value:this.metadata.tileset.tilewidth|0||8
                //         }]
                //     ]],
                //     [{className:'row'}, [
                //         ['span', {textContent:'Tile Height:'}],
                //         ['input', {
                //             id:'tileheight', type:"number", min:"8", max:"256",
                //             onchange:this.changeMeta.bind(this),
                //             value:this.metadata.tileset.tileheight|0||8
                //         }]
                //     ]]
                // ]]
            ]]
        ]), {}, this);
        // this.#dom.tileset.value = this.metadata.tilemap.tileset;
        // this.#dom.mode.value = this.metadata.mode;
    }

    commit() {
    }

    reload() {
        this.#dom.img.src = this.#fs.readFile(this.path);
    }

    refreshTileSets() {
        const tileset = this.#dom.tileset;
        let oldValue = tileset.value;

        while (tileset.children.length)
            tileset.children[0].remove();

        for (let path of this.getTilesets())
            dom(tileset, 'option', {value:path, textContent:path.replace(/.*\/|\..*/g, '')});

        tileset.value = oldValue;
        this.tilesetData = null;
        this.layout();
    }

    onload() {
        this.layout();
    }

    initCanvas(width, height, img) {
        if (!width || !height)
            return false;
        const canvas = this.#dom.canvas;
        if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
            this.imgData = null;
        }
        if (!this.ctx) {
            this.ctx = canvas.getContext('2d');
        }
        if (!this.imgData) {
            if (img)
                this.ctx.drawImage(img, 0, 0);
            this.imgData = this.ctx.getImageData(0, 0, width, height);
            return true;
        }
        return false;
    }

    layout() {
        const mode = this.metadata.mode;
        const editor = this.#dom.imageEditor[0];
        editor.classList.toggle('image', mode == 'image');
        editor.classList.toggle('tilemap', mode == 'tilemap');
        editor.classList.toggle('tileset', mode == 'tileset');

        if (mode == 'image')
            this.layoutImage();

        if (mode == 'tilemap')
            this.layoutTilemap();

        if (mode == 'tileset')
            this.layoutTileset();
    }

    autozoom() {
        const img = this.#dom.img;
        const canvas = this.#dom.canvas;
        const parent = img.parentElement;
        const zoom = Math.min(parent.clientWidth/img.naturalWidth, parent.clientHeight/img.naturalHeight) * 0.85;
        const width = img.naturalWidth * zoom | 0;
        const height = img.naturalHeight * zoom | 0;
        canvas.style.width  = img.style.width  = width + "px";
        canvas.style.height = img.style.height = height + "px";
        canvas.style.left   = img.style.left   = ((parent.clientWidth/2 - width/2)|0) + "px";
        canvas.style.top    = img.style.top    = ((parent.clientHeight/2 - height/2)|0) + "px";
    }

    layoutImage() {
        this.autozoom();

        const img = this.#dom.img;
        this.#dom.imgwidth.textContent = img.naturalWidth;
        this.#dom.imgheight.textContent = img.naturalHeight;

        if (!this.initCanvas(img.naturalWidth, img.naturalHeight, img)) {
            return;
        }
        const u8 = convertToU8(this.imgData);
        const data = this.imgData.data;
        let i = 0;
        for (let y = 0; y < img.naturalHeight; ++y) {
            for (let x = 0; x < img.naturalWidth; ++x) {
                let color = palette[u8[y + 1][x]];
                data[i++] = color[0];
                data[i++] = color[1];
                data[i++] = color[2];
                data[i++] = 255;
            }
        }
        this.ctx.putImageData(this.imgData, 0, 0);
    }

    getTilesets() {
        const fs = this.#fs;
        let tilesets = []
        let path = [];

        recurse(fs.root, (entity) => {
            if (!entity.isFile())
                return entity.name[0] != '.';
            let extension = entity.extension;
            if (extension == 'meta') {
                try {
                    let meta = JSON.parse(entity.node.data);
                    if (meta.mode == 'tileset')
                        tilesets.push(path.join('/'));
                } catch (ex){}
            }
            return false;
        });

        return tilesets;

        function recurse(entity, callback) {
            path.push(entity.name);
            if (callback(entity) !== false && entity.isDirectory()) {
                for (let child of Object.values(entity.node.children))
                    recurse(child, callback);
            }
            path.pop();
        }
    }

    tilesetDimensions() {
        const tilewidth = (this.tilesetData.tileset.tilewidth|0) || 8;
        const tileheight = (this.tilesetData.tileset.tileheight|0) || 8;
        return {
            tilewidth,
            tileheight,
            tilesPerRow: ((this.tilesetImg.naturalWidth / tilewidth) | 0) || 1,
            tilesPerCol: ((this.tilesetImg.naturalWidth / tileheight) | 0) || 1
        };
    }

    async layoutTilemap() {
        this.autozoom();

        let forceRedraw = this.forceRedraw;
        this.forceRedraw = false;

        if (this.tilesetPath != this.metadata.tilemap.tileset) {
            this.tilesetData = null;
            this.tilesetImg = null;
        }

        if (!this.tilesetData) {
            this.tilesetData = JSON.parse(this.#fs.readFile(this.metadata.tilemap.tileset));
            this.tilesetPath = this.metadata.tilemap.tileset;
            forceRedraw = true;
        }

        if (!this.tilesetImg) {
            forceRedraw = true;
            let imgName = this.metadata.tilemap.tileset.replace(/\.meta$/gi, '');
            let imgSrc = this.#fs.readFile(imgName);
            await new Promise((onload, onerror) => {
                this.tilesetImg = dom('img', {src:imgSrc, onload, onerror});
            });
        }

        if (!forceRedraw)
            return;

        const {tilewidth, tileheight, tilesPerRow, tilesPerCol} = this.tilesetDimensions();
        const img = this.#dom.img;
        this.initCanvas(img.naturalWidth, img.naturalHeight, img);

        const canvas = this.#dom.canvas;
        canvas.width = img.naturalWidth * tilewidth;
        canvas.height = img.naturalHeight * tileheight;

        let i = 0, ntid = 1;
        let assign = {};
        for (let y = 0; y < this.imgData.height; ++y) {
            for (let x = 0; x < this.imgData.width; ++x) {
                let c = 0;
                c = this.imgData.data[i++];
                c <<= 8;
                c |= this.imgData.data[i++];
                c <<= 8;
                c |= this.imgData.data[i++];

                let A = this.imgData.data[i++];
                if (A < 128)
                    continue;

                c = c.toString(16);

                let tdat = this.metadata.tilemap['#' + c];
                if (!tdat || typeof tdat != 'object')
                    this.metadata.tilemap['#' + c] = tdat = {};
                assign[c] = tdat;

                let tid = tdat.id;
                if (tid === undefined)
                    continue;

                tid |= 0;
                let tx = tid % tilesPerRow;
                let ty = (tid / tilesPerRow) | 0;
                if (ty >= tilesPerCol) {
                    tdat.id = 0;
                    continue;
                }

                this.ctx.drawImage(
                    this.tilesetImg,
                    tx * tilewidth, ty * tileheight, tilewidth, tileheight,
                    x * tilewidth, y * tilewidth, tilewidth, tileheight
                );
            }
        }

        let old = this.#dom.tilemapSidebar.querySelectorAll('.assign');
        for (let i = 0; i < old.length; ++i)
            old[i].remove();

        for (let key in assign) {
            const row = dom(this.#dom.tilemapSidebar, {className:'row assign'}, [
                [{style:{backgroundColor:'#' + '0'.repeat(6 - key.length) + key, width:'32px', flexGrow:0}}],
                ['canvas', {width:tilewidth, height:tileheight, flexGrow:0, onclick:this.changeTileId.bind(this, key, assign[key])}],
                ['input', {type:'number', value:assign[key].info|0, style:{flexGrow:1}, onchange:this.changeTileInfo.bind(this, key, assign[key])}]
            ]);
            const tid = assign[key].id;
            const canvas = row.querySelector('canvas');
            const ctx = canvas.getContext('2d');
            let tx = tid % tilesPerRow;
            let ty = (tid / tilesPerRow) | 0;
            ctx.drawImage(this.tilesetImg, tx * tilewidth, ty * tileheight, tilewidth, tileheight, 0, 0, tilewidth, tileheight);
        }
    }

    changeTileId(key, obj) {
        if (!this.tilesetImg)
            return;
        const {tilewidth, tileheight, tilesPerRow, tilesPerCol} = this.tilesetDimensions();
        const canvases = [];
        const parent = this.#dom.imageEditor[0];
        const aspect = this.tilesetImg.naturalWidth / this.tilesetImg.naturalHeight;
        const height = parent.clientHeight * 0.9 | 0;
        const width = height * aspect | 0;
        const popup = dom(parent, {
            className:'overlay',
            onclick:event=>{
                if (event.target == popup)
                    popup.remove();
            }
        }, [
            [{className:'popup', style:{height:height + 'px', width:width + "px"}}]
        ]);
        const container = popup.querySelector('.popup');
        for (let ty = 0; ty < tilesPerCol; ++ty) {
            for (let tx = 0; tx < tilesPerRow; ++tx) {
                const canvas = dom('canvas', {width:tilewidth, height:tileheight, className:'tile', onclick:setTID.bind(this, tx, ty)}, container);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(this.tilesetImg, tx * tilewidth, ty * tileheight, tilewidth, tileheight, 0, 0, tilewidth, tileheight);
                canvases.push(canvas);
            }
        }

        setTID.call(this, obj.id % tilesPerRow, obj.id / tilesPerRow|0);

        function setTID(tx, ty) {
            const id = ty * tilesPerRow + tx;
            canvases.forEach((canvas, i) => {
                canvas.classList.toggle('selected', i == id)
            });
            if (id != obj.id) {
                obj.id = id;
                this.forceRedraw = true;
                this.changeMeta();
            }
        }
    }

    changeTileInfo(key, obj, event) {
        obj.info = event.target.value | 0;
        this.dirty();
    }

    layoutTileset() {
        this.autozoom();

        const dom = this.#dom;
        const imgwidth  = dom.img.naturalWidth;
        const imgheight = dom.img.naturalHeight;
        const tw = this.metadata.tileset.tilewidth || 8;
        const th = this.metadata.tileset.tileheight || 8;

        if (!this.initCanvas(imgwidth/tw, imgheight/th)) {
            return;
        }

        let i = 0;
        const data = this.imgData.data;
        for (let y = 0; y < this.imgData.height; ++y) {
            for (let x = 0; x < this.imgData.width; ++x) {
                let c = (x + y) & 1 ? 0xAA : 0x77;
                data[i++] = c;
                data[i++] = c;
                data[i++] = c;
                data[i++] = 255;
            }
        }

        this.ctx.putImageData(this.imgData, 0, 0);
    }

    changeMeta() {
        const dom = this.#dom;

        const imgwidth = dom.img.naturalWidth;
        const imgheight = dom.img.naturalHeight;

        let tilewidth = (dom.tilewidth.value | 0) || 8;
        let tileheight = (dom.tileheight.value | 0) || 8;

        const tilesPerRow = Math.round(imgwidth / tilewidth) || 1;
        const tilesPerCol = Math.round(imgheight / tileheight) || 1;

        if ((imgwidth / tilesPerRow)|0 != tilewidth)
            dom.tilewidth.value = tilewidth = (imgwidth / tilesPerRow)|0;
        if ((imgheight / tilesPerCol)|0 != tileheight)
            dom.tileheight.value = tileheight = (imgheight / tilesPerCol)|0;

        this.metadata = {
            mode:dom.mode.value,
            image:{},
            tilemap:Object.assign(this.metadata.tilemap, {
                tileset:dom.tileset.value
            }),
            tileset:Object.assign(this.metadata.tileset, {
                tilewidth:tilewidth,
                tileheight:tileheight
            })
        };

        this.dirty();

        this.layout();
    }

    dirty() {
        this.#fs.writeFile(this.path + ".meta", JSON.stringify(this.metadata, 0, 4));
    }
};

module.exports.ImageEditor = ImageEditor;

},{"./PreBuild.js":46,"./dom.js":62}],45:[function(require,module,exports){
const localforage = require('localforage');

localforage.config({name:"model"});

class Model {
    #storageId;
    #data;
    #timeout;
    #dirtyCount = 0;
    onBeforeSave;
    onAfterSave;

    constructor() {
        this.#data = {};
    }

    dirty(key){
        let entry = this.#data[key];
        if (entry)
            entry.listeners.forEach(listener => listener(entry.value));

        if (!this.#storageId)
            return;

        if (this.#timeout > 0) {
            this.#dirtyCount++;
            if (this.#dirtyCount > 100)
                return;
            // console.log("Delaying save ", this.#dirtyCount);
            clearTimeout(this.#timeout);
            this.#timeout = 0;
        } else if (this.#timeout == -1) {
            // console.log("Ignoring dirty");
            return;
        } else {
            // console.log("Schedule save");
        }

        this.#timeout = setTimeout(this.flush.bind(this), 1000);
    }

    flush() {
        clearTimeout(this.#timeout);
        this.#timeout = -1;
        console.log("Saving", this.#storageId);
        this.onBeforeSave?.();
        clearTimeout(this.#timeout);
        this.#timeout = 0;
        this.#dirtyCount = 0;
        localforage.setItem(this.#storageId, this.toJSON());
        this.onAfterSave?.();
    }

    toJSON() {
        const json = {};
        for (let k in this.#data) {
            let v = this.#data[k].value;
            if (v && typeof v == 'object' && v.constructor != Object && v.constructor != Array) {
                // console.log(`Skipping serialization of ${v.constructor.name}`);
                continue;
            }
            json[k] = v;
        }
        return json;
    }

    async useStorage(storageId){
        this.#storageId = null;
        const data = await localforage.getItem(storageId);
        if (data) {
            for (let k in data)
                this.set(k, data[k]);
        }
        this.#storageId = storageId;
    }

    async destroy(storageId) {
        if (storageId || this.#storageId)
            await localforage.removeItem(storageId || this.#storageId);
    }

    init(values) {
        const listeners = [];
        for (const key in values) {
            const value = values[key];
            let entry = this.#data[key];
            if (entry && ('value' in entry))
                continue;
            if (!entry) {
                entry = this.#data[key] = {
                    value,
                    listeners:[]
                };
            } else {
                entry.value = value;
                listeners.push(...entry.listeners.map(l => l.bind(null, value)));
            }
        }
        listeners.forEach(listener => listener());
    }

    set(key, value) {
        let entry = this.#data[key];
        if (!entry) {
            entry = this.#data[key] = {
                value,
                listeners:[]
            };
        } else if (entry.value != value || (value && typeof value == 'object')) {
            entry.value = value;
            this.dirty(key);
        }
    }

    get(key, defval) {
        let entry = this.#data[key];
        if (!entry) {
            if (defval !== undefined)
                this.set(key, defval)
            return defval;
        }
        return entry.value;
    }

    watch(key, callback) {
        if (typeof key == 'object') {
            const bound = [];
            for (let name in key) {
                const el = key[name];
                if (Array.isArray(el) || bound.indexOf(el) != -1)
                    continue;
                for (let i = 0; i < el.attributes.length; ++i) {
                    const attr = el.attributes[i];
                    const parts = attr.name.split('-');
                    if (parts.length != 2)
                        continue;

                    let prop = ({
                        text:'textContent',
                        html:'innerHTML'
                    })[parts[1]] || parts[1];

                    if (parts[0] == 'read' || parts[0] == 'readwrite')
                        this.watch(attr.value, read.bind(this, el, prop));
                    if (parts[0] == 'write' || parts[0] == 'readwrite')
                        el.addEventListener('change', write.bind(this, el, prop, attr.value));
                    if (parts[0] == 'for' && parts[1] == 'each')
                        this.watch(attr.value, foreach.bind(this, el, el.innerHTML));
                }
            }

            function foreach(el, template, arr) {
                if (!Array.isArray(arr))
                    return;
                const children = [];
                for (const desc of arr)
                    children.push(template.replace(/\$\{([^}]+)\}/g, (_, key) => desc[key]));
                el.innerHTML = children.join('');
            }

            function read(el, prop, val) {
                el[prop] = val;
                console.log('updating ', el, 'prop', prop, 'with val', val);
            }

            function write(el, prop, key) {
                this.set(key, el[prop]);
            }
        } else {
            let entry = this.#data[key];
            if (!entry) {
                entry = this.#data[key] = {
                    listeners:[callback]
                };
            } else {
                entry.listeners.push(callback);
            }
            callback(entry.value);
        }
    }
};

module.exports.Model = Model;

},{"localforage":80}],46:[function(require,module,exports){
const {PNGFS} = require('./pngfs.js');
const {dom} = require('./dom.js');

const palette = [
    [255, 0, 255],
    [0, 0, 0],
    [15, 15, 15],
    [30, 30, 30],
    [61, 59, 0],
    [0, 2, 61],
    [45, 45, 45],
    [22, 68, 32],
    [32, 22, 68],
    [68, 32, 22],
    [91, 65, 0],
    [0, 91, 65],
    [65, 0, 91],
    [63, 63, 63],
    [42, 66, 84],
    [84, 42, 66],
    [66, 84, 42],
    [25, 105, 21],
    [21, 93, 105],
    [51, 21, 105],
    [105, 21, 59],
    [105, 84, 21],
    [127, 59, 0],
    [4, 127, 0],
    [0, 67, 127],
    [123, 0, 127],
    [79, 79, 79],
    [84, 59, 98],
    [98, 84, 59],
    [59, 98, 84],
    [39, 105, 118],
    [68, 39, 118],
    [118, 39, 73],
    [118, 100, 39],
    [42, 118, 39],
    [57, 138, 19],
    [19, 138, 84],
    [19, 90, 138],
    [51, 19, 138],
    [138, 19, 124],
    [138, 19, 23],
    [138, 118, 19],
    [158, 31, 0],
    [94, 158, 0],
    [0, 158, 94],
    [0, 31, 158],
    [158, 0, 158],
    [94, 94, 94],
    [113, 75, 79],
    [79, 113, 75],
    [75, 79, 113],
    [86, 56, 132],
    [132, 56, 86],
    [132, 116, 56],
    [56, 132, 56],
    [56, 116, 132],
    [37, 150, 141],
    [37, 64, 150],
    [109, 37, 150],
    [150, 37, 96],
    [150, 77, 37],
    [128, 150, 37],
    [37, 150, 45],
    [104, 169, 18],
    [18, 169, 33],
    [18, 169, 134],
    [18, 104, 169],
    [33, 18, 169],
    [134, 18, 169],
    [169, 18, 104],
    [169, 33, 18],
    [169, 134, 18],
    [188, 0, 9],
    [103, 188, 0],
    [0, 188, 179],
    [84, 0, 188],
    [109, 109, 109],
    [126, 131, 87],
    [87, 126, 131],
    [131, 87, 126],
    [153, 65, 97],
    [153, 138, 65],
    [65, 153, 68],
    [65, 133, 153],
    [103, 65, 153],
    [63, 43, 175],
    [175, 43, 175],
    [175, 43, 61],
    [175, 138, 43],
    [100, 175, 43],
    [43, 175, 100],
    [43, 138, 175],
    [21, 197, 138],
    [21, 138, 197],
    [21, 21, 197],
    [138, 21, 197],
    [197, 21, 138],
    [197, 21, 21],
    [197, 138, 21],
    [138, 197, 21],
    [21, 197, 21],
    [179, 219, 0],
    [32, 219, 0],
    [0, 219, 113],
    [0, 179, 219],
    [0, 32, 219],
    [113, 0, 219],
    [219, 0, 179],
    [219, 0, 32],
    [219, 113, 0],
    [127, 127, 127],
    [107, 147, 121],
    [121, 107, 147],
    [147, 121, 107],
    [169, 158, 85],
    [85, 169, 91],
    [85, 147, 169],
    [124, 85, 169],
    [169, 85, 113],
    [191, 63, 142],
    [191, 93, 63],
    [180, 191, 63],
    [70, 191, 63],
    [63, 191, 165],
    [63, 106, 191],
    [129, 63, 191],
    [43, 60, 211],
    [138, 43, 211],
    [211, 43, 172],
    [211, 43, 60],
    [211, 138, 43],
    [172, 211, 43],
    [60, 211, 43],
    [43, 211, 138],
    [43, 172, 211],
    [21, 233, 109],
    [21, 233, 222],
    [21, 127, 233],
    [32, 21, 233],
    [145, 21, 233],
    [233, 21, 205],
    [233, 21, 88],
    [233, 71, 21],
    [233, 183, 21],
    [166, 233, 21],
    [49, 233, 21],
    [255, 238, 0],
    [142, 142, 142],
    [120, 139, 165],
    [165, 120, 139],
    [139, 165, 120],
    [97, 187, 105],
    [97, 162, 187],
    [141, 97, 187],
    [187, 97, 126],
    [187, 177, 97],
    [210, 156, 75],
    [147, 210, 75],
    [75, 210, 118],
    [75, 185, 210],
    [79, 75, 210],
    [194, 75, 210],
    [210, 75, 109],
    [232, 53, 211],
    [232, 53, 91],
    [232, 133, 53],
    [211, 232, 53],
    [91, 232, 53],
    [53, 232, 133],
    [53, 211, 232],
    [53, 91, 232],
    [133, 53, 232],
    [30, 112, 255],
    [97, 30, 255],
    [247, 30, 255],
    [255, 30, 112],
    [255, 97, 30],
    [255, 247, 30],
    [112, 255, 30],
    [30, 255, 97],
    [30, 255, 247],
    [158, 158, 158],
    [169, 138, 177],
    [177, 169, 138],
    [138, 177, 169],
    [119, 172, 196],
    [159, 119, 196],
    [196, 119, 141],
    [196, 190, 119],
    [119, 196, 128],
    [119, 216, 99],
    [99, 216, 179],
    [99, 152, 216],
    [146, 99, 216],
    [216, 99, 185],
    [216, 113, 99],
    [216, 214, 99],
    [235, 134, 80],
    [233, 235, 80],
    [129, 235, 80],
    [80, 235, 134],
    [80, 233, 235],
    [80, 129, 235],
    [134, 80, 235],
    [235, 80, 233],
    [235, 80, 129],
    [229, 61, 255],
    [255, 132, 61],
    [87, 255, 61],
    [61, 183, 255],
    [173, 173, 173],
    [193, 154, 153],
    [153, 193, 154],
    [154, 153, 193],
    [177, 132, 214],
    [214, 132, 153],
    [214, 210, 132],
    [132, 214, 144],
    [132, 185, 214],
    [112, 226, 234],
    [112, 122, 234],
    [208, 112, 234],
    [234, 112, 157],
    [234, 171, 112],
    [191, 234, 112],
    [112, 234, 136],
    [159, 255, 91],
    [91, 255, 219],
    [91, 94, 255],
    [255, 91, 225],
    [255, 154, 91],
    [191, 191, 191],
    [201, 212, 170],
    [170, 201, 212],
    [212, 170, 201],
    [233, 149, 167],
    [233, 231, 149],
    [149, 233, 164],
    [149, 201, 233],
    [198, 149, 233],
    [165, 127, 255],
    [255, 127, 153],
    [216, 255, 127],
    [127, 255, 229],
    [206, 206, 206],
    [182, 230, 205],
    [205, 182, 230],
    [230, 205, 182],
    [255, 255, 158],
    [158, 255, 255],
    [255, 158, 255],
    [221, 221, 221],
    [188, 207, 255],
    [255, 236, 188],
    [237, 237, 237],
    [255, 255, 255]
];

function getImageHeaderSize(img) {
    if (img.width < 256 && img.height < 256)
        return 4;
    return 7;
}

function convertToU8(img, settings){
    settings = settings || {bpp:8, header:1, isTransparent:1};
    let transparentIndex = settings.transparent|0;
    // let palette = settings.palette;
    let out = [];
    let bpp = (settings.bpp|0) || (Math.log(palette.length) / Math.log(2))|0;
    if (settings.header|0) {
        if (getImageHeaderSize(img) === 4) {
            out.push([img.width, img.height, bpp, 0]);
        } else {
            out.push([
                0,
                (img.width >> 8) & 0xFF, img.width & 0xFF,
                (img.height >> 8) & 0xFF, img.height & 0xFF,
                bpp,
                0
            ]);
        }
    }
    let i=0, len, bytes, data = img.data;
    let ppb = 8 / bpp;
    let run = [],
        min = settings.paloffset|0,
        max = Math.min(palette.length, min+(1<<bpp));
    let lowest = 255;
    let highest = 0;

    let transparent = settings.isTransparent;

    if (transparent === undefined){
        for( i=3; !transparent && i<data.length; i+=4 ){
            transparent = data[i] < 128;
        }
    } else transparent = transparent|0;
    settings.isTransparent = transparent;

    i=0;
    let PC = undefined, PCC = 0;

    for( let y=0; y<img.height; ++y ){

        run = [];

        for( let x=0; x<img.width; ++x ){
            let closest = 0;
            let closestDist = Number.POSITIVE_INFINITY;
            let R = data[i++]|0;
            let G = data[i++]|0;
            let B = data[i++]|0;
            let A = data[i++]|0;
            if(bpp == 16) {
                let C = (R>>3<<11) | (G>>2<<5) | (B>>3);
                run.push(C&0xFF, C>>8);
            } else if(bpp == 1) {
                if (transparent) {
                    closest = A > 128;
                } else {
                    closest = (R + G + B) / 3 > 128;
                }

                run[x>>3|0] = (run[x>>3]||0) + (closest<<(7 - (x&7)));
            } else {
                let C = (R<<16) + (G<<8) + B;
                if( A > 128 || !transparent ) {
                    if(C === PC){
                        closest = PCC;
                    } else {

                        for( let c=min; c<max; ++c ){
                            if( transparent && c == transparentIndex )
                                continue;
                            const ca = palette[c];
                            const PR = ca[0]|0;
                            const PG = ca[1]|0;
                            const PB = ca[2]|0;
		            const dist = (R-PR)*(R-PR)
                                  + (G-PG)*(G-PG)
                                  + (B-PB)*(B-PB);

                            if( dist < closestDist ){
                                closest = c;
                                closestDist = dist;
                            }
                        }

                        PC = C;
                        PCC = closest;

                    }

                }else{
                    closest = transparentIndex;
                }

                if (closest < lowest)
                    lowest = closest;
                if (closest > highest)
                    highest = closest;

                let shift = (ppb - 1 - x%ppb) * bpp;
                run[(x/ppb)|0] = (run[(x/ppb)|0]||0) + ((closest-min)<<shift);
            }
        }

        out.push(run);
    }

    let range = (highest - lowest) + 1;


    return out;
}

function bytesToStr(arr) {
    let out = '';
    if (!Array.isArray(arr))
        throw "Expected array of bytes";
    for (let data of arr) {
        if (typeof data === 'number') {
            data = data >>> 0;
            do {
                const v = data & 0xFF;
                data >>>= 8;
                out += v.toString(16).padStart(2, '0');
            } while (data > 0);
        } else {
            out += bytesToStr(data);
        }
    }
    return out;
}

function normalizeBytes(arr) {
    let out = [];
    if (!Array.isArray(arr))
        throw "Expected array of bytes";
    for (let data of arr) {
        if (typeof data === 'number') {
            data = data >>> 0;
            do {
                const v = data & 0xFF;
                data >>>= 8;
                out.push(v);
            } while (data > 0);
        } else {
            for (let b of normalizeBytes(data))
                out.push(b);
        }
    }
    return out;
}

function bytesToWords(bytes) {
    while (bytes.length & 0x3)
        bytes.push(0);
    return Array.from(new Uint32Array(Uint8Array.from(bytes).buffer));
}

function bytesToLen(arr) {
    let out = 0;
    if (!Array.isArray(arr))
        return 0;
    for (let data of arr) {
        if (typeof data === 'number') {
            data = data >>> 0;
            do {
                const v = data & 0xFF;
                data >>>= 8;
                out += 2;
            } while (data > 0);
        } else {
            out += bytesToLen(data);
        }
    }
    return out;
}

function u32(x) {
    return [
        (x) & 0xFF,
        (x >>> 8) & 0xFF,
        (x >>> 16) & 0xFF,
        (x >>> 24) & 0xFF
    ];
}

function u16(x) {
    return [
        (x) & 0xFF,
        (x >>> 8) & 0xFF
    ];
}

async function loadImage(data) {
    return new Promise((resolve, fail) => {
        const img = new Image();
        img.onload = _=>{
            const canvas = dom('canvas', {width:img.width, height:img.height});
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            resolve(ctx.getImageData(0, 0, img.width, img.height));
        };
        img.onerror = _=>{
            fail('Could not load image ' + name);
        };
        img.src = data;
    });
}

async function convertImage(name, data, outfs, tileTable) {
    const recname = name.split('.')[0];
    const imgdata = await loadImage(data);
    tileTable.setTileImage(name, imgdata);
    const out = bytesToStr(convertToU8(imgdata, {bpp:8, header:1, isTransparent:1}));
    const outName = `/.R/${recname}.raw`;
    outfs.writeFile(outName, out);
}

function getTile(index, layerNumber, data) {
    let tile = null;

    if (layerNumber != 0) {
        let id = data.layers[layerNumber].data[index];
        tile = getSingleTile(data, id);
        if (tile)
            tile.gid = [id];
    } else {
        const gid = [];
        for (let i = 0; i < data.layers.length; ++i) {
            if (data.layers[i].type != 'tilelayer')
                continue;
            let id = data.layers[i].data[index];
            let single = getSingleTile(data, id);
            if (!single)
                continue;
            if (!tile)
                tile = Object.assign({}, single, {properties:{}, gid});
            gid.push(id);
            Object.assign(tile.properties, single.properties);
        }
    }

    return tile;

    function getSingleTile(map, id) {
        id &= 0xFFFFFF;

        if (!id)
            return null;

        if (!map._cache)
            map._cache = {};
        const cache = map._cache;

        if (id in cache)
            return cache[id];

        let tilesets = map.tilesets;
        let set = null;
        for (let candidate of tilesets) {
            if (candidate.firstgid <= id && (candidate.firstgid + candidate.tilecount) > id) {
                set = candidate;
                break;
            }
        }

        if (!set) {
            cache[id] = null;
            return null;
        }

        let index = (id|0) - (set.firstgid|0);
        let x = index % set.columns;
        let y = (index / set.columns) | 0;
        let properties = null;

        if (set.tiles) {
            for (let entry of set.tiles) {
                if (entry.id != index)
                    continue;
                properties = Object.assign(Object.create(null), entry);
                delete properties.id;

                for (let prop in properties) {
                    let value = prop.value;

                    if (typeof value == 'string')
                        value = {h:value};
                    else
                        value |= 0;

                    if (!value)
                        delete properties[prop];
                    else
                        properties[prop] = value;
                }

                if (entry.properties) {
                    delete properties.properties;
                    for (let prop of entry.properties) {
                        let value = prop.value;

                        if (typeof value == "string")
                            value = {h:value};
                        else
                            value |= 0;

                        if (value)
                            properties[prop.name] = value;
                    }
                }

                break;
            }
        }

        const tile = {
            image:set.image,
            properties,
            offsetX:x * set.tilewidth,
            offsetY:y * set.tileheight
        };

        cache[id] = tile;

        return tile;
    }
}

function convertTileLayer(layer, data, tileTable, layerNumber) {
    const out = [0];
    for (let i = 0; i < layer.data.length; ++i) {
        let tile = getTile(i, layerNumber, data);
        if (!tile) {
            out.push(0);
            continue;
        }
        let cell = tile.gid.join(',');
        delete tile.gid;
        let id = tileTable.getId(cell, tile, false, false);
        out.push(id);
    }
    return out;
}

function convertObjectLayer(layer, data, tileTable) {
    const out = [1];
    return out;
}

async function convertTMJ(name, datasrc, outfs, tileTable) {
    const data = JSON.parse(datasrc);
    const layerCount = [];
    const header = [
        0, 0xFF,                                  // map resource indicator
        layerCount,                               // layer count
        u32(0),                                   // tile set offset
        u16(data.width), u16(data.height),        // map width, height
        u16(data.tilewidth), u16(data.tileheight) // tile width, height
    ];

    const layers = [];
    const tiles = [];
    const out = [header, layers, tiles];
    const outName = `/.R/${name.split('.')[0]}.u32`;
    let visibleLayerCount = 0;
    for (let i = 0; i < data.layers.length; ++i) {
        let layer = data.layers[i];
        if (!layer.visible)
            continue;
        visibleLayerCount++;
        if (layer.type == "tilelayer") {
            layers.push(convertTileLayer(layer, data, tileTable, layers.length));
        } else if (layer.type == "objectgroup") {
            layers.push(convertObjectLayer(layer, data, tileTable, layers.length));
        }
    }

    layerCount.push(u16(visibleLayerCount));

    const tileStart = bytesToLen(out);
    // header[1] = u32(tileStart);
    tileTable.tileStart = tileStart;

    // outfs.writeFile(outName, bytesToStr(out));
    const normalized = bytesToWords(normalizeBytes(out));
    normalized.splice(1, 1, {r:'TileTable'});

    outfs.writeFile(outName, JSON.stringify(normalized));
}

class TileTable {
    index = [];
    cache = {};
    tileStart = 0;

    images = Object.create(null);

    setTileImage(name, data) {
        this.images[name] = data;
    }

    serialize(out) {
        let tiles = [];
        let props = [];
        out.push(tiles, props);
    }

    write(fs) {
        const tiles = [];
        const props = [];
        let propind = this.index.length * 2;

        for (let entry of this.index) {
            let img = this.images[entry.tile.image];
            if (!img)
                throw "Could not find " + entry.tile.image + " for tileset";

            const tile = entry.tile;
            let propcount = tile.properties ? Object.keys(tile.properties).length : 0;

            tiles.push(
                {r:tile.image, o:getImageHeaderSize(img) + tile.offsetY * img.width + tile.offsetX},
                (propcount ? propind : 0) | (img.width << 16)
            );

            if (tile.properties) {
                props.push(propcount); propind++;
                for (let key in tile.properties) {
                    props.push({h:key}, tile.properties[key]);
                    propind += 2;
                }
            }
        }

        const out = [...tiles, ...props];
        fs.writeFile('/.R/TileTable.u32', JSON.stringify(out));
    }

    getTile(id) {
        return this.index[id - 1];
    }

    getId(gid, tile, mirror, flip) {
        if (gid in this.cache)
            return this.cache[gid];

        let key = JSON.stringify([tile, mirror, flip]);
        for (let i = 0; i < this.index.length; ++i) {
            const entry = this.index[i];
            if (entry.key == key) {
                this.cache[gid] = i + 1;
                return i + 1;
            }
        }

        this.index.push({
            key,
            tile,
            mirror, flip
        });

        this.cache[gid] = this.index.length;
        return this.cache[gid];
    }
}

async function prebuild(fs) {
    let promises = [];
    let outfs;
    let tileTable = new TileTable();

    fs.recurse(entity => {
        if (!entity.isFile())
            return entity.name[0] != '.';
        let extension = entity.extension;
        if (extension == 'jpg' || extension == 'png') {
            init().push(convertImage.call(this, entity.name, entity.node.data, outfs, tileTable));
        }
        if (extension == 'tmj') {
            init().push(convertTMJ.call(this, entity.name, entity.node.data, outfs, tileTable));
        }
        return false;
    });

    if (!promises.length)
        return fs;

    await Promise.all(promises);

    tileTable.write(outfs);

    return outfs;

    function init() {
        if (!outfs) {
            outfs = new PNGFS(fs.toJSON());
            outfs.mkdir('/.R');
            outfs.mkdir('/.SD');
        }
        return promises;
    }
}

module.exports.PreBuild = prebuild;
module.exports.palette = palette;
module.exports.convertToU8 = convertToU8;

},{"./dom.js":62,"./pngfs.js":83}],47:[function(require,module,exports){
"use strict";

const {
  index
} = require('./dom.js');
class Preview {
  constructor(node, parent, model) {
    this.view = index(node, {}, this);
    this.model = model;
    this.parent = parent;
    model.watch(this.view);
    model.watch('platform', _ => this.resize());
    model.watch('previewHTML', html => this.showHTML(html));
    this.resize();
  }
  getPlatformSize() {
    const platform = this.model.get('platform');
    const lcd = {
      pokitto: [220, 176],
      blit: [320, 240],
      espboy: [128, 128],
      meta: [160, 128],
      metro: [320, 240],
      pico: [240, 240],
      galuni: [53, 11]
    };
    return lcd[platform];
  }
  setExportVisibility(visible) {
    this.view.export.classList.toggle('hidden', !visible);
  }
  resize() {
    const container = this.view.screencontainer;
    const size = this.getPlatformSize();
    const zoom = this.view.zoom.value;
    if (!size) {
      container.display = 'none';
      return;
    }
    const [width, height] = size;
    const screen = this.view.screencontainer.querySelector('iframe');
    if (screen) {
      screen.style.width = width * zoom + "px";
      screen.style.height = height * zoom + "px";
    }
    container.style.display = 'block';
    container.style.height = height * zoom + "px";
    container.style["min-width"] = width * zoom + "px";
    container.parentElement.style["min-width"] = width * zoom + "px";
  }
  htmlStub() {
    document.addEventListener('DOMContentLoaded', _ => {
      if (typeof canvas != "undefined") {
        canvas.addEventListener('click', ({
          clientX,
          clientY
        }) => {
          const X = Math.round(clientX / canvas.clientWidth * 1000) / 1000;
          const Xpx = Math.round(X * canvas.width);
          const Y = Math.round(clientY / canvas.clientHeight * 1000) / 1000;
          const Ypx = Math.round(Y * canvas.height);
          if (window.top != window) window.top.postMessage({
            log: [`click:
X: ${Xpx}px or getWidth()*${X}
Y: ${Ypx}px or getHeight()*${Y}
`]
          }, "*");
        });
      }
    });
  }
  showHTML(html) {
    this.view.screen.remove();
    this.view.screencontainer.innerHTML = this.view.screen.outerHTML;
    const screen = this.view.screencontainer.querySelector('iframe');
    screen.src = "about:blank";
    let stopped = !html;
    if (!stopped) screen.focus();
    html = html || '';
    html += `<script>(function ${this.htmlStub.toString()})();</script>`;
    screen.contentWindow.document.open();
    screen.contentWindow.document.write(html);
    screen.contentWindow.document.close();
    this.resize();
    this.view.run.textContent = !stopped ? 'Stop' : 'Run';
  }
  toggleRun() {
    this.model.set('runSize', this.model.get('previewHTML') ? null : this.getPlatformSize());
  }
  export() {
    this.parent.export();
  }
}
module.exports.Preview = Preview;

},{"./dom.js":62}],48:[function(require,module,exports){
const {dom, index} = require('./dom.js');

class ProjectControls {
    constructor(el, model) {
        this.el = el;
        this.view = index(el, {}, this);
        this.model = model;
        model.watch(this.view);
    }

    goToTOP() {
        this.model.set('state', 'TOP');
    }
}

module.exports.ProjectControls = ProjectControls;

},{"./dom.js":62}],49:[function(require,module,exports){
"use strict";

var _app = require("firebase/app");
var _database = require("firebase/database");
class Remote {
  #db;
  #listen;
  constructor() {}
  async requestKey() {
    return (0, _database.push)((0, _database.child)((0, _database.ref)(this.#db), 'project')).key;
  }
  async saveProject(key, data) {
    await (0, _database.set)((0, _database.ref)(this.#db, 'project/' + key), data);
  }
  async loadProject(key) {
    const snapshot = await (0, _database.get)((0, _database.ref)(this.#db, 'project/' + key));
    return snapshot.exists() ? snapshot.val() : undefined;
  }
  async requestBuild(key, project) {
    await (0, _database.update)((0, _database.ref)(this.#db), {
      [`/project/${key}`]: project,
      [`/request/${key}`]: 'build',
      [`/build/${key}`]: null
    });
    return new Promise((ok, fail) => {
      const listen = (0, _database.ref)(this.#db, `/build/${key}`);
      (0, _database.onValue)(listen, snapshot => {
        if (!snapshot.exists()) return;
        (0, _database.off)(listen);
        ok(snapshot.val());
      });
    });
  }
  boot() {
    const FBAPP = (0, _app.initializeApp)({
      apiKey: "AIzaSyDsjCMDUl0e50zO_L_g7gWJyfLENuMv2a8",
      authDomain: "microjs-7d00a.firebaseapp.com",
      projectId: "microjs-7d00a",
      storageBucket: "microjs-7d00a.appspot.com",
      messagingSenderId: "850079858570",
      appId: "1:850079858570:web:f71216680a1a6c624c1273",
      databaseURL: "https://microjs-7d00a-default-rtdb.europe-west1.firebasedatabase.app"
    });
    this.#db = (0, _database.getDatabase)(FBAPP);
  }
}
module.exports.Remote = Remote;

},{"firebase/app":74,"firebase/database":75}],50:[function(require,module,exports){
const base = require('./Flasher.js');
const {SamBA} = require('./samba.js');
const {Device} = require('./device.js');
const {Flash} = require('./SAMDFlash.js');
const {Uint8Buffer} = require('./Uint8Buffer.js');

class FlashOffsetError extends Error {
  constructor(msg) {
    super(msg);
  }
}

class FileSizeError extends Error {
  constructor(msg) {
    super(msg);
  }
}

class Flasher {
  constructor(samba, flash, observer) {
    this._flash = flash;
    this._samba = samba;
    this._observer = observer;
  }

  _samba;
  _flash;
  _observer;

  async erase(foffset) {
    this._observer.onStatus('Erase flash\n');
    await this._flash.eraseAll(foffset);
    this._flash.eraseAuto = false;
  }

  async write(data, foffset) {

    let pageSize = this._flash.pageSize;
    var pageNum = 0;
    var numPages = 0;
    var fsize = data.byteLength;
    let fbytes = 0;
    let remaining = data.byteLength;
    var dataOffset = 0;

    // target address must align with pages
    if (foffset % pageSize != 0 || foffset >= this._flash.totalSize)
        throw new FlashOffsetError();

    numPages = Math.trunc((fsize + pageSize - 1) / pageSize);
    if (numPages > this._flash.numPages)
        throw new FileSizeError();

    this._observer.onStatus('Write ' + fsize + ' bytes to flash (' + numPages + ' pages)\n');

    if (this._samba.canWriteBuffer)
    {
        var offset = 0;
        let bufferSize = this._samba.writeBufferSize;
        let buffer = new Uint8Buffer(bufferSize);

        while (remaining > 0) {
          let fbytes = (remaining < bufferSize ? remaining : bufferSize);

          buffer.reset();
          buffer.copy(new Uint8Array(data.slice(dataOffset, dataOffset + fbytes)));

          this._observer.onProgress(offset / pageSize, numPages);

          remaining -= fbytes;
          dataOffset += fbytes;

          if (fbytes < bufferSize)
          {
            buffer.fill(0, bufferSize - fbytes);
            fbytes = Math.trunc((fbytes + pageSize - 1) / pageSize) * pageSize;
          }

          await this._flash.loadBuffer(buffer.view(), 0, fbytes);
          await this._flash.writeBuffer(foffset + offset, fbytes);

          offset += fbytes;
        }
    }
    else
    {
      let buffer = new Uint8Buffer(pageSize);
      let pageOffset = foffset / pageSize;

      while (remaining > 0) {

        let fbytes = (remaining < pageSize ? remaining : pageSize);

        buffer.reset();
        buffer.copy(new Uint8Array(data.slice(dataOffset, dataOffset + fbytes)));

        this._observer.onProgress(pageNum, numPages);

        remaining -= fbytes;
        dataOffset += fbytes;

        if (fbytes < pageSize)
        {
          buffer.fill(0, pageSize - fbytes);
          fbytes = Math.trunc((fbytes + pageSize - 1) / pageSize) * pageSize;
        }

        await this._flash.loadBuffer(buffer.view(), 0, fbytes);
        await this._flash.writePage(pageOffset + pageNum);

        pageNum++;

        if (pageNum == numPages || fbytes != pageSize)
          break;
      }

    }

    this._observer.onProgress(numPages, numPages);
  }

  async verify(data, foffset) {

//     uint32_t pageSize = _flash->pageSize();
//     uint8_t bufferA[pageSize];
//     uint8_t bufferB[pageSize];
//     uint32_t pageNum = 0;
//     uint32_t numPages;
//     uint32_t pageOffset;
//     uint32_t byteErrors = 0;
//     uint16_t flashCrc;
//     long fsize;
//     size_t fbytes;

//     pageErrors = 0;
//     totalErrors = 0;

//     if (foffset % pageSize != 0 || foffset >= _flash->totalSize())
//         throw FlashOffsetError();

//     pageOffset = foffset / pageSize;

//     infile = fopen(filename, "rb");
//     if (!infile)
//         throw FileOpenError(errno);

//     try
//     {
//         if (fseek(infile, 0, SEEK_END) != 0 || (fsize = ftell(infile)) < 0)
//             throw FileIoError(errno);

//         rewind(infile);

//         numPages = (fsize + pageSize - 1) / pageSize;
//         if (numPages > _flash->numPages())
//             throw FileSizeError();

//         _observer.onStatus("Verify %ld bytes of flash\n", fsize);

//         while ((fbytes = fread(bufferA, 1, pageSize, infile)) > 0)
//         {
//             byteErrors = 0;

//             _observer.onProgress(pageNum, numPages);

//             if (_samba.canChecksumBuffer())
//             {
//                 uint16_t calcCrc = 0;
//                 for (uint32_t i = 0; i < fbytes; i++)
//                     calcCrc = _samba.checksumCalc(bufferA[i], calcCrc);

//                 flashCrc = _samba.checksumBuffer((pageOffset + pageNum) * pageSize, fbytes);

//                 if (flashCrc != calcCrc)
//                 {
//                     _flash->readPage(pageOffset + pageNum, bufferB);

//                     for (uint32_t i = 0; i < fbytes; i++)
//                     {
//                         if (bufferA[i] != bufferB[i])
//                             byteErrors++;
//                     }
//                 }
//             }
//             else
//             {
//                 _flash->readPage(pageOffset + pageNum, bufferB);

//                 for (uint32_t i = 0; i < fbytes; i++)
//                 {
//                     if (bufferA[i] != bufferB[i])
//                         byteErrors++;
//                 }
//             }

//             if (byteErrors != 0)
//             {
//                 pageErrors++;
//                 totalErrors += byteErrors;
//             }

//             pageNum++;
//             if (pageNum == numPages || fbytes != pageSize)
//                 break;
//         }
//     }
//     catch(...)
//     {
//         fclose(infile);
//         throw;
//     }

//     fclose(infile);

//      _observer.onProgress(numPages, numPages);

//     if (pageErrors != 0)
//         return false;

//     return true;
// }
  }

// read(const char* filename, uint32_t fsize, uint32_t foffset)
// {
//     FILE* outfile;
//     uint32_t pageSize = _flash->pageSize();
//     uint8_t buffer[pageSize];
//     uint32_t pageNum = 0;
//     uint32_t pageOffset;
//     uint32_t numPages;
//     size_t fbytes;

//     if (foffset % pageSize != 0 || foffset >= _flash->totalSize())
//         throw FlashOffsetError();

//     pageOffset = foffset / pageSize;

//     if (fsize == 0)
//         fsize = pageSize * (_flash->numPages() - pageOffset);

//     numPages = (fsize + pageSize - 1) / pageSize;
//     if (pageOffset + numPages > _flash->numPages())
//         throw FileSizeError();

//     outfile = fopen(filename, "wb");
//     if (!outfile)
//         throw FileOpenError(errno);

//     _observer.onStatus("Read %d bytes from flash\n", fsize);

//     try
//     {
//         for (pageNum = 0; pageNum < numPages; pageNum++)
//         {
//             _observer.onProgress(pageNum, numPages);

//             _flash->readPage(pageOffset + pageNum, buffer);

//             if (pageNum == numPages - 1 && fsize % pageSize > 0)
//                 pageSize = fsize % pageSize;
//             fbytes = fwrite(buffer, 1, pageSize, outfile);
//             if (fbytes != pageSize)
//                 throw FileShortError();
//         }
//     }
//     catch(...)
//     {
//         fclose(outfile);
//         throw;
//     }

//     _observer.onProgress(numPages, numPages);

//     fclose(outfile);
// }

// void
// Flasher::lock(string& regionArg, bool enable)
// {
//     if (regionArg.empty())
//     {
//         _observer.onStatus("%s all regions\n", enable ? "Lock" : "Unlock");
//         std::vector<bool> regions(_flash->lockRegions(), enable);
//         _flash->setLockRegions(regions);
//     }
//     else
//     {
//         size_t pos = 0;
//         size_t delim;
//         uint32_t region;
//         string sub;
//         std::vector<bool> regions = _flash->getLockRegions();

//         do
//         {
//             delim = regionArg.find(',', pos);
//             sub = regionArg.substr(pos, delim - pos);
//             region = strtol(sub.c_str(), NULL, 0);
//             _observer.onStatus("%s region %d\n", enable ? "Lock" : "Unlock", region);
//             regions[region] = enable;
//             pos = delim + 1;
//         } while (delim != string::npos);

//         _flash->setLockRegions(regions);
//     }
// }


}


class SAMDFlasher extends base.Flasher {
    port;
    samba;
    device;

    async connect() {
        if (this.port) {
            try {
                this.disconnect();
            } catch(ex) {}
        }

        let port = await (navigator.serial.requestPort({
            filters:[{
                usbVendorId:0x2341,
                usbProductId:0x804d
            }, {
                usbVendorId:0x2341,
                usbProductId:0x4d
            }]
        }));

        let info = port.getInfo();
        console.log('VID: 0x' + info.usbVendorId.toString(16), ' PID:0x' + info.usbProductId.toString(16));

        if (info.usbProductId == 0x804d) {
            await port.open({ baudRate: 1200 });
            await new Promise(ret => setTimeout(ret, 100));
            await port.close();
            throw "retry";
        }

        this.port = port;
    }

    disconnect() {
        if (!this.port)
            return;
        this.port.close();
        this.port = null;
    }

    async upload(offset) {
        const binary = this.data.buffer;

        if (!this.port) {
            await this.showConnectPopup();
        }
        await this.connect();

        this.samba = new SamBA(this.port, {
            logger: {
                log: this.log,
                debug: this.log,
                error: this.log
            }// ,
            // debug: true,
            // trace: true
        });

        const samba = this.samba;
        await samba.connect(false, 1000);

        const device = new Device(samba);
        await device.create();
        this.device = device;

        await this.flashImage(binary, offset);
        await this.device.reset();
    }

    async flashImage(data, address) {
        if (!this.device)
            throw "No device";
        if (!this.samba)
            throw "No samba";
        if (!this.device.flash)
            throw "No device.flash";
        const flasher = new Flasher(this.samba, this.device.flash, this);
        await flasher.erase(address);
        await flasher.write(data, address);
    }

    onStatus(msg) {
        this.log(msg);
    }

    onProgress(progress, total) {
        postMessage({build:["Uploading: " + Math.floor((progress / total) * 100) + "%"]}, '*');
    }
}

module.exports.upload = async function(offset, binary, name = "micojs") {
    window.retry = async () => {
        const flasher = new SAMDFlasher(name + ".bin", new Uint8Array(binary));
        // await flasher.connect();
        await flasher.upload(offset);
    };

    let msg;

    do {
        msg = null;
        try {
            await window.retry();
        } catch (ex) {
            msg = ex;
        }
    } while (msg == "retry");

    if (msg)
        throw msg;
};

},{"./Flasher.js":42,"./SAMDFlash.js":53,"./Uint8Buffer.js":59,"./device.js":61,"./samba.js":84}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.D2xNvmFlash = void 0;
const {
  Flash,
  FlashCmdError,
  FlashConfigError,
  FlashPageError,
  FlashEraseError
} = require('./SAMDFlash.js');
const {
  SamBA
} = require('./samba.js');

// CMDEX field should be 0xA5 to allow execution of any command.
const CMDEX_KEY = 0xa500;

// NVM ready bit mask
const NVM_INT_STATUS_READY_MASK = 0x1;

// NVM status mask
const NVM_CTRL_STATUS_MASK = 0xFFEB;
const NVM_REG_BASE = 0x41004000;
const NVM_REG_CTRLA = 0x00;
const NVM_REG_CTRLB = 0x04;
const NVM_REG_INTFLAG = 0x14;
const NVM_REG_STATUS = 0x18;
const NVM_REG_ADDR = 0x1c;
const NVM_REG_LOCK = 0x20;
const NVM_CMD_ER = 0x02;
const NVM_CMD_WP = 0x04;
const NVM_CMD_EAR = 0x05;
const NVM_CMD_WAP = 0x06;
const NVM_CMD_LR = 0x40;
const NVM_CMD_UR = 0x41;
const NVM_CMD_SSB = 0x45;
const NVM_CMD_PBC = 0x44;
const ERASE_ROW_PAGES = 4; // pages

// NVM User Row
const NVM_UR_ADDR = 0x804000;
const NVM_UR_BOD33_ENABLE_OFFSET = 0x1;
const NVM_UR_BOD33_ENABLE_MASK = 0x6;
const NVM_UR_BOD33_RESET_OFFSET = 0x1;
const NVM_UR_BOD33_RESET_MASK = 0x7;
const NVM_UR_NVM_LOCK_OFFSET = 0x6;
class D2xNvmFlash extends Flash {
  _eraseAuto;
  constructor(samba, name, pages, size, user, stack) {
    super(samba, name, 0, pages, size, 1, 16, user, stack);
    this._eraseAuto = true;
  }
  get NVM_UR_SIZE() {
    return this._size * ERASE_ROW_PAGES;
  }
  async erase(offset, size) {
    let eraseSize = this._size * ERASE_ROW_PAGES;

    // Offset must be a multiple of the erase size
    if (offset % eraseSize) throw new FlashEraseError();

    // Offset and size must be in range
    if (offset + size > this.totalSize) throw new FlashEraseError();
    let eraseEnd = (offset + size + eraseSize - 1) / eraseSize;

    // Erase each erase size set of pages
    for (var eraseNum = offset / eraseSize; eraseNum < eraseEnd; eraseNum++) {
      await this.waitReady();

      // Clear error bits
      let statusReg = await this.readReg(NVM_REG_STATUS);
      await this.writeReg(NVM_REG_STATUS, statusReg | NVM_CTRL_STATUS_MASK);

      // Issue erase command
      let wordAddr = eraseNum * eraseSize / 2;
      await this.writeReg(NVM_REG_ADDR, wordAddr);
      await this.command(NVM_CMD_ER);
    }
  }
  async eraseAll(offset) {
    // Use the extended Samba command if available
    if (this._samba.canChipErase) {
      await this._samba.chipErase(offset);
    } else {
      await this.erase(offset, this.totalSize - offset);
    }
  }
  get eraseAuto() {
    return this._eraseAuto;
  }
  set eraseAuto(enable) {
    this._eraseAuto = enable;
  }
  async getLockRegions() {
    var lockBits = 0;
    let addr = NVM_UR_ADDR + NVM_UR_NVM_LOCK_OFFSET;
    var regions = new Array(this._lockRegions);
    for (var region = 0; region < this._lockRegions; region++) {
      if (region % 8 == 0) lockBits = await this._samba.readByte(addr++);
      regions[region] = (lockBits & 1 << region % 8) == 0;
    }
    return regions;
  }
  async getSecurity() {
    let reg = await this.readReg(NVM_REG_STATUS);
    return (reg & 0x100) != 0;
  }
  async getBod() {
    let byte = await this._samba.readByte(NVM_UR_ADDR + NVM_UR_BOD33_ENABLE_OFFSET);
    return (byte & NVM_UR_BOD33_ENABLE_MASK) != 0;
  }
  canBod() {
    return true;
  }
  async getBor() {
    let byte = await this._samba.readByte(NVM_UR_ADDR + NVM_UR_BOD33_RESET_OFFSET);
    return (byte & NVM_UR_BOD33_RESET_MASK) != 0;
  }
  canBor() {
    return true;
  }
  getBootFlash() {
    return true;
  }
  canBootFlash() {
    return false;
  }
  async readUserRow(userRow) {
    if (userRow.length != this.NVM_UR_SIZE) throw new Error('Invalid row buffer size');
    await this._samba.read(NVM_UR_ADDR, userRow, this.NVM_UR_SIZE);
  }
  async writeOptions() {
    var userRow = new Uint8Array(this.NVM_UR_SIZE);
    if (this.canBor() && this._bor.isDirty() && this._bor.get() != (await this.getBor())) {
      await this.readUserRow(userRow);
      if (this._bor.get()) userRow[NVM_UR_BOD33_RESET_OFFSET] |= NVM_UR_BOD33_RESET_MASK;else userRow[NVM_UR_BOD33_RESET_OFFSET] &= ~NVM_UR_BOD33_RESET_MASK;
    }
    if (this.canBod() && this._bod.isDirty() && this._bod.get() != (await this.getBod())) {
      await this.readUserRow(userRow);
      if (this._bod.get()) userRow[NVM_UR_BOD33_ENABLE_OFFSET] |= NVM_UR_BOD33_ENABLE_MASK;else userRow[NVM_UR_BOD33_ENABLE_OFFSET] &= ~NVM_UR_BOD33_ENABLE_MASK;
    }
    if (this._regions.isDirty()) {
      // Check if any lock bits are different from the current set
      var current = await this.getLockRegions();
      var regions = this._regions.get();
      var equal = true;
      for (var i = 0; i < regions.length && equal; i++) {
        equal &= regions[i] == current[i];
      }
      if (!equal) {
        await this.readUserRow(userRow);
        for (var region = 0; region < this._regions.get().length; region++) {
          if (this._regions.get()[region]) userRow[NVM_UR_NVM_LOCK_OFFSET + region / 8] &= ~(1 << region % 8);else userRow[NVM_UR_NVM_LOCK_OFFSET + region / 8] |= 1 << region % 8;
        }
      }
    }

    // Erase and write the user row if modified
    if (userRow) {
      // Disable cache and configure manual page write
      await this.writeReg(NVM_REG_CTRLB, (await this.readReg(NVM_REG_CTRLB)) | 0x1 << 18 | 0x1 << 7);

      // Erase user row
      await this.writeReg(NVM_REG_ADDR, NVM_UR_ADDR / 2);
      await this.command(NVM_CMD_EAR);

      // Write user row in page chunks
      for (var offset = 0; offset < this.NVM_UR_SIZE; offset += this._size) {
        // Load the buffer with the page
        await this.loadBuffer(userRow, offset, this._size);

        // Clear page buffer
        await this.command(NVM_CMD_PBC);

        // Copy page to page buffer
        await this.prepareApplet();
        await this._wordCopy.setDstAddr(NVM_UR_ADDR + offset);
        await this._wordCopy.setSrcAddr(this._onBufferA ? this._pageBufferA : this._pageBufferB);
        this._onBufferA = !this._onBufferA;
        await this.waitReady();
        await this._wordCopy.runv();

        // Write the page
        await this.writeReg(NVM_REG_ADDR, (NVM_UR_ADDR + offset) / 2);
        await this.command(NVM_CMD_WAP);
      }
    }

    // Always do security last
    if (this._security.isDirty() && this._security.get() == true && this._security.get() != (await this.getSecurity())) {
      await this.command(NVM_CMD_SSB);
    }
  }
  async writePage(page) {
    if (page >= this._pages) {
      throw new FlashPageError();
    }

    // Disable cache and configure manual page write
    await this.writeReg(NVM_REG_CTRLB, (await this.readReg(NVM_REG_CTRLB)) | 0x1 << 18 | 0x1 << 7);

    // Auto-erase if writing at the start of the erase page
    if (this.eraseAuto && page % ERASE_ROW_PAGES == 0) await this.erase(page * this._size, ERASE_ROW_PAGES * this._size);

    // Clear page buffer
    await this.command(NVM_CMD_PBC);

    // Compute the start address.
    let addr = this._addr + page * this._size;
    await this.prepareApplet();
    await this._wordCopy.setDstAddr(addr);
    await this._wordCopy.setSrcAddr(this._onBufferA ? this._pageBufferA : this._pageBufferB);
    this._onBufferA = !this._onBufferA;
    await this.waitReady();
    await this._wordCopy.runv();
    await this.writeReg(NVM_REG_ADDR, addr / 2);
    await this.command(NVM_CMD_WP);
  }
  async waitReady() {
    while (((await this.readReg(NVM_REG_INTFLAG)) & 0x1) == 0);
  }
  async readPage(page, buf) {
    if (page >= this._pages) {
      throw new FlashPageError();
    }
    await this._samba.read(this._addr + page * this._size, buf, this._size);
  }
  async readReg(reg) {
    return await this._samba.readWord(NVM_REG_BASE + reg);
  }
  async writeReg(reg, value) {
    await this._samba.writeWord(NVM_REG_BASE + reg, value);
  }
  async command(cmd) {
    await this.waitReady();
    await this.writeReg(NVM_REG_CTRLA, CMDEX_KEY | cmd);
    await this.waitReady();
    if ((await this.readReg(NVM_REG_INTFLAG)) & 0x2) {
      // Clear the error bit
      await this.writeReg(NVM_REG_INTFLAG, 0x2);
      throw new FlashCmdError();
    }
  }
  async writeBuffer(dst_addr, size) {
    // Auto-erase if enabled
    if (this.eraseAuto) await this.erase(dst_addr, size);

    // Call the base class method
    await super.writeBuffer(dst_addr, size);
  }
  /* */
}
exports.D2xNvmFlash = D2xNvmFlash;

},{"./SAMDFlash.js":53,"./samba.js":84}],52:[function(require,module,exports){

const { Flash } = require('./SAMDFlash.js');
const { SamBA } = require('./samba.js');

// CMDEX field should be 0xA5 to allow execution of any command.
const CMDEX_KEY                 =    0xa500;

const NVM_REG_BASE              =    0x41004000;

const NVM_REG_CTRLA             =    0x00;
const NVM_REG_CTRLB             =    0x04;
const NVM_REG_INTFLAG           =    0x10;
const NVM_REG_STATUS            =    0x12;
const NVM_REG_ADDR              =    0x14;
const NVM_REG_RUNLOCK           =    0x18;

const NVM_CMD_EP                =    0x00;
const NVM_CMD_EB                =    0x01;
const NVM_CMD_WP                =    0x03;
const NVM_CMD_WQW               =    0x04;
const NVM_CMD_LR                =    0x11;
const NVM_CMD_UR                =    0x12;
const NVM_CMD_SSB               =    0x16;
const NVM_CMD_PBC               =    0x15;

const ERASE_BLOCK_PAGES         =    16;   // pages

// NVM User Row
const NVM_UP_ADDR                 =    0x804000;
const NVM_UP_BOD33_DISABLE_OFFSET =    0x0;
const NVM_UP_BOD33_DISABLE_MASK   =    0x1;
const NVM_UP_BOD33_RESET_OFFSET   =    0x1;
const NVM_UP_BOD33_RESET_MASK     =    0x2;
const NVM_UP_NVM_LOCK_OFFSET      =    0x8;

class FlashEraseError extends Error {
  constructor(msg) {
    super(msg);
  }
}
module.exports.FlashEraseError = FlashEraseError;

class FlashCmdError extends Error {

  constructor(msg) {
    super(msg);
  }
}
module.exports.FlashCmdError = FlashCmdError;

class FlashPageError extends Error {

  constructor(msg) {
    super(msg);
  }
}
module.exports.FlashPageError = FlashPageError;

class D5xNvmFlash extends Flash {

  _eraseAuto;

  constructor(
    samba,
    name,
    pages,
    size,
    user,
    stack) {

    super(samba, name, 0, pages, size, 1, 32, user, stack);

    this._eraseAuto = true;
  }

  get NVM_UP_SIZE() {
    return this._size;
  }

  async erase(offset, size) {
    let eraseSize = this._size * ERASE_BLOCK_PAGES;

    // Offset must be a multiple of the erase size
    if (offset % eraseSize)
      throw new FlashEraseError();

    // Offset and size must be in range
    if (offset + size > this.totalSize)
      throw new FlashEraseError();

    let eraseEnd = (offset + size + eraseSize - 1) / eraseSize;

    // Erase each erase size set of pages
    for (var eraseNum = offset / eraseSize; eraseNum < eraseEnd; eraseNum++) {

      // Issue erase command
      let wordAddr = (eraseNum * eraseSize);
      await this.writeRegU32(NVM_REG_ADDR, wordAddr);
      await this.command(NVM_CMD_EB);
    }
  }

  async waitReady() {
    while ((await this.readRegU16(NVM_REG_STATUS) & 0x1) == 0);
  }

  async eraseAll(offset ) {
    // Use the extended Samba command if available
    if (this._samba.canChipErase)
    {
      await this._samba.chipErase(offset);
    }
    else
    {
      await this.erase(offset, this.totalSize - offset);
    }
  }

  get eraseAuto() {
    return this._eraseAuto;
  }

  set eraseAuto(enable) {
    this._eraseAuto = enable;
  }

  async getLockRegions() {
    var lockBits = 0;
    let addr = NVM_UP_ADDR + NVM_UP_NVM_LOCK_OFFSET;
    var regions = new Array(this._lockRegions);

    for (var region = 0; region < this._lockRegions; region++) {
      if (region % 8 == 0)
        lockBits = await this._samba.readByte(addr++);

      regions[region] = (lockBits & (1 << (region % 8))) == 0;
    }

    return regions;
  }

  async getSecurity() {
    // There doesn't seem to be a way to read this
    return false;
  }

  async getBod() {
    let byte = await this._samba.readByte(NVM_UP_ADDR + NVM_UP_BOD33_DISABLE_OFFSET);
    return (byte & NVM_UP_BOD33_DISABLE_MASK) == 0;
  }

  canBod() { return true; }

  async getBor() {
    let byte = await this._samba.readByte(NVM_UP_ADDR + NVM_UP_BOD33_RESET_OFFSET);
    return (byte & NVM_UP_BOD33_RESET_MASK) != 0;
  }

  canBor() { return true; }

  getBootFlash() { return true; }
  canBootFlash() { return false; }

  async readUserPage(userRow ) {
    if (userRow.length != this.NVM_UP_SIZE)
      throw new Error('Invalid row buffer size');

    await this._samba.read(NVM_UP_ADDR, userRow, this.NVM_UP_SIZE);
  }

  async writeOptions() {

    var userPage = new Uint8Array(this.NVM_UP_SIZE);

    if (this.canBor() && this._bor.isDirty() && this._bor.get() != await this.getBor())
    {
      await this.readUserPage( userPage );

      if (this._bor.get())
        userPage[NVM_UP_BOD33_RESET_OFFSET] |= NVM_UP_BOD33_RESET_MASK;
      else
        userPage[NVM_UP_BOD33_RESET_OFFSET] &= ~NVM_UP_BOD33_RESET_MASK;
    }

    if (this.canBod() && this._bod.isDirty() && this._bod.get() != await this.getBod())
    {
      await this.readUserPage(userPage);

      if (this._bod.get())
        userPage[NVM_UP_BOD33_DISABLE_OFFSET] &= ~NVM_UP_BOD33_DISABLE_MASK;
      else
        userPage[NVM_UP_BOD33_DISABLE_OFFSET] |= NVM_UP_BOD33_DISABLE_MASK;
    }

    if (this._regions.isDirty()) {

      // Check if any lock bits are different from the current set
      var current = await this.getLockRegions();

      var regions = this._regions.get();
      var equal = true;
      for (var i = 0; i < regions.length && equal; i++) {
        equal &= (regions[ i ] == current[ i ]);
      }
      if (!equal) {
        await this.readUserPage(userPage);

        for (var region = 0; region < this._regions.get().length; region++) {
          if (this._regions.get()[region])
            userPage[NVM_UP_NVM_LOCK_OFFSET + region / 8] &= ~(1 << (region % 8));
          else
            userPage[NVM_UP_NVM_LOCK_OFFSET + region / 8] |= (1 << (region % 8));
        }
      }
    }

    // Erase and write the user row if modified
    if (userPage)
    {
      // Disable cache and configure manual page write
        // Configure manual page write and disable caches
      await this.writeRegU16(NVM_REG_CTRLA, (await this.readRegU16(NVM_REG_CTRLA) | (0x3 << 14)) & 0xffcf);

      // Erase user row
      await this.writeRegU32(NVM_REG_ADDR, NVM_UP_ADDR);
      await this.command(NVM_CMD_EP);

      // Write user page in quad-word chunks
      for (var offset = 0; offset < this.NVM_UP_SIZE; offset += this._size)
      {
        // Load the buffer with the quad word
        await this.loadBuffer(userPage, offset, 16);

        // Clear page buffer
        await this.command(NVM_CMD_PBC);

        // Copy quad word to page buffer
        await this.prepareApplet();
        await this._wordCopy.setDstAddr(NVM_UP_ADDR + offset);
        await this._wordCopy.setSrcAddr(this._onBufferA ? this._pageBufferA : this._pageBufferB);
        await this._wordCopy.setWords(4);
        this._onBufferA = !this._onBufferA;
        await this.waitReady();
        await this._wordCopy.runv();

        // Write the quad word
        await this.writeRegU32(NVM_REG_ADDR, (NVM_UP_ADDR + offset));
        await this.command(NVM_CMD_WQW);
      }
    }

    // Always do security last
    if (this._security.isDirty() && this._security.get() == true && this._security.get() != await this.getSecurity())
    {
      await this.command(NVM_CMD_SSB);
    }
  }

  async writePage(page) {

    if (page >= this._pages) {
      throw new FlashPageError();
    }

    // Disable cache and configure manual page write
    await this.writeRegU16(NVM_REG_CTRLA, (await this.readRegU16(NVM_REG_CTRLA) | (0x3 << 14)) & 0xffcf);

    // Auto-erase if writing at the start of the erase page
    if (this.eraseAuto && page % ERASE_BLOCK_PAGES == 0)
      await this.erase(page * this._size, ERASE_BLOCK_PAGES * this._size);

    // Clear page buffer
    await this.command(NVM_CMD_PBC);

    // Compute the start address.
    let addr = this._addr + (page * this._size);

    await this.prepareApplet();
    await this._wordCopy.setDstAddr(addr);
    await this._wordCopy.setSrcAddr(this._onBufferA ? this._pageBufferA : this._pageBufferB);
    await this._wordCopy.setWords(this._size / 4); // sizeof(uint32_t)
    this._onBufferA = !this._onBufferA;
    await this.waitReady();
    await this._wordCopy.runv();

    await this.writeRegU32(NVM_REG_ADDR, addr / 2);
    await this.command(NVM_CMD_WP);
  }

  async readPage(page, buf) {

    if (page >= this._pages) {
      throw new FlashPageError();
    }

    await this._samba.read(this._addr + (page * this._size), buf, this._size);
  }

  async readRegU16(reg) {

    return await this._samba.readByte(NVM_REG_BASE + reg)
        | (await this._samba.readByte(NVM_REG_BASE + reg + 1) << 8);
  }

  async writeRegU16(reg, value) {
    await this._samba.writeByte(NVM_REG_BASE + reg, value & 0xff);
    await this._samba.writeByte(NVM_REG_BASE + reg, (value >> 8) & 0xff);
  }

  async readRegU32(reg) {
    return await this._samba.readWord(NVM_REG_BASE + reg);
  }

  async writeRegU32(reg, value) {
    await this._samba.writeWord(NVM_REG_BASE + reg, value);
  }


  async command(cmd) {

    await this.waitReady();

    await this.writeRegU32(NVM_REG_CTRLB, CMDEX_KEY | cmd);

    await this.waitReady();

    if ((await this.readRegU16(NVM_REG_INTFLAG)) & 0xce) {
      // Clear the error bit
      await this.writeRegU16(NVM_REG_INTFLAG, 0xce);
      throw new FlashCmdError();
    }
  }

  async writeBuffer(dst_addr, size) {
    // Auto-erase if enabled
    if (this.eraseAuto && ((dst_addr / this._size) % ERASE_BLOCK_PAGES == 0))
      await this.erase(dst_addr, size);

    // Call the base class method
    await super.writeBuffer(dst_addr, size);
  }
}
module.exports.D5xNvmFlash = D5xNvmFlash;

},{"./SAMDFlash.js":53,"./samba.js":84}],53:[function(require,module,exports){

const { WordCopyApplet } = require('./wordcopyapplet.js');
const { SamBA } = require('./samba.js');

class FlashConfigError extends Error {
  constructor(msg) {
    super(msg);
  }
}
module.exports.FlashConfigError = FlashConfigError;

class FlashRegionError extends Error {
  constructor(msg) {
    super(msg);
  }
}
module.exports.FlashRegionError = FlashRegionError;

class FlashEraseError extends Error {
  constructor(msg) {
    super(msg);
  }
}
module.exports.FlashEraseError = FlashEraseError;

class FlashCmdError extends Error {
  constructor(msg) {
    super(msg);
  }
}
module.exports.FlashCmdError = FlashCmdError;

class FlashPageError extends Error {
  constructor(msg) {
    super(msg);
  }
}
module.exports.FlashPageError = FlashPageError;

class FlashOption
{
    constructor(value) {
      this._dirty = false;
      this._value = value;
    }

    set(value)  {
      this._value = value;
      this._dirty = true;
    }

    get()  {
      return this._value;
    }

    isDirty()  { return this._dirty; }

    _value;
    _dirty;
};

/**
 *
 */
class Flash {

  /**
   * Create a flasher
   *
   * @param samba SamBA instance handling IO with board
   * @param name Name of the board
   * @param addr Flash base address
   * @param pages Number of pages
   * @param size Page size in bytes
   * @param planes Number of flash planes
   * @param lockRegions Number of flash lock regions
   * @param user Address in SRAM where the applet and buffers will be placed
   * @param stack Address in SRAM where the applet stack will be placed
   */
  constructor(
          samba,
          name,
          addr,
          pages,
          size,
          planes,
          lockRegions,
          user,
          stack) {

    this._samba = samba;
    this._name = name;

    this._addr = addr;
    this._pages = pages;
    this._size = size;
    this._planes = planes;
    this._lockRegions = lockRegions;
    this._user = user;
    this._stack = stack;

    this._bootFlash = new FlashOption(true);
    this._bod = new FlashOption(true);
    this._bor = new FlashOption(true);
    this._security = new FlashOption(true);

    this._regions = new FlashOption(new Array(0));

    this._wordCopy = new WordCopyApplet(samba, user);

    if (!((size & (size - 1)) == 0)) {
      throw new FlashConfigError();
    }

    if (!((pages & (pages - 1)) == 0)) {
      throw new FlashConfigError();
    }

    if (!((lockRegions & (lockRegions - 1)) == 0)) {
      throw new FlashConfigError();
    }

    this._onBufferA = true;

    // page buffers will have the size of a physical page and will be situated right after the applet
    this._pageBufferA = Math.trunc((this._user + this._wordCopy.size + 3) / 4) * 4; // we need to avoid non 32bits aligned access on Cortex-M0+
    this._pageBufferB = this._pageBufferA + size;

  }

  _samba;
  _name;
  _addr;
  _pages;
  _size;
  _planes;
  _lockRegions;
  _user;
  _stack;

  _prepared  = false;

  // // abstract set eraseAuto(enable);

  get address() { return this._addr; }
  get pageSize() { return this._size; }
  get numPages() { return this._pages; }
  get numPlanes() { return this._planes; }
  get totalSize() { return this._size * this._pages; }
  get lockRegions() { return this._lockRegions; }

  // abstract eraseAll(offset: number) : void;

  // abstract getLockRegions() : Promise<Array<boolean>>;
  setLockRegions(regions) {
    if (regions.length > this._lockRegions)
        throw new FlashRegionError();

    this._regions.set(regions);
  }

  // abstract getSecurity() : Promise<boolean>;
  setSecurity() {
    this._security.set(true);
  }

  // abstract getBod() : Promise<boolean>;
  setBod(enable) {
    if (this.canBod())
      this._bod.set(enable);
  }
  // abstract canBod() : boolean;

  // abstract getBor() : Promise<boolean>;
  setBor(enable) {
    if (this.canBor())
      this._bor.set(enable);
  }
  // abstract canBor() : boolean;

  // abstract getBootFlash() : boolean;
  setBootFlash(enable) {
    if (this.canBootFlash())
      this._bootFlash.set(enable);
  }
  // abstract canBootFlash() : boolean;

  // abstract writeOptions() : void;

  // abstract writePage(page: number) : void;
  // abstract readPage(page: number, buf: Uint8Array) : Promise<void>;

  async writeBuffer(dst_addr, size) {
    await this._samba.writeBuffer(this._onBufferA ? this._pageBufferA : this._pageBufferB, dst_addr + this._addr, size);
  }

  async loadBuffer(data, offset = 0, bufferSize = data.length) {

    if (offset > 0) {
      data = data.subarray(offset);
    }

    await this._samba.write(this._onBufferA ? this._pageBufferA : this._pageBufferB, data, bufferSize);
  }

  async prepareApplet() {

    if (!this._prepared) {
      await this._wordCopy.setWords(this._size / 4 /* sizeof(uint32_t) */);
      await this._wordCopy.setStack(this._stack);

      this._prepared = true;
    }
  }

  _wordCopy;
  _bootFlash;
  _regions;
  _bod;
  _bor;
  _security;
  _onBufferA = true;
  _pageBufferA  = 0;
  _pageBufferB  = 0;
}

module.exports.Flash = Flash;

},{"./samba.js":84,"./wordcopyapplet.js":86}],54:[function(require,module,exports){
const {dom, index} = require('./dom.js');
const {Model} = require('./Model.js');

class TOP {
    #el;
    #view;
    #parent;
    #model;

    constructor(el, parent, model) {
        this.#el = el;
        this.#view = index(el, {}, this);
        this.#parent = parent;
        this.#model = model;
        model.watch(this.#view);
        model.watch('state', state => this.changeState(state));
    }

    changeState(newState) {
        this.#el.classList.toggle('hidden', newState != this.constructor.name);
    }

    clickProject(event) {
        if (event.target != event.currentTarget)
            this[event.target.getAttribute('bind-click')]?.(event);
    }

    checkName() {
        const old = this.#view.newprojectname.value;
        const name = old
              .trim()
              .replace(/[^a-zA-Z 0-9]+/, '')
              .substr(0, 18);
        // if (old != name)
        //     this.#view.newprojectname.value = name;
        return name;
    }

    newJSProject() {
        this.newProject("js");
    }

    newBlocklyProject() {
        this.newProject("blockly");
    }

    async newProject(template) {
        const rawName = this.#view.newprojectname.value.trim();
        const name = this.checkName();
        const newprojectname = this.#view.newprojectname;
        if (name.length == 0){
            newprojectname.focus();
            newprojectname.placeholder = 'Enter Your Project\'s name here.';
            return;
        }

        const projectList = this.#model.get('projectList', []);

        let id = 0;
        for (let project of projectList) {
            if (id <= (project.id|0))
                id = (project.id|0) + 1;
            if (project.name.toLowerCase() == name.toLowerCase()) {
                newprojectname.focus();
                newprojectname.placeholder = 'Name already taken by another project.';
                newprojectname.value = '';
                return;
            }
        }

        const remote = this.#parent.remote;
        const remoteProject = await remote.loadProject(rawName);
        if (remoteProject) {
            const modelId = 'project-' + id;
            const projectModel = new Model();
            projectModel.useStorage(modelId);
            projectModel.set('fs', remoteProject.fs);
            projectModel.set('RPIN', rawName);
            this.#model.set(modelId, projectModel);
        }

        const project = {id, name};
        projectList.push(project);
        this.#model.set('newProjectTemplate', template);
        this.#model.set('projectId', project.id);
        this.#model.set('projectName', project.name);
        this.#model.set('state', 'IDE');
        this.#model.set('projectList', projectList);
    }

    findProject(pred) {
        const projectList = this.#model.get('projectList', []);
        nextProject: for (const project of projectList) {
            for (const key in pred) {
                if (pred[key] != project[key])
                    continue nextProject;
            }
            return project;
        }
        return undefined;
    }

    openProject(event) {
        const project = this.findProject({id:event.target.getAttribute('project-id')});
        this.#model.set('projectId', project.id);
        this.#model.set('projectName', project.name);
        this.#model.set('state', 'IDE');
    }

    deleteProject() {
        const project = this.findProject({id:event.target.getAttribute('project-id')});
        if (!confirm(`Are you sure you want to delete ${project.name}?`))
            return;

        const projectList = this.#model.get('projectList', []);
        const index = projectList.indexOf(project);
        projectList.splice(index, 1);
        this.#model.dirty('projectList');

        const projectId = project.id;
        const modelId = "project-" + projectId;
        let model = this.#model.get(modelId, null);
        if (!model)
            model = new Model();
        model.destroy(modelId);
        this.#model.set(modelId, null);
    }
}

module.exports.TOP = TOP;

},{"./Model.js":45,"./dom.js":62}],55:[function(require,module,exports){
const {dom} = require('./dom.js');

class TabContainer {
    constructor(node) {
        this.onClose = null;
        this.onActivate = null;
        this.tabs = {};
        this.node = node;
        this.tabset = dom(node, {className:'tabset'});
        this.container = dom(node, {className:'tabcontainer'});
    }

    close(name) {
        const tab = this.tabs[name];
        if (!tab)
            return;

        if (this.onClose) {
            if (this.onClose(tab.contents) === false)
                return;
        }

        let active = null;
        let beforeActive = null;
        let afterActive = null;

        for (let name in this.tabs) {
            const {tab} = this.tabs[name];
            const isActive = tab.className.indexOf("inactive") == -1;
            if (isActive) {
                active = name;
            } else if (!active) {
                beforeActive = name;
            } else if (!afterActive) {
                afterActive = name;
                break;
            }
        }

        if (active == name) {
            if (beforeActive) {
                this.activate(beforeActive);
            } else if (afterActive) {
                this.activate(afterActive);
            }
        }

        tab.tab.remove();
        tab.contents.remove();
        delete this.tabs[name];
    }

    active() {
        for (let name in this.tabs) {
            const {tab, contents} = this.tabs[name];
            if (tab.className.indexOf("inactive") == -1) {
                return {name, contents};
            }
        }
        return undefined;
    }

    add(name, contents) {
        let close = [];

        if (this.onClose) {
            close.push(dom('span', {className:'tabclose', textContent:'x', onclick:this.close.bind(this, name)}));
        }

        this.tabs[name] = {
            tab:dom(this.tabset, {textContent:name, className:'tab inactive', onclick:_=>{this.activate(name);}}, close),
            contents
        };
    }

    activate(name) {
        const tab = this.tabs[name];
        if (!tab)
            return false;

        while (this.container.lastChild)
            this.container.removeChild(this.container.lastChild);

        this.container.appendChild(tab.contents);

        for (let k in this.tabs)
            this.tabs[k].tab.className = 'tab ' + (k == name ? 'active' : 'inactive');

        if (this.onActivate)
            this.onActivate(tab.contents);

        return true;
    }
}

module.exports.TabContainer = TabContainer;

},{"./dom.js":62}],56:[function(require,module,exports){
const {dom, index} = require('./dom.js');
const {convertToU8, palette} = require('./PreBuild.js');

function log(...msgs) {
    postMessage({build:msgs}, '*');
}

function assert(check, ...msgs) {
    if (!check) {
        log(...msgs);
        return true;
    }
    return false;
}

class TileMapEditor {
    #fs;
    #dom;
    path;
    #map;
    canvas;
    ctx;
    imgData;
    forceRedraw;

    #cache = {};

    constructor(parentElement, path, map, fs) {
        this.path = path;
        this.#fs = fs;

        this.#dom = index(dom('div', parentElement, {className:'imageEditor'}, [
            ['div', {id:'imgcontainer'}, [
                ['canvas', {id:'canvas'}]
            ]]
            // ['div', {id:'sidebar'}, [
            //     ['select', {id:'mode', onchange:this.changeMeta.bind(this)}, [
            //         ['option', {value:'image', textContent:'image'}],
            //         ['option', {value:'tilemap', textContent:'tilemap'}],
            //         ['option', {value:'tileset', textContent:'tileset'}]
            //     ]],
            //     [{id:'imageSidebar'}, [
            //         [{className:'row'}, [
            //             ['span', {textContent:'Width:'}],
            //             ['span', {id:'imgwidth'}]
            //         ]],
            //         [{className:'row'}, [
            //             ['span', {textContent:'Height:'}],
            //             ['span', {id:'imgheight'}]
            //         ]]
            //     ]],
            //     [{id:'tilemapSidebar'}, [
            //         [{className:'row'}, [
            //             ['span', {textContent:'Tile Set:'}],
            //             ['select', {id:'tileset', onchange:this.changeMeta.bind(this)}, this.getTilesets().map(path => [
            //                 'option', {value:path, textContent:path.replace(/.*\/|\..*/g, '')}
            //             ])],
            //             ['button', {id:'refresh', onclick:this.refreshTileSets.bind(this), textContent:''}]
            //         ]]
            //     ]],
            //     [{id:'tilesetSidebar'}, [
            //         [{className:'row'}, [
            //             ['span', {textContent:'Tile Width:'}],
            //             ['input', {
            //                 id:'tilewidth', type:"number", min:"8", max:"256",
            //                 onchange:this.changeMeta.bind(this),
            //                 value:this.metadata.tileset.tilewidth|0||8
            //             }]
            //         ]],
            //         [{className:'row'}, [
            //             ['span', {textContent:'Tile Height:'}],
            //             ['input', {
            //                 id:'tileheight', type:"number", min:"8", max:"256",
            //                 onchange:this.changeMeta.bind(this),
            //                 value:this.metadata.tileset.tileheight|0||8
            //             }]
            //         ]]
            //     ]]
            // ]]
        ]), {}, this);

        this.load(map);
    }

    async loadImage(path) {
        if (!(path in this.#cache)) {
            this.#cache[path] = new Promise((onload, onerror) => {
                let pathparts = this.path.split('/');
                pathparts[pathparts.length - 1] = path;
                let fullpath = pathparts.join('/');
                log("Loading image ", fullpath);
                const imgSrc = this.#fs.readFile(fullpath);
                const el = dom('img', {src:imgSrc, onload:_=>{
                    const canvas = dom('canvas', {
                        width: el.naturalWidth,
                        height: el.naturalHeight
                    });
                    const ctx = canvas.getContext("2d");
                    ctx.drawImage(el, 0, 0);
                    onload(ctx.getImageData(0, 0, canvas.width, canvas.height));
                }, onerror});
            });
        }
        return await this.#cache[path];
    }

    commit() {
    }

    reload() {
        this.load(this.#fs.readFile(this.path));
    }

    load(map) {
        this.#map = null;
        try {
            this.#map = JSON.parse(map);
        } catch (ex) {
            log(ex + '');
        }
        this.layout();
    }

    clear() {
        const canvas = this.#dom.canvas;
        if (!this.ctx)
            this.ctx = canvas.getContext('2d');
    }

    async layout() {
        this.clear();
        let map = this.#map;

        if (assert(map, "No map data"))
            return;

        if (assert(map.compressionlevel == -1, "Invalid compression in map:", map.compressionlevel))
            return;

        if (assert(!map.infinite, "Infinite map not supported"))
            return;

        if (assert(map.renderorder == "right-down", "Render order " + map.renderorder + " not supported"))
            return;

        if (assert(map.orientation == "orthogonal", "Map orientation not orthogonal"))
            return;

        if (assert(map.layers?.length, "No layers in map"))
            return;

        const {width, height, tilewidth, tileheight, layers} = map;

        const canvas = this.#dom.canvas;

        if (canvas.width != width * tilewidth) {
            canvas.width = width * tilewidth;
            this.imgData = null;
        }

        if (canvas.height != height * tileheight) {
            canvas.height = height * tileheight;
            this.imgData = null;
        }

        if (!this.imgData)
            this.imgData = this.ctx.getImageData(0, 0, canvas.width, canvas.height);

        const data = this.imgData.data;
        data.fill(0xFF);

        for (const layer of layers) {
            if (layer.visible && layer.opacity > 0.5) {
                await this[layer.type]?.(layer, data);
            }
        }

        this.ctx.putImageData(this.imgData, 0, 0);
    }

    async getTile(id) {
        id &= 0xFFFFFF;

        if (!id)
            return null;

        let tilesets = this.#map.tilesets;
        let set = null;
        for (let candidate of tilesets) {
            if (candidate.firstgid <= id && (candidate.firstgid + candidate.tilecount) > id) {
                set = candidate;
                break;
            }
        }

        if (!set)
            return null;

        let image = await this.loadImage(set.image);
        let index = (id|0) - (set.firstgid|0);
        let x = index % set.columns;
        let y = (index / set.columns) | 0;
        return {
            image,
            offsetX:x * set.tilewidth,
            offsetY:y * set.tileheight
        };
    }

    async tilelayer(layer, out) {
        const out32 = new Uint32Array(out.buffer);
        const outStride = this.imgData.width;

        const {data, width, height} = layer;
        const {tilewidth, tileheight} = this.#map;
        for (let y = 0; y < height; ++y) {
            for (let x = 0; x < width; ++x) {
                const tile = await this.getTile(data[y * width + x]);
                if (!tile || !tile.image)
                    continue;

                const img32 = new Uint32Array(tile.image.data.buffer);
                const imgStride = tile.image.width;

                let {offsetX, offsetY} = tile;
                for (let py = 0; py < tileheight; ++py) {
                    const outOffset = (y * tileheight + py) * outStride + x * tilewidth;
                    const imgOffset = (offsetY + py) * imgStride + offsetX;
                    for (let px = 0; px < tilewidth; ++px) {
                        let c = img32[imgOffset + px];
                        if (c)
                            out32[outOffset + px] = c;
                    }
                }
            }
        }
    }

    // autozoom() {
    //     const img = this.#dom.img;
    //     const canvas = this.#dom.canvas;
    //     const parent = img.parentElement;
    //     const zoom = Math.min(parent.clientWidth/img.naturalWidth, parent.clientHeight/img.naturalHeight) * 0.85;
    //     const width = img.naturalWidth * zoom | 0;
    //     const height = img.naturalHeight * zoom | 0;
    //     canvas.style.width  = img.style.width  = width + "px";
    //     canvas.style.height = img.style.height = height + "px";
    //     canvas.style.left   = img.style.left   = ((parent.clientWidth/2 - width/2)|0) + "px";
    //     canvas.style.top    = img.style.top    = ((parent.clientHeight/2 - height/2)|0) + "px";
    // }

    // layoutImage() {
    //     this.autozoom();

    //     const img = this.#dom.img;
    //     this.#dom.imgwidth.textContent = img.naturalWidth;
    //     this.#dom.imgheight.textContent = img.naturalHeight;

    //     if (!this.initCanvas(img.naturalWidth, img.naturalHeight, img)) {
    //         return;
    //     }
    //     const u8 = convertToU8(this.imgData);
    //     const data = this.imgData.data;
    //     let i = 0;
    //     for (let y = 0; y < img.naturalHeight; ++y) {
    //         for (let x = 0; x < img.naturalWidth; ++x) {
    //             let color = palette[u8[y + 1][x]];
    //             data[i++] = color[0];
    //             data[i++] = color[1];
    //             data[i++] = color[2];
    //             data[i++] = 255;
    //         }
    //     }
    //     this.ctx.putImageData(this.imgData, 0, 0);
    // }


    async layoutTilemap() {
        // this.autozoom();

        // let forceRedraw = this.forceRedraw;
        // this.forceRedraw = false;

        // if (this.tilesetPath != this.metadata.tilemap.tileset) {
        //     this.tilesetData = null;
        //     this.tilesetImg = null;
        // }

        // if (!this.tilesetData) {
        //     this.tilesetData = JSON.parse(this.#fs.readFile(this.metadata.tilemap.tileset));
        //     this.tilesetPath = this.metadata.tilemap.tileset;
        //     forceRedraw = true;
        // }

        // if (!this.tilesetImg) {
        //     forceRedraw = true;
        //     let imgName = this.metadata.tilemap.tileset.replace(/\.meta$/gi, '');
        //     let imgSrc = this.#fs.readFile(imgName);
        //     await new Promise((onload, onerror) => {
        //         this.tilesetImg = dom('img', {src:imgSrc, onload, onerror});
        //     });
        // }

        // if (!forceRedraw)
        //     return;

        // const {tilewidth, tileheight, tilesPerRow, tilesPerCol} = this.tilesetDimensions();
        // const img = this.#dom.img;
        // this.initCanvas(img.naturalWidth, img.naturalHeight, img);

        // const canvas = this.#dom.canvas;
        // canvas.width = img.naturalWidth * tilewidth;
        // canvas.height = img.naturalHeight * tileheight;

        // let i = 0, ntid = 1;
        // let assign = {};
        // for (let y = 0; y < this.imgData.height; ++y) {
        //     for (let x = 0; x < this.imgData.width; ++x) {
        //         let c = 0;
        //         c = this.imgData.data[i++];
        //         c <<= 8;
        //         c |= this.imgData.data[i++];
        //         c <<= 8;
        //         c |= this.imgData.data[i++];

        //         let A = this.imgData.data[i++];
        //         if (A < 128)
        //             continue;

        //         c = c.toString(16);

        //         let tdat = this.metadata.tilemap['#' + c];
        //         if (!tdat || typeof tdat != 'object')
        //             this.metadata.tilemap['#' + c] = tdat = {};
        //         assign[c] = tdat;

        //         let tid = tdat.id;
        //         if (tid === undefined)
        //             continue;

        //         tid |= 0;
        //         let tx = tid % tilesPerRow;
        //         let ty = (tid / tilesPerRow) | 0;
        //         if (ty >= tilesPerCol) {
        //             tdat.id = 0;
        //             continue;
        //         }

        //         this.ctx.drawImage(
        //             this.tilesetImg,
        //             tx * tilewidth, ty * tileheight, tilewidth, tileheight,
        //             x * tilewidth, y * tilewidth, tilewidth, tileheight
        //         );
        //     }
        // }

        // let old = this.#dom.tilemapSidebar.querySelectorAll('.assign');
        // for (let i = 0; i < old.length; ++i)
        //     old[i].remove();

        // for (let key in assign) {
        //     const row = dom(this.#dom.tilemapSidebar, {className:'row assign'}, [
        //         [{style:{backgroundColor:'#' + '0'.repeat(6 - key.length) + key, width:'32px', flexGrow:0}}],
        //         ['canvas', {width:tilewidth, height:tileheight, flexGrow:0, onclick:this.changeTileId.bind(this, key, assign[key])}],
        //         ['input', {type:'number', value:assign[key].info|0, style:{flexGrow:1}, onchange:this.changeTileInfo.bind(this, key, assign[key])}]
        //     ]);
        //     const tid = assign[key].id;
        //     const canvas = row.querySelector('canvas');
        //     const ctx = canvas.getContext('2d');
        //     let tx = tid % tilesPerRow;
        //     let ty = (tid / tilesPerRow) | 0;
        //     ctx.drawImage(this.tilesetImg, tx * tilewidth, ty * tileheight, tilewidth, tileheight, 0, 0, tilewidth, tileheight);
        // }
    }

    dirty() {
    }
};

module.exports.TileMapEditor = TileMapEditor;

},{"./PreBuild.js":46,"./dom.js":62}],57:[function(require,module,exports){
const {dom} = require('./dom.js');

class TreeListNode {
    constructor(entry, path, cb, index) {
        this.path = path + entry.name;
        this.entry = entry;
        index[this.path] = this;

        const depth = path.split("/").length - 2;
        const space = "&nbsp;".repeat(depth * 2);

        const children = Object.values(entry.node.children || {})
              .sort((a, b)=>(a.node.children && !b.node.children) || a.name > b.name);

        this.dom = dom('div', {
            className:`treenode ${this.entry.node.constructor.name}`,
            onclick:event=>{
                event.stopPropagation();
                event.preventDefault();
                cb(path + entry.name);
            }
        }, [
            ["div", {innerHTML:space + entry.name, className:"filelabel"}],
            ...children.map(child => (new TreeListNode(child, this.path + "/", cb, index)).dom)
        ]);
    }

    remove() {
        this.dom.remove();
    }

    setActive(isActive) {
        this.dom.classList.toggle('active', !!isActive);
    }

    isActive() {
        return this.dom.classList.contains("active");
    }

    isFile() {
        return this.entry.isFile();
    }

    isDirectory() {
        return this.entry.isDirectory();
    }
}

module.exports.TreeListNode = TreeListNode;

},{"./dom.js":62}],58:[function(require,module,exports){
const {dom, index} = require('./dom.js');

class URLEditor {
    #dom;
    path;

    constructor(parentElement, path) {
        this.path = path;
        this.#dom = index(dom('iframe', parentElement, {className:'urlEditor', src:path}), {}, this);
    }

    commit(){}
};

module.exports.URLEditor = URLEditor;

},{"./dom.js":62}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Uint8Buffer = void 0;
exports.toByteArray = toByteArray;
exports.toHex = toHex;
// Copyright (C) 2021 Toitware ApS. All rights reserved.
// Use of this source code is governed by an MIT-style license that can be
// found in the LICENSE file.

async function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
module.exports.sleep = sleep;
class Uint8Buffer {
  readOffset = 0;
  writeOffset = 0;
  size;
  _buffer;
  _view;
  constructor(size = 64) {
    this.size = size;
    this._buffer = new ArrayBuffer(this.size);
    this._view = new Uint8Array(this._buffer);
  }
  get length() {
    return this.writeOffset - this.readOffset;
  }
  shift() {
    if (this.length <= 0) {
      return undefined;
    }
    return this._view[this.readOffset++];
  }
  grow(newSize) {
    const newBuffer = new ArrayBuffer(newSize);
    const newView = new Uint8Array(newBuffer);
    this._view.forEach((v, i) => newView[i] = v);
    this.size = newSize;
    this._buffer = newBuffer;
    this._view = newView;
  }
  fill(element, length = 1) {
    this.ensure(length);
    this._view.fill(element, this.writeOffset, this.writeOffset + length);
    this.writeOffset += length;
  }
  ensure(length) {
    if (this.size - this.writeOffset < length) {
      const newSize = this.size + Math.max(length, this.size);
      this.grow(newSize);
    }
  }
  pushBytes(value, byteCount, littleEndian) {
    for (let i = 0; i < byteCount; i++) {
      if (littleEndian) {
        this.push(value >> i * 8 & 0xff);
      } else {
        this.push(value >> (byteCount - i) * 8 & 0xff);
      }
    }
  }
  reset() {
    this.writeOffset = 0;
    this.readOffset = 0;
  }
  push(...bytes) {
    this.ensure(bytes.length);
    this._view.set(bytes, this.writeOffset);
    this.writeOffset += bytes.length;
  }
  copy(bytes) {
    this.ensure(bytes.length);
    this._view.set(bytes, this.writeOffset);
    this.writeOffset += bytes.length;
  }
  view() {
    return new Uint8Array(this._buffer, this.readOffset, this.writeOffset);
  }
}
exports.Uint8Buffer = Uint8Buffer;
function toByteArray(str) {
  const byteArray = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    const charcode = str.charCodeAt(i);
    byteArray[i] = charcode & 0xff;
  }
  return byteArray;
}
function toHex(value, size = 2) {
  return "0x" + (value >>> 0).toString(16).toUpperCase().padStart(size, "0");
}

},{}],60:[function(require,module,exports){
"use strict";

var _samba = require("./samba.js");
class Applet {
  /**
   * Create a flasher
   *
   * @param samba SamBA instance handling IO with board
   * @param addr Flash base address
   * @param size Page size in bytes
   * @param user Address in SRAM where the applet and buffers will be placed
   */
  constructor(samba, addr, code, size, start, stack, reset) {
    this._samba = samba;
    this._addr = addr;
    this._size = size;
    this._start = start;
    this._stack = stack;
    this._reset = reset;
    this._code = code;
    this._installed = false;
  }
  get size() {
    return this._size;
  }
  get addr() {
    return this._addr;
  }
  _samba;
  _addr; // Address in device SRAM where will be placed the applet
  _size; // Applet size
  _start; //
  _stack; // Applet stack address in device SRAM
  _reset;
  _code;
  _installed;
  async checkInstall() {
    if (!this._installed) {
      await this._samba.write(this._addr, this._code, this._size);
      this._installed = true;
    }
  }
  async setStack(stack) {
    // Check if applet is already on the board and install if not
    await this.checkInstall();
    await this._samba.writeWord(this._stack, stack);
  }

  // To be used for Thumb-1 based devices (ARM7TDMI, ARM9)
  async run() {
    // Check if applet is already on the board and install if not
    await this.checkInstall();
    // Add one to the start address for Thumb mode
    await this._samba.go(this._start + 1);
  }

  // To be used for Thumb-2 based devices (Cortex-Mx)
  async runv() {
    // Check if applet is already on the board and install if not
    await this.checkInstall();
    // Add one to the start address for Thumb mode
    await this._samba.writeWord(this._reset, this._start + 1);

    // The stack is the first reset vector
    await this._samba.go(this._stack);
  }
}
module.exports.Applet = Applet;

},{"./samba.js":84}],61:[function(require,module,exports){

const { SamBA } = require("./samba.js");
const { D2xNvmFlash } = require('./SAMD2x.js');
const { D5xNvmFlash } = require('./SAMD5x.js');
const { Flash } = require('./SAMDFlash.js');

const Family = {
    FAMILY_NONE: 0,

    FAMILY_SAM7S: 1,
    FAMILY_SAM7SE: 2,
    FAMILY_SAM7X: 3,
    FAMILY_SAM7XC: 4,
    FAMILY_SAM7L: 5,

    FAMILY_SAM3N: 6,
    FAMILY_SAM3S: 7,
    FAMILY_SAM3U: 8,
    FAMILY_SAM3X: 9,
    FAMILY_SAM3A: 10,

    FAMILY_SAM4S: 11,
    FAMILY_SAM4E: 12,

    FAMILY_SAM9XE: 13,

    FAMILY_SAMD21: 14,
    FAMILY_SAMR21: 15,
    FAMILY_SAML21: 16,

    FAMILY_SAMD51: 17,
    FAMILY_SAME51: 18,
    FAMILY_SAME53: 19,
    FAMILY_SAME54: 20,

    FAMILY_SAME70: 21,
    FAMILY_SAMS70: 22,
    FAMILY_SAMV70: 23,
    FAMILY_SAMV71: 24,
};

class DeviceUnsupportedError extends Error {
  constructor(msg ) {
    super(msg);
  }
}
module.exports.DeviceUnsupportedError = DeviceUnsupportedError;

class Device {
  _samba;

  _flash;
  _family;
  _uniqueId;

  constructor(samba) {
    this._samba = samba;
    this._flash = undefined;
    this._uniqueId = undefined;
    this._family = Family.FAMILY_NONE;
  }

  async create() {

    var chipId = 0;
    var cpuId = 0;
    var extChipId = 0;
    var deviceId = 0;

    var flashPtr = null;

    // Device identification must be performed carefully to avoid reading from
    // addresses that devices do not support which will lock up the CPU

    // All devices support addresss 0 as the ARM reset vector so if the vector is
    // a ARM7TDMI branch, then assume we have an Atmel SAM7/9 CHIPID register
    if (((await this._samba.readWord(0x0)) & 0xff000000) == 0xea000000)
    {
        chipId = await this._samba.readWord(0xfffff240);
    }
    else
    {
        // Next try the ARM CPUID register since all Cortex-M devices support it
        cpuId = await this._samba.readWord(0xe000ed00) & 0x0000fff0;

        // Cortex-M0+
        if (cpuId == 0xC600)
        {
            // These should support the ARM device ID register
            deviceId = await this._samba.readWord(0x41002018);
        }
        // Cortex-M4
        else if (cpuId == 0xC240)
        {
            // SAM4 processors have a reset vector to the SAM-BA ROM
            if (((await this._samba.readWord(0x4)) & 0xfff00000) == 0x800000)
            {
              let id = await this.readChipId();
              chipId = id.chipId;
              extChipId = id.extChipId;
            }
            // Else we should have a device that supports the ARM device ID register
            else
            {
                deviceId = await this._samba.readWord(0x41002018);
            }
        }
        // For all other Cortex versions try the Atmel chip ID registers
        else
        {
          let id = await this.readChipId();
          chipId = id.chipId;
          extChipId = id.extChipId;
        }
    }

    // Instantiate the proper flash for the device
    switch (chipId & 0x7fffffe0)
    {
    //
    // SAM7SE
    //
    case 0x272a0a40:
        this._family = Family.FAMILY_SAM7SE;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAM7SE512", 0x100000, 2048, 256, 2, 32, 0x202000, 0x208000, true);
        break;
    case 0x272a0940:
        this._family = Family.FAMILY_SAM7SE;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAM7SE256", 0x100000, 1024, 256, 1, 16, 0x202000, 0x208000, true);
        break;
    case 0x272a0340:
        this._family = Family.FAMILY_SAM7SE;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAM7SE32", 0x100000, 256, 128, 1, 8, 0x201400, 0x201C00, true);
        break;
    //
    // SAM7S
    //
    case 0x270b0a40:
        this._family = Family.FAMILY_SAM7S;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAM7S512", 0x100000, 2048, 256, 2, 32, 0x202000, 0x210000, false);
        break;
    case 0x270d0940: // A
    case 0x270b0940: // B/C
        this._family = Family.FAMILY_SAM7S;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAM7S256", 0x100000, 1024, 256, 1, 16, 0x202000, 0x210000, false);
        break;
    case 0x270c0740: // A
    case 0x270a0740: // B/C
        this._family = Family.FAMILY_SAM7S;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAM7S128", 0x100000, 512, 256, 1, 8, 0x202000, 0x208000, false);
        break;
    case 0x27090540:
        this._family = Family.FAMILY_SAM7S;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAM7S64", 0x100000, 512, 128, 1, 16, 0x202000, 0x204000, false);
        break;
    case 0x27080340:
        this._family = Family.FAMILY_SAM7S;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAM7S32", 0x100000, 256, 128, 1, 8, 0x201400, 0x202000, false);
        break;
    case 0x27050240:
        this._family = Family.FAMILY_SAM7S;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAM7S16", 0x100000, 256, 64, 1, 8, 0x200000, 0x200e00, false);
        break;
    //
    // SAM7XC
    //
    case 0x271c0a40:
        this._family = Family.FAMILY_SAM7XC;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAMXC512", 0x100000, 2048, 256, 2, 32, 0x202000, 0x220000, true);
        break;
    case 0x271b0940:
        this._family = Family.FAMILY_SAM7XC;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAMXC256", 0x100000, 1024, 256, 1, 16, 0x202000, 0x210000, true);
        break;
    case 0x271a0740:
        this._family = Family.FAMILY_SAM7XC;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAMXC128", 0x100000, 512, 256, 1, 8, 0x202000, 0x208000, true);
        break;
    //
    // SAM7X
    //
    case 0x275c0a40:
        this._family = Family.FAMILY_SAM7X;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAMX512", 0x100000, 2048, 256, 2, 32, 0x202000, 0x220000, true);
        break;
    case 0x275b0940:
        this._family = Family.FAMILY_SAM7X;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAMX256", 0x100000, 1024, 256, 1, 16, 0x202000, 0x210000, true);
        break;
    case 0x275a0740:
        this._family = Family.FAMILY_SAM7X;
        flashPtr = null; // new EfcFlash(this._samba, "AT91SAMX128", 0x100000, 512, 256, 1, 8, 0x202000, 0x208000, true);
        break;
    //
    // SAM4S
    //
    case 0x29870ee0: // A
    case 0x29970ee0: // B
    case 0x29A70ee0: // C
        this._family = Family.FAMILY_SAM4S;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM4SD32", 0x400000, 4096, 512, 2, 256, 0x20001000, 0x20010000, 0x400e0a00, false);
        break;
    case 0x29870c30: // A
    case 0x29970c30: // B
    case 0x29a70c30: // C
        this._family = Family.FAMILY_SAM4S;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM4SD16", 0x400000, 2048, 512, 2, 256, 0x20001000, 0x20010000, 0x400e0a00, false);
        break;
    case 0x28870ce0: // A
    case 0x28970ce0: // B
    case 0x28A70ce0: // C
        this._family = Family.FAMILY_SAM4S;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM4SA16", 0x400000, 2048, 512, 1, 256, 0x20001000, 0x20010000, 0x400e0a00, false);
        break;
    case 0x288c0ce0 : // A
    case 0x289c0ce0 : // B
    case 0x28ac0ce0 : // C
        this._family = Family.FAMILY_SAM4S;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM4S16", 0x400000, 2048, 512, 1, 128, 0x20001000, 0x20020000, 0x400e0a00, false);
        break;
    case 0x288c0ae0 : // A
    case 0x289c0ae0 : // B
    case 0x28ac0ae0 : // C
        this._family = Family.FAMILY_SAM4S;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM4S8", 0x400000, 1024, 512, 1, 64, 0x20001000, 0x20020000, 0x400e0a00, false);
        break;
    case 0x288b09e0 : // A
    case 0x289b09e0 : // B
    case 0x28ab09e0 : // C
        this._family = Family.FAMILY_SAM4S;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM4S4", 0x400000, 512, 512, 1, 16, 0x20001000, 0x20010000, 0x400e0a00, false);
        break;
    case 0x288b07e0 : // A
    case 0x289b07e0 : // B
    case 0x28ab07e0 : // C
        this._family = Family.FAMILY_SAM4S;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM4S2", 0x400000, 256, 512, 1, 16, 0x20001000, 0x20010000, 0x400e0a00, false);
        break;
    //
    // SAM3N
    //
    case 0x29340960 : // A
    case 0x29440960 : // B
    case 0x29540960 : // C
        this._family = Family.FAMILY_SAM3N;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3N4", 0x400000, 1024, 256, 1, 16, 0x20001000, 0x20006000, 0x400e0a00, false);
        break;
    case 0x29390760 : // A
    case 0x29490760 : // B
    case 0x29590760 : // C
        this._family = Family.FAMILY_SAM3N;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3N2", 0x400000, 512, 256, 1, 8, 0x20001000, 0x20004000, 0x400e0a00, false);
        break;
    case 0x29380560 : // A
    case 0x29480560 : // B
    case 0x29580560 : // C
        this._family = Family.FAMILY_SAM3N;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3N1", 0x400000, 256, 256, 1, 4, 0x20000800, 0x20002000, 0x400e0a00, false);
        break;
    case 0x29380360 : // A
    case 0x29480360 : // B
    case 0x29580360 : // C
        this._family = Family.FAMILY_SAM3N;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3N0", 0x400000, 128, 256, 1, 1, 0x20000800, 0x20002000, 0x400e0a00, false);
        break;
    //
    // SAM3S
    //
    case 0x299b0a60 : // B
    case 0x29ab0a60 : // C
        this._family = Family.FAMILY_SAM3S;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3SD8", 0x400000, 2048, 256, 1, 16, 0x20001000, 0x20010000, 0x400e0a00, false);
        break;
    case 0x289b0a60 : // B
    case 0x28ab0a60 : // C
        this._family = Family.FAMILY_SAM3S;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3S8", 0x400000, 2048, 256, 1, 16, 0x20001000, 0x20010000, 0x400e0a00, false);
        break;
    case 0x28800960 : // A
    case 0x28900960 : // B
    case 0x28a00960 : // C
        this._family = Family.FAMILY_SAM3S;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3S4", 0x400000, 1024, 256, 1, 16, 0x20001000, 0x2000c000, 0x400e0a00, false);
        break;
    case 0x288a0760 : // A
    case 0x289a0760 : // B
    case 0x28aa0760 : // C
        this._family = Family.FAMILY_SAM3S;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3S2", 0x400000, 512, 256, 1, 8, 0x20000800, 0x20008000, 0x400e0a00, false);
        break;
    case 0x28890560 : // A
    case 0x28990560 : // B
    case 0x28a90560 : // C
        this._family = Family.FAMILY_SAM3S;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3S1", 0x400000, 256, 256, 1, 4, 0x20000800, 0x20004000, 0x400e0a00, false);
        break;
    //
    // SAM3U
    //
    case 0x28000960 : // C
    case 0x28100960 : // E
        this._family = Family.FAMILY_SAM3U;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3U4", 0xE0000, 1024, 256, 2, 32, 0x20001000, 0x20008000, 0x400e0800, false);
        break;
    case 0x280a0760 : // C
    case 0x281a0760 : // E
        this._family = Family.FAMILY_SAM3U;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3U2", 0x80000, 512, 256, 1, 16, 0x20001000, 0x20004000, 0x400e0800, false);
        break;
    case 0x28090560 : // C
    case 0x28190560 : // E
        this._family = Family.FAMILY_SAM3U;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3U1", 0x80000, 256, 256, 1, 8, 0x20001000, 0x20002000, 0x400e0800, false);
        break;
    //
    // SAM3X
    //
    case 0x286e0a60 : // 8H
    case 0x285e0a60 : // 8E
    case 0x284e0a60 : // 8C
        this._family = Family.FAMILY_SAM3X;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3X8", 0x80000, 2048, 256, 2, 32, 0x20001000, 0x20010000, 0x400e0a00, false);
        break;
    case 0x285b0960 : // 4E
    case 0x284b0960 : // 4C
        this._family = Family.FAMILY_SAM3X;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3X4", 0x80000, 1024, 256, 2, 16, 0x20001000, 0x20008000, 0x400e0a00, false);
        break;
    //
    // SAM3A
    //
    case 0x283e0A60 : // 8C
        this._family = Family.FAMILY_SAM3A;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3A8", 0x80000, 2048, 256, 2, 32, 0x20001000, 0x20010000, 0x400e0a00, false);
        break;
    case 0x283b0960 : // 4C
        this._family = Family.FAMILY_SAM3A;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM3A4", 0x80000, 1024, 256, 2, 16, 0x20001000, 0x20008000, 0x400e0a00, false);
        break;
    //
    // SAM7L
    //
    case 0x27330740 :
        this._family = Family.FAMILY_SAM7L;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM7L128", 0x100000, 512, 256, 1, 16, 0x2ffb40, 0x300700, 0xffffff60, false);
        break;
    case 0x27330540 :
        this._family = Family.FAMILY_SAM7L;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM7L64", 0x100000, 256, 256, 1, 8, 0x2ffb40, 0x300700, 0xffffff60, false);
        break;
    //
    // SAM9XE
    //
    case 0x329aa3a0 :
        this._family = Family.FAMILY_SAM9XE;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM9XE512", 0x200000, 1024, 512, 1, 32, 0x300000, 0x307000, 0xfffffa00, true);
        break;
    case 0x329a93a0 :
        this._family = Family.FAMILY_SAM9XE;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM9XE256", 0x200000, 512, 512, 1, 16, 0x300000, 0x307000, 0xfffffa00, true);
        break;
    case 0x329973a0 :
        this._family = Family.FAMILY_SAM9XE;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAM9XE128", 0x200000, 256, 512, 1, 8, 0x300000, 0x303000, 0xfffffa00, true);
        break;
    //
    // SAM4E
    //
    case 0x23cc0ce0:
        switch (extChipId)
        {
        case 0x00120200: // E
        case 0x00120201: // C
            this._family = Family.FAMILY_SAM4E;
            flashPtr = null; // new EefcFlash(this._samba, "ATSAM4E16", 0x400000, 2048, 512, 1, 128, 0x20001000, 0x20020000, 0x400e0a00, false);
            break;
        case 0x00120208: // E
        case 0x00120209: // C
            this._family = Family.FAMILY_SAM4E;
            flashPtr = null; // new EefcFlash(this._samba, "ATSAM4E8", 0x400000, 1024, 512, 1, 64, 0x20001000, 0x20020000, 0x400e0a00, false);
            break;
        }
        break;
    //
    // SAME70
    //
    case 0x210d0a00:
        this._family = Family.FAMILY_SAME70;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAME70x19", 0x400000, 1024, 512, 1, 32, 0x20401000, 0x20404000, 0x400e0c00, false);
        break;
    case 0x21020c00:
        this._family = Family.FAMILY_SAME70;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAME70x20", 0x400000, 2048, 512, 1, 64, 0x20401000, 0x20404000, 0x400e0c00, false);
        break;
    case 0x21020e00:
        this._family = Family.FAMILY_SAME70;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAME70x21", 0x400000, 4096, 512, 1, 128, 0x20401000, 0x20404000, 0x400e0c00, false);
        break;
    //
    // SAMS70
    //
    case 0x211d0a00:
        this._family = Family.FAMILY_SAMS70;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAMS70x19", 0x400000, 1024, 512, 1, 32, 0x20401000, 0x20404000, 0x400e0c00, false);
        break;
    case 0x21120c00:
        this._family = Family.FAMILY_SAMS70;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAMS70x20", 0x400000, 2048, 512, 1, 64, 0x20401000, 0x20404000, 0x400e0c00, false);
        break;
    case 0x21120e00:
        this._family = Family.FAMILY_SAMS70;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAMS70x21", 0x400000, 4096, 512, 1, 128, 0x20401000, 0x20404000, 0x400e0c00, false);
        break;
    //
    // SAMV70
    //
    case 0x213d0a00:
        this._family = Family.FAMILY_SAMV70;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAMV70x19", 0x400000, 1024, 512, 1, 32, 0x20401000, 0x20404000, 0x400e0c00, false);
        break;
    case 0x21320c00:
        this._family = Family.FAMILY_SAMV70;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAMV70x20", 0x400000, 2048, 512, 1, 64, 0x20401000, 0x20404000, 0x400e0c00, false);
        break;
    //
    // SAMV71
    //
    case 0x212d0a00:
        this._family = Family.FAMILY_SAMV71;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAMV71x19", 0x400000, 1024, 512, 1, 32, 0x20401000, 0x20404000, 0x400e0c00, false);
        break;
    case 0x21220c00:
        this._family = Family.FAMILY_SAMV71;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAMV71x20", 0x400000, 2048, 512, 1, 64, 0x20401000, 0x20404000, 0x400e0c00, false);
        break;
    case 0x21220e00:
        this._family = Family.FAMILY_SAMV71;
        flashPtr = null; // new EefcFlash(this._samba, "ATSAMV71x21", 0x400000, 4096, 512, 1, 128, 0x20401000, 0x20404000, 0x400e0c00, false);
        break;
    //
    // No CHIPID devices
    //
    case 0:
        switch (deviceId & 0xffff00ff)
        {
        //
        // SAMD21
        //
        case 0x10010003: // J15A
        case 0x10010008: // G15A
        case 0x1001000d: // E15A
        case 0x10010021: // J15B
        case 0x10010024: // G15B
        case 0x10010027: // E15B
        case 0x10010056: // E15B WLCSP
        case 0x10010063: // E15C WLCSP
            this._family = Family.FAMILY_SAMD21;
            flashPtr = new D2xNvmFlash(this._samba, "ATSAMD21x15", 512, 64, 0x20000800, 0x20001000) ;
            break;

        case 0x10010002: // J16A
        case 0x10010007: // G16A
        case 0x1001000c: // E16A
        case 0x10010020: // J16B
        case 0x10010023: // G16B
        case 0x10010026: // E16B
        case 0x10010055: // E16B WLCSP
        case 0x10010062: // E16C WLCSP
            this._family = Family.FAMILY_SAMD21;
            flashPtr = new D2xNvmFlash(this._samba, "ATSAMD21x16", 1024, 64, 0x20001000, 0x20002000) ;
            break;

        case 0x10010001: // J17A
        case 0x10010006: // G17A
        case 0x1001000b: // E17A
        case 0x10010010: // G17A WLCSP
            this._family = Family.FAMILY_SAMD21;
            flashPtr = new D2xNvmFlash(this._samba, "ATSAMD21x17", 2048, 64, 0x20002000, 0x20004000) ;
            break;

        case 0x10010000: // J18A
        case 0x10010005: // G18A
            this._uniqueId = await this.readChipUniqueId();
        case 0x1001000a: // E18A
        case 0x1001000f: // G18A WLCSP
            this._family = Family.FAMILY_SAMD21;
            flashPtr = new D2xNvmFlash(this._samba, "ATSAMD21x18", 4096, 64, 0x20004000, 0x20008000) ;
            break;

        //
        // SAMR21
        //
        case 0x1001001e: // E16A
        case 0x1001001b: // G16A
            this._family = Family.FAMILY_SAMR21;
            flashPtr = new D2xNvmFlash(this._samba, "ATSAMR21x16", 1024, 64, 0x20001000, 0x20002000) ;
            break;

        case 0x1001001d: // E17A
            this._uniqueId = await this.readChipUniqueId();
        case 0x1001001a: // G17A
            this._family = Family.FAMILY_SAMR21;

            flashPtr = new D2xNvmFlash(this._samba, "ATSAMR21x17", 2048, 64, 0x20002000, 0x20004000) ;
            break;

        case 0x1001001c: // E18A
        case 0x10010019: // G18A
            this._family = Family.FAMILY_SAMR21;
            this._uniqueId = await this.readChipUniqueId();
            flashPtr = new D2xNvmFlash(this._samba, "ATSAMR21x18", 4096, 64, 0x20004000, 0x20008000) ;
            break;

        case 0x10010018: // E19A
            this._family = Family.FAMILY_SAMR21;
            flashPtr = new D2xNvmFlash(this._samba, "ATSAMR21x19", 4096, 64, 0x20004000, 0x20008000) ;
            break;

        //
        // SAML21
        //
        case 0x1081000d: // E15A
        case 0x1081001c: // E15B
            this._family = Family.FAMILY_SAMD21;
            flashPtr = new D2xNvmFlash(this._samba, "ATSAML21x15", 512, 64, 0x20000800, 0x20001000) ;
            break;

        case 0x10810002: // J16A
        case 0x10810007: // G16A
        case 0x1081000c: // E16A
        case 0x10810011: // J16B
        case 0x10810016: // G16B
        case 0x1081001b: // E16B
            this._family = Family.FAMILY_SAML21;
            flashPtr = new D2xNvmFlash(this._samba, "ATSAML21x16", 1024, 64, 0x20001000, 0x20002000) ;
            break;

        case 0x10810001: // J17A
        case 0x10810006: // G17A
        case 0x1081000b: // E17A
        case 0x10810010: // J17B
        case 0x10810015: // G17B
        case 0x1081001a: // E17B
            this._family = Family.FAMILY_SAML21;
            flashPtr = new D2xNvmFlash(this._samba, "ATSAML21x17", 2048, 64, 0x20002000, 0x20004000) ;
            break;

        case 0x10810000: // J18A
        case 0x10810005: // G18A
        case 0x1081000a: // E18A
        case 0x1081000f: // J18B
        case 0x10810014: // G18B
        case 0x10810019: // E18B
            this._family = Family.FAMILY_SAML21;
            flashPtr = new D2xNvmFlash(this._samba, "ATSAML21x18", 4096, 64, 0x20004000, 0x20008000) ;
            break;

        //
        // SAMD51
        //
        case 0x60060006: // J18A
        case 0x60060008: // G18A
            this._family = Family.FAMILY_SAMD51;
            flashPtr = new D5xNvmFlash(this._samba, "ATSAMD51x18", 512, 512, 0x20004000, 0x20008000) ;
            break;

        case 0x60060001: // P19A
        case 0x60060003: // N19A
        case 0x60060005: // J19A
        case 0x60060007: // G19A
            this._family = Family.FAMILY_SAMD51;
            flashPtr = new D5xNvmFlash(this._samba, "ATSAMD51x19", 1024, 512, 0x20004000, 0x20008000) ;
            break;

        case 0x60060000: // P20A
        case 0x60060002: // N20A
        case 0x60060004: // J20A
            this._family = Family.FAMILY_SAMD51;
            flashPtr = new D5xNvmFlash(this._samba, "ATSAMD51x20", 2048, 512, 0x20004000, 0x20008000) ;
            break;

        //
        // SAME51
        //
        case 0x61810003: // J18A
            this._family = Family.FAMILY_SAME51;
            flashPtr = new D5xNvmFlash(this._samba, "ATSAME51x18", 512, 512, 0x20004000, 0x20008000) ;
            break;

        case 0x61810002: // J19A
        case 0x61810001: // N19A
            this._family = Family.FAMILY_SAME51;
            flashPtr = new D5xNvmFlash(this._samba, "ATSAME51x19", 1024, 512, 0x20004000, 0x20008000) ;
            break;

        case 0x61810004: // J20A
        case 0x61810000: // N20A
            this._family = Family.FAMILY_SAME51;
            flashPtr = new D5xNvmFlash(this._samba, "ATSAME51x20", 2048, 512, 0x20004000, 0x20008000) ;
            break;

        //
        // SAME53
        //
        case 0x61830006: // J18A
            this._family = Family.FAMILY_SAME53;
            flashPtr = new D5xNvmFlash(this._samba, "ATSAME53x18", 512, 512, 0x20004000, 0x20008000) ;
            break;

        case 0x61830005: // J19A
        case 0x61830003: // N19A
            this._family = Family.FAMILY_SAME53;
            flashPtr = new D5xNvmFlash(this._samba, "ATSAME53x19", 1024, 512, 0x20004000, 0x20008000) ;
            break;

        case 0x61830004: // J20A
        case 0x61830002: // N20A
            this._family = Family.FAMILY_SAME53;
            flashPtr = new D5xNvmFlash(this._samba, "ATSAME53x20", 2048, 512, 0x20004000, 0x20008000) ;
            break;

        //
        // SAME54
        //
        case 0x61840001: // P19A
        case 0x61840003: // N19A
            this._family = Family.FAMILY_SAME54;
            flashPtr = new D5xNvmFlash(this._samba, "ATSAME54x19", 1024, 512, 0x20004000, 0x20008000) ;
            break;

        case 0x61840000: // P20A
        case 0x61840002: // N20A
            this._family = Family.FAMILY_SAME54;
            flashPtr = new D5xNvmFlash(this._samba, "ATSAME54x20", 2048, 512, 0x20004000, 0x20008000) ;
            break;

        //
        // Unknown
        //
        default:
            throw new DeviceUnsupportedError();
            break;
        }
        break;

    //
    // Unsupported device
    //
    default:
      throw new DeviceUnsupportedError();
      break;
    }

    if (flashPtr == null) {
      throw new DeviceUnsupportedError();
    }

    this._flash = flashPtr;
  }

  async reset() {
    try
    {
        switch (this._family)
        {
        case Family.FAMILY_SAMD21:
        case Family.FAMILY_SAMR21:
        case Family.FAMILY_SAML21:
        case Family.FAMILY_SAMD51:
        case Family.FAMILY_SAME51:
        case Family.FAMILY_SAME53:
        case Family.FAMILY_SAME54:
        case Family.FAMILY_SAME70:
        case Family.FAMILY_SAMS70:
        case Family.FAMILY_SAMV70:
        case Family.FAMILY_SAMV71:
            await this._samba.writeWord(0xE000ED0C, 0x05FA0004);
            break;

        case Family.FAMILY_SAM3X:
        case Family.FAMILY_SAM3S:
        case Family.FAMILY_SAM3A:
            await this._samba.writeWord(0x400E1A00, 0xA500000D);
            break;

        case Family.FAMILY_SAM3U:
            await this._samba.writeWord(0x400E1200, 0xA500000D);
            break;

        case Family.FAMILY_SAM3N:
        case Family.FAMILY_SAM4S:
            await this._samba.writeWord(0x400E1400, 0xA500000D);
            break;

        case Family.FAMILY_SAM4E:
            await this._samba.writeWord(0x400E1800, 0xA500000D);
            break;

        case Family.FAMILY_SAM7S:
        case Family.FAMILY_SAM7SE:
        case Family.FAMILY_SAM7X:
        case Family.FAMILY_SAM7XC:
        case Family.FAMILY_SAM7L:
        case Family.FAMILY_SAM9XE:
            await this._samba.writeWord(0xFFFFFD00, 0xA500000D);
            break;

        default:
            break;
        }
    }
    catch (expected)
    {   // writeWord will most likely throw an exception when the CPU is reset
    }
  }

  get family() {
    return this._family;
  }

  get flash() {
    return this._flash;
  }

  get chipUniqueId() {
      return this._uniqueId;
  }

  async readChipUniqueId() {

    let result = '';

    let word = await this._samba.readWord(0x0080A00C);
    result += (word >>> 0).toString(16).toUpperCase().padStart(8, "0");

    word = await this._samba.readWord(0x0080A040);
    result += (word >>> 0).toString(16).toUpperCase().padStart(8, "0");

    word = await this._samba.readWord(0x0080A044);
    result += (word >>> 0).toString(16).toUpperCase().padStart(8, "0");

    word = await this._samba.readWord(0x0080A048);
    result += (word >>> 0).toString(16).toUpperCase().padStart(8, "0");

    return result;
  }

  async readChipId() {

    let chipId = await this._samba.readWord(0x400e0740);
    let extChipId = 0;

    if (chipId != 0) {
        let extChipId = await this._samba.readWord(0x400e0744);
    }
    else {
      chipId = await this._samba.readWord(0x400e0940);

      if (chipId != 0) {
        extChipId = await this._samba.readWord(0x400e0944);
      }
    }

    return {
      chipId: chipId,
      extChipId: extChipId
    }
  }

}
module.exports.Device = Device;

},{"./SAMD2x.js":51,"./SAMD5x.js":52,"./SAMDFlash.js":53,"./samba.js":84}],62:[function(require,module,exports){
function dom(...args) {
    let tag = "div";
    let parent = null;
    let props = null;
    let children = null;
    for (let arg of args) {
        if (arg === undefined)
            continue;

        if (typeof arg == 'string') {
            tag = arg;
            continue;
        }
        if (arg && arg instanceof Element) {
            parent = arg;
            continue;
        }
        if (arg && Array.isArray(arg)) {
            children = arg;
            continue;
        }
        if (arg && typeof arg == 'object') {
            props = arg;
            continue;
        }
    }

    let node = document.createElement(tag);

    if (parent)
        parent.appendChild(node);

    if (props) {
        if (props.style) {
            Object.assign(node.style, props.style);
            props = Object.assign({}, props);
            delete props.style;
        }
        if (props.attr) {
            for (let key in props.attr) {
                node.setAttribute(key, props.attr[key]);
            }
            delete props.attr;
        }
        Object.assign(node, props);
    }

    if (children)
        children.forEach(child => {
            if (!child)
                return;
            else if (Array.isArray(child))
                dom(node, ...child);
            else if (child instanceof Element)
                node.appendChild(child);
        });

    return node;
}

function index(el, map = {}, bind = null) {
    if (el.className) {
        if (!Array.isArray(map[el.className]))
            map[el.className] = [el];
        else
            map[el.className].push(el);
    }
    if (el.id)
        map[el.id] = el;

    let recurse = true;

    if (bind) {
        const bindClazz = bind.constructor.name.toLowerCase();

        for (let i = 0; i < el.attributes.length; ++i) {
            const key = el.attributes[i].name;
            const value = el.attributes[i].value;
            const parts = key.split('-');

            if (parts.length != 2 || (parts[0] != 'index' && parts[0] != 'bind'))
                continue;

            if (parts[0] == 'index' && parts[1] != bindClazz)
                continue;


            const func = bind[value];

            if (typeof func != 'function') {
                console.warn(`No method ${value} in ${bind.constructor.name}.`, el);
                continue;
            }

            if (parts[0] == 'index') {
                recurse = func.call(bind, el) !== false;
            } else if (parts[0] == 'bind') {
                el.addEventListener(parts[1], bind[value].bind(bind));
            }
        }
    }

    if (recurse) {
        for (let i = 0, max = el.children.length; i < max; ++i)
            index(el.children[i], map, bind);
    }

    return map;
}

module.exports.dom = dom;
module.exports.index = index;

},{}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connect = exports.ESPLoader = exports.CHIP_FAMILY_ESP8266 = exports.CHIP_FAMILY_ESP32S3 = exports.CHIP_FAMILY_ESP32S2 = exports.CHIP_FAMILY_ESP32H2 = exports.CHIP_FAMILY_ESP32C6 = exports.CHIP_FAMILY_ESP32C3 = exports.CHIP_FAMILY_ESP32 = void 0;
const t = t => {
    let e = [];
    for (let a = 0; a < t.length; a++) {
      let i = t.charCodeAt(a);
      i <= 255 && e.push(i);
    }
    return e;
  },
  e = t => "[" + t.map(t => a(t)).join(", ") + "]",
  a = (t, e = 2) => {
    let a = t.toString(16).toUpperCase();
    return a.startsWith("-") ? "-0x" + a.substring(1).padStart(e, "0") : "0x" + a.padStart(e, "0");
  },
  i = t => new Promise(e => setTimeout(e, t)),
  s = {
    18: "256KB",
    19: "512KB",
    20: "1MB",
    21: "2MB",
    22: "4MB",
    23: "8MB",
    24: "16MB",
    25: "32MB",
    26: "64MB"
  },
  r = t(" UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU"),
  n = 33382,
  o = 50,
  l = 12882,
  h = 12883,
  d = 12995,
  f = 12998,
  _ = 12914,
  c = {
    4293968129: {
      name: "ESP8266",
      family: 33382
    },
    15736195: {
      name: "ESP32",
      family: o
    },
    1990: {
      name: "ESP32-S2",
      family: l
    },
    9: {
      name: "ESP32-S3",
      family: h
    },
    3942662454: {
      name: "ESP32-S3(beta2)",
      family: h
    },
    1763790959: {
      name: "ESP32-C3",
      family: d
    },
    456216687: {
      name: "ESP32-C3",
      family: d
    },
    3391540258: {
      name: "ESP32-H2",
      family: 12914
    },
    228687983: {
      name: "ESP32-C6(beta)",
      family: 12998
    }
  },
  u = (t, e) => {
    let a = Math.floor(t * (e / 486));
    return a < 3e3 ? 3e3 : a;
  },
  g = t => {
    switch (t) {
      case o:
        return {
          regBase: 1072963584,
          baseFuse: 1073061888,
          macFuse: 1073061888,
          usrOffs: 28,
          usr1Offs: 32,
          usr2Offs: 36,
          mosiDlenOffs: 40,
          misoDlenOffs: 44,
          w0Offs: 128,
          uartDateReg: 1610612856,
          flashOffs: 4096
        };
      case l:
        return {
          regBase: 1061167104,
          baseFuse: 1061265408,
          macFuse: 1061265476,
          usrOffs: 24,
          usr1Offs: 28,
          usr2Offs: 32,
          mosiDlenOffs: 36,
          misoDlenOffs: 40,
          w0Offs: 88,
          uartDateReg: 1610612856,
          flashOffs: 4096
        };
      case h:
        return {
          regBase: 1610620928,
          usrOffs: 24,
          baseFuse: 1610641408,
          macFuse: 1610641476,
          usr1Offs: 28,
          usr2Offs: 32,
          mosiDlenOffs: 36,
          misoDlenOffs: 40,
          w0Offs: 88,
          uartDateReg: 1610612864,
          flashOffs: 0
        };
      case 33382:
        return {
          regBase: 1610613248,
          usrOffs: 28,
          baseFuse: 1072693328,
          macFuse: 1072693328,
          usr1Offs: 32,
          usr2Offs: 36,
          mosiDlenOffs: -1,
          misoDlenOffs: -1,
          w0Offs: 64,
          uartDateReg: 1610612856,
          flashOffs: 0
        };
      case d:
        return {
          regBase: 1610620928,
          baseFuse: 1610647552,
          macFuse: 1610647620,
          usrOffs: 24,
          usr1Offs: 28,
          usr2Offs: 32,
          mosiDlenOffs: 36,
          misoDlenOffs: 40,
          w0Offs: 88,
          uartDateReg: 1610612860,
          flashOffs: 0
        };
      default:
        return {
          regBase: -1,
          baseFuse: -1,
          macFuse: -1,
          usrOffs: -1,
          usr1Offs: -1,
          usr2Offs: -1,
          mosiDlenOffs: -1,
          misoDlenOffs: -1,
          w0Offs: -1,
          uartDateReg: -1,
          flashOffs: -1
        };
    }
  };
exports.CHIP_FAMILY_ESP32H2 = _;
exports.CHIP_FAMILY_ESP32C6 = f;
exports.CHIP_FAMILY_ESP32C3 = d;
exports.CHIP_FAMILY_ESP32S3 = h;
exports.CHIP_FAMILY_ESP32S2 = l;
exports.CHIP_FAMILY_ESP32 = o;
exports.CHIP_FAMILY_ESP8266 = n;
class w extends Error {
  constructor(t) {
    super(t), this.name = "SlipReadError";
  }
}
const m = async e => {
  let a;
  return e == o ? a = await import("./esp32-273074c1.js") : e == l ? a = await import("./esp32s2-f8cf1215.js") : e == h ? a = await import("./esp32s3-b0a5f517.js") : 33382 == e ? a = await import("./esp8266-b7fae3a7.js") : e == d && (a = await import("./esp32c3-8f007052.js")), {
    ...a,
    text: t(atob(a.text)),
    data: t(atob(a.data))
  };
};
function p(t) {
  let e = t.length;
  for (; --e >= 0;) t[e] = 0;
}
const b = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
  y = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
  k = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
  v = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
  x = new Array(576);
p(x);
const z = new Array(60);
p(z);
const S = new Array(512);
p(S);
const U = new Array(256);
p(U);
const E = new Array(29);
p(E);
const R = new Array(30);
function A(t, e, a, i, s) {
  this.static_tree = t, this.extra_bits = e, this.extra_base = a, this.elems = i, this.max_length = s, this.has_stree = t && t.length;
}
let I, D, F;
function B(t, e) {
  this.dyn_tree = t, this.max_code = 0, this.stat_desc = e;
}
p(R);
const O = t => t < 256 ? S[t] : S[256 + (t >>> 7)],
  T = (t, e) => {
    t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255;
  },
  Z = (t, e, a) => {
    t.bi_valid > 16 - a ? (t.bi_buf |= e << t.bi_valid & 65535, T(t, t.bi_buf), t.bi_buf = e >> 16 - t.bi_valid, t.bi_valid += a - 16) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += a);
  },
  C = (t, e, a) => {
    Z(t, a[2 * e], a[2 * e + 1]);
  },
  L = (t, e) => {
    let a = 0;
    do {
      a |= 1 & t, t >>>= 1, a <<= 1;
    } while (--e > 0);
    return a >>> 1;
  },
  M = (t, e, a) => {
    const i = new Array(16);
    let s,
      r,
      n = 0;
    for (s = 1; s <= 15; s++) n = n + a[s - 1] << 1, i[s] = n;
    for (r = 0; r <= e; r++) {
      let e = t[2 * r + 1];
      0 !== e && (t[2 * r] = L(i[e]++, e));
    }
  },
  N = t => {
    let e;
    for (e = 0; e < 286; e++) t.dyn_ltree[2 * e] = 0;
    for (e = 0; e < 30; e++) t.dyn_dtree[2 * e] = 0;
    for (e = 0; e < 19; e++) t.bl_tree[2 * e] = 0;
    t.dyn_ltree[512] = 1, t.opt_len = t.static_len = 0, t.sym_next = t.matches = 0;
  },
  P = t => {
    t.bi_valid > 8 ? T(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0;
  },
  H = (t, e, a, i) => {
    const s = 2 * e,
      r = 2 * a;
    return t[s] < t[r] || t[s] === t[r] && i[e] <= i[a];
  },
  $ = (t, e, a) => {
    const i = t.heap[a];
    let s = a << 1;
    for (; s <= t.heap_len && (s < t.heap_len && H(e, t.heap[s + 1], t.heap[s], t.depth) && s++, !H(e, i, t.heap[s], t.depth));) t.heap[a] = t.heap[s], a = s, s <<= 1;
    t.heap[a] = i;
  },
  j = (t, e, a) => {
    let i,
      s,
      r,
      n,
      o = 0;
    if (0 !== t.sym_next) do {
      i = 255 & t.pending_buf[t.sym_buf + o++], i += (255 & t.pending_buf[t.sym_buf + o++]) << 8, s = t.pending_buf[t.sym_buf + o++], 0 === i ? C(t, s, e) : (r = U[s], C(t, r + 256 + 1, e), n = b[r], 0 !== n && (s -= E[r], Z(t, s, n)), i--, r = O(i), C(t, r, a), n = y[r], 0 !== n && (i -= R[r], Z(t, i, n)));
    } while (o < t.sym_next);
    C(t, 256, e);
  },
  V = (t, e) => {
    const a = e.dyn_tree,
      i = e.stat_desc.static_tree,
      s = e.stat_desc.has_stree,
      r = e.stat_desc.elems;
    let n,
      o,
      l,
      h = -1;
    for (t.heap_len = 0, t.heap_max = 573, n = 0; n < r; n++) 0 !== a[2 * n] ? (t.heap[++t.heap_len] = h = n, t.depth[n] = 0) : a[2 * n + 1] = 0;
    for (; t.heap_len < 2;) l = t.heap[++t.heap_len] = h < 2 ? ++h : 0, a[2 * l] = 1, t.depth[l] = 0, t.opt_len--, s && (t.static_len -= i[2 * l + 1]);
    for (e.max_code = h, n = t.heap_len >> 1; n >= 1; n--) $(t, a, n);
    l = r;
    do {
      n = t.heap[1], t.heap[1] = t.heap[t.heap_len--], $(t, a, 1), o = t.heap[1], t.heap[--t.heap_max] = n, t.heap[--t.heap_max] = o, a[2 * l] = a[2 * n] + a[2 * o], t.depth[l] = (t.depth[n] >= t.depth[o] ? t.depth[n] : t.depth[o]) + 1, a[2 * n + 1] = a[2 * o + 1] = l, t.heap[1] = l++, $(t, a, 1);
    } while (t.heap_len >= 2);
    t.heap[--t.heap_max] = t.heap[1], ((t, e) => {
      const a = e.dyn_tree,
        i = e.max_code,
        s = e.stat_desc.static_tree,
        r = e.stat_desc.has_stree,
        n = e.stat_desc.extra_bits,
        o = e.stat_desc.extra_base,
        l = e.stat_desc.max_length;
      let h,
        d,
        f,
        _,
        c,
        u,
        g = 0;
      for (_ = 0; _ <= 15; _++) t.bl_count[_] = 0;
      for (a[2 * t.heap[t.heap_max] + 1] = 0, h = t.heap_max + 1; h < 573; h++) d = t.heap[h], _ = a[2 * a[2 * d + 1] + 1] + 1, _ > l && (_ = l, g++), a[2 * d + 1] = _, d > i || (t.bl_count[_]++, c = 0, d >= o && (c = n[d - o]), u = a[2 * d], t.opt_len += u * (_ + c), r && (t.static_len += u * (s[2 * d + 1] + c)));
      if (0 !== g) {
        do {
          for (_ = l - 1; 0 === t.bl_count[_];) _--;
          t.bl_count[_]--, t.bl_count[_ + 1] += 2, t.bl_count[l]--, g -= 2;
        } while (g > 0);
        for (_ = l; 0 !== _; _--) for (d = t.bl_count[_]; 0 !== d;) f = t.heap[--h], f > i || (a[2 * f + 1] !== _ && (t.opt_len += (_ - a[2 * f + 1]) * a[2 * f], a[2 * f + 1] = _), d--);
      }
    })(t, e), M(a, h, t.bl_count);
  },
  W = (t, e, a) => {
    let i,
      s,
      r = -1,
      n = e[1],
      o = 0,
      l = 7,
      h = 4;
    for (0 === n && (l = 138, h = 3), e[2 * (a + 1) + 1] = 65535, i = 0; i <= a; i++) s = n, n = e[2 * (i + 1) + 1], ++o < l && s === n || (o < h ? t.bl_tree[2 * s] += o : 0 !== s ? (s !== r && t.bl_tree[2 * s]++, t.bl_tree[32]++) : o <= 10 ? t.bl_tree[34]++ : t.bl_tree[36]++, o = 0, r = s, 0 === n ? (l = 138, h = 3) : s === n ? (l = 6, h = 3) : (l = 7, h = 4));
  },
  K = (t, e, a) => {
    let i,
      s,
      r = -1,
      n = e[1],
      o = 0,
      l = 7,
      h = 4;
    for (0 === n && (l = 138, h = 3), i = 0; i <= a; i++) if (s = n, n = e[2 * (i + 1) + 1], !(++o < l && s === n)) {
      if (o < h) do {
        C(t, s, t.bl_tree);
      } while (0 != --o);else 0 !== s ? (s !== r && (C(t, s, t.bl_tree), o--), C(t, 16, t.bl_tree), Z(t, o - 3, 2)) : o <= 10 ? (C(t, 17, t.bl_tree), Z(t, o - 3, 3)) : (C(t, 18, t.bl_tree), Z(t, o - 11, 7));
      o = 0, r = s, 0 === n ? (l = 138, h = 3) : s === n ? (l = 6, h = 3) : (l = 7, h = 4);
    }
  };
let Y = !1;
const q = (t, e, a, i) => {
  Z(t, 0 + (i ? 1 : 0), 3), P(t), T(t, a), T(t, ~a), a && t.pending_buf.set(t.window.subarray(e, e + a), t.pending), t.pending += a;
};
var G = (t, e, a, i) => {
    let s,
      r,
      n = 0;
    t.level > 0 ? (2 === t.strm.data_type && (t.strm.data_type = (t => {
      let e,
        a = 4093624447;
      for (e = 0; e <= 31; e++, a >>>= 1) if (1 & a && 0 !== t.dyn_ltree[2 * e]) return 0;
      if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return 1;
      for (e = 32; e < 256; e++) if (0 !== t.dyn_ltree[2 * e]) return 1;
      return 0;
    })(t)), V(t, t.l_desc), V(t, t.d_desc), n = (t => {
      let e;
      for (W(t, t.dyn_ltree, t.l_desc.max_code), W(t, t.dyn_dtree, t.d_desc.max_code), V(t, t.bl_desc), e = 18; e >= 3 && 0 === t.bl_tree[2 * v[e] + 1]; e--);
      return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;
    })(t), s = t.opt_len + 3 + 7 >>> 3, r = t.static_len + 3 + 7 >>> 3, r <= s && (s = r)) : s = r = a + 5, a + 4 <= s && -1 !== e ? q(t, e, a, i) : 4 === t.strategy || r === s ? (Z(t, 2 + (i ? 1 : 0), 3), j(t, x, z)) : (Z(t, 4 + (i ? 1 : 0), 3), ((t, e, a, i) => {
      let s;
      for (Z(t, e - 257, 5), Z(t, a - 1, 5), Z(t, i - 4, 4), s = 0; s < i; s++) Z(t, t.bl_tree[2 * v[s] + 1], 3);
      K(t, t.dyn_ltree, e - 1), K(t, t.dyn_dtree, a - 1);
    })(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, n + 1), j(t, t.dyn_ltree, t.dyn_dtree)), N(t), i && P(t);
  },
  X = {
    _tr_init: t => {
      Y || ((() => {
        let t, e, a, i, s;
        const r = new Array(16);
        for (a = 0, i = 0; i < 28; i++) for (E[i] = a, t = 0; t < 1 << b[i]; t++) U[a++] = i;
        for (U[a - 1] = i, s = 0, i = 0; i < 16; i++) for (R[i] = s, t = 0; t < 1 << y[i]; t++) S[s++] = i;
        for (s >>= 7; i < 30; i++) for (R[i] = s << 7, t = 0; t < 1 << y[i] - 7; t++) S[256 + s++] = i;
        for (e = 0; e <= 15; e++) r[e] = 0;
        for (t = 0; t <= 143;) x[2 * t + 1] = 8, t++, r[8]++;
        for (; t <= 255;) x[2 * t + 1] = 9, t++, r[9]++;
        for (; t <= 279;) x[2 * t + 1] = 7, t++, r[7]++;
        for (; t <= 287;) x[2 * t + 1] = 8, t++, r[8]++;
        for (M(x, 287, r), t = 0; t < 30; t++) z[2 * t + 1] = 5, z[2 * t] = L(t, 5);
        I = new A(x, b, 257, 286, 15), D = new A(z, y, 0, 30, 15), F = new A(new Array(0), k, 0, 19, 7);
      })(), Y = !0), t.l_desc = new B(t.dyn_ltree, I), t.d_desc = new B(t.dyn_dtree, D), t.bl_desc = new B(t.bl_tree, F), t.bi_buf = 0, t.bi_valid = 0, N(t);
    },
    _tr_stored_block: q,
    _tr_flush_block: G,
    _tr_tally: (t, e, a) => (t.pending_buf[t.sym_buf + t.sym_next++] = e, t.pending_buf[t.sym_buf + t.sym_next++] = e >> 8, t.pending_buf[t.sym_buf + t.sym_next++] = a, 0 === e ? t.dyn_ltree[2 * a]++ : (t.matches++, e--, t.dyn_ltree[2 * (U[a] + 256 + 1)]++, t.dyn_dtree[2 * O(e)]++), t.sym_next === t.sym_end),
    _tr_align: t => {
      Z(t, 2, 3), C(t, 256, x), (t => {
        16 === t.bi_valid ? (T(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8);
      })(t);
    }
  };
var Q = (t, e, a, i) => {
  let s = 65535 & t | 0,
    r = t >>> 16 & 65535 | 0,
    n = 0;
  for (; 0 !== a;) {
    n = a > 2e3 ? 2e3 : a, a -= n;
    do {
      s = s + e[i++] | 0, r = r + s | 0;
    } while (--n);
    s %= 65521, r %= 65521;
  }
  return s | r << 16 | 0;
};
const J = new Uint32Array((() => {
  let t,
    e = [];
  for (var a = 0; a < 256; a++) {
    t = a;
    for (var i = 0; i < 8; i++) t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
    e[a] = t;
  }
  return e;
})());
var tt = (t, e, a, i) => {
    const s = J,
      r = i + a;
    t ^= -1;
    for (let a = i; a < r; a++) t = t >>> 8 ^ s[255 & (t ^ e[a])];
    return -1 ^ t;
  },
  et = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
  },
  at = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
const {
    _tr_init: it,
    _tr_stored_block: st,
    _tr_flush_block: rt,
    _tr_tally: nt,
    _tr_align: ot
  } = X,
  {
    Z_NO_FLUSH: lt,
    Z_PARTIAL_FLUSH: ht,
    Z_FULL_FLUSH: dt,
    Z_FINISH: ft,
    Z_BLOCK: _t,
    Z_OK: ct,
    Z_STREAM_END: ut,
    Z_STREAM_ERROR: gt,
    Z_DATA_ERROR: wt,
    Z_BUF_ERROR: mt,
    Z_DEFAULT_COMPRESSION: pt,
    Z_FILTERED: bt,
    Z_HUFFMAN_ONLY: yt,
    Z_RLE: kt,
    Z_FIXED: vt,
    Z_DEFAULT_STRATEGY: xt,
    Z_UNKNOWN: zt,
    Z_DEFLATED: St
  } = at,
  Ut = (t, e) => (t.msg = et[e], e),
  Et = t => 2 * t - (t > 4 ? 9 : 0),
  Rt = t => {
    let e = t.length;
    for (; --e >= 0;) t[e] = 0;
  },
  At = t => {
    let e,
      a,
      i,
      s = t.w_size;
    e = t.hash_size, i = e;
    do {
      a = t.head[--i], t.head[i] = a >= s ? a - s : 0;
    } while (--e);
    e = s, i = e;
    do {
      a = t.prev[--i], t.prev[i] = a >= s ? a - s : 0;
    } while (--e);
  };
let It = (t, e, a) => (e << t.hash_shift ^ a) & t.hash_mask;
const Dt = t => {
    const e = t.state;
    let a = e.pending;
    a > t.avail_out && (a = t.avail_out), 0 !== a && (t.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + a), t.next_out), t.next_out += a, e.pending_out += a, t.total_out += a, t.avail_out -= a, e.pending -= a, 0 === e.pending && (e.pending_out = 0));
  },
  Ft = (t, e) => {
    rt(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, Dt(t.strm);
  },
  Bt = (t, e) => {
    t.pending_buf[t.pending++] = e;
  },
  Ot = (t, e) => {
    t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e;
  },
  Tt = (t, e, a, i) => {
    let s = t.avail_in;
    return s > i && (s = i), 0 === s ? 0 : (t.avail_in -= s, e.set(t.input.subarray(t.next_in, t.next_in + s), a), 1 === t.state.wrap ? t.adler = Q(t.adler, e, s, a) : 2 === t.state.wrap && (t.adler = tt(t.adler, e, s, a)), t.next_in += s, t.total_in += s, s);
  },
  Zt = (t, e) => {
    let a,
      i,
      s = t.max_chain_length,
      r = t.strstart,
      n = t.prev_length,
      o = t.nice_match;
    const l = t.strstart > t.w_size - 262 ? t.strstart - (t.w_size - 262) : 0,
      h = t.window,
      d = t.w_mask,
      f = t.prev,
      _ = t.strstart + 258;
    let c = h[r + n - 1],
      u = h[r + n];
    t.prev_length >= t.good_match && (s >>= 2), o > t.lookahead && (o = t.lookahead);
    do {
      if (a = e, h[a + n] === u && h[a + n - 1] === c && h[a] === h[r] && h[++a] === h[r + 1]) {
        r += 2, a++;
        do {} while (h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && r < _);
        if (i = 258 - (_ - r), r = _ - 258, i > n) {
          if (t.match_start = e, n = i, i >= o) break;
          c = h[r + n - 1], u = h[r + n];
        }
      }
    } while ((e = f[e & d]) > l && 0 != --s);
    return n <= t.lookahead ? n : t.lookahead;
  },
  Ct = t => {
    const e = t.w_size;
    let a, i, s;
    do {
      if (i = t.window_size - t.lookahead - t.strstart, t.strstart >= e + (e - 262) && (t.window.set(t.window.subarray(e, e + e - i), 0), t.match_start -= e, t.strstart -= e, t.block_start -= e, t.insert > t.strstart && (t.insert = t.strstart), At(t), i += e), 0 === t.strm.avail_in) break;
      if (a = Tt(t.strm, t.window, t.strstart + t.lookahead, i), t.lookahead += a, t.lookahead + t.insert >= 3) for (s = t.strstart - t.insert, t.ins_h = t.window[s], t.ins_h = It(t, t.ins_h, t.window[s + 1]); t.insert && (t.ins_h = It(t, t.ins_h, t.window[s + 3 - 1]), t.prev[s & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = s, s++, t.insert--, !(t.lookahead + t.insert < 3)););
    } while (t.lookahead < 262 && 0 !== t.strm.avail_in);
  },
  Lt = (t, e) => {
    let a,
      i,
      s,
      r = t.pending_buf_size - 5 > t.w_size ? t.w_size : t.pending_buf_size - 5,
      n = 0,
      o = t.strm.avail_in;
    do {
      if (a = 65535, s = t.bi_valid + 42 >> 3, t.strm.avail_out < s) break;
      if (s = t.strm.avail_out - s, i = t.strstart - t.block_start, a > i + t.strm.avail_in && (a = i + t.strm.avail_in), a > s && (a = s), a < r && (0 === a && e !== ft || e === lt || a !== i + t.strm.avail_in)) break;
      n = e === ft && a === i + t.strm.avail_in ? 1 : 0, st(t, 0, 0, n), t.pending_buf[t.pending - 4] = a, t.pending_buf[t.pending - 3] = a >> 8, t.pending_buf[t.pending - 2] = ~a, t.pending_buf[t.pending - 1] = ~a >> 8, Dt(t.strm), i && (i > a && (i = a), t.strm.output.set(t.window.subarray(t.block_start, t.block_start + i), t.strm.next_out), t.strm.next_out += i, t.strm.avail_out -= i, t.strm.total_out += i, t.block_start += i, a -= i), a && (Tt(t.strm, t.strm.output, t.strm.next_out, a), t.strm.next_out += a, t.strm.avail_out -= a, t.strm.total_out += a);
    } while (0 === n);
    return o -= t.strm.avail_in, o && (o >= t.w_size ? (t.matches = 2, t.window.set(t.strm.input.subarray(t.strm.next_in - t.w_size, t.strm.next_in), 0), t.strstart = t.w_size, t.insert = t.strstart) : (t.window_size - t.strstart <= o && (t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, t.insert > t.strstart && (t.insert = t.strstart)), t.window.set(t.strm.input.subarray(t.strm.next_in - o, t.strm.next_in), t.strstart), t.strstart += o, t.insert += o > t.w_size - t.insert ? t.w_size - t.insert : o), t.block_start = t.strstart), t.high_water < t.strstart && (t.high_water = t.strstart), n ? 4 : e !== lt && e !== ft && 0 === t.strm.avail_in && t.strstart === t.block_start ? 2 : (s = t.window_size - t.strstart, t.strm.avail_in > s && t.block_start >= t.w_size && (t.block_start -= t.w_size, t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, s += t.w_size, t.insert > t.strstart && (t.insert = t.strstart)), s > t.strm.avail_in && (s = t.strm.avail_in), s && (Tt(t.strm, t.window, t.strstart, s), t.strstart += s, t.insert += s > t.w_size - t.insert ? t.w_size - t.insert : s), t.high_water < t.strstart && (t.high_water = t.strstart), s = t.bi_valid + 42 >> 3, s = t.pending_buf_size - s > 65535 ? 65535 : t.pending_buf_size - s, r = s > t.w_size ? t.w_size : s, i = t.strstart - t.block_start, (i >= r || (i || e === ft) && e !== lt && 0 === t.strm.avail_in && i <= s) && (a = i > s ? s : i, n = e === ft && 0 === t.strm.avail_in && a === i ? 1 : 0, st(t, t.block_start, a, n), t.block_start += a, Dt(t.strm)), n ? 3 : 1);
  },
  Mt = (t, e) => {
    let a, i;
    for (;;) {
      if (t.lookahead < 262) {
        if (Ct(t), t.lookahead < 262 && e === lt) return 1;
        if (0 === t.lookahead) break;
      }
      if (a = 0, t.lookahead >= 3 && (t.ins_h = It(t, t.ins_h, t.window[t.strstart + 3 - 1]), a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== a && t.strstart - a <= t.w_size - 262 && (t.match_length = Zt(t, a)), t.match_length >= 3) {
        if (i = nt(t, t.strstart - t.match_start, t.match_length - 3), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= 3) {
          t.match_length--;
          do {
            t.strstart++, t.ins_h = It(t, t.ins_h, t.window[t.strstart + 3 - 1]), a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart;
          } while (0 != --t.match_length);
          t.strstart++;
        } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = It(t, t.ins_h, t.window[t.strstart + 1]);
      } else i = nt(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
      if (i && (Ft(t, !1), 0 === t.strm.avail_out)) return 1;
    }
    return t.insert = t.strstart < 2 ? t.strstart : 2, e === ft ? (Ft(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (Ft(t, !1), 0 === t.strm.avail_out) ? 1 : 2;
  },
  Nt = (t, e) => {
    let a, i, s;
    for (;;) {
      if (t.lookahead < 262) {
        if (Ct(t), t.lookahead < 262 && e === lt) return 1;
        if (0 === t.lookahead) break;
      }
      if (a = 0, t.lookahead >= 3 && (t.ins_h = It(t, t.ins_h, t.window[t.strstart + 3 - 1]), a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = 2, 0 !== a && t.prev_length < t.max_lazy_match && t.strstart - a <= t.w_size - 262 && (t.match_length = Zt(t, a), t.match_length <= 5 && (t.strategy === bt || 3 === t.match_length && t.strstart - t.match_start > 4096) && (t.match_length = 2)), t.prev_length >= 3 && t.match_length <= t.prev_length) {
        s = t.strstart + t.lookahead - 3, i = nt(t, t.strstart - 1 - t.prev_match, t.prev_length - 3), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
        do {
          ++t.strstart <= s && (t.ins_h = It(t, t.ins_h, t.window[t.strstart + 3 - 1]), a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart);
        } while (0 != --t.prev_length);
        if (t.match_available = 0, t.match_length = 2, t.strstart++, i && (Ft(t, !1), 0 === t.strm.avail_out)) return 1;
      } else if (t.match_available) {
        if (i = nt(t, 0, t.window[t.strstart - 1]), i && Ft(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return 1;
      } else t.match_available = 1, t.strstart++, t.lookahead--;
    }
    return t.match_available && (i = nt(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < 2 ? t.strstart : 2, e === ft ? (Ft(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (Ft(t, !1), 0 === t.strm.avail_out) ? 1 : 2;
  };
function Pt(t, e, a, i, s) {
  this.good_length = t, this.max_lazy = e, this.nice_length = a, this.max_chain = i, this.func = s;
}
const Ht = [new Pt(0, 0, 0, 0, Lt), new Pt(4, 4, 8, 4, Mt), new Pt(4, 5, 16, 8, Mt), new Pt(4, 6, 32, 32, Mt), new Pt(4, 4, 16, 16, Nt), new Pt(8, 16, 32, 32, Nt), new Pt(8, 16, 128, 128, Nt), new Pt(8, 32, 128, 256, Nt), new Pt(32, 128, 258, 1024, Nt), new Pt(32, 258, 258, 4096, Nt)];
function $t() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = St, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), Rt(this.dyn_ltree), Rt(this.dyn_dtree), Rt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), Rt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), Rt(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const jt = t => {
    if (!t) return 1;
    const e = t.state;
    return !e || e.strm !== t || 42 !== e.status && 57 !== e.status && 69 !== e.status && 73 !== e.status && 91 !== e.status && 103 !== e.status && 113 !== e.status && 666 !== e.status ? 1 : 0;
  },
  Vt = t => {
    if (jt(t)) return Ut(t, gt);
    t.total_in = t.total_out = 0, t.data_type = zt;
    const e = t.state;
    return e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = 2 === e.wrap ? 57 : e.wrap ? 42 : 113, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = -2, it(e), ct;
  },
  Wt = t => {
    const e = Vt(t);
    var a;
    return e === ct && ((a = t.state).window_size = 2 * a.w_size, Rt(a.head), a.max_lazy_match = Ht[a.level].max_lazy, a.good_match = Ht[a.level].good_length, a.nice_match = Ht[a.level].nice_length, a.max_chain_length = Ht[a.level].max_chain, a.strstart = 0, a.block_start = 0, a.lookahead = 0, a.insert = 0, a.match_length = a.prev_length = 2, a.match_available = 0, a.ins_h = 0), e;
  },
  Kt = (t, e, a, i, s, r) => {
    if (!t) return gt;
    let n = 1;
    if (e === pt && (e = 6), i < 0 ? (n = 0, i = -i) : i > 15 && (n = 2, i -= 16), s < 1 || s > 9 || a !== St || i < 8 || i > 15 || e < 0 || e > 9 || r < 0 || r > vt || 8 === i && 1 !== n) return Ut(t, gt);
    8 === i && (i = 9);
    const o = new $t();
    return t.state = o, o.strm = t, o.status = 42, o.wrap = n, o.gzhead = null, o.w_bits = i, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = s + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + 3 - 1) / 3), o.window = new Uint8Array(2 * o.w_size), o.head = new Uint16Array(o.hash_size), o.prev = new Uint16Array(o.w_size), o.lit_bufsize = 1 << s + 6, o.pending_buf_size = 4 * o.lit_bufsize, o.pending_buf = new Uint8Array(o.pending_buf_size), o.sym_buf = o.lit_bufsize, o.sym_end = 3 * (o.lit_bufsize - 1), o.level = e, o.strategy = r, o.method = a, Wt(t);
  };
var Yt = {
  deflateInit: (t, e) => Kt(t, e, St, 15, 8, xt),
  deflateInit2: Kt,
  deflateReset: Wt,
  deflateResetKeep: Vt,
  deflateSetHeader: (t, e) => jt(t) || 2 !== t.state.wrap ? gt : (t.state.gzhead = e, ct),
  deflate: (t, e) => {
    if (jt(t) || e > _t || e < 0) return t ? Ut(t, gt) : gt;
    const a = t.state;
    if (!t.output || 0 !== t.avail_in && !t.input || 666 === a.status && e !== ft) return Ut(t, 0 === t.avail_out ? mt : gt);
    const i = a.last_flush;
    if (a.last_flush = e, 0 !== a.pending) {
      if (Dt(t), 0 === t.avail_out) return a.last_flush = -1, ct;
    } else if (0 === t.avail_in && Et(e) <= Et(i) && e !== ft) return Ut(t, mt);
    if (666 === a.status && 0 !== t.avail_in) return Ut(t, mt);
    if (42 === a.status && 0 === a.wrap && (a.status = 113), 42 === a.status) {
      let e = St + (a.w_bits - 8 << 4) << 8,
        i = -1;
      if (i = a.strategy >= yt || a.level < 2 ? 0 : a.level < 6 ? 1 : 6 === a.level ? 2 : 3, e |= i << 6, 0 !== a.strstart && (e |= 32), e += 31 - e % 31, Ot(a, e), 0 !== a.strstart && (Ot(a, t.adler >>> 16), Ot(a, 65535 & t.adler)), t.adler = 1, a.status = 113, Dt(t), 0 !== a.pending) return a.last_flush = -1, ct;
    }
    if (57 === a.status) if (t.adler = 0, Bt(a, 31), Bt(a, 139), Bt(a, 8), a.gzhead) Bt(a, (a.gzhead.text ? 1 : 0) + (a.gzhead.hcrc ? 2 : 0) + (a.gzhead.extra ? 4 : 0) + (a.gzhead.name ? 8 : 0) + (a.gzhead.comment ? 16 : 0)), Bt(a, 255 & a.gzhead.time), Bt(a, a.gzhead.time >> 8 & 255), Bt(a, a.gzhead.time >> 16 & 255), Bt(a, a.gzhead.time >> 24 & 255), Bt(a, 9 === a.level ? 2 : a.strategy >= yt || a.level < 2 ? 4 : 0), Bt(a, 255 & a.gzhead.os), a.gzhead.extra && a.gzhead.extra.length && (Bt(a, 255 & a.gzhead.extra.length), Bt(a, a.gzhead.extra.length >> 8 & 255)), a.gzhead.hcrc && (t.adler = tt(t.adler, a.pending_buf, a.pending, 0)), a.gzindex = 0, a.status = 69;else if (Bt(a, 0), Bt(a, 0), Bt(a, 0), Bt(a, 0), Bt(a, 0), Bt(a, 9 === a.level ? 2 : a.strategy >= yt || a.level < 2 ? 4 : 0), Bt(a, 3), a.status = 113, Dt(t), 0 !== a.pending) return a.last_flush = -1, ct;
    if (69 === a.status) {
      if (a.gzhead.extra) {
        let e = a.pending,
          i = (65535 & a.gzhead.extra.length) - a.gzindex;
        for (; a.pending + i > a.pending_buf_size;) {
          let s = a.pending_buf_size - a.pending;
          if (a.pending_buf.set(a.gzhead.extra.subarray(a.gzindex, a.gzindex + s), a.pending), a.pending = a.pending_buf_size, a.gzhead.hcrc && a.pending > e && (t.adler = tt(t.adler, a.pending_buf, a.pending - e, e)), a.gzindex += s, Dt(t), 0 !== a.pending) return a.last_flush = -1, ct;
          e = 0, i -= s;
        }
        let s = new Uint8Array(a.gzhead.extra);
        a.pending_buf.set(s.subarray(a.gzindex, a.gzindex + i), a.pending), a.pending += i, a.gzhead.hcrc && a.pending > e && (t.adler = tt(t.adler, a.pending_buf, a.pending - e, e)), a.gzindex = 0;
      }
      a.status = 73;
    }
    if (73 === a.status) {
      if (a.gzhead.name) {
        let e,
          i = a.pending;
        do {
          if (a.pending === a.pending_buf_size) {
            if (a.gzhead.hcrc && a.pending > i && (t.adler = tt(t.adler, a.pending_buf, a.pending - i, i)), Dt(t), 0 !== a.pending) return a.last_flush = -1, ct;
            i = 0;
          }
          e = a.gzindex < a.gzhead.name.length ? 255 & a.gzhead.name.charCodeAt(a.gzindex++) : 0, Bt(a, e);
        } while (0 !== e);
        a.gzhead.hcrc && a.pending > i && (t.adler = tt(t.adler, a.pending_buf, a.pending - i, i)), a.gzindex = 0;
      }
      a.status = 91;
    }
    if (91 === a.status) {
      if (a.gzhead.comment) {
        let e,
          i = a.pending;
        do {
          if (a.pending === a.pending_buf_size) {
            if (a.gzhead.hcrc && a.pending > i && (t.adler = tt(t.adler, a.pending_buf, a.pending - i, i)), Dt(t), 0 !== a.pending) return a.last_flush = -1, ct;
            i = 0;
          }
          e = a.gzindex < a.gzhead.comment.length ? 255 & a.gzhead.comment.charCodeAt(a.gzindex++) : 0, Bt(a, e);
        } while (0 !== e);
        a.gzhead.hcrc && a.pending > i && (t.adler = tt(t.adler, a.pending_buf, a.pending - i, i));
      }
      a.status = 103;
    }
    if (103 === a.status) {
      if (a.gzhead.hcrc) {
        if (a.pending + 2 > a.pending_buf_size && (Dt(t), 0 !== a.pending)) return a.last_flush = -1, ct;
        Bt(a, 255 & t.adler), Bt(a, t.adler >> 8 & 255), t.adler = 0;
      }
      if (a.status = 113, Dt(t), 0 !== a.pending) return a.last_flush = -1, ct;
    }
    if (0 !== t.avail_in || 0 !== a.lookahead || e !== lt && 666 !== a.status) {
      let i = 0 === a.level ? Lt(a, e) : a.strategy === yt ? ((t, e) => {
        let a;
        for (;;) {
          if (0 === t.lookahead && (Ct(t), 0 === t.lookahead)) {
            if (e === lt) return 1;
            break;
          }
          if (t.match_length = 0, a = nt(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, a && (Ft(t, !1), 0 === t.strm.avail_out)) return 1;
        }
        return t.insert = 0, e === ft ? (Ft(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (Ft(t, !1), 0 === t.strm.avail_out) ? 1 : 2;
      })(a, e) : a.strategy === kt ? ((t, e) => {
        let a, i, s, r;
        const n = t.window;
        for (;;) {
          if (t.lookahead <= 258) {
            if (Ct(t), t.lookahead <= 258 && e === lt) return 1;
            if (0 === t.lookahead) break;
          }
          if (t.match_length = 0, t.lookahead >= 3 && t.strstart > 0 && (s = t.strstart - 1, i = n[s], i === n[++s] && i === n[++s] && i === n[++s])) {
            r = t.strstart + 258;
            do {} while (i === n[++s] && i === n[++s] && i === n[++s] && i === n[++s] && i === n[++s] && i === n[++s] && i === n[++s] && i === n[++s] && s < r);
            t.match_length = 258 - (r - s), t.match_length > t.lookahead && (t.match_length = t.lookahead);
          }
          if (t.match_length >= 3 ? (a = nt(t, 1, t.match_length - 3), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (a = nt(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), a && (Ft(t, !1), 0 === t.strm.avail_out)) return 1;
        }
        return t.insert = 0, e === ft ? (Ft(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (Ft(t, !1), 0 === t.strm.avail_out) ? 1 : 2;
      })(a, e) : Ht[a.level].func(a, e);
      if (3 !== i && 4 !== i || (a.status = 666), 1 === i || 3 === i) return 0 === t.avail_out && (a.last_flush = -1), ct;
      if (2 === i && (e === ht ? ot(a) : e !== _t && (st(a, 0, 0, !1), e === dt && (Rt(a.head), 0 === a.lookahead && (a.strstart = 0, a.block_start = 0, a.insert = 0))), Dt(t), 0 === t.avail_out)) return a.last_flush = -1, ct;
    }
    return e !== ft ? ct : a.wrap <= 0 ? ut : (2 === a.wrap ? (Bt(a, 255 & t.adler), Bt(a, t.adler >> 8 & 255), Bt(a, t.adler >> 16 & 255), Bt(a, t.adler >> 24 & 255), Bt(a, 255 & t.total_in), Bt(a, t.total_in >> 8 & 255), Bt(a, t.total_in >> 16 & 255), Bt(a, t.total_in >> 24 & 255)) : (Ot(a, t.adler >>> 16), Ot(a, 65535 & t.adler)), Dt(t), a.wrap > 0 && (a.wrap = -a.wrap), 0 !== a.pending ? ct : ut);
  },
  deflateEnd: t => {
    if (jt(t)) return gt;
    const e = t.state.status;
    return t.state = null, 113 === e ? Ut(t, wt) : ct;
  },
  deflateSetDictionary: (t, e) => {
    let a = e.length;
    if (jt(t)) return gt;
    const i = t.state,
      s = i.wrap;
    if (2 === s || 1 === s && 42 !== i.status || i.lookahead) return gt;
    if (1 === s && (t.adler = Q(t.adler, e, a, 0)), i.wrap = 0, a >= i.w_size) {
      0 === s && (Rt(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0);
      let t = new Uint8Array(i.w_size);
      t.set(e.subarray(a - i.w_size, a), 0), e = t, a = i.w_size;
    }
    const r = t.avail_in,
      n = t.next_in,
      o = t.input;
    for (t.avail_in = a, t.next_in = 0, t.input = e, Ct(i); i.lookahead >= 3;) {
      let t = i.strstart,
        e = i.lookahead - 2;
      do {
        i.ins_h = It(i, i.ins_h, i.window[t + 3 - 1]), i.prev[t & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = t, t++;
      } while (--e);
      i.strstart = t, i.lookahead = 2, Ct(i);
    }
    return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = 2, i.match_available = 0, t.next_in = n, t.input = o, t.avail_in = r, i.wrap = s, ct;
  },
  deflateInfo: "pako deflate (from Nodeca project)"
};
const qt = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
var Gt = function (t) {
    const e = Array.prototype.slice.call(arguments, 1);
    for (; e.length;) {
      const a = e.shift();
      if (a) {
        if ("object" != typeof a) throw new TypeError(a + "must be non-object");
        for (const e in a) qt(a, e) && (t[e] = a[e]);
      }
    }
    return t;
  },
  Xt = t => {
    let e = 0;
    for (let a = 0, i = t.length; a < i; a++) e += t[a].length;
    const a = new Uint8Array(e);
    for (let e = 0, i = 0, s = t.length; e < s; e++) {
      let s = t[e];
      a.set(s, i), i += s.length;
    }
    return a;
  };
let Qt = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (t) {
  Qt = !1;
}
const Jt = new Uint8Array(256);
for (let t = 0; t < 256; t++) Jt[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1;
Jt[254] = Jt[254] = 1;
var te = t => {
    if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return new TextEncoder().encode(t);
    let e,
      a,
      i,
      s,
      r,
      n = t.length,
      o = 0;
    for (s = 0; s < n; s++) a = t.charCodeAt(s), 55296 == (64512 & a) && s + 1 < n && (i = t.charCodeAt(s + 1), 56320 == (64512 & i) && (a = 65536 + (a - 55296 << 10) + (i - 56320), s++)), o += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
    for (e = new Uint8Array(o), r = 0, s = 0; r < o; s++) a = t.charCodeAt(s), 55296 == (64512 & a) && s + 1 < n && (i = t.charCodeAt(s + 1), 56320 == (64512 & i) && (a = 65536 + (a - 55296 << 10) + (i - 56320), s++)), a < 128 ? e[r++] = a : a < 2048 ? (e[r++] = 192 | a >>> 6, e[r++] = 128 | 63 & a) : a < 65536 ? (e[r++] = 224 | a >>> 12, e[r++] = 128 | a >>> 6 & 63, e[r++] = 128 | 63 & a) : (e[r++] = 240 | a >>> 18, e[r++] = 128 | a >>> 12 & 63, e[r++] = 128 | a >>> 6 & 63, e[r++] = 128 | 63 & a);
    return e;
  },
  ee = (t, e) => {
    const a = e || t.length;
    if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return new TextDecoder().decode(t.subarray(0, e));
    let i, s;
    const r = new Array(2 * a);
    for (s = 0, i = 0; i < a;) {
      let e = t[i++];
      if (e < 128) {
        r[s++] = e;
        continue;
      }
      let n = Jt[e];
      if (n > 4) r[s++] = 65533, i += n - 1;else {
        for (e &= 2 === n ? 31 : 3 === n ? 15 : 7; n > 1 && i < a;) e = e << 6 | 63 & t[i++], n--;
        n > 1 ? r[s++] = 65533 : e < 65536 ? r[s++] = e : (e -= 65536, r[s++] = 55296 | e >> 10 & 1023, r[s++] = 56320 | 1023 & e);
      }
    }
    return ((t, e) => {
      if (e < 65534 && t.subarray && Qt) return String.fromCharCode.apply(null, t.length === e ? t : t.subarray(0, e));
      let a = "";
      for (let i = 0; i < e; i++) a += String.fromCharCode(t[i]);
      return a;
    })(r, s);
  },
  ae = (t, e) => {
    (e = e || t.length) > t.length && (e = t.length);
    let a = e - 1;
    for (; a >= 0 && 128 == (192 & t[a]);) a--;
    return a < 0 || 0 === a ? e : a + Jt[t[a]] > e ? a : e;
  };
var ie = function () {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
};
const se = Object.prototype.toString,
  {
    Z_NO_FLUSH: re,
    Z_SYNC_FLUSH: ne,
    Z_FULL_FLUSH: oe,
    Z_FINISH: le,
    Z_OK: he,
    Z_STREAM_END: de,
    Z_DEFAULT_COMPRESSION: fe,
    Z_DEFAULT_STRATEGY: _e,
    Z_DEFLATED: ce
  } = at;
function ue(t) {
  this.options = Gt({
    level: fe,
    method: ce,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: _e
  }, t || {});
  let e = this.options;
  e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new ie(), this.strm.avail_out = 0;
  let a = Yt.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
  if (a !== he) throw new Error(et[a]);
  if (e.header && Yt.deflateSetHeader(this.strm, e.header), e.dictionary) {
    let t;
    if (t = "string" == typeof e.dictionary ? te(e.dictionary) : "[object ArrayBuffer]" === se.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, a = Yt.deflateSetDictionary(this.strm, t), a !== he) throw new Error(et[a]);
    this._dict_set = !0;
  }
}
function ge(t, e) {
  const a = new ue(e);
  if (a.push(t, !0), a.err) throw a.msg || et[a.err];
  return a.result;
}
ue.prototype.push = function (t, e) {
  const a = this.strm,
    i = this.options.chunkSize;
  let s, r;
  if (this.ended) return !1;
  for (r = e === ~~e ? e : !0 === e ? le : re, "string" == typeof t ? a.input = te(t) : "[object ArrayBuffer]" === se.call(t) ? a.input = new Uint8Array(t) : a.input = t, a.next_in = 0, a.avail_in = a.input.length;;) if (0 === a.avail_out && (a.output = new Uint8Array(i), a.next_out = 0, a.avail_out = i), (r === ne || r === oe) && a.avail_out <= 6) this.onData(a.output.subarray(0, a.next_out)), a.avail_out = 0;else {
    if (s = Yt.deflate(a, r), s === de) return a.next_out > 0 && this.onData(a.output.subarray(0, a.next_out)), s = Yt.deflateEnd(this.strm), this.onEnd(s), this.ended = !0, s === he;
    if (0 !== a.avail_out) {
      if (r > 0 && a.next_out > 0) this.onData(a.output.subarray(0, a.next_out)), a.avail_out = 0;else if (0 === a.avail_in) break;
    } else this.onData(a.output);
  }
  return !0;
}, ue.prototype.onData = function (t) {
  this.chunks.push(t);
}, ue.prototype.onEnd = function (t) {
  t === he && (this.result = Xt(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
};
var we = {
  Deflate: ue,
  deflate: ge,
  deflateRaw: function (t, e) {
    return (e = e || {}).raw = !0, ge(t, e);
  },
  gzip: function (t, e) {
    return (e = e || {}).gzip = !0, ge(t, e);
  },
  constants: at
};
var me = function (t, e) {
  let a, i, s, r, n, o, l, h, d, f, _, c, u, g, w, m, p, b, y, k, v, x, z, S;
  const U = t.state;
  a = t.next_in, z = t.input, i = a + (t.avail_in - 5), s = t.next_out, S = t.output, r = s - (e - t.avail_out), n = s + (t.avail_out - 257), o = U.dmax, l = U.wsize, h = U.whave, d = U.wnext, f = U.window, _ = U.hold, c = U.bits, u = U.lencode, g = U.distcode, w = (1 << U.lenbits) - 1, m = (1 << U.distbits) - 1;
  t: do {
    c < 15 && (_ += z[a++] << c, c += 8, _ += z[a++] << c, c += 8), p = u[_ & w];
    e: for (;;) {
      if (b = p >>> 24, _ >>>= b, c -= b, b = p >>> 16 & 255, 0 === b) S[s++] = 65535 & p;else {
        if (!(16 & b)) {
          if (0 == (64 & b)) {
            p = u[(65535 & p) + (_ & (1 << b) - 1)];
            continue e;
          }
          if (32 & b) {
            U.mode = 16191;
            break t;
          }
          t.msg = "invalid literal/length code", U.mode = 16209;
          break t;
        }
        y = 65535 & p, b &= 15, b && (c < b && (_ += z[a++] << c, c += 8), y += _ & (1 << b) - 1, _ >>>= b, c -= b), c < 15 && (_ += z[a++] << c, c += 8, _ += z[a++] << c, c += 8), p = g[_ & m];
        a: for (;;) {
          if (b = p >>> 24, _ >>>= b, c -= b, b = p >>> 16 & 255, !(16 & b)) {
            if (0 == (64 & b)) {
              p = g[(65535 & p) + (_ & (1 << b) - 1)];
              continue a;
            }
            t.msg = "invalid distance code", U.mode = 16209;
            break t;
          }
          if (k = 65535 & p, b &= 15, c < b && (_ += z[a++] << c, c += 8, c < b && (_ += z[a++] << c, c += 8)), k += _ & (1 << b) - 1, k > o) {
            t.msg = "invalid distance too far back", U.mode = 16209;
            break t;
          }
          if (_ >>>= b, c -= b, b = s - r, k > b) {
            if (b = k - b, b > h && U.sane) {
              t.msg = "invalid distance too far back", U.mode = 16209;
              break t;
            }
            if (v = 0, x = f, 0 === d) {
              if (v += l - b, b < y) {
                y -= b;
                do {
                  S[s++] = f[v++];
                } while (--b);
                v = s - k, x = S;
              }
            } else if (d < b) {
              if (v += l + d - b, b -= d, b < y) {
                y -= b;
                do {
                  S[s++] = f[v++];
                } while (--b);
                if (v = 0, d < y) {
                  b = d, y -= b;
                  do {
                    S[s++] = f[v++];
                  } while (--b);
                  v = s - k, x = S;
                }
              }
            } else if (v += d - b, b < y) {
              y -= b;
              do {
                S[s++] = f[v++];
              } while (--b);
              v = s - k, x = S;
            }
            for (; y > 2;) S[s++] = x[v++], S[s++] = x[v++], S[s++] = x[v++], y -= 3;
            y && (S[s++] = x[v++], y > 1 && (S[s++] = x[v++]));
          } else {
            v = s - k;
            do {
              S[s++] = S[v++], S[s++] = S[v++], S[s++] = S[v++], y -= 3;
            } while (y > 2);
            y && (S[s++] = S[v++], y > 1 && (S[s++] = S[v++]));
          }
          break;
        }
      }
      break;
    }
  } while (a < i && s < n);
  y = c >> 3, a -= y, c -= y << 3, _ &= (1 << c) - 1, t.next_in = a, t.next_out = s, t.avail_in = a < i ? i - a + 5 : 5 - (a - i), t.avail_out = s < n ? n - s + 257 : 257 - (s - n), U.hold = _, U.bits = c;
};
const pe = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
  be = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
  ye = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
  ke = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
var ve = (t, e, a, i, s, r, n, o) => {
  const l = o.bits;
  let h,
    d,
    f,
    _,
    c,
    u,
    g = 0,
    w = 0,
    m = 0,
    p = 0,
    b = 0,
    y = 0,
    k = 0,
    v = 0,
    x = 0,
    z = 0,
    S = null;
  const U = new Uint16Array(16),
    E = new Uint16Array(16);
  let R,
    A,
    I,
    D = null;
  for (g = 0; g <= 15; g++) U[g] = 0;
  for (w = 0; w < i; w++) U[e[a + w]]++;
  for (b = l, p = 15; p >= 1 && 0 === U[p]; p--);
  if (b > p && (b = p), 0 === p) return s[r++] = 20971520, s[r++] = 20971520, o.bits = 1, 0;
  for (m = 1; m < p && 0 === U[m]; m++);
  for (b < m && (b = m), v = 1, g = 1; g <= 15; g++) if (v <<= 1, v -= U[g], v < 0) return -1;
  if (v > 0 && (0 === t || 1 !== p)) return -1;
  for (E[1] = 0, g = 1; g < 15; g++) E[g + 1] = E[g] + U[g];
  for (w = 0; w < i; w++) 0 !== e[a + w] && (n[E[e[a + w]]++] = w);
  if (0 === t ? (S = D = n, u = 20) : 1 === t ? (S = pe, D = be, u = 257) : (S = ye, D = ke, u = 0), z = 0, w = 0, g = m, c = r, y = b, k = 0, f = -1, x = 1 << b, _ = x - 1, 1 === t && x > 852 || 2 === t && x > 592) return 1;
  for (;;) {
    R = g - k, n[w] + 1 < u ? (A = 0, I = n[w]) : n[w] >= u ? (A = D[n[w] - u], I = S[n[w] - u]) : (A = 96, I = 0), h = 1 << g - k, d = 1 << y, m = d;
    do {
      d -= h, s[c + (z >> k) + d] = R << 24 | A << 16 | I | 0;
    } while (0 !== d);
    for (h = 1 << g - 1; z & h;) h >>= 1;
    if (0 !== h ? (z &= h - 1, z += h) : z = 0, w++, 0 == --U[g]) {
      if (g === p) break;
      g = e[a + n[w]];
    }
    if (g > b && (z & _) !== f) {
      for (0 === k && (k = b), c += m, y = g - k, v = 1 << y; y + k < p && (v -= U[y + k], !(v <= 0));) y++, v <<= 1;
      if (x += 1 << y, 1 === t && x > 852 || 2 === t && x > 592) return 1;
      f = z & _, s[f] = b << 24 | y << 16 | c - r | 0;
    }
  }
  return 0 !== z && (s[c + z] = g - k << 24 | 64 << 16 | 0), o.bits = b, 0;
};
const {
    Z_FINISH: xe,
    Z_BLOCK: ze,
    Z_TREES: Se,
    Z_OK: Ue,
    Z_STREAM_END: Ee,
    Z_NEED_DICT: Re,
    Z_STREAM_ERROR: Ae,
    Z_DATA_ERROR: Ie,
    Z_MEM_ERROR: De,
    Z_BUF_ERROR: Fe,
    Z_DEFLATED: Be
  } = at,
  Oe = 16209,
  Te = t => (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24);
function Ze() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const Ce = t => {
    if (!t) return 1;
    const e = t.state;
    return !e || e.strm !== t || e.mode < 16180 || e.mode > 16211 ? 1 : 0;
  },
  Le = t => {
    if (Ce(t)) return Ae;
    const e = t.state;
    return t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = 16180, e.last = 0, e.havedict = 0, e.flags = -1, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(852), e.distcode = e.distdyn = new Int32Array(592), e.sane = 1, e.back = -1, Ue;
  },
  Me = t => {
    if (Ce(t)) return Ae;
    const e = t.state;
    return e.wsize = 0, e.whave = 0, e.wnext = 0, Le(t);
  },
  Ne = (t, e) => {
    let a;
    if (Ce(t)) return Ae;
    const i = t.state;
    return e < 0 ? (a = 0, e = -e) : (a = 5 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? Ae : (null !== i.window && i.wbits !== e && (i.window = null), i.wrap = a, i.wbits = e, Me(t));
  },
  Pe = (t, e) => {
    if (!t) return Ae;
    const a = new Ze();
    t.state = a, a.strm = t, a.window = null, a.mode = 16180;
    const i = Ne(t, e);
    return i !== Ue && (t.state = null), i;
  };
let He,
  $e,
  je = !0;
const Ve = t => {
    if (je) {
      He = new Int32Array(512), $e = new Int32Array(32);
      let e = 0;
      for (; e < 144;) t.lens[e++] = 8;
      for (; e < 256;) t.lens[e++] = 9;
      for (; e < 280;) t.lens[e++] = 7;
      for (; e < 288;) t.lens[e++] = 8;
      for (ve(1, t.lens, 0, 288, He, 0, t.work, {
        bits: 9
      }), e = 0; e < 32;) t.lens[e++] = 5;
      ve(2, t.lens, 0, 32, $e, 0, t.work, {
        bits: 5
      }), je = !1;
    }
    t.lencode = He, t.lenbits = 9, t.distcode = $e, t.distbits = 5;
  },
  We = (t, e, a, i) => {
    let s;
    const r = t.state;
    return null === r.window && (r.wsize = 1 << r.wbits, r.wnext = 0, r.whave = 0, r.window = new Uint8Array(r.wsize)), i >= r.wsize ? (r.window.set(e.subarray(a - r.wsize, a), 0), r.wnext = 0, r.whave = r.wsize) : (s = r.wsize - r.wnext, s > i && (s = i), r.window.set(e.subarray(a - i, a - i + s), r.wnext), (i -= s) ? (r.window.set(e.subarray(a - i, a), 0), r.wnext = i, r.whave = r.wsize) : (r.wnext += s, r.wnext === r.wsize && (r.wnext = 0), r.whave < r.wsize && (r.whave += s))), 0;
  };
var Ke = {
  inflateReset: Me,
  inflateReset2: Ne,
  inflateResetKeep: Le,
  inflateInit: t => Pe(t, 15),
  inflateInit2: Pe,
  inflate: (t, e) => {
    let a,
      i,
      s,
      r,
      n,
      o,
      l,
      h,
      d,
      f,
      _,
      c,
      u,
      g,
      w,
      m,
      p,
      b,
      y,
      k,
      v,
      x,
      z = 0;
    const S = new Uint8Array(4);
    let U, E;
    const R = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (Ce(t) || !t.output || !t.input && 0 !== t.avail_in) return Ae;
    a = t.state, 16191 === a.mode && (a.mode = 16192), n = t.next_out, s = t.output, l = t.avail_out, r = t.next_in, i = t.input, o = t.avail_in, h = a.hold, d = a.bits, f = o, _ = l, x = Ue;
    t: for (;;) switch (a.mode) {
      case 16180:
        if (0 === a.wrap) {
          a.mode = 16192;
          break;
        }
        for (; d < 16;) {
          if (0 === o) break t;
          o--, h += i[r++] << d, d += 8;
        }
        if (2 & a.wrap && 35615 === h) {
          0 === a.wbits && (a.wbits = 15), a.check = 0, S[0] = 255 & h, S[1] = h >>> 8 & 255, a.check = tt(a.check, S, 2, 0), h = 0, d = 0, a.mode = 16181;
          break;
        }
        if (a.head && (a.head.done = !1), !(1 & a.wrap) || (((255 & h) << 8) + (h >> 8)) % 31) {
          t.msg = "incorrect header check", a.mode = Oe;
          break;
        }
        if ((15 & h) !== Be) {
          t.msg = "unknown compression method", a.mode = Oe;
          break;
        }
        if (h >>>= 4, d -= 4, v = 8 + (15 & h), 0 === a.wbits && (a.wbits = v), v > 15 || v > a.wbits) {
          t.msg = "invalid window size", a.mode = Oe;
          break;
        }
        a.dmax = 1 << a.wbits, a.flags = 0, t.adler = a.check = 1, a.mode = 512 & h ? 16189 : 16191, h = 0, d = 0;
        break;
      case 16181:
        for (; d < 16;) {
          if (0 === o) break t;
          o--, h += i[r++] << d, d += 8;
        }
        if (a.flags = h, (255 & a.flags) !== Be) {
          t.msg = "unknown compression method", a.mode = Oe;
          break;
        }
        if (57344 & a.flags) {
          t.msg = "unknown header flags set", a.mode = Oe;
          break;
        }
        a.head && (a.head.text = h >> 8 & 1), 512 & a.flags && 4 & a.wrap && (S[0] = 255 & h, S[1] = h >>> 8 & 255, a.check = tt(a.check, S, 2, 0)), h = 0, d = 0, a.mode = 16182;
      case 16182:
        for (; d < 32;) {
          if (0 === o) break t;
          o--, h += i[r++] << d, d += 8;
        }
        a.head && (a.head.time = h), 512 & a.flags && 4 & a.wrap && (S[0] = 255 & h, S[1] = h >>> 8 & 255, S[2] = h >>> 16 & 255, S[3] = h >>> 24 & 255, a.check = tt(a.check, S, 4, 0)), h = 0, d = 0, a.mode = 16183;
      case 16183:
        for (; d < 16;) {
          if (0 === o) break t;
          o--, h += i[r++] << d, d += 8;
        }
        a.head && (a.head.xflags = 255 & h, a.head.os = h >> 8), 512 & a.flags && 4 & a.wrap && (S[0] = 255 & h, S[1] = h >>> 8 & 255, a.check = tt(a.check, S, 2, 0)), h = 0, d = 0, a.mode = 16184;
      case 16184:
        if (1024 & a.flags) {
          for (; d < 16;) {
            if (0 === o) break t;
            o--, h += i[r++] << d, d += 8;
          }
          a.length = h, a.head && (a.head.extra_len = h), 512 & a.flags && 4 & a.wrap && (S[0] = 255 & h, S[1] = h >>> 8 & 255, a.check = tt(a.check, S, 2, 0)), h = 0, d = 0;
        } else a.head && (a.head.extra = null);
        a.mode = 16185;
      case 16185:
        if (1024 & a.flags && (c = a.length, c > o && (c = o), c && (a.head && (v = a.head.extra_len - a.length, a.head.extra || (a.head.extra = new Uint8Array(a.head.extra_len)), a.head.extra.set(i.subarray(r, r + c), v)), 512 & a.flags && 4 & a.wrap && (a.check = tt(a.check, i, c, r)), o -= c, r += c, a.length -= c), a.length)) break t;
        a.length = 0, a.mode = 16186;
      case 16186:
        if (2048 & a.flags) {
          if (0 === o) break t;
          c = 0;
          do {
            v = i[r + c++], a.head && v && a.length < 65536 && (a.head.name += String.fromCharCode(v));
          } while (v && c < o);
          if (512 & a.flags && 4 & a.wrap && (a.check = tt(a.check, i, c, r)), o -= c, r += c, v) break t;
        } else a.head && (a.head.name = null);
        a.length = 0, a.mode = 16187;
      case 16187:
        if (4096 & a.flags) {
          if (0 === o) break t;
          c = 0;
          do {
            v = i[r + c++], a.head && v && a.length < 65536 && (a.head.comment += String.fromCharCode(v));
          } while (v && c < o);
          if (512 & a.flags && 4 & a.wrap && (a.check = tt(a.check, i, c, r)), o -= c, r += c, v) break t;
        } else a.head && (a.head.comment = null);
        a.mode = 16188;
      case 16188:
        if (512 & a.flags) {
          for (; d < 16;) {
            if (0 === o) break t;
            o--, h += i[r++] << d, d += 8;
          }
          if (4 & a.wrap && h !== (65535 & a.check)) {
            t.msg = "header crc mismatch", a.mode = Oe;
            break;
          }
          h = 0, d = 0;
        }
        a.head && (a.head.hcrc = a.flags >> 9 & 1, a.head.done = !0), t.adler = a.check = 0, a.mode = 16191;
        break;
      case 16189:
        for (; d < 32;) {
          if (0 === o) break t;
          o--, h += i[r++] << d, d += 8;
        }
        t.adler = a.check = Te(h), h = 0, d = 0, a.mode = 16190;
      case 16190:
        if (0 === a.havedict) return t.next_out = n, t.avail_out = l, t.next_in = r, t.avail_in = o, a.hold = h, a.bits = d, Re;
        t.adler = a.check = 1, a.mode = 16191;
      case 16191:
        if (e === ze || e === Se) break t;
      case 16192:
        if (a.last) {
          h >>>= 7 & d, d -= 7 & d, a.mode = 16206;
          break;
        }
        for (; d < 3;) {
          if (0 === o) break t;
          o--, h += i[r++] << d, d += 8;
        }
        switch (a.last = 1 & h, h >>>= 1, d -= 1, 3 & h) {
          case 0:
            a.mode = 16193;
            break;
          case 1:
            if (Ve(a), a.mode = 16199, e === Se) {
              h >>>= 2, d -= 2;
              break t;
            }
            break;
          case 2:
            a.mode = 16196;
            break;
          case 3:
            t.msg = "invalid block type", a.mode = Oe;
        }
        h >>>= 2, d -= 2;
        break;
      case 16193:
        for (h >>>= 7 & d, d -= 7 & d; d < 32;) {
          if (0 === o) break t;
          o--, h += i[r++] << d, d += 8;
        }
        if ((65535 & h) != (h >>> 16 ^ 65535)) {
          t.msg = "invalid stored block lengths", a.mode = Oe;
          break;
        }
        if (a.length = 65535 & h, h = 0, d = 0, a.mode = 16194, e === Se) break t;
      case 16194:
        a.mode = 16195;
      case 16195:
        if (c = a.length, c) {
          if (c > o && (c = o), c > l && (c = l), 0 === c) break t;
          s.set(i.subarray(r, r + c), n), o -= c, r += c, l -= c, n += c, a.length -= c;
          break;
        }
        a.mode = 16191;
        break;
      case 16196:
        for (; d < 14;) {
          if (0 === o) break t;
          o--, h += i[r++] << d, d += 8;
        }
        if (a.nlen = 257 + (31 & h), h >>>= 5, d -= 5, a.ndist = 1 + (31 & h), h >>>= 5, d -= 5, a.ncode = 4 + (15 & h), h >>>= 4, d -= 4, a.nlen > 286 || a.ndist > 30) {
          t.msg = "too many length or distance symbols", a.mode = Oe;
          break;
        }
        a.have = 0, a.mode = 16197;
      case 16197:
        for (; a.have < a.ncode;) {
          for (; d < 3;) {
            if (0 === o) break t;
            o--, h += i[r++] << d, d += 8;
          }
          a.lens[R[a.have++]] = 7 & h, h >>>= 3, d -= 3;
        }
        for (; a.have < 19;) a.lens[R[a.have++]] = 0;
        if (a.lencode = a.lendyn, a.lenbits = 7, U = {
          bits: a.lenbits
        }, x = ve(0, a.lens, 0, 19, a.lencode, 0, a.work, U), a.lenbits = U.bits, x) {
          t.msg = "invalid code lengths set", a.mode = Oe;
          break;
        }
        a.have = 0, a.mode = 16198;
      case 16198:
        for (; a.have < a.nlen + a.ndist;) {
          for (; z = a.lencode[h & (1 << a.lenbits) - 1], w = z >>> 24, m = z >>> 16 & 255, p = 65535 & z, !(w <= d);) {
            if (0 === o) break t;
            o--, h += i[r++] << d, d += 8;
          }
          if (p < 16) h >>>= w, d -= w, a.lens[a.have++] = p;else {
            if (16 === p) {
              for (E = w + 2; d < E;) {
                if (0 === o) break t;
                o--, h += i[r++] << d, d += 8;
              }
              if (h >>>= w, d -= w, 0 === a.have) {
                t.msg = "invalid bit length repeat", a.mode = Oe;
                break;
              }
              v = a.lens[a.have - 1], c = 3 + (3 & h), h >>>= 2, d -= 2;
            } else if (17 === p) {
              for (E = w + 3; d < E;) {
                if (0 === o) break t;
                o--, h += i[r++] << d, d += 8;
              }
              h >>>= w, d -= w, v = 0, c = 3 + (7 & h), h >>>= 3, d -= 3;
            } else {
              for (E = w + 7; d < E;) {
                if (0 === o) break t;
                o--, h += i[r++] << d, d += 8;
              }
              h >>>= w, d -= w, v = 0, c = 11 + (127 & h), h >>>= 7, d -= 7;
            }
            if (a.have + c > a.nlen + a.ndist) {
              t.msg = "invalid bit length repeat", a.mode = Oe;
              break;
            }
            for (; c--;) a.lens[a.have++] = v;
          }
        }
        if (a.mode === Oe) break;
        if (0 === a.lens[256]) {
          t.msg = "invalid code -- missing end-of-block", a.mode = Oe;
          break;
        }
        if (a.lenbits = 9, U = {
          bits: a.lenbits
        }, x = ve(1, a.lens, 0, a.nlen, a.lencode, 0, a.work, U), a.lenbits = U.bits, x) {
          t.msg = "invalid literal/lengths set", a.mode = Oe;
          break;
        }
        if (a.distbits = 6, a.distcode = a.distdyn, U = {
          bits: a.distbits
        }, x = ve(2, a.lens, a.nlen, a.ndist, a.distcode, 0, a.work, U), a.distbits = U.bits, x) {
          t.msg = "invalid distances set", a.mode = Oe;
          break;
        }
        if (a.mode = 16199, e === Se) break t;
      case 16199:
        a.mode = 16200;
      case 16200:
        if (o >= 6 && l >= 258) {
          t.next_out = n, t.avail_out = l, t.next_in = r, t.avail_in = o, a.hold = h, a.bits = d, me(t, _), n = t.next_out, s = t.output, l = t.avail_out, r = t.next_in, i = t.input, o = t.avail_in, h = a.hold, d = a.bits, 16191 === a.mode && (a.back = -1);
          break;
        }
        for (a.back = 0; z = a.lencode[h & (1 << a.lenbits) - 1], w = z >>> 24, m = z >>> 16 & 255, p = 65535 & z, !(w <= d);) {
          if (0 === o) break t;
          o--, h += i[r++] << d, d += 8;
        }
        if (m && 0 == (240 & m)) {
          for (b = w, y = m, k = p; z = a.lencode[k + ((h & (1 << b + y) - 1) >> b)], w = z >>> 24, m = z >>> 16 & 255, p = 65535 & z, !(b + w <= d);) {
            if (0 === o) break t;
            o--, h += i[r++] << d, d += 8;
          }
          h >>>= b, d -= b, a.back += b;
        }
        if (h >>>= w, d -= w, a.back += w, a.length = p, 0 === m) {
          a.mode = 16205;
          break;
        }
        if (32 & m) {
          a.back = -1, a.mode = 16191;
          break;
        }
        if (64 & m) {
          t.msg = "invalid literal/length code", a.mode = Oe;
          break;
        }
        a.extra = 15 & m, a.mode = 16201;
      case 16201:
        if (a.extra) {
          for (E = a.extra; d < E;) {
            if (0 === o) break t;
            o--, h += i[r++] << d, d += 8;
          }
          a.length += h & (1 << a.extra) - 1, h >>>= a.extra, d -= a.extra, a.back += a.extra;
        }
        a.was = a.length, a.mode = 16202;
      case 16202:
        for (; z = a.distcode[h & (1 << a.distbits) - 1], w = z >>> 24, m = z >>> 16 & 255, p = 65535 & z, !(w <= d);) {
          if (0 === o) break t;
          o--, h += i[r++] << d, d += 8;
        }
        if (0 == (240 & m)) {
          for (b = w, y = m, k = p; z = a.distcode[k + ((h & (1 << b + y) - 1) >> b)], w = z >>> 24, m = z >>> 16 & 255, p = 65535 & z, !(b + w <= d);) {
            if (0 === o) break t;
            o--, h += i[r++] << d, d += 8;
          }
          h >>>= b, d -= b, a.back += b;
        }
        if (h >>>= w, d -= w, a.back += w, 64 & m) {
          t.msg = "invalid distance code", a.mode = Oe;
          break;
        }
        a.offset = p, a.extra = 15 & m, a.mode = 16203;
      case 16203:
        if (a.extra) {
          for (E = a.extra; d < E;) {
            if (0 === o) break t;
            o--, h += i[r++] << d, d += 8;
          }
          a.offset += h & (1 << a.extra) - 1, h >>>= a.extra, d -= a.extra, a.back += a.extra;
        }
        if (a.offset > a.dmax) {
          t.msg = "invalid distance too far back", a.mode = Oe;
          break;
        }
        a.mode = 16204;
      case 16204:
        if (0 === l) break t;
        if (c = _ - l, a.offset > c) {
          if (c = a.offset - c, c > a.whave && a.sane) {
            t.msg = "invalid distance too far back", a.mode = Oe;
            break;
          }
          c > a.wnext ? (c -= a.wnext, u = a.wsize - c) : u = a.wnext - c, c > a.length && (c = a.length), g = a.window;
        } else g = s, u = n - a.offset, c = a.length;
        c > l && (c = l), l -= c, a.length -= c;
        do {
          s[n++] = g[u++];
        } while (--c);
        0 === a.length && (a.mode = 16200);
        break;
      case 16205:
        if (0 === l) break t;
        s[n++] = a.length, l--, a.mode = 16200;
        break;
      case 16206:
        if (a.wrap) {
          for (; d < 32;) {
            if (0 === o) break t;
            o--, h |= i[r++] << d, d += 8;
          }
          if (_ -= l, t.total_out += _, a.total += _, 4 & a.wrap && _ && (t.adler = a.check = a.flags ? tt(a.check, s, _, n - _) : Q(a.check, s, _, n - _)), _ = l, 4 & a.wrap && (a.flags ? h : Te(h)) !== a.check) {
            t.msg = "incorrect data check", a.mode = Oe;
            break;
          }
          h = 0, d = 0;
        }
        a.mode = 16207;
      case 16207:
        if (a.wrap && a.flags) {
          for (; d < 32;) {
            if (0 === o) break t;
            o--, h += i[r++] << d, d += 8;
          }
          if (4 & a.wrap && h !== (4294967295 & a.total)) {
            t.msg = "incorrect length check", a.mode = Oe;
            break;
          }
          h = 0, d = 0;
        }
        a.mode = 16208;
      case 16208:
        x = Ee;
        break t;
      case Oe:
        x = Ie;
        break t;
      case 16210:
        return De;
      default:
        return Ae;
    }
    return t.next_out = n, t.avail_out = l, t.next_in = r, t.avail_in = o, a.hold = h, a.bits = d, (a.wsize || _ !== t.avail_out && a.mode < Oe && (a.mode < 16206 || e !== xe)) && We(t, t.output, t.next_out, _ - t.avail_out), f -= t.avail_in, _ -= t.avail_out, t.total_in += f, t.total_out += _, a.total += _, 4 & a.wrap && _ && (t.adler = a.check = a.flags ? tt(a.check, s, _, t.next_out - _) : Q(a.check, s, _, t.next_out - _)), t.data_type = a.bits + (a.last ? 64 : 0) + (16191 === a.mode ? 128 : 0) + (16199 === a.mode || 16194 === a.mode ? 256 : 0), (0 === f && 0 === _ || e === xe) && x === Ue && (x = Fe), x;
  },
  inflateEnd: t => {
    if (Ce(t)) return Ae;
    let e = t.state;
    return e.window && (e.window = null), t.state = null, Ue;
  },
  inflateGetHeader: (t, e) => {
    if (Ce(t)) return Ae;
    const a = t.state;
    return 0 == (2 & a.wrap) ? Ae : (a.head = e, e.done = !1, Ue);
  },
  inflateSetDictionary: (t, e) => {
    const a = e.length;
    let i, s, r;
    return Ce(t) ? Ae : (i = t.state, 0 !== i.wrap && 16190 !== i.mode ? Ae : 16190 === i.mode && (s = 1, s = Q(s, e, a, 0), s !== i.check) ? Ie : (r = We(t, e, a, a), r ? (i.mode = 16210, De) : (i.havedict = 1, Ue)));
  },
  inflateInfo: "pako inflate (from Nodeca project)"
};
var Ye = function () {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
};
const qe = Object.prototype.toString,
  {
    Z_NO_FLUSH: Ge,
    Z_FINISH: Xe,
    Z_OK: Qe,
    Z_STREAM_END: Je,
    Z_NEED_DICT: ta,
    Z_STREAM_ERROR: ea,
    Z_DATA_ERROR: aa,
    Z_MEM_ERROR: ia
  } = at;
function sa(t) {
  this.options = Gt({
    chunkSize: 65536,
    windowBits: 15,
    to: ""
  }, t || {});
  const e = this.options;
  e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && 0 == (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new ie(), this.strm.avail_out = 0;
  let a = Ke.inflateInit2(this.strm, e.windowBits);
  if (a !== Qe) throw new Error(et[a]);
  if (this.header = new Ye(), Ke.inflateGetHeader(this.strm, this.header), e.dictionary && ("string" == typeof e.dictionary ? e.dictionary = te(e.dictionary) : "[object ArrayBuffer]" === qe.call(e.dictionary) && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (a = Ke.inflateSetDictionary(this.strm, e.dictionary), a !== Qe))) throw new Error(et[a]);
}
sa.prototype.push = function (t, e) {
  const a = this.strm,
    i = this.options.chunkSize,
    s = this.options.dictionary;
  let r, n, o;
  if (this.ended) return !1;
  for (n = e === ~~e ? e : !0 === e ? Xe : Ge, "[object ArrayBuffer]" === qe.call(t) ? a.input = new Uint8Array(t) : a.input = t, a.next_in = 0, a.avail_in = a.input.length;;) {
    for (0 === a.avail_out && (a.output = new Uint8Array(i), a.next_out = 0, a.avail_out = i), r = Ke.inflate(a, n), r === ta && s && (r = Ke.inflateSetDictionary(a, s), r === Qe ? r = Ke.inflate(a, n) : r === aa && (r = ta)); a.avail_in > 0 && r === Je && a.state.wrap > 0 && 0 !== t[a.next_in];) Ke.inflateReset(a), r = Ke.inflate(a, n);
    switch (r) {
      case ea:
      case aa:
      case ta:
      case ia:
        return this.onEnd(r), this.ended = !0, !1;
    }
    if (o = a.avail_out, a.next_out && (0 === a.avail_out || r === Je)) if ("string" === this.options.to) {
      let t = ae(a.output, a.next_out),
        e = a.next_out - t,
        s = ee(a.output, t);
      a.next_out = e, a.avail_out = i - e, e && a.output.set(a.output.subarray(t, t + e), 0), this.onData(s);
    } else this.onData(a.output.length === a.next_out ? a.output : a.output.subarray(0, a.next_out));
    if (r !== Qe || 0 !== o) {
      if (r === Je) return r = Ke.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, !0;
      if (0 === a.avail_in) break;
    }
  }
  return !0;
}, sa.prototype.onData = function (t) {
  this.chunks.push(t);
}, sa.prototype.onEnd = function (t) {
  t === Qe && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = Xt(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
};
const {
  Deflate: ra,
  deflate: na,
  deflateRaw: oa,
  gzip: la
} = we;
var ha = na;
const da = {
    b: {
      u: DataView.prototype.getInt8,
      p: DataView.prototype.setInt8,
      bytes: 1
    },
    B: {
      u: DataView.prototype.getUint8,
      p: DataView.prototype.setUint8,
      bytes: 1
    },
    h: {
      u: DataView.prototype.getInt16,
      p: DataView.prototype.setInt16,
      bytes: 2
    },
    H: {
      u: DataView.prototype.getUint16,
      p: DataView.prototype.setUint16,
      bytes: 2
    },
    i: {
      u: DataView.prototype.getInt32,
      p: DataView.prototype.setInt32,
      bytes: 4
    },
    I: {
      u: DataView.prototype.getUint32,
      p: DataView.prototype.setUint32,
      bytes: 4
    },
    q: {
      u: DataView.prototype.getInt64,
      p: DataView.prototype.setInt64,
      bytes: 8
    },
    Q: {
      u: DataView.prototype.getUint64,
      p: DataView.prototype.setUint64,
      bytes: 8
    }
  },
  fa = (t, ...e) => {
    let a = 0;
    if (t.replace(/[<>]/, "").length != e.length) throw "Pack format to Argument count mismatch";
    let i = [],
      s = !0;
    for (let i = 0; i < t.length; i++) "<" == t[i] ? s = !0 : ">" == t[i] ? s = !1 : (r(t[i], e[a]), a++);
    function r(t, e) {
      if (!(t in da)) throw "Unhandled character '" + t + "' in pack format";
      let a = da[t].bytes,
        r = new DataView(new ArrayBuffer(a));
      da[t].p.bind(r)(0, e, s);
      for (let t = 0; t < a; t++) i.push(r.getUint8(t));
    }
    return i;
  },
  _a = (t, e) => {
    let a = 0,
      i = [],
      s = !0;
    for (let e of t) "<" == e ? s = !0 : ">" == e ? s = !1 : r(e);
    function r(t) {
      if (!(t in da)) throw "Unhandled character '" + t + "' in unpack format";
      let r = da[t].bytes,
        n = new DataView(new ArrayBuffer(r));
      for (let t = 0; t < r; t++) n.setUint8(t, 255 & e[a + t]);
      let o = da[t].u.bind(n);
      i.push(o(0, s)), a += r;
    }
    return i;
  };
class ca extends EventTarget {
  constructor(t, e, a) {
    super(), this.port = t, this.logger = e, this._parent = a, this.chipName = null, this._efuses = new Array(4).fill(0), this._flashsize = 4194304, this.debug = !1, this.IS_STUB = !1, this.connected = !0, this.flashSize = null;
  }
  get _inputBuffer() {
    return this._parent ? this._parent._inputBuffer : this.__inputBuffer;
  }
  async initialize() {
    await this.hardReset(!0), this._parent || (this.__inputBuffer = [], this.readLoop()), await this.sync();
    let t = await this.readRegister(1073745920),
      e = c[t >>> 0];
    if (void 0 === e) throw new Error(`Unknown Chip: Hex: ${a(t >>> 0, 8).toLowerCase()} Number: ${t}`);
    this.chipName = e.name, this.chipFamily = e.family;
    let i = g(this.getChipFamily()).macFuse;
    for (let t = 0; t < 4; t++) this._efuses[t] = await this.readRegister(i + 4 * t);
    this.logger.log(`Chip type ${this.chipName}`);
  }
  async readLoop() {
    this.debug && this.logger.debug("Starting read loop"), this._reader = this.port.readable.getReader();
    try {
      for (;;) {
        const {
          value: t,
          done: e
        } = await this._reader.read();
        if (e) {
          this._reader.releaseLock();
          break;
        }
        t && 0 !== t.length && this._inputBuffer.push(...Array.from(t));
      }
    } catch (t) {
      console.error("Read loop got disconnected");
    }
    this.connected = !1, this.dispatchEvent(new Event("disconnect")), this.logger.debug("Finished read loop");
  }
  async hardReset(t = !1) {
    this.logger.log("Try hard reset."), await this.port.setSignals({
      dataTerminalReady: !1,
      requestToSend: !0
    }), await this.port.setSignals({
      dataTerminalReady: t,
      requestToSend: !1
    }), await new Promise(t => setTimeout(t, 1e3));
  }
  macAddr() {
    let t,
      e = new Array(6).fill(0),
      a = this._efuses[0],
      i = this._efuses[1],
      s = this._efuses[2],
      r = this._efuses[3];
    if (33382 == this.chipFamily) {
      if (0 != r) t = [r >> 16 & 255, r >> 8 & 255, 255 & r];else if (0 == (i >> 16 & 255)) t = [24, 254, 52];else {
        if (1 != (i >> 16 & 255)) throw new Error("Couldnt determine OUI");
        t = [172, 208, 116];
      }
      e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = i >> 8 & 255, e[4] = 255 & i, e[5] = a >> 24 & 255;
    } else if (this.chipFamily == o) e[0] = s >> 8 & 255, e[1] = 255 & s, e[2] = i >> 24 & 255, e[3] = i >> 16 & 255, e[4] = i >> 8 & 255, e[5] = 255 & i;else {
      if (this.chipFamily != l && this.chipFamily != h && this.chipFamily != d) throw new Error("Unknown chip family");
      e[0] = i >> 8 & 255, e[1] = 255 & i, e[2] = a >> 24 & 255, e[3] = a >> 16 & 255, e[4] = a >> 8 & 255, e[5] = 255 & a;
    }
    return e;
  }
  async readRegister(t) {
    this.debug && this.logger.debug("Reading from Register " + a(t, 8));
    let e = fa("<I", t);
    await this.sendCommand(10, e);
    let [i, s] = await this.getResponse(10);
    return i;
  }
  async checkCommand(t, e, i = 0, s = 3e3) {
    s = Math.min(s, 12e5), await this.sendCommand(t, e, i);
    let [r, n] = await this.getResponse(t, s);
    if (null === n) throw new Error("Didn't get enough status bytes");
    let f = 0;
    if (this.IS_STUB || 33382 == this.chipFamily ? f = 2 : [o, l, h, d].includes(this.chipFamily) ? f = 4 : [2, 4].includes(n.length) && (f = n.length), n.length < f) throw new Error("Didn't get enough status bytes");
    let _ = n.slice(-f, n.length);
    if (n = n.slice(0, -f), this.debug && (this.logger.debug("status", _), this.logger.debug("value", r), this.logger.debug("data", n)), 1 == _[0]) throw 5 == _[1] ? new Error("Invalid (unsupported) command " + a(t)) : new Error("Command failure error code " + a(_[1]));
    return [r, n];
  }
  async sendCommand(t, e, a = 0) {
    let i = (t => {
      let e = [192];
      for (let a of t) 219 == a ? e = e.concat([219, 221]) : 192 == a ? e = e.concat([219, 220]) : e.push(a);
      return e.push(192), e;
    })([...fa("<BBHI", 0, t, e.length, a), ...e]);
    this.debug && this.logger.debug(`Writing ${i.length} byte${1 == i.length ? "" : "s"}:`, i), await this.writeToStream(i);
  }
  async readPacket(t) {
    let s = null,
      r = !1,
      n = [];
    for (;;) {
      let o = Date.now();
      for (n = []; Date.now() - o < t;) {
        if (this._inputBuffer.length > 0) {
          n.push(this._inputBuffer.shift());
          break;
        }
        await i(10);
      }
      if (0 == n.length) {
        throw new w("Timed out waiting for packet " + (null === s ? "header" : "content"));
      }
      this.debug && this.logger.debug("Read " + n.length + " bytes: " + e(n));
      for (let t of n) if (null === s) {
        if (192 != t) throw this.debug && (this.logger.debug("Read invalid data: " + e(n)), this.logger.debug("Remaining data in serial buffer: " + e(this._inputBuffer))), new w("Invalid head of packet (" + a(t) + ")");
        s = [];
      } else if (r) {
        if (r = !1, 220 == t) s.push(192);else {
          if (221 != t) throw this.debug && (this.logger.debug("Read invalid data: " + e(n)), this.logger.debug("Remaining data in serial buffer: " + e(this._inputBuffer))), new w("Invalid SLIP escape (0xdb, " + a(t) + ")");
          s.push(219);
        }
      } else if (219 == t) r = !0;else {
        if (192 == t) return this.debug && this.logger.debug("Received full packet: " + e(s)), s;
        s.push(t);
      }
    }
    throw new w("Invalid state");
  }
  async getResponse(t, e = 3e3) {
    for (let i = 0; i < 100; i++) {
      const i = await this.readPacket(e);
      if (i.length < 8) continue;
      const [s, r, n, o] = _a("<BBHI", i.slice(0, 8));
      if (1 != s) continue;
      const l = i.slice(8);
      if (null == t || r == t) return [o, l];
      if (0 != l[0] && 5 == l[1]) throw this._inputBuffer.length = 0, new Error(`Invalid (unsupported) command ${a(t)}`);
    }
    throw "Response doesn't match request";
  }
  checksum(t, e = 239) {
    for (let a of t) e ^= a;
    return e;
  }
  async setBaudrate(t) {
    if (33382 == this.chipFamily) throw new Error("Changing baud rate is not supported on the ESP8266");
    this.logger.log("Attempting to change baud rate to " + t + "...");
    try {
      let e = fa("<II", t, this.IS_STUB ? 115200 : 0);
      await this.checkCommand(15, e);
    } catch (e) {
      throw console.error(e), new Error(`Unable to change the baud rate to ${t}: No response from set baud rate command.`);
    }
    this._parent ? await this._parent.reconfigurePort(t) : await this.reconfigurePort(t);
  }
  async reconfigurePort(t) {
    var e;
    try {
      await (null === (e = this._reader) || void 0 === e ? void 0 : e.cancel()), await this.port.close(), await this.port.open({
        baudRate: t
      }), this.readLoop(), this.logger.log(`Changed baud rate to ${t}`);
    } catch (e) {
      throw console.error(e), new Error(`Unable to change the baud rate to ${t}: ${e}`);
    }
  }
  async sync() {
    for (let t = 0; t < 5; t++) {
      if (this._inputBuffer.length = 0, await this._sync()) return await i(100), !0;
      await i(100);
    }
    throw new Error("Couldn't sync to ESP. Try resetting.");
  }
  async _sync() {
    await this.sendCommand(8, r);
    for (let t = 0; t < 8; t++) try {
      let [t, e] = await this.getResponse(8, 100);
      if (e.length > 1 && 0 == e[0] && 0 == e[1]) return !0;
    } catch (t) {}
    return !1;
  }
  getFlashWriteSize() {
    return this.IS_STUB ? 16384 : 1024;
  }
  async flashData(t, e, i = 0, s = !1) {
    if (t.byteLength >= 8) {
      var r = Array.from(new Uint8Array(t, 0, 4));
      let e = r[0],
        i = r[2],
        s = r[3];
      this.logger.log(`Image header, Magic=${a(e)}, FlashMode=${a(i)}, FlashSizeFreq=${a(s)}`);
    }
    let n,
      o = t.byteLength,
      l = 0,
      h = 3e3;
    s ? (n = ha(new Uint8Array(t), {
      level: 9
    }).buffer, l = n.byteLength, this.logger.log(`Writing data with filesize: ${o}. Compressed Size: ${l}`), h = await this.flashDeflBegin(o, l, i)) : (this.logger.log(`Writing data with filesize: ${o}`), n = t, await this.flashBegin(o, i));
    let d = [],
      f = 0,
      _ = 0,
      c = 0,
      u = Date.now(),
      g = this.getFlashWriteSize(),
      w = s ? l : o;
    for (; w - c > 0;) this.debug && this.logger.log(`Writing at ${a(i + f * g, 8)} `), w - c >= g ? d = Array.from(new Uint8Array(n, c, g)) : (d = Array.from(new Uint8Array(n, c, w - c)), s || (d = d.concat(new Array(g - d.length).fill(255)))), s ? await this.flashDeflBlock(d, f, h) : await this.flashBlock(d, f), f += 1, _ += s ? Math.round(d.length * o / l) : d.length, c += g, e(Math.min(_, o), o);
    this.logger.log("Took " + (Date.now() - u) + "ms to write " + w + " bytes"), this.IS_STUB && (await this.flashBegin(0, 0), s ? await this.flashDeflFinish() : await this.flashFinish());
  }
  async flashBlock(t, e, a = 3e3) {
    await this.checkCommand(3, fa("<IIII", t.length, e, 0, 0).concat(t), this.checksum(t), a);
  }
  async flashDeflBlock(t, e, a = 3e3) {
    await this.checkCommand(17, fa("<IIII", t.length, e, 0, 0).concat(t), this.checksum(t), a);
  }
  async flashBegin(t = 0, e = 0, i = !1) {
    let s,
      r,
      n = this.getFlashWriteSize();
    !this.IS_STUB && [o, l, h, d].includes(this.chipFamily) && (await this.checkCommand(13, new Array(8).fill(0)));
    let f,
      _ = Math.floor((t + n - 1) / n);
    s = 33382 == this.chipFamily ? this.getEraseSize(e, t) : t, f = this.IS_STUB ? 3e3 : u(3e4, t);
    let c = Date.now();
    return r = fa("<IIII", s, _, n, e), this.chipFamily != o && this.chipFamily != l && this.chipFamily != h && this.chipFamily != d || (r = r.concat(fa("<I", i ? 1 : 0))), this.logger.log("Erase size " + s + ", blocks " + _ + ", block size " + a(n, 4) + ", offset " + a(e, 4) + ", encrypted " + (i ? "yes" : "no")), await this.checkCommand(2, r, 0, f), 0 == t || this.IS_STUB || this.logger.log("Took " + (Date.now() - c) + "ms to erase " + _ + " bytes"), _;
  }
  async flashDeflBegin(t = 0, e = 0, a = 0, i = !1) {
    let s,
      r = this.getFlashWriteSize(),
      n = Math.floor((e + r - 1) / r),
      o = Math.floor((t + r - 1) / r),
      l = 0,
      h = 0;
    return this.IS_STUB ? (l = t, h = u(3e4, l)) : (l = o * r, h = 3e3), s = fa("<IIII", l, n, r, a), await this.checkCommand(16, s, 0, h), h;
  }
  async flashFinish() {
    let t = fa("<I", 1);
    await this.checkCommand(4, t);
  }
  async flashDeflFinish() {
    let t = fa("<I", 1);
    await this.checkCommand(18, t);
  }
  getBootloaderOffset() {
    return g(this.getChipFamily()).flashOffs;
  }
  async flashId() {
    return await this.runSpiFlashCommand(159, [], 24);
  }
  getChipFamily() {
    return this._parent ? this._parent.chipFamily : this.chipFamily;
  }
  async writeRegister(t, e, a = 4294967295, i = 0, s = 0) {
    let r = fa("<IIII", t, e, a, i);
    s > 0 && r.concat(fa("<IIII", g(this.getChipFamily()).uartDateReg, 0, 0, s)), await this.checkCommand(9, r);
  }
  async setDataLengths(t, e, a) {
    if (-1 != t.mosiDlenOffs) {
      let i = t.regBase + t.mosiDlenOffs,
        s = t.regBase + t.misoDlenOffs;
      e > 0 && (await this.writeRegister(i, e - 1)), a > 0 && (await this.writeRegister(s, a - 1));
    } else {
      let i = t.regBase + t.usr1Offs,
        s = (0 == a ? 0 : a - 1) << 8 | (0 == e ? 0 : e - 1) << 17;
      await this.writeRegister(i, s);
    }
  }
  async waitDone(t, e) {
    for (let a = 0; a < 10; a++) {
      if (0 == ((await this.readRegister(t)) & e)) return;
    }
    throw Error("SPI command did not complete in time");
  }
  async runSpiFlashCommand(t, e, i = 0) {
    let s = g(this.getChipFamily()),
      r = s.regBase,
      n = r,
      o = r + s.usrOffs,
      l = r + s.usr2Offs,
      h = r + s.w0Offs,
      d = 1 << 18;
    if (i > 32) throw new Error("Reading more than 32 bits back from a SPI flash operation is unsupported");
    if (e.length > 64) throw new Error("Writing more than 64 bytes of data with one SPI command is unsupported");
    let f = 8 * e.length,
      _ = await this.readRegister(o),
      c = await this.readRegister(l),
      u = 1 << 31;
    if (i > 0 && (u |= 268435456), f > 0 && (u |= 134217728), await this.setDataLengths(s, f, i), await this.writeRegister(o, u), await this.writeRegister(l, 7 << 28 | t), 0 == f) await this.writeRegister(h, 0);else {
      e.concat(new Array(e.length % 4).fill(0));
      let t = _a("I".repeat(Math.floor(e.length / 4)), e),
        i = h;
      this.logger.debug(`Words Length: ${t.length}`);
      for (const e of t) this.logger.debug(`Writing word ${a(e)} to register offset ${a(i)}`), await this.writeRegister(i, e), i += 4;
    }
    await this.writeRegister(n, d), await this.waitDone(n, d);
    let w = await this.readRegister(h);
    return await this.writeRegister(o, _), await this.writeRegister(l, c), w;
  }
  async detectFlashSize() {
    this.logger.log("Detecting Flash Size");
    let t = await this.flashId(),
      e = 255 & t,
      i = t >> 16 & 255;
    this.logger.log(`FlashId: ${a(t)}`), this.logger.log(`Flash Manufacturer: ${e.toString(16)}`), this.logger.log(`Flash Device: ${(t >> 8 & 255).toString(16)}${i.toString(16)}`), this.flashSize = s[i], this.logger.log(`Auto-detected Flash size: ${this.flashSize}`);
  }
  getEraseSize(t, e) {
    let a = 4096,
      i = Math.floor((e + a - 1) / a),
      s = 16 - Math.floor(t / a) % 16;
    return i < s && (s = i), i < 2 * s ? Math.floor((i + 1) / 2 * a) : (i - s) * a;
  }
  async memBegin(t, e, a, i) {
    return await this.checkCommand(5, fa("<IIII", t, e, a, i));
  }
  async memBlock(t, e) {
    return await this.checkCommand(7, fa("<IIII", t.length, e, 0, 0).concat(t), this.checksum(t));
  }
  async memFinish(t = 0) {
    let e = this.IS_STUB ? 3e3 : 500,
      a = fa("<II", 0 == t ? 1 : 0, t);
    return await this.checkCommand(6, a, 0, e);
  }
  async runStub() {
    const t = await m(this.chipFamily);
    let e,
      a = 2048;
    this.logger.log("Uploading stub...");
    for (let e of ["text", "data"]) if (Object.keys(t).includes(e)) {
      let i = t[e + "_start"],
        s = t[e].length,
        r = Math.floor((s + a - 1) / a);
      await this.memBegin(s, r, a, i);
      for (let i of Array(r).keys()) {
        let r = i * a,
          n = r + a;
        n > s && (n = s), await this.memBlock(t[e].slice(r, n), i);
      }
    }
    this.logger.log("Running stub..."), await this.memFinish(t.entry);
    const i = await this.readPacket(500);
    if (e = String.fromCharCode(...i), "OHAI" != e) throw new Error("Failed to start stub. Unexpected response: " + e);
    this.logger.log("Stub is now running...");
    const s = new ua(this.port, this.logger, this);
    return await s.detectFlashSize(), s;
  }
  async writeToStream(t) {
    const e = this.port.writable.getWriter();
    await e.write(new Uint8Array(t));
    try {
      e.releaseLock();
    } catch (t) {
      console.error("Ignoring release lock error", t);
    }
  }
  async disconnect() {
    this._parent ? await this._parent.disconnect() : (await this.port.writable.getWriter().close(), await new Promise(t => {
      this._reader || t(void 0), this.addEventListener("disconnect", t, {
        once: !0
      }), this._reader.cancel();
    }), this.connected = !1);
  }
}
exports.ESPLoader = ca;
class ua extends ca {
  constructor() {
    super(...arguments), this.IS_STUB = !0;
  }
  async memBegin(t, e, i, s) {
    let r = await m(this.chipFamily),
      n = s,
      o = s + t;
    console.log(n, o), console.log(r.data_start, r.data.length, r.text_start, r.text.length);
    for (let [t, e] of [[r.data_start, r.data_start + r.data.length], [r.text_start, r.text_start + r.text.length]]) if (n < e && o > t) throw new Error("Software loader is resident at " + a(t, 8) + "-" + a(e, 8) + ". Can't load binary at overlapping address range " + a(n, 8) + "-" + a(o, 8) + ". Try changing the binary loading address.");
  }
  async eraseFlash() {
    await this.checkCommand(208, [], 0, 6e5);
  }
}
const ga = async t => {
  const e = await navigator.serial.requestPort({
    filters: [{
      usbProductId: 29987,
      usbVendorId: 6790
    }]
  });
  return t.log("Connecting..."), await e.open({
    baudRate: 115200
  }), t.log("Connected successfully."), new ca(e, t);
};
exports.connect = ga;

},{}],64:[function(require,module,exports){
const wheel = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAOpJREFUOI1jZMAN/qPxGbEpwirIwMDwf5uJE4qA15l9WNVjMwBDMz5D0A3AqRmXIcgGENSMzRAmonTgASzoAp7LvsLZ26O4GRgYGBjUfHzgYre2bEFRj+KCyKxPqIad3svgeXoviliWcjhWA/7zzzNhYGBgYBA48henc12uQ1ykED6TgQGaThiRNSODD4mnUfiKEbMw1DxYmY4ZBjBQduwiTpcgA4pjAZYOsHojTX0OAwMDA8PqSScx5B6sTGdgYGBghLmA8WPSGaJthWlGdgEMoLgEZig01DE0YzOAgQE1GzPiEWNgYGBgAABEAkFa5rPi7QAAAABJRU5ErkJggg==";

const background = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAADwCAYAAAApd3lbAAAABGdBTUEAALGOfPtRkwAAIABJREFUeJztnXtwHdWd579XupJ99bQsS1eWZEu2JD8wNhhssME2dogrBONJPCSBZajMTCapzWZr89hMUsmQ2qK2wk5qsqnAzO6ErU2Y2VmWdcIwhLHBEF4GFBuQF2MTPyXZkq3X1cN6S7ae+8e5p/t09+l39+2+uudTpdK9/Tjd95zzO7/XOd2RrzfNz0MgECxosoK+AYFA4D9Rvwq+sxrYnzcjfT80EcUHHX5dTSAQGBHxw3T/8ZoZ3X0/uujb2CIQCHTw3HS/s9rdfoFA4D2eqVcqwKy5zmN/3gw+8M9jEAgEHDyROCNTXSAQBI9r092uKX5oIirMd4EgxbgWdDNTneXQhGxACGEXCFJHSp1lzaBQLVJuAkEqcK3RWS1tl/15M7izWmh3gcBvXAu6W41Mtbxa4IXwCwTe4dmEGfVMOCtQa0CY7wKBv3jmo3/QAZEfFwhCiljUIhBkAELQBYIMQAi6QJABCEEXCDIAET0TcBHPE1hY+LIeXZDeiOcJLDyE6S5QIJ4nsDARw7MAgHiewEJHtJhAPE8gAxCme4YjnieQGQhBz3DE8wQyA2G6CywjnieQvgiNnuGI5wlkBkLQMxzxPIHMQEyYEQAQzxNY6AgfXQBAPE9goSNMd4EgAxCCLhBkAELQBYIMQAi6QJABCEEXCDIAIegCQQYg8ikCTxBPpAk3QtAFttCbWHNoIiqePhNiRMsIuAiBXliIFstwhEBnBqIlMwQh0JmNaOEFhhBoAQ/R8mmKEGiBHUSPCDlCoAVeIHpKiOA9clkItMALRA8KmDur5Qc3SP9Fswg8RkyBDRgxe0yQCoSgCwQZgBB0gSADEIIuEGQAQtAFggxACLpAkAGIPI4gZbCTf8R69dQiXuAgSAl6r2YWk4FSgzDdBb5j9Hom8W721CCGU4FvWH3NEzs7UOAPQqMLfMHJu9wE/iEEXeALVoWcvqhRvH3VX4SgCzzHjtDuz5tRvHpZ4A/CRxd4jhOTXTqnWqTd/ECk1wSe4aVfLvLs3iIEXeAJfqXJRJ7dG4SPLnCNn761yLN7gxguBY5JVQpN5NndIzS6wBEiT55eCEEXOCJVQi7y7N4gBF1gm1QKncize4Pw0QW2CcJkF3l2dwhBT3MybY33/rwZoFrZbRf6b/YCIehpjDr1RIVgoXd89QsuRFTeHOGjpyl6+eVMi4RTH17478YIQU9DzDq1352eRsLDhBB2Y4SgpyFGWjsVQhhmM/nOavmP3ZbpiLnuaYjVaaF+B+fCNGmGHeDCPBAFhRD0NMSOgFEBCLvAH5qIWiqDPS4Vv22hIAQ9TTETrqBSbbxXP5uhdjf0zhWC7Rwh6AJBBiCCcQJBBiAEXSDIAISgCwQZgBB0gSADEIIuEGQAQtAFggxACLpAkAEIQRcIMgAh6AJBBiAEXSDIAISgCwQZgBB0gSADEIIuEGQAQtAFggxACLpAkAEIQRcIMgAh6AJBBiAEXSDIAISgCwQZgKuHgGfae7+8Juj6C/r66U461Z/jh0PqPVv8RxfD9xaPMBJ0/QV9/XQn3erPkelu9OYLqy8XyGSCrr+gr5/upGP92Rp+rD6oX7zdkk/Q9Rf09dOddK4/yxo9TK/fSUeCrr+gr5/upHv9WRZ0u68AEi+2UxJ0/QV9/XQn3evPkqDbuWn6vmq75y1kgq6/oK+f7iyE+rPkozsxWaRzqsOddkgFQddf0NdPdxZC/Rmm17z0S/zIM4Y9jxl0/QV9fTNE+7nDTv3pCrpfaQKv8oxhz2MGXX9BX98M0X7usFt/XB/dT9/CiwoMex4z6PoL+vpmiPZzh5P6U4h/qlIITvOMYc9jBl1/QV/fynmi/YKpvyx2Z5jzhOL+wn19M8T9ucPt/UmCnqof6TTPGPY8ZtD1F/T1zRDtRwiq/rKcXNQNTvKMYc9jBl1/QV/fDNF+MkHVX5TuTDV28oxhz2MGXX9BX1+0n4trpqj+Iv3D046WqfqBOhfotd9kVH7QeeqFgGg/d/hZf6ESdAr1M/xqBKPyg85TLwRE+7nDj/oLpaAHjVlnCZsmECgR7aclHNOQQkbQeWqBO0T7aREPh7RIJneShUCmt58QdBVB56kF7hDtx0cIuoqg89QCd4j24yOCcSYcmggmTy3wBtF+BCHoKeZSH7C6LOi7EIQVv/qHMN0FggxACHoAXOoL+g4EYcaP/iEE3WeuDgrBFuiTqv7h2kenPsXVQWA6GfMQPiiQGOHPRZqbB7Ii5HO8aOEHiUT/4JPq/uF6Zlx+bhSJYSA3C8jNJdsSw/rHx4sXfuc2gjZikKQyICj6hz386h/CdBcIMgBfBX1+bs7P4kPN+I0ZzM1D8xcWwhA3EP0jdf3DtenONlYki4wb41MzyM+Nco/JFPIXhWe9EPWPg/CNRf/gk+r+4fpqtPFYcnOyDY7xt1HDEvwZvzGDWK62elPpo3cPk+tHs4BoLtCd9I0XReeRlRVB9zCw3GefWPQPPqnuH64FfXp+HlPTs8jNyUZORHuX41MzUsNG9V8K4xmx3Ci6h+XODcgdnIdfHT1MGl1Nlk5v8iNIJ/oHn1T3D9s++lMv9/hxH4IFgugf4STrUh8Zydk/M8wac2p61qPbs89sZF76o0xOzUj79I5RE4ZgVSqhv5fXH0T/0JJu/cNUo//qzRExSgt0Ef0jPYjmRLM5m2fx+1biQ6yrXQpgKX7fSvZsWlWN3EXA71uBu+tmkBOJIEcVVGCDLWx0FZEI2GCLkU9oNVKsLiN7XusHqoM/vGP0eOrlHnxrXwV+9eYIxq5PAAC+ta/C9D7CEIybZPxflmyOr8zvB3qI/kFJl/4RjSZLnk0GQsziIbmLlN+dBlsSw9nIz9WfJUVnUiWGgXix0tSjlctjlrkfXodWdH6VPcNGYimb68rw7vlZNFTlA8gHALx7nm96dgwAu9aRsr0ItrgNjvE6khG0umi9zc7PKz4D2v7xflMLtm2tl76L/hHO/pE1MzePmbl5zM8rG/HE+Q6MXIfmT01OJIL83KiiEVkfjO7LiUS4qRanPPVyD9dPyo5EEMuNKhqRvR+6LzsSkUbuzsFsdA5mIwvZWBSV/zoHjbXc3PCI7r4gJsyo62Nyagaz8/OaPz1oH2D7xMzcPJ470qLbPwDRP/QIU/+ITs8oRx9qwm1ZZ+35O27SJ7MWflh2BJJZ9Md3VSn25eXSipZ/g9MR+8YMfxRmGyuruAgAcLK1D5vryrjHACUAgkmvqUd3uxpd3Rd4+9j+8X5TCwCgaLFWs0vnif4Riv6he7UT5zuwplYr7EWLfb0fBRe6SEOsXk78wJZusn1F6TKUFC3GuU5gfZW/apI2HktVaRysL8k7xi+s+oRe8M4xEmRbGluMF99sAwB86TN1AEj/oLCaXfSPcPYPnWCcdY3uJtiS7TDwUKLTm556uQdf2lGt0WTs/Sj2qfoAHeVZ37R3aB6dAwlUlcZRvkQ7a+tka1+yYYFlkSHQEdtpsIXnB7I0rKvGK63A8mQQDABeadU/flOptqPzNBlgLyBH+8f7TS2ScPOaRfSPcPQP1xrdz5lPpy93SJXEUlqUI31m/Zpv7atAxxDfNHvlxDWMXZ/A/jsqNKbZHGaREwXm52cxkyyP/i9fMofyJWVgO2DnQCK5DUkTje6TR267plnXELmn7AiQncNut17GyBhQVKDcpifUulyTj//0zZzB/hpw9VoUK5NfVybN9ZVb69E1PIPKYvK7ryT3i/5Rhshlarpn4flnlaPyrj9aa+m3uu0fulF3nkbvOn4BRduVN8YbsaemZ6VtRiP2+BTxe2jF0gagnzetMrcq6AhoNZd76EMyqgOQRuwsZOPGzKxiZKekasTOigDvHbqI7Q+sMbz/kTH5MxXq5vMdaGDaiz1mVkej/6axQ66HJJGIRokZ0jVMVAsVbh6Z2j8SJ9pQ1rAUJ1v7cFtWTPd66gCcX/0jOpO80r8c61QEM/Q0uho3I3Z+rrLicpjvObnZlkZsSmFegWabHlLkmQm2LIpmc3s5b8RmfTAjjX7wvQ48vJNfh4ebiAah/vV7hy4CAKKqKvx1Yyce2iG3i1pjy/cD7jF2NLofU80ztX/MD14CkOwfl8e0JybRE2x1/6A47R/R+qlBAMD3t+QByc9IJL/jmvKMvWUAruGtsaW6N664iWNd2H+HcaDo3UMXsWs/f5SyMmKzFMVIHjO/kDT0+Oi04jMAjEyO2yqzdyjLkUa/cG4am5fFceHcNLfchoJCoKAQ734wj113WhfGib5p6X7yyrQduvm83PlnYjnAMnkfNU+9wkiTW8FK/zAirP3jT1aNAqto1H0cKGHbV5UamVTJWJJv3AwAeUCCmP01AGr2lgHXB9G+uET3fvT6RzS73YYTSCk1FnS1iXP8sLnJAQAHGzvxMDM62RmxAbmRRibZbaaXBQDJNFMHW5z66HbZuX8N3jt0ETPzpL5GlpdJQjkP+Z7yynLQUKbs4J0DCWlbA8flOn6OhMVL8vNQkp+n2U4gZvjlNusvGf8SJ51mBZ4JbIV06R+OZMoGL4+S/1b7x3zLJURna5YoNma3D0G9TYO+JWKLd5PmKv38sEqz2x2xRyfMb8zMhPtNYwcevFvuTE41OgCM3DDvRUWLiP92sZN0nCMnRrEEwNx8FDeXl2qOd6rRrw70m94LZeuaVYrvTRcva7YFASvkQHj7h5n8GMmYFfmb+4RYUnb6h+usvTrYcpgxD2/LiqHzxDAqSpfh+GEi1F98lORhDzZ2ojJ5DvuZxe6IbdUPk/zWpM/FRlUBZXTVqY8OyEKsJnKNmGM9A/2YBPB8MxC/jQQ5l/R0S8fl9pN6bLxwRdqWv32tZsRm60it0dmZcFWlceQX5ihMVkBpwt7MyUytcqi5AeP+AegH46j2PnxiEGPXJzRCDoS3f/jN2upFuNBxQ/o+Pz+PrOR/VqMXXhwg/0uXIfrs62Se4KN7tZNmdU0QxnSnwZaz50jjxXOiiOckO/y41j89/C45rq6wCCgswuSVbtQVFmFycBxvfUgmNu/cWmw5qupk2qA62PK7j4jg0Q4YicimpdOou10SH10g97YhjuwzCSLwpcs0x9nV6NnLIhgcn0DB4jwMj49iOOmCDqtcUfr95lpr8RerGPYPAE2n+NNE6wqL0HRqVDqe9g0g/P1DT254mtqJ/HXlZCFnMbm5yclpzEEendn+UcicY6jR/9fFadStkdNprRcv4E/XKDsXHbFjsRz8oXcA39igV/laMwMAsLJI+t/WNY3ayhxgCLhWIkdVRxMJ6fBrk8oJ1eur6qTPVoMt2ZEI3r4KjPfQTkaqoTg5g4ldhuzGRz/ZT+67qjSOL2xjAzLFqv8qNis1z7WuUiytnGG+y3X8/qSxjz47P4+S/DxcHejnaj81v0lOa2VZGpEnjbf0KNNUX3/ggGF56v5h5R7UlGTPAJCVRk7EetSdjWqnqn8AfNl5tMb6b9Yr40/X5KBy0RJgETA9PolYLEcRif9cRQ5QkewDFbLMReWCtNG/R5NRdsoLx8/i0Zp7FD46HbEBvs9gRFsXqdzaSq1mevZIK27bREzG0YRmNxezYMtgoh8l8WXJETsimUBqU4id1+zGR9+8zH6nNuJaV1Qh8Dyaz3egcnAckfrVkkYHyLRQds63EVvXrMJr7/0rPrPzjwAArc3On7LA9o/elibcXH6f47IodA68XR+9va0dJfFlpsE4t/1jtmZJUqhl2dlew19mZkf+tteUkRYcUB43MSXfT6mO7tbV6Gqz4TvHT8nbdaLuf+gdwK4ye5VvhN6IrYeVYAvLpf4bKCydQ9fkpGQKTatWYLnx0dlg3LUu5xH5tg5gaaX8X43aRx8/fkFj1lsJxlUOjuNLzISoVcXERDWYYWubP/QOmB+kQk+B2PHRBxPk95v1EdaPd9o/jKLupoFuC2Wc7JtAVWkcJdnEdAf4MQkWXUFnzYbWixd0C5CDLfx8sRE8TU7ZcIscACoolgeP5arjPu4C0BVFZcUSABYrMWnq5C4pkpondwkwNTSCnMVQTI8089Ffe+0VbL7zAQBajc4G48w0sTGkmSzMX8L4cdJWE33TmG+5hFkmrWkWjBsbJOcuxhi+/cBeUNPtgS0bmSuwnwHWvFvNeCJrAPS1AotA/jYtBTY9sBcAcOJ6gWFAUPN9Qql2afs58dGtBORo27vpH41YDYDIDitHVs13tfzRzztwCZuTv3t6fAaxWA5iuVE55aczDcBy1P3B7QfwwvEXAQCvHH4R9z9wAE+9LftrddlFqCsswm8b9QcFNZ/foT/Pt8vgyZxuudDTgTIDy+OFk53S583Ly3DygyZsrrtf2sb66ACYBi6S6mRzHt8SoXOdb129Gg13RUy/s+gNFqyPTskry8F4C/ktBXN5hsG4NVPzwCBQULoM7x+/gBVVzvLcVpnNLsdiALMDsgAbfZ8EMHpDFqKDHyXbZ0I7KxBQavTnk21ZEl8maXXqwunxm4/s9Y9UR93V/OYjee5DZSdf0qNUW6t9CNY/IPuu4YXjSdPjODkmXiCPjjGQYEsloAggAMoRySqVOnEqgAwCevuN9lGGsgswBzJCF0Rj0og8BWKaxYsLkBgbQ7ygAL1DxGTrHcrSaPTX32+U9p384DD2btsh18mcMhhHoelFq9/VXOuKgs5p6eFYtF0l+agcHMdEH7Gw4gUFyJ1dbByMm1JGvutWGs9Wa73So3uM0T5KR98iw/1q1MG4SIy0jxWNTtuDWuxFsXwMoh/Ly5foBuPiBfb6B89H366SHfmzEjvyBwCzWIKTJzoUpjsrh8A4V/6ivLD+00fJxdkI68+33wIA+MuD70jbJi+d0xz3jc9po7Aby+0JearIXVKEKQBlBdWYAoChSeQweWT6++orKnDyg8MAgM985n7NemPawFnFRcCorJV4wTg3Gl2PqtI4YhdGEAMQjxQBS4uAa5PA0uVAHwBMoSSS3MZhhvHxli1VO0fe097WjlvrtHlxu+j56DRLw2ZoqAZvb2sHAHT3DiEyMobRBP84gN8/Rvp7UVgsH+PWR+fJn1kZm1cRt4Ca7mOQA4U8K3lj+VrjPDoLDcb9fPst+M7xU3jl8Iuor/DngQcA33Tnaeozp0g6iPXpjcoAgNHJMZTF9P35xJi1oN7ebTvw+vuNktafGx5BYoJUemVevmpmHJl66lajE/M96bODpNcAoP9at94ptmm9wjfdeZr6ycOvA0DSp1eXo79izE5QjgbjLnT1Ym1ludQ+ehqdl6WhZnu0cDFmRq9jMNGPpTH+uvXEGL9/DHT0Svvp/+hsvisfXU/+jHx03v1KlPH7teSj34gno8LxIvz5HSu5BwPABIAnVPtbLgH1q+m3GbQw93LymH7M1shHH2xrQU2p3LHaB3pQyRFmI3hllNTWG5pm+5ZnQQrqrWQrjQahprGetsmyGDY8sBfADdzzwF60XunBI0lhONfPnxnnh0bvHEhgk6eauBeHTn+CHbfskLY0nmrEt01McjW8MvZvIvVYVRpHe1s7btpI2tROMI6aqqxGL8+Vl5rVrSB1oTtkqqqqcGAS5aVyW/UORIHupPAULpL6h/r6AFBeOIfR9qsYHbuK0XZi3b4GACCK8dbSm/TuwjEnL+ub7noxMiaP7v7VM0qBJ9StWevIR1dr6A3VfCFnBdlqGRd6yIjNM83sQDWWmU/K8sVH6/DYU4ckze2Fj96wrhq4oP8gQrvUrazQCPWWFVqNDUAhyGrUWp6W8ftED0qyZ9AOIDcpxLnZACbkPsh+v9JFtP/S2GJc6CJaNRpfrNTo192/FKJXJfAAMFWQI/WP0upyDHT0IjE2ht7TTSjftBXR2XzDMrW+thI2j/6XB9+RXGQjH31zAUlvU9O9dYzUT+/pJtxaehPfR6dfWrQWgWWarwyifnWJ9J9lY7kzH13P7DYLtJmdDwD9o+MoKyMaHSABlhwfnnXGM92pxm4+Nm9boz/21CF894vKGMjIGDA1AayAd+a7nukOWB/UjMx2gOZ/5f8sozfmULgoC7GYfvq1f3QcYNzz3gF7g7TiehNEwOl/lqmhEU3/6B+VI9vlS+Yw2q5fttrX9iKPPnI9qqmb3tNNAAx8dPpFrYntQYS7YaWzed48ikaJ6dQ+0CNpbTvmO2u2s2XMJzqxrIqMwrlLku7KkDNtaNbpeab7xwNnAQANd0Xw2FOH8MS39iv22/bRAYwAQPJRAnVr1qK2mkyuoXl3O5/bOoCp8RYMRsiI2niqUdLadsx31mxnyyiZH8b98VJgdhZ1yf8aoiDbx8i+yiJGazKf2aFELaBOKMyTyxidIIJ2bUAO1JVWlwMA/vhzawHIAnXr+u3yZ1WZv+ddqEKecBZJVuf7WIovfPsAfg9gW881Qx/daADUQ5NHf+ypQwCA/Zs2YtueWtPvLLzBwiivbuSj+8F8Qs5/9vXx110/ebjJcnm8ABTl5IQyIrQLSgFpPkZmcljR6C+9R/KZ9RUVUv1Tzd58hfyOOIqwbOlyDPeP4FRyEtwpZjKcnc8x9zJjSGLUm3XOp5nZIZuLiePddPEyAGBtcSmK4kWm31nMBgsajHv3sie3r8s2k/r/uLUT0TgxMYpGyHzMotqtaGlrwm8bL+DjgbOa2ICUR7/tDqJJ1BrG7LualkvElAeAeF6ZYx+9oJoEGFjfnOentw/0cPex/jndR6Ox8QI5D6qmF1q/k9VIduCV/8S39uOxpw4RIW6y76PrXsO55aqBtVRY35znpzeeauTuYwdB5b4Y+q/Yn0XJI16gDVaq182bfaeMJGSrbjGAxbnEcijL1frgVSZL89+9DOzSOcZon0SPsY+OS+RzvKAAkyP8QVO9GEbKo9NMnBuNrmZjOf3vn4/OS6vpnl+/FoUtxjP3eFpaLxBlh1/8+oz0ubpiNX7x6zPSf3Pkp8JUVxCz6dfvncJDO29xfV88jPxrtbuiZ9UYlVGst5IxybOnj+LRTbsNj9HDqUbvm1LOKCsYHcdYIT/QVuVwKbIdjHz0pZE+oBf45LRcx1/ZuQ8tbbJruLEcePYDYgm2DPTIefQvPkp+tFuNTsx3UhHtczOoyXL2bAurPrpeHl3XR4cyD6phqbVgiRXY8nt7XEQ7dblFukYcRZ4F41ZUZVv20fXy6EY+uhXT3eyYeGGBon4riwsVK+4oVjU61dwXhkkEuwBE2K9wnnWvZ7rzNPU/P0mmjX/h29qJZHrlbIvZy6MDwDPvvQwAePxzB/D4Sy/i8ZeU81w89dF5BOWj31FcAszcQM9AP1aC+OeROJmNVdk5jtm1/OmgtONawchHV5vtuRWuop3m10ma7l4F4/ykP1aiGcDp55NnX5eOOXn2dWy+aa/imPaBHtyeR6bQ8lwjNz46C/Vz6TXZNG4ngN6XXtTMEQBHmI3glVHOmVkKAEXLSKrxNFZi5zIyj2Un57j2uRn8+X6lMq64MojI714nj9O47Q7neXQ2f6720QH9ue7UtKdID54A8KaBz8nOZx/rIKM69enpvvw2MjL3cJZndlXp5z57TzdZ9tG3rFBGTdh53s9dUZpeuQ6WZ5rx0M5b8L8vkGDcpknvXvtz81rjlx2yv/PEVdJQtC6szHU38tGfPX0UAPDopt2mJvzvksG4ot6r0jY6HVut2Y3oHZjE4hlyT1SjX0t8IpXTdPEyakorpGBd4e3Gi35YP7znbWIxV+wp0+zTY1uPdm36mXHn7dt8ZdBfjZ4KH52ybzopWHkg6x/oCqwqew9/6PHIR39omkRFf50jp2c6PDTfq32yEAB7PrqTMox8dCrgbhlJjOhq9JUzs4iVlqMoXoRIYkhKx1PrL1ZajuMJuZy1xaXAzDRGEmQwOHlZ30c3DbQlMYrcb4tpffTmCecTgtoSXVpBD9pHf/ylF/H45w7YzqN39rif2QcA2XXevOWyeyypFVV9YsctO9CwkkwuovMO7HxuvjIoRbr9xM88Oo8tuXJ8YcuWtQC6pf96bKEfqpnRX/rcjSMo4vroibMthmY7DczV127VBOkIJVjTRjS1un6smu+s2c6WcbGWaH61j775LncBwFD56P/YdNjaXXOoqiA/5eBp/edO8fKLmmPOnbV8TSMffXmBdn1ydcVqtCW60JboAgDpv93Petrcy2Ccn/ACbeev93p/ofq1kka/fZesID5+7yz2VpC+d7lZfuR4SzJVe0/9A2hpA6ricXzSpp32lvoXYsv8wyFZ/pbV1Jp+p3ieR1eTqjw6VA8SUOcR69asxcfHz+LjgbN4cLty1GXv7+PjZz3LowNywGjQBx+dLd/LYNyKUlkQ/cijv3NJa6ntW6EK2HjAZchR9jkAUydlq4/9bAQvGFe3CtKbWL6wR+5L7GcKrR/1PjYKz+6rALh59DNJw0IdaDP7TvE1jw7Ym+v+Z1sfkLS67Tz6tDbvSDtx60X+dgrdX1vtXx49FdiZGfdG85v4dMO93GOmxvW1qxd59A3RUmyIl4I+TIJ89m6ZLQvV6H9VWQTcTrbtv/1uyA9dZCco1WG6vQVAE+7bFgfQhKOld6I9OUbTYJyRf6320XlpNbMyeD46lhFXw7FG9zqP7hV28+j7biIa/eFNNLQyBCQ7Ltk2hBcA/GTPHqBfWYl0P/qBnnxvDTOa682FP8E4No9uFyrsPPzMo+txvtM7831dFbEQZB99AI+/YTx98PFPa+ee8oJxWGrdR9fLo9v20ZMGq2ONrt6QKh99LIeMqOzTaf5sK3nI4uMvvSjlT63yg7ffxn9YTzKLRwabpe20fLrPLGj3d+fetnxNIx+dBuPiK5Smu9fBOD+mwAbJ092D2HHLDo0AWf3ceKoRX18uB66oRt893QtAfqrNV7eX4pfHB/DV7SQD8MvjA5hub0F7+5TifvoW8YNxQeFUo3ueR6ffKSP9Ua6Pfupycnpej9bEe/xzB2zn0U+efR0/2bMHB08npEGELf/gflpTAAATIElEQVTW0pusBeMGrPvoRnn02VaSVqPptVTk0e0E44zqYvd248c8uc2jnzkzqNm2r3TU9J7tciQm97m9lUSjUwGnfHV7KVqv9ODtzhw8/ulY0nSX+ellbezgU//GeAVlxuXRAdlHX5Q4pti+hZ5ay8lzJ47hfu1WmQiSazMhPUr9S9vimJ88i4caVMcmy29v78a25SVQ+4J9tbsVA9HuUm0nTxcfHSDBuBeOv4gHtx9AbbW88g2QB73vfvEAPn7+rBS4A5TBuNYr+jPjvMij98cqtME4e+/+sAzV6HsrSUdhhVz+rr/skxeMs+Oj65FyH119Eb98dLVJlGrO9+Vxt9++QxmMm01jE5gG4wAognJqTn3MP4ZdpupnHn1DdDplwTjWR89irM76ujbFcS2ttdJn2ldranJRXhrTBOM6gdTn0dPFR3+oIRcA8MP3Lb5fySP+ehu1GCa4+8v6hxTBuB+87Y2PTskZptMz83wJxtHyP7n7dmlffOs+fCJ9Y7YDmGzuxocYRNHW2/AhBnHHUHD+pho/gnGsRv9htvw8ArSptHh2JwBiktfU5Eqb9YJxQRH6PLoa9WR+ozy1u/3NOtsJvOCcF3l0GoyrWUZWw13pnpLK9jIYV5NcbdcKYPw1Y62Y/xlrD5AMcj2618E4VqPn1Nh//TNvZtyuVSUij65GyqOrfHRAfvRU4ynldzWu9pu8H/A9VZDMqzw6nRnXxWzzc2bcZLNSyHlR5cnmbsypjIp+jsls55lxTvLo10c5L3AoJVr4yapyAH34wpa1oI1n5zP5L8NqdBpo++H7Ce5g8fl15Kk/rOmufnsvkJ559Mgv/vv5ecD+k01YjKLudK67OhiXavRiBOpgHDsrzC68qPu/TBCLInKDHyNww0M7b8HBD0mwbebu2zH+WrdhVDn/M8s1A8LXasmDxi0/My75WGv6O9V5dLrvycOv6/roHTPaYNx/WuF9DEcddbeCOur+m5FN2mWqDQW6PvoXvn1AEVlX59Hpvn9+Ut9H/37sGp59vU811925fKYk6k599G256RGM+9nz3qxHp1DTmpruXsOa7oD9qDINzAGpe2ZcKoNx6qi7XfSCcUER+jz6Qw2ktoIKxulp9Np1yud2/uDttz3No7Ma3etgnFqjs9qaF1WONSxXmO9Zq8ENxgWxHn1LbrfnwTi1RrdiurOTZmpqcvGv19Zryq663zgYl9F5dLWPHtZgnFc+urRMVSUzqVqmyqaL1GSZLGUPcj26XzPj9lYWScG4/1pTD/JQMeDz6+6WPlPYqDsvGNcawHr0tMmj8whjMG63By//A5hlqkxWz+9lqrEG+69l4s2ms/PMOD1sPzPOp2AcG3V3Ai8YF4XIo2uQ8+jku5zXbpaEkGxr1hVKt/uNUC+jffLwi5bPtZRHHyJ28kzsZvs3ZwGpfMim+0jTR9xO1LyBCC9rut/7KfK7g35mXCpmxjmJuus9My4oQht1pz76tlx/gi1W0Q3GHbgDb751QZoO+rPnX/TUR78U/RgAcKrP+G21Tnho5y04f/4NAMCJjbssnaOOurv10fWi7kbo+ehe40XU/WjOna6eGacXdTfCFx+d5tG/+V+eU+x8cPtdHs91DzYYZzYz7j8e/idp21vHjuD7D/2x9N2Lue6XWk8pvufmF7oqLyzPjKMC/je//hd543HSf/TQ89GNgnF/23JF8f2b9fpv/AX4M+OM+OYzryq+/+xe4s+7fWYcFfDnnpD713MAqh/5sm4ZTnz0qXHloqAHt9+l1OijFwfmAeDcPPGbfvHMUcUJP/2rR3RviGInj04FPVXBuH0xEowzi7o3l5M0k/r3swJvBk+jH+oiL9G9976d3PL/7cOPOArG0aj7C7/7PwCAyX1ftGS6W4m6x2K9tvPof/HQ7dzf96m7Pqvx0XmCTqPuesE4o/LZ+6TBOLtR97XrJrnl37NZ6/O2rtdfj66XR7daP07z6Fl5Xdzyaf+K9h0jUefVByoByJqGjhBuNToAvH9uAPcs1W4PQzDuREsyaNZC1nWrf7/Rc96trEffsJJYFK+9Q5Zmrq4jb1ehGv71JvKmFqfBOFr+CcjBuFjDPinXEN+wT5N3YKPuesE4uxSOkwZ+cPtdqFtZodTwKs70aq2rLdUmwbhWooj+/h7ySMhvvHOC7MvRD8a1XpVN4L2VMIm6k6f2Uk3+3TfJoEAf/8wSdbAefXg5sUCqH/kydq1Sang7mPnk6v4r37MKGlX/XtKU9yLqXlEsm01GwbjvHtQPAr117Aje4kyu+9m99a6CcbyHOO64ZQfeOnZE+uxkrjst99CVpKsS895HB4AztPyNwNX/edD2+atX3qnZZmeuu1m9bFkR08x1vz6qXY/uJ+QtqXzXzQpLY8p3at9q45lxZvVTsafMl7nu/+Og0hWPVlSRkXICZESmGpvihUYHrC1T/Wb9SvxtyxV848Ih/P3a/fiLynfxq65dKPj6HMaezlL4ZdRns7r8VS8YNzQ1IEWe33zrgqSl30ru13bU8LJs9z3oP/qObv2t+NrDkul+7co75JylyyWtvmwpsQi8yKNTeGXFC0uRGB3D/5u4wUSzvX/wBH0NMgmiTdiOurPQVzb1TY17sh6dwivr7l7Oe9ds5tHVpESjA/IkBCvBuL9fS67xqy4SSR57mpjBT3drNQFvG4tZMK523RrpGXIPb4pDv4u7hzczzulsOV4wLtawHDiqX3+UrNUArsAQt3l0thzeM+PihQW4v7AAdBos4GyZqt45NBjHYmvCjI5xWZabjxG4z6NT1rT1aXz02RrO+//cavSnzpIplF+7g2hLrzX6Px4lwaK168lQx/oO6kCKHrz91k1r45lxT3/0suJ727BS8zv10WkQTg2dGUcb4s/373c8M44G4lhWfO1h3Xvi0dIrt/dQUmY21mjNeS9pbH9Fs21Lw2YANmbGJS26P5RvUGxnZ8YNdr6U/A/srXRmlRVd/wAz11Uz8df/ie7x1Pd+DsAjj+lH1o34b0eOaLbt2fUQABcanQZzKF5rdLb8777ZgmcuvYqmH/8EW3/0A3wFJCroJNhG/fWGlSWugnHq39/2yagnPrq67FN92plxgLtgHFv+CcD2hBl1GRQv1qPL52h99Ln5OM5cSWiubWdmHHWtjIJx6vKdmO68+onp+OhTx0aV/fsJObjL898Bvo8+eYlfP4ALja4uyC8fnUIroenHPwGeOYo1fR/anvlGI6IALJ1vh3T20a1G3al/rocX70e3Ulaq8cJ0B4znqav7t956dKOythoc71ij06gtnd7gtUan5e9Yvwo/u7ce333mKH6x+j7gmaNSKsMJ/+4ruzU5QydIUeskDTWui+SX7UPUXVH+Rnvn0vpT/34A2FhT66uPTq/JXntvQ6W9H2ABtvw9xg//tVSGxGq+j96bX4hfMP3biunO89F59VNeS/471uhq8+DI0UHD7yyf3W2eT6TlU3OIRta/Wb8S7e1TutFwM6iQv3ZCaZSsK+MH3fSus2G9+dtWD5/4xHD/A1u0Uqau11N93gfj1Ka7nUdJ0frjmYdmnOvtw7leffPJLDKvd83ffmz/oR9653z+1gLNdVreNX6vXv0u7WjAu9cmgzIeeezLeO6Jf0Ll5i/jqDYUQTCJzBu1CXX17KLR6NTPZXPWNAjE7rcKq9ElWuQo/Pk+feHUY13ZSsWUSPZ8domhEv41XrWg0deXE22s7tx0Ow+NJkiBRlcvP2VnwLHQNJymjCSf37lN+szz0e3UB89H/+17H2iO29tQaasf/C75wpd1ZRPSIK48v0Cj0dV9g128ogevfnbdC9M8etZ6YO6c8rws7dJ2ro9+4qj2mlSj18Zly4fGbGrjlYrPgHbKNff9Q+x01oaVJYpXIdN9Lc4UkS60stvbp/B096BkgvzDoUOKz19fXqLwodaVTSjOdUNzj75G5GmpupUVuj5oc083Giq0y0ZpII02BP1t6gg7neYKyFpf/Z0Hu1R1Mhkrpg+cMIP+fit+tVF9sOfzyqLX4dUPTYux02EBThpLcXyv5lw92AdE1iQ7UU5NvWYxCw963xMGPjpl1yrgXd62y0q/nOejdxrUD6BVtux3nqIGgn0DLJeamlz8dU0c6PsQQDIQx372Eb2K9bMs1hRjI+x+LlrRg96zmeltNhDUrawAjjOf1ddpN68bNgIPaCPvdApsKqH1s8XE9H7OeDeZAst8VnPCw35IiTzx5Bvz5oeFj6sb+D7iijPWTOR0Pz9ogv79QZ+fbkQ/v3Mzd0fzpQ40rK7WPTGo/X937XcAgK/s4RsjzyRH/fuGblqQ51NE/Wdm/TvdH22+1ME98EyncVI6iP2vLjmLytoE7lul/7inr+yJ4tXLnXi1DYDKlU3381lE/af+fJYwyofR/rQy3a9u6ENlLYlIfqf6Qfy84wXct6oKr17ulBrv1cvkQT9dbXGNGcaezza2k/PdXt/J+UHjZf0FXf9Orp/ORH77/Km0EHQ6GgOkkceGjqBgyWfx844XdM/paovjvqGbNOdbRe98t9d3cn7QeFl/bs8Pov3TnaiZCaDH1Q19rkY82+czC3q+19iIn+74LL7X2IjKWuPTpN/HWRBkBd75bq/v6HybeN4+Htaf2/MDaX+PSbX8KNYvXt3Qh5buTuk/r3C6/8Yb2px1S3en4s/r8ymVtYlkIytH6O9UP6j/Sz3E7fWdnh90+4SFoNrfTv2FTX40PrrZSEHTEk5HIzfnX8i/irzaxYoG7mqLo7I2oTDnvtfYiIm261g7vsLy+SxdbXHb57u9vpXzgWDbx8/6c3t+KtrfCmGVn8jXX/+/aeGjA8BE23Xk1S7W3ffVT6/BL9+4iLzaxdxjjc63ci0/r2/l/KDxs/7cnp+K9k9ndAVdN8/4tvN3tHnBRBt5uiqvEeg+vf1m57vd7/b6Vs63yk937MD3Gs1f3WQXP+vP7f5UtL9VwiY/kf/c/KQk6NSMMcozAiQFwTN57GB2vtn+lqPF3O31u4ctXT/dzzeqHytRabftF/TvD/p8PZM/rPLDFXTAWp7SzY16waIjEaypmAUAXOzJxo3P2vNC0v18NbTNutrikkb3s42C/v1Bn68mzPIjRd3VNzk2dATfqX5QurFXL3dKnwES+exq83eRiRG8a9u5n3Q/Xw3bZnpRaS8J+vcHfT7v3DDLD/clW99rbJSil15Bf5TejzPbrz52ou061lTMoramGLU1xVhTMYuJtusL9nyz+lG3Gc+sNDrfDulYf27Pt1N/YZQfyXRXmxI804KaI0bHmN2sG79cfSwbfAGgSZ0stPPd1p+X5mI61p/b843qL+zyo/DRW44W28pTWg1cCASZQJjlh5sDUKv/rrY4/v3RN/DVT2/AL599Y0HlF9MVPRMt6ACpIJzyo/DR63cPY6LtusakAYhZ88s3LgKA6WjkpT/u9Hyj6ZBhuD+n53e1xdHVFsdX9kS5f3S/GWGvnzDfn97+MMuPwnRn8TPPa2W/m/K9yCP7ned0cj7d5jZPG/b6Cfv9WdkfNvnRFXTA+zyj36Q6j5xq2Ma1sp5aLxgU1voJ+/3ZJUzyoyvoXW1xrDrXq7jRy+vLQ1vxai3gZYQ5DDj5PbzcbljrJ+z3Z5ewyQ83j+5HntFvv8ltHjnMfrkXhL1+wn5/dsoPo/wYavRU53nN8DuPHEa/3E3ZVnK7dq6R6e1np/ywyY+hjy4IF0Z5WhbaycQ8BwEldC9w8Ao9Eyed/T6K+rf5Ze5bgUaXxaASbnR9dPa/1/iZR/Uqz+zm/v3ab5SnpdD9qRC8lqPFqN89jPrdw7rpJB5+59HdXt/v/W5xUn+GPrrfq5+8zqN6lWe2QtD+pts8rVuokJtt08PvPLqb66div1vs1h9XowP+m7i88ukoZGX1j9H9scsB1d/V+5xiVj9+76/fPYwNkyM4UDyIA8WD2DA5EoiQs1rFjmb3s/2dXj+V+91it/5CE4xzm0f1IiqdTgSVp6UBQSOcuA4LLY+easzqT/HgCfa/1/idR/WbMPl1TvK0XmBFyAGSRlJr9qDbP0zt5wS39af7KCk/8NPvSYVGD5Nf5yRP6wVUgFmBZ5+YSu+Jp9GD9nvD1H5OcHP90JjuXiDyzP5C65c3wKifwCrqN1z4nkcPIs8apjzzQoE123nmu3obMd9Fft0tXsmPbtTdizymX3lWv/PMfvtjqTjfy/XcTQfbMdhzWlOvRt8n2q5jsOc0mg62u74+jzCvV3d7fxQv5YdrunuRx/Qzz2r1+jzSYT292/P9Ws/NCm1JxSbueYM9p6XPWx+ucXT/ZvvDvl49jPKjEHSv1gOr86xsGXZu1i1hWg+cClK5npunqQFj4XZL2Nerh1l+JEH3Ko/pV57VLkHlmYMilXloahLy6hfwZ7JI2PPsYZcfyUf3Io/pZ57V7zxzGPw6N+enaj033U/rd/2KFVi/YoVUv3pluL1+2Nerh11+bOXRrYxSQeZZ1ceGaT1wKs5PVR6YFXYW2sZO5zoEvd+MVFzfL/nxNI8u8qwCgXP8lJ//D+Fe08IJlGMzAAAAAElFTkSuQmCC";

const bat1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAABtQTFRFUQAAHRgergAAQy9TXENvX197d4SitXKx//nWkPMycwAAAAl0Uk5TAP//////////NwKb1AAAAHlJREFUOI3tkEsSwCAIQ00JcP8bN9Tu/HSmazMuHHgmYGtHR39kpS0Bki+ygNGlfkSdWUqADkMgfOgb9UoxSXhcGAzMVNfrAugxcXimLMCggAsjUQNqD0/UtWG2MzxZFtNv6CGeyVwD8jV+AMxthEY0bAxEbNtFDJUbQdUB+6VV/48AAAAASUVORK5CYII=";

const bat2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAABtQTFRFUQAAHRgergAAQy9TXENvX197d4SitXKx//nWkPMycwAAAAl0Uk5TAP//////////NwKb1AAAAIlJREFUOI3tkDESAjEMA09YVvj/i1HM0Nk5Gjo86XYTybmu7yfiRgDPCrAWz0bkrRFnw0KsNRvmpM8sGJczG3gL87Y7JAhqUhD7uqOk1qgHykihM6qCOcwf7RsIhyAtSIl2jb0IhMxnx+srsCtYbHmINnxfA2fukThw57sdB+wCVXJI/yj/+d28AACRAly6tdJ8AAAAAElFTkSuQmCC";

const bat3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAABtQTFRFUQAAHRgergAAQy9TXENvX197d4SitXKx//nWkPMycwAAAAl0Uk5TAP//////////NwKb1AAAAHFJREFUOI3tkEEOgEAIA6kF1v+/WKoewauJsZc9zCw0mH0wJB8hfS1OkuBa7gnPVqFDqaekbIxiuBR4JHrjDFB862ZYfRZGVgJdUS2gjNhbXoarguoOPAXVsefMiND6iXvUBcbxRhUcqQrYE72VPy/mAKmjAdOmo0sxAAAAAElFTkSuQmCC";

const bat4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAABtQTFRFUQAAHRgergAAQy9TXENvX197d4SitXKx//nWkPMycwAAAAl0Uk5TAP//////////NwKb1AAAAINJREFUOI3dksESAzEIQpciuv//xSU77S2aa6fmyBtAJ9f1p0PyAETOCCMyRwKhxEAA1l+NhwtSSI+wj5eIROru9ApCAWx1A+UVjO3lL+CIrv+KoDM6/bEITgBY4RLtkeAbqmzSBXi7ZdEugfVYY8unxvwhQB0t1Jb4EIgZWCYH4NfmDXtdAh0Eq2UvAAAAAElFTkSuQmCC";

const mainjs = `
"push title Game Title";
"push author Your Name";
"push description A MicoJS game";
"set version v0.0.1";
"set category game";
"set url https://micojs.github.com";

const bgColor = setPen(0, 0, 0);
const txtColor = setPen(64, 128, 255);

let screenWidth, screenHeight;

class Wheel {
    init() {
        this.x = screenWidth/2;
        this.y = screenHeight/2;
        this.speedX = rand(-3, 3);
        this.speedY = rand(-3, 3);
        this.color = 0;
    }

    update() {
        if (A)
            this.color++;
        if (B)
            this.color = 0;

        this.x += this.speedX;
        this.y += this.speedY;

        let bounce = false;
        while (!this.speedX || (this.x > screenWidth && this.speedX > 0) || (this.x < 0 && this.speedX < 0)) {
            this.speedX = rand(-5, 5);
            bounce = true;
        }
        while (!this.speedY || (this.y > screenHeight && this.speedY > 0) || (this.y < 0 && this.speedY < 0)) {
            this.speedY = rand(-5, 5);
            bounce = true;
        }
        if (bounce)
            debug("Bounce");
    }

    render() {
        setMirrored(this.speedX < 0);
        setFlipped(this.speedY < 0);
        setPen(this.color);
        image(R.wheel, this.x, this.y);
    }
}

const wheel = new Wheel();

function init() {
    screenWidth = getWidth();
    screenHeight = getHeight();
    wheel.init();
}

function update(time) {
    wheel.update();
}

function render() {
    setPen(bgColor);
    clear();
    wheel.render();
    setPen(txtColor);
    text("Hello world!", 5, 5);
}
`;

const mainblock = {"blocks":{"languageVersion":0,"blocks":[{"type":"procedures_defnoreturn","id":"h#i-jy;zgd~fum4z8?h.","x":209,"y":-566,"icons":{"comment":{"text":"This function gets called once, when the game starts up.","pinned":true,"height":46,"width":501}},"fields":{"NAME":"init"},"inputs":{"STACK":{"block":{"type":"variables_set","id":"l#mDEP*x=nFP54X_DkXS","fields":{"VAR":{"id":"#9?40i7c9)0m2jGBB,??"}},"inputs":{"VALUE":{"block":{"type":"math_number","id":"hF8nG`Itt@ZM?~vIiI;N","fields":{"NUM":0}}}},"next":{"block":{"type":"setFont","id":"z+`+B8K-.mXUPs|GHX)5","fields":{"FONT":"fontTIC806x6"},"next":{"block":{"type":"variables_set","id":"a_r]jq.YMBEYG!EmzpgQ","fields":{"VAR":{"id":"%e4=`XKqec2W|]qiCeic"}},"inputs":{"VALUE":{"block":{"type":"lists_create_with","id":"@o7/ONoP:JeW?DTZ*m).","extraState":{"itemCount":4},"inputs":{"ADD0":{"block":{"type":"resource","id":"}sw_RQi+R7E%V(.!zPJ-","fields":{"TEXT":"bat2.png"}}},"ADD1":{"block":{"type":"resource","id":"Yr^=t:kGQ6,UVrE^cAsK","fields":{"TEXT":"bat3.png"}}},"ADD2":{"block":{"type":"resource","id":"M%iwzvrL#7;5r5|[8|kp","fields":{"TEXT":"bat4.png"}}},"ADD3":{"block":{"type":"resource","id":"J(A_gP.`+YH#ov.qk6pe","fields":{"TEXT":"bat3.png"}}}}}}},"next":{"block":{"type":"variables_set","id":"h5~lnqX{Ba(oU|nSl}u,","fields":{"VAR":{"id":"0vX1hx=H~.o^G8eKJF[f"}},"inputs":{"VALUE":{"block":{"type":"math_number","id":"N1!,Jo)/;VPaM9i^9Jm_","fields":{"NUM":0}}}}}}}}}}}}}},{"type":"procedures_defnoreturn","id":"7!_Dl3!_?uz@sA_W]o=Q","x":209,"y":-324,"icons":{"comment":{"text":"Update all game logic here!","pinned":true,"height":42,"width":246}},"fields":{"NAME":"update"},"inputs":{"STACK":{"block":{"type":"math_change","id":"2toZ)[wz,V4Du+]8y~MU","fields":{"VAR":{"id":"#9?40i7c9)0m2jGBB,??"}},"inputs":{"DELTA":{"shadow":{"type":"math_number","id":"7c#[!NK(1y#jfpl0JB|W","fields":{"NUM":33}}}},"next":{"block":{"type":"math_change","id":"J~3}bm4Nj*4v,Xr;!AS=","fields":{"VAR":{"id":"0vX1hx=H~.o^G8eKJF[f"}},"inputs":{"DELTA":{"shadow":{"type":"math_number","id":"?btN{324]?9rb8.;c*[J","fields":{"NUM":0.2}}}}}}}}}},{"type":"procedures_defnoreturn","id":"$}l{c5[!@~~.retU@pMj","x":210,"y":-200,"icons":{"comment":{"text":"Draw all your graphics here!","pinned":true,"height":49,"width":263}},"fields":{"NAME":"render"},"inputs":{"STACK":{"block":{"type":"setPen","id":"vJ@(UGzTX}IlYH-m#q-=","inputs":{"COLOR":{"block":{"type":"colour_picker","id":"G6{:06IY,gT_$nysV/?F","fields":{"COLOUR":"#8ab1a9"}}}},"next":{"block":{"type":"clear","id":"TkQ#U,pae4Zd2Y2?9Hxa","next":{"block":{"type":"clearPen","id":":fAS-7.eD]1-5K}e-[vk","next":{"block":{"type":"showImage","id":"S3~Sa2P[je+9ElGxf)}B","inputs":{"TEXT":{"block":{"type":"resource","id":".xpzjMPEdXOHnDp^4O32","fields":{"TEXT":"background"}}},"X":{"block":{"type":"math_number","id":"~B!CEiSg6cbX$)Gk|=n-","fields":{"NUM":80}}},"Y":{"block":{"type":"math_number","id":":n[/C,(K{AM!!8XEPsYz","fields":{"NUM":64}}},"ANGLE":{"block":{"type":"math_number","id":"R=+1q,tOd#z;98qkX*Om","fields":{"NUM":0}}},"SCALE":{"block":{"type":"math_number","id":"$]))R-p~#`q~4x-e$[1|","fields":{"NUM":1}}}},"next":{"block":{"type":"setPen","id":"JePs,B|J}-5dzZYnz7nn","inputs":{"COLOR":{"block":{"type":"colour_picker","id":"xHRcG36izFuGNFA2F~H/","fields":{"COLOUR":"#164420"}}}},"next":{"block":{"type":"showText","id":"={WLGho,MoHGU]=]oAn/","inputs":{"TEXT":{"block":{"type":"text","id":"9i$?@2KYK.Y@c6p0|V53","fields":{"TEXT":"Hello World"}}},"X":{"block":{"type":"math_number","id":"GzT5@^0eU%!EuiP9yYe4","fields":{"NUM":50}}},"Y":{"block":{"type":"math_number","id":"70pF:CSe+tRCV_6%RABZ","fields":{"NUM":25}}}},"next":{"block":{"type":"clearPen","id":"u+4:62i7pR#pX{GG8Tbk","next":{"block":{"type":"showImage","id":"PmK;DV!snssjU6@TzrW!","inputs":{"TEXT":{"block":{"type":"resource","id":"s87H;;|o0;in}dc*Z3U]","fields":{"TEXT":"wheel.png"}}},"X":{"block":{"type":"math_number","id":"go.#_P}!nC$8pD[U)aE6","fields":{"NUM":80}}},"Y":{"block":{"type":"math_number","id":"9+d+U}cng*S93-ph@-0R","fields":{"NUM":80}}},"ANGLE":{"block":{"type":"variables_get","id":"gQ(N)+:#{,PRt@qKHH+_","fields":{"VAR":{"id":"#9?40i7c9)0m2jGBB,??"}}}},"SCALE":{"block":{"type":"math_number","id":"gm!_j0-YRR%oar!(|FPf","fields":{"NUM":3}}}},"next":{"block":{"type":"showImage","id":"SYf-{$Vh6Wikx3@VWvwF","inputs":{"TEXT":{"block":{"type":"lists_getIndex","id":"Hl2RgOp#[x:ZGm$L0UD_","fields":{"MODE":"GET","WHERE":"FROM_START"},"inputs":{"VALUE":{"block":{"type":"variables_get","id":"/Fnr67)Ae8J;XEb6#~${","fields":{"VAR":{"id":"%e4=`XKqec2W|]qiCeic"}}}},"AT":{"block":{"type":"math_arithmetic","id":"4EQQ+^#h6.ByvKDHj_0c","fields":{"OP":"ADD"},"inputs":{"A":{"block":{"type":"math_modulo","id":"^cPVm%%+;{),_^Egx+P|","inputs":{"DIVIDEND":{"block":{"type":"math_round","id":"q*P54MUd05YHegI!hN}q","fields":{"OP":"ROUNDDOWN"},"inputs":{"NUM":{"block":{"type":"variables_get","id":"l,KXcGvM{V2Zv-VHrFjJ","fields":{"VAR":{"id":"0vX1hx=H~.o^G8eKJF[f"}}}}}}},"DIVISOR":{"block":{"type":"math_number","id":"_39XH6_vG9~!t|U:;Z9-","fields":{"NUM":3}}}}}},"B":{"block":{"type":"math_number","id":"ZB:~NojS^@a2t{Z6Pt$D","fields":{"NUM":1}}}}}}}}},"X":{"block":{"type":"math_modulo","id":"ZJ`^|kk:L|$l5C0gb;`2","inputs":{"DIVIDEND":{"block":{"type":"variables_get","id":"C*4Ts2ipg/X5tztQz;W5","fields":{"VAR":{"id":"0vX1hx=H~.o^G8eKJF[f"}}}},"DIVISOR":{"block":{"type":"math_number","id":"}bN}t[%=qs9r+P!UB7:c","fields":{"NUM":160}}}}}},"Y":{"block":{"type":"math_number","id":"0%SW@SrvM7#ld~a29U.s","fields":{"NUM":10}}},"ANGLE":{"block":{"type":"math_number","id":"cPSL~k%syz`x,1)2{g7/","fields":{"NUM":0}}},"SCALE":{"block":{"type":"math_number","id":"u:2X8}ALHH+P0!X5-w`7","fields":{"NUM":1}}}}}}}}}}}}}}}}}}}}}}}}]},"variables":[{"name":"angle","id":"#9?40i7c9)0m2jGBB,??"},{"name":"bat","id":"%e4=`XKqec2W|]qiCeic"},{"name":"batFrame","id":"0vX1hx=H~.o^G8eKJF[f"}]};

const templates = {
    js(fs) {
        fs.mkdir('/images');
        fs.mkdir('/source');
        fs.writeFile('/images/wheel.png', wheel);
        fs.writeFile('/source/main.js', mainjs);
    },

    blockly(fs) {
        fs.mkdir('/images');
        fs.mkdir('/source');
        fs.writeFile('/images/wheel.png', wheel);
        fs.writeFile('/images/background.png', background);
        fs.writeFile('/images/bat1.png', bat1);
        fs.writeFile('/images/bat2.png', bat2);
        fs.writeFile('/images/bat3.png', bat3);
        fs.writeFile('/images/bat4.png', bat4);
        fs.writeFile('/source/main.block', JSON.stringify(mainblock));
    }
};

module.exports.loadExample = function loadExample(fs, templateName) {
    (templates[templateName] || templates.js)(fs);
};

},{}],65:[function(require,module,exports){
const {dom, index} = require('./dom.js');

const {Model} = require('./Model.js');
const {Remote} = require('./Remote.js');

const {IDE} = require('./IDE.js');
const {TOP} = require('./TOP.js');

class Main {
    #view;
    #ide;
    #top;
    #model = new Model();
    #remote;

    constructor() {
        addEventListener('DOMContentLoaded', this.loaded.bind(this));
        addEventListener('resize', this.resize.bind(this));
    }

    get remote() {
        if (!this.#remote) {
            this.#remote = new Remote();
            this.#remote.boot();
        }
        return this.#remote;
    }

    setupIDE(el) {
        this.#ide = new IDE(el, this, this.#model);
        return false;
    }

    setupTOP(el) {
        this.#top = new TOP(el, this, this.#model);
        return false;
    }

    loaded() {
        if (!window.monaco) {
            setTimeout(this.loaded.bind(this), 1000);
        } else {
            this.boot();
        }
    }

    resize() {
        this.#model.set("windowSize", [window.clientWidth, window.clientHeight]);
    }

    async boot() {
        await this.#model.useStorage("main");
        this.#model.init({
            windowSize: [0, 0],
            state:'TOP',
            platform:'espboy',
            projectId:null,
            projectName:null,
            projectList:[
                {id:1, name:"Bats"}
            ]
        });
        this.#view = index(document.body, {}, this);
    }
};

window.main = new Main();


},{"./IDE.js":43,"./Model.js":45,"./Remote.js":49,"./TOP.js":54,"./dom.js":62}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FirebaseError", {
  enumerable: true,
  get: function () {
    return _util.FirebaseError;
  }
});
exports._DEFAULT_ENTRY_NAME = exports.SDK_VERSION = void 0;
exports._addComponent = _addComponent;
exports._addOrOverwriteComponent = _addOrOverwriteComponent;
exports._apps = void 0;
exports._clearComponents = _clearComponents;
exports._components = void 0;
exports._getProvider = _getProvider;
exports._registerComponent = _registerComponent;
exports._removeServiceInstance = _removeServiceInstance;
exports.deleteApp = deleteApp;
exports.getApp = getApp;
exports.getApps = getApps;
exports.initializeApp = initializeApp;
exports.onLog = onLog;
exports.registerVersion = registerVersion;
exports.setLogLevel = setLogLevel;
var _component = require("@firebase/component");
var _logger = require("@firebase/logger");
var _util = require("@firebase/util");
var _idb = require("idb");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlatformLoggerServiceImpl {
  constructor(container) {
    this.container = container;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    const providers = this.container.getProviders();
    // Loop through providers and get library/version pairs from any that are
    // version components.
    return providers.map(provider => {
      if (isVersionServiceProvider(provider)) {
        const service = provider.getImmediate();
        return `${service.library}/${service.version}`;
      } else {
        return null;
      }
    }).filter(logString => logString).join(' ');
  }
}
/**
 *
 * @param provider check if this provider provides a VersionService
 *
 * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider
 * provides VersionService. The provider is not necessarily a 'app-version'
 * provider.
 */
function isVersionServiceProvider(provider) {
  const component = provider.getComponent();
  return (component === null || component === void 0 ? void 0 : component.type) === "VERSION" /* VERSION */;
}

const name$o = "@firebase/app";
const version$1 = "0.8.4";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger = new _logger.Logger('@firebase/app');
const name$n = "@firebase/app-compat";
const name$m = "@firebase/analytics-compat";
const name$l = "@firebase/analytics";
const name$k = "@firebase/app-check-compat";
const name$j = "@firebase/app-check";
const name$i = "@firebase/auth";
const name$h = "@firebase/auth-compat";
const name$g = "@firebase/database";
const name$f = "@firebase/database-compat";
const name$e = "@firebase/functions";
const name$d = "@firebase/functions-compat";
const name$c = "@firebase/installations";
const name$b = "@firebase/installations-compat";
const name$a = "@firebase/messaging";
const name$9 = "@firebase/messaging-compat";
const name$8 = "@firebase/performance";
const name$7 = "@firebase/performance-compat";
const name$6 = "@firebase/remote-config";
const name$5 = "@firebase/remote-config-compat";
const name$4 = "@firebase/storage";
const name$3 = "@firebase/storage-compat";
const name$2 = "@firebase/firestore";
const name$1 = "@firebase/firestore-compat";
const name = "firebase";
const version = "9.14.0";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The default app name
 *
 * @internal
 */
const DEFAULT_ENTRY_NAME = '[DEFAULT]';
exports._DEFAULT_ENTRY_NAME = DEFAULT_ENTRY_NAME;
const PLATFORM_LOG_STRING = {
  [name$o]: 'fire-core',
  [name$n]: 'fire-core-compat',
  [name$l]: 'fire-analytics',
  [name$m]: 'fire-analytics-compat',
  [name$j]: 'fire-app-check',
  [name$k]: 'fire-app-check-compat',
  [name$i]: 'fire-auth',
  [name$h]: 'fire-auth-compat',
  [name$g]: 'fire-rtdb',
  [name$f]: 'fire-rtdb-compat',
  [name$e]: 'fire-fn',
  [name$d]: 'fire-fn-compat',
  [name$c]: 'fire-iid',
  [name$b]: 'fire-iid-compat',
  [name$a]: 'fire-fcm',
  [name$9]: 'fire-fcm-compat',
  [name$8]: 'fire-perf',
  [name$7]: 'fire-perf-compat',
  [name$6]: 'fire-rc',
  [name$5]: 'fire-rc-compat',
  [name$4]: 'fire-gcs',
  [name$3]: 'fire-gcs-compat',
  [name$2]: 'fire-fst',
  [name$1]: 'fire-fst-compat',
  'fire-js': 'fire-js',
  [name]: 'fire-js-all'
};

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
const _apps = new Map();
/**
 * Registered components.
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports._apps = _apps;
const _components = new Map();
/**
 * @param component - the component being added to this app's container
 *
 * @internal
 */
exports._components = _components;
function _addComponent(app, component) {
  try {
    app.container.addComponent(component);
  } catch (e) {
    logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);
  }
}
/**
 *
 * @internal
 */
function _addOrOverwriteComponent(app, component) {
  app.container.addOrOverwriteComponent(component);
}
/**
 *
 * @param component - the component to register
 * @returns whether or not the component is registered successfully
 *
 * @internal
 */
function _registerComponent(component) {
  const componentName = component.name;
  if (_components.has(componentName)) {
    logger.debug(`There were multiple attempts to register component ${componentName}.`);
    return false;
  }
  _components.set(componentName, component);
  // add the component to existing app instances
  for (const app of _apps.values()) {
    _addComponent(app, component);
  }
  return true;
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 *
 * @returns the provider for the service with the matching name
 *
 * @internal
 */
function _getProvider(app, name) {
  const heartbeatController = app.container.getProvider('heartbeat').getImmediate({
    optional: true
  });
  if (heartbeatController) {
    void heartbeatController.triggerHeartbeat();
  }
  return app.container.getProvider(name);
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 * @param instanceIdentifier - service instance identifier in case the service supports multiple instances
 *
 * @internal
 */
function _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {
  _getProvider(app, name).clearInstance(instanceIdentifier);
}
/**
 * Test only
 *
 * @internal
 */
function _clearComponents() {
  _components.clear();
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS = {
  ["no-app" /* NO_APP */]: "No Firebase App '{$appName}' has been created - " + 'call Firebase App.initializeApp()',
  ["bad-app-name" /* BAD_APP_NAME */]: "Illegal App name: '{$appName}",
  ["duplicate-app" /* DUPLICATE_APP */]: "Firebase App named '{$appName}' already exists with different options or config",
  ["app-deleted" /* APP_DELETED */]: "Firebase App named '{$appName}' already deleted",
  ["no-options" /* NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',
  ["invalid-app-argument" /* INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' + 'Firebase App instance.',
  ["invalid-log-argument" /* INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',
  ["idb-open" /* IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',
  ["idb-get" /* IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',
  ["idb-set" /* IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',
  ["idb-delete" /* IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.'
};
const ERROR_FACTORY = new _util.ErrorFactory('app', 'Firebase', ERRORS);

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FirebaseAppImpl {
  constructor(options, config, container) {
    this._isDeleted = false;
    this._options = Object.assign({}, options);
    this._config = Object.assign({}, config);
    this._name = config.name;
    this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;
    this._container = container;
    this.container.addComponent(new _component.Component('app', () => this, "PUBLIC" /* PUBLIC */));
  }

  get automaticDataCollectionEnabled() {
    this.checkDestroyed();
    return this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(val) {
    this.checkDestroyed();
    this._automaticDataCollectionEnabled = val;
  }
  get name() {
    this.checkDestroyed();
    return this._name;
  }
  get options() {
    this.checkDestroyed();
    return this._options;
  }
  get config() {
    this.checkDestroyed();
    return this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(val) {
    this._isDeleted = val;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted) {
      throw ERROR_FACTORY.create("app-deleted" /* APP_DELETED */, {
        appName: this._name
      });
    }
  }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The current SDK version.
 *
 * @public
 */
const SDK_VERSION = version;
exports.SDK_VERSION = SDK_VERSION;
function initializeApp(_options, rawConfig = {}) {
  let options = _options;
  if (typeof rawConfig !== 'object') {
    const name = rawConfig;
    rawConfig = {
      name
    };
  }
  const config = Object.assign({
    name: DEFAULT_ENTRY_NAME,
    automaticDataCollectionEnabled: false
  }, rawConfig);
  const name = config.name;
  if (typeof name !== 'string' || !name) {
    throw ERROR_FACTORY.create("bad-app-name" /* BAD_APP_NAME */, {
      appName: String(name)
    });
  }
  options || (options = (0, _util.getDefaultAppConfig)());
  if (!options) {
    throw ERROR_FACTORY.create("no-options" /* NO_OPTIONS */);
  }

  const existingApp = _apps.get(name);
  if (existingApp) {
    // return the existing app if options and config deep equal the ones in the existing app.
    if ((0, _util.deepEqual)(options, existingApp.options) && (0, _util.deepEqual)(config, existingApp.config)) {
      return existingApp;
    } else {
      throw ERROR_FACTORY.create("duplicate-app" /* DUPLICATE_APP */, {
        appName: name
      });
    }
  }
  const container = new _component.ComponentContainer(name);
  for (const component of _components.values()) {
    container.addComponent(component);
  }
  const newApp = new FirebaseAppImpl(options, config, container);
  _apps.set(name, newApp);
  return newApp;
}
/**
 * Retrieves a {@link @firebase/app#FirebaseApp} instance.
 *
 * When called with no arguments, the default app is returned. When an app name
 * is provided, the app corresponding to that name is returned.
 *
 * An exception is thrown if the app being retrieved has not yet been
 * initialized.
 *
 * @example
 * ```javascript
 * // Return the default app
 * const app = getApp();
 * ```
 *
 * @example
 * ```javascript
 * // Return a named app
 * const otherApp = getApp("otherApp");
 * ```
 *
 * @param name - Optional name of the app to return. If no name is
 *   provided, the default is `"[DEFAULT]"`.
 *
 * @returns The app corresponding to the provided app name.
 *   If no app name is provided, the default app is returned.
 *
 * @public
 */
function getApp(name = DEFAULT_ENTRY_NAME) {
  const app = _apps.get(name);
  if (!app && name === DEFAULT_ENTRY_NAME) {
    return initializeApp();
  }
  if (!app) {
    throw ERROR_FACTORY.create("no-app" /* NO_APP */, {
      appName: name
    });
  }
  return app;
}
/**
 * A (read-only) array of all initialized apps.
 * @public
 */
function getApps() {
  return Array.from(_apps.values());
}
/**
 * Renders this app unusable and frees the resources of all associated
 * services.
 *
 * @example
 * ```javascript
 * deleteApp(app)
 *   .then(function() {
 *     console.log("App deleted successfully");
 *   })
 *   .catch(function(error) {
 *     console.log("Error deleting app:", error);
 *   });
 * ```
 *
 * @public
 */
async function deleteApp(app) {
  const name = app.name;
  if (_apps.has(name)) {
    _apps.delete(name);
    await Promise.all(app.container.getProviders().map(provider => provider.delete()));
    app.isDeleted = true;
  }
}
/**
 * Registers a library's name and version for platform logging purposes.
 * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)
 * @param version - Current version of that library.
 * @param variant - Bundle variant, e.g., node, rn, etc.
 *
 * @public
 */
function registerVersion(libraryKeyOrName, version, variant) {
  var _a;
  // TODO: We can use this check to whitelist strings when/if we set up
  // a good whitelist system.
  let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
  if (variant) {
    library += `-${variant}`;
  }
  const libraryMismatch = library.match(/\s|\//);
  const versionMismatch = version.match(/\s|\//);
  if (libraryMismatch || versionMismatch) {
    const warning = [`Unable to register library "${library}" with version "${version}":`];
    if (libraryMismatch) {
      warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
    }
    if (libraryMismatch && versionMismatch) {
      warning.push('and');
    }
    if (versionMismatch) {
      warning.push(`version name "${version}" contains illegal characters (whitespace or "/")`);
    }
    logger.warn(warning.join(' '));
    return;
  }
  _registerComponent(new _component.Component(`${library}-version`, () => ({
    library,
    version
  }), "VERSION" /* VERSION */));
}
/**
 * Sets log handler for all Firebase SDKs.
 * @param logCallback - An optional custom log handler that executes user code whenever
 * the Firebase SDK makes a logging call.
 *
 * @public
 */
function onLog(logCallback, options) {
  if (logCallback !== null && typeof logCallback !== 'function') {
    throw ERROR_FACTORY.create("invalid-log-argument" /* INVALID_LOG_ARGUMENT */);
  }

  (0, _logger.setUserLogHandler)(logCallback, options);
}
/**
 * Sets log level for all Firebase SDKs.
 *
 * All of the log types above the current log level are captured (i.e. if
 * you set the log level to `info`, errors are logged, but `debug` and
 * `verbose` logs are not).
 *
 * @public
 */
function setLogLevel(logLevel) {
  (0, _logger.setLogLevel)(logLevel);
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME = 'firebase-heartbeat-database';
const DB_VERSION = 1;
const STORE_NAME = 'firebase-heartbeat-store';
let dbPromise = null;
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = (0, _idb.openDB)(DB_NAME, DB_VERSION, {
      upgrade: (db, oldVersion) => {
        // We don't use 'break' in this switch statement, the fall-through
        // behavior is what we want, because if there are multiple versions between
        // the old version and the current version, we want ALL the migrations
        // that correspond to those versions to run, not only the last one.
        // eslint-disable-next-line default-case
        switch (oldVersion) {
          case 0:
            db.createObjectStore(STORE_NAME);
        }
      }
    }).catch(e => {
      throw ERROR_FACTORY.create("idb-open" /* IDB_OPEN */, {
        originalErrorMessage: e.message
      });
    });
  }
  return dbPromise;
}
async function readHeartbeatsFromIndexedDB(app) {
  var _a;
  try {
    const db = await getDbPromise();
    return db.transaction(STORE_NAME).objectStore(STORE_NAME).get(computeKey(app));
  } catch (e) {
    if (e instanceof _util.FirebaseError) {
      logger.warn(e.message);
    } else {
      const idbGetError = ERROR_FACTORY.create("idb-get" /* IDB_GET */, {
        originalErrorMessage: (_a = e) === null || _a === void 0 ? void 0 : _a.message
      });
      logger.warn(idbGetError.message);
    }
  }
}
async function writeHeartbeatsToIndexedDB(app, heartbeatObject) {
  var _a;
  try {
    const db = await getDbPromise();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const objectStore = tx.objectStore(STORE_NAME);
    await objectStore.put(heartbeatObject, computeKey(app));
    return tx.done;
  } catch (e) {
    if (e instanceof _util.FirebaseError) {
      logger.warn(e.message);
    } else {
      const idbGetError = ERROR_FACTORY.create("idb-set" /* IDB_WRITE */, {
        originalErrorMessage: (_a = e) === null || _a === void 0 ? void 0 : _a.message
      });
      logger.warn(idbGetError.message);
    }
  }
}
function computeKey(app) {
  return `${app.name}!${app.options.appId}`;
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MAX_HEADER_BYTES = 1024;
// 30 days
const STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;
class HeartbeatServiceImpl {
  constructor(container) {
    this.container = container;
    /**
     * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate
     * the header string.
     * Stores one record per date. This will be consolidated into the standard
     * format of one record per user agent string before being sent as a header.
     * Populated from indexedDB when the controller is instantiated and should
     * be kept in sync with indexedDB.
     * Leave public for easier testing.
     */
    this._heartbeatsCache = null;
    const app = this.container.getProvider('app').getImmediate();
    this._storage = new HeartbeatStorageImpl(app);
    this._heartbeatsCachePromise = this._storage.read().then(result => {
      this._heartbeatsCache = result;
      return result;
    });
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    const platformLogger = this.container.getProvider('platform-logger').getImmediate();
    // This is the "Firebase user agent" string from the platform logger
    // service, not the browser user agent.
    const agent = platformLogger.getPlatformInfoString();
    const date = getUTCDateString();
    if (this._heartbeatsCache === null) {
      this._heartbeatsCache = await this._heartbeatsCachePromise;
    }
    // Do not store a heartbeat if one is already stored for this day
    // or if a header has already been sent today.
    if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {
      return;
    } else {
      // There is no entry for this date. Create one.
      this._heartbeatsCache.heartbeats.push({
        date,
        agent
      });
    }
    // Remove entries older than 30 days.
    this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => {
      const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
      const now = Date.now();
      return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
    });
    return this._storage.overwrite(this._heartbeatsCache);
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    if (this._heartbeatsCache === null) {
      await this._heartbeatsCachePromise;
    }
    // If it's still null or the array is empty, there is no data to send.
    if (this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0) {
      return '';
    }
    const date = getUTCDateString();
    // Extract as many heartbeats from the cache as will fit under the size limit.
    const {
      heartbeatsToSend,
      unsentEntries
    } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
    const headerString = (0, _util.base64urlEncodeWithoutPadding)(JSON.stringify({
      version: 2,
      heartbeats: heartbeatsToSend
    }));
    // Store last sent date to prevent another being logged/sent for the same day.
    this._heartbeatsCache.lastSentHeartbeatDate = date;
    if (unsentEntries.length > 0) {
      // Store any unsent entries if they exist.
      this._heartbeatsCache.heartbeats = unsentEntries;
      // This seems more likely than emptying the array (below) to lead to some odd state
      // since the cache isn't empty and this will be called again on the next request,
      // and is probably safest if we await it.
      await this._storage.overwrite(this._heartbeatsCache);
    } else {
      this._heartbeatsCache.heartbeats = [];
      // Do not wait for this, to reduce latency.
      void this._storage.overwrite(this._heartbeatsCache);
    }
    return headerString;
  }
}
function getUTCDateString() {
  const today = new Date();
  // Returns date format 'YYYY-MM-DD'
  return today.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
  // Heartbeats grouped by user agent in the standard format to be sent in
  // the header.
  const heartbeatsToSend = [];
  // Single date format heartbeats that are not sent.
  let unsentEntries = heartbeatsCache.slice();
  for (const singleDateHeartbeat of heartbeatsCache) {
    // Look for an existing entry with the same user agent.
    const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);
    if (!heartbeatEntry) {
      // If no entry for this user agent exists, create one.
      heartbeatsToSend.push({
        agent: singleDateHeartbeat.agent,
        dates: [singleDateHeartbeat.date]
      });
      if (countBytes(heartbeatsToSend) > maxSize) {
        // If the header would exceed max size, remove the added heartbeat
        // entry and stop adding to the header.
        heartbeatsToSend.pop();
        break;
      }
    } else {
      heartbeatEntry.dates.push(singleDateHeartbeat.date);
      // If the header would exceed max size, remove the added date
      // and stop adding to the header.
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatEntry.dates.pop();
        break;
      }
    }
    // Pop unsent entry from queue. (Skipped if adding the entry exceeded
    // quota and the loop breaks early.)
    unsentEntries = unsentEntries.slice(1);
  }
  return {
    heartbeatsToSend,
    unsentEntries
  };
}
class HeartbeatStorageImpl {
  constructor(app) {
    this.app = app;
    this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    if (!(0, _util.isIndexedDBAvailable)()) {
      return false;
    } else {
      return (0, _util.validateIndexedDBOpenable)().then(() => true).catch(() => false);
    }
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return {
        heartbeats: []
      };
    } else {
      const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
      return idbHeartbeatObject || {
        heartbeats: []
      };
    }
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(heartbeatsObject) {
    var _a;
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return;
    } else {
      const existingHeartbeatsObject = await this.read();
      return writeHeartbeatsToIndexedDB(this.app, {
        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
        heartbeats: heartbeatsObject.heartbeats
      });
    }
  }
  // add heartbeats
  async add(heartbeatsObject) {
    var _a;
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return;
    } else {
      const existingHeartbeatsObject = await this.read();
      return writeHeartbeatsToIndexedDB(this.app, {
        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
        heartbeats: [...existingHeartbeatsObject.heartbeats, ...heartbeatsObject.heartbeats]
      });
    }
  }
}
/**
 * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped
 * in a platform logging header JSON object, stringified, and converted
 * to base 64.
 */
function countBytes(heartbeatsCache) {
  // base64 has a restricted set of characters, all of which should be 1 byte.
  return (0, _util.base64urlEncodeWithoutPadding)(
  // heartbeatsCache wrapper properties
  JSON.stringify({
    version: 2,
    heartbeats: heartbeatsCache
  })).length;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerCoreComponents(variant) {
  _registerComponent(new _component.Component('platform-logger', container => new PlatformLoggerServiceImpl(container), "PRIVATE" /* PRIVATE */));
  _registerComponent(new _component.Component('heartbeat', container => new HeartbeatServiceImpl(container), "PRIVATE" /* PRIVATE */));
  // Register `app` package.
  registerVersion(name$o, version$1, variant);
  // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
  registerVersion(name$o, version$1, 'esm2017');
  // Register platform SDK identifier (no version).
  registerVersion('fire-js', '');
}

/**
 * Firebase App
 *
 * @remarks This package coordinates the communication between the different Firebase components
 * @packageDocumentation
 */
registerCoreComponents('');

},{"@firebase/component":67,"@firebase/logger":69,"@firebase/util":70,"idb":76}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Provider = exports.ComponentContainer = exports.Component = void 0;
var _util = require("@firebase/util");
/**
 * Component for service name T, e.g. `auth`, `auth-internal`
 */
class Component {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(name, instanceFactory, type) {
    this.name = name;
    this.instanceFactory = instanceFactory;
    this.type = type;
    this.multipleInstances = false;
    /**
     * Properties to be added to the service namespace
     */
    this.serviceProps = {};
    this.instantiationMode = "LAZY" /* LAZY */;
    this.onInstanceCreated = null;
  }
  setInstantiationMode(mode) {
    this.instantiationMode = mode;
    return this;
  }
  setMultipleInstances(multipleInstances) {
    this.multipleInstances = multipleInstances;
    return this;
  }
  setServiceProps(props) {
    this.serviceProps = props;
    return this;
  }
  setInstanceCreatedCallback(callback) {
    this.onInstanceCreated = callback;
    return this;
  }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.Component = Component;
const DEFAULT_ENTRY_NAME = '[DEFAULT]';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for instance for service name T, e.g. 'auth', 'auth-internal'
 * NameServiceMapping[T] is an alias for the type of the instance
 */
class Provider {
  constructor(name, container) {
    this.name = name;
    this.container = container;
    this.component = null;
    this.instances = new Map();
    this.instancesDeferred = new Map();
    this.instancesOptions = new Map();
    this.onInitCallbacks = new Map();
  }
  /**
   * @param identifier A provider can provide mulitple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(identifier) {
    // if multipleInstances is not supported, use the default name
    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    if (!this.instancesDeferred.has(normalizedIdentifier)) {
      const deferred = new _util.Deferred();
      this.instancesDeferred.set(normalizedIdentifier, deferred);
      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
        // initialize the service if it can be auto-initialized
        try {
          const instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
          if (instance) {
            deferred.resolve(instance);
          }
        } catch (e) {
          // when the instance factory throws an exception during get(), it should not cause
          // a fatal error. We just return the unresolved promise in this case.
        }
      }
    }
    return this.instancesDeferred.get(normalizedIdentifier).promise;
  }
  getImmediate(options) {
    var _a;
    // if multipleInstances is not supported, use the default name
    const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
    const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
      try {
        return this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
      } catch (e) {
        if (optional) {
          return null;
        } else {
          throw e;
        }
      }
    } else {
      // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw
      if (optional) {
        return null;
      } else {
        throw Error(`Service ${this.name} is not available`);
      }
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(component) {
    if (component.name !== this.name) {
      throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
    }
    if (this.component) {
      throw Error(`Component for ${this.name} has already been provided`);
    }
    this.component = component;
    // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)
    if (!this.shouldAutoInitialize()) {
      return;
    }
    // if the service is eager, initialize the default instance
    if (isComponentEager(component)) {
      try {
        this.getOrInitializeService({
          instanceIdentifier: DEFAULT_ENTRY_NAME
        });
      } catch (e) {
        // when the instance factory for an eager Component throws an exception during the eager
        // initialization, it should not cause a fatal error.
        // TODO: Investigate if we need to make it configurable, because some component may want to cause
        // a fatal error in this case?
      }
    }
    // Create service instances for the pending promises and resolve them
    // NOTE: if this.multipleInstances is false, only the default instance will be created
    // and all promises with resolve with it regardless of the identifier.
    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
      const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      try {
        // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.
        const instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
        instanceDeferred.resolve(instance);
      } catch (e) {
        // when the instance factory throws an exception, it should not cause
        // a fatal error. We just leave the promise unresolved.
      }
    }
  }
  clearInstance(identifier = DEFAULT_ENTRY_NAME) {
    this.instancesDeferred.delete(identifier);
    this.instancesOptions.delete(identifier);
    this.instances.delete(identifier);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const services = Array.from(this.instances.values());
    await Promise.all([...services.filter(service => 'INTERNAL' in service) // legacy services
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    .map(service => service.INTERNAL.delete()), ...services.filter(service => '_delete' in service) // modularized services
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    .map(service => service._delete())]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(identifier = DEFAULT_ENTRY_NAME) {
    return this.instances.has(identifier);
  }
  getOptions(identifier = DEFAULT_ENTRY_NAME) {
    return this.instancesOptions.get(identifier) || {};
  }
  initialize(opts = {}) {
    const {
      options = {}
    } = opts;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
    if (this.isInitialized(normalizedIdentifier)) {
      throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
    }
    if (!this.isComponentSet()) {
      throw Error(`Component ${this.name} has not been registered yet`);
    }
    const instance = this.getOrInitializeService({
      instanceIdentifier: normalizedIdentifier,
      options
    });
    // resolve any pending promise waiting for the service instance
    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
      const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      if (normalizedIdentifier === normalizedDeferredIdentifier) {
        instanceDeferred.resolve(instance);
      }
    }
    return instance;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(callback, identifier) {
    var _a;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
    existingCallbacks.add(callback);
    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
    const existingInstance = this.instances.get(normalizedIdentifier);
    if (existingInstance) {
      callback(existingInstance, normalizedIdentifier);
    }
    return () => {
      existingCallbacks.delete(callback);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(instance, identifier) {
    const callbacks = this.onInitCallbacks.get(identifier);
    if (!callbacks) {
      return;
    }
    for (const callback of callbacks) {
      try {
        callback(instance, identifier);
      } catch (_a) {
        // ignore errors in the onInit callback
      }
    }
  }
  getOrInitializeService({
    instanceIdentifier,
    options = {}
  }) {
    let instance = this.instances.get(instanceIdentifier);
    if (!instance && this.component) {
      instance = this.component.instanceFactory(this.container, {
        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
        options
      });
      this.instances.set(instanceIdentifier, instance);
      this.instancesOptions.set(instanceIdentifier, options);
      /**
       * Invoke onInit listeners.
       * Note this.component.onInstanceCreated is different, which is used by the component creator,
       * while onInit listeners are registered by consumers of the provider.
       */
      this.invokeOnInitCallbacks(instance, instanceIdentifier);
      /**
       * Order is important
       * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which
       * makes `isInitialized()` return true.
       */
      if (this.component.onInstanceCreated) {
        try {
          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
        } catch (_a) {
          // ignore errors in the onInstanceCreatedCallback
        }
      }
    }
    return instance || null;
  }
  normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {
    if (this.component) {
      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
    } else {
      return identifier; // assume multiple instances are supported before the component is provided.
    }
  }

  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT" /* EXPLICIT */;
  }
}
// undefined should be passed to the service factory for the default instance
exports.Provider = Provider;
function normalizeIdentifierForFactory(identifier) {
  return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;
}
function isComponentEager(component) {
  return component.instantiationMode === "EAGER" /* EAGER */;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`
 */
class ComponentContainer {
  constructor(name) {
    this.name = name;
    this.providers = new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(component) {
    const provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
    }
    provider.setComponent(component);
  }
  addOrOverwriteComponent(component) {
    const provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      // delete the existing provider from the container, so we can register the new component
      this.providers.delete(component.name);
    }
    this.addComponent(component);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(name) {
    if (this.providers.has(name)) {
      return this.providers.get(name);
    }
    // create a Provider for a service that hasn't registered with Firebase
    const provider = new Provider(name, this);
    this.providers.set(name, provider);
    return provider;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
exports.ComponentContainer = ComponentContainer;

},{"@firebase/util":70}],68:[function(require,module,exports){
(function (process){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports._TEST_ACCESS_hijackHash=exports._TEST_ACCESS_forceRestClient=exports._ReferenceImpl=exports._QueryParams=exports._QueryImpl=exports.TransactionResult=exports.QueryConstraint=exports.OnDisconnect=exports.Database=exports.DataSnapshot=void 0;exports._repoManagerDatabaseFromApp=repoManagerDatabaseFromApp;exports._setSDKVersion=setSDKVersion;exports._validateWritablePath=exports._validatePathString=void 0;exports.child=child;exports.connectDatabaseEmulator=connectDatabaseEmulator;exports.enableLogging=enableLogging;exports.endAt=endAt;exports.endBefore=endBefore;exports.equalTo=equalTo;exports.forceLongPolling=forceLongPolling;exports.forceWebSockets=forceWebSockets;exports.get=get;exports.getDatabase=getDatabase;exports.goOffline=goOffline;exports.goOnline=goOnline;exports.increment=increment;exports.limitToFirst=limitToFirst;exports.limitToLast=limitToLast;exports.off=off;exports.onChildAdded=onChildAdded;exports.onChildChanged=onChildChanged;exports.onChildMoved=onChildMoved;exports.onChildRemoved=onChildRemoved;exports.onDisconnect=onDisconnect;exports.onValue=onValue;exports.orderByChild=orderByChild;exports.orderByKey=orderByKey;exports.orderByPriority=orderByPriority;exports.orderByValue=orderByValue;exports.push=push;exports.query=query;exports.ref=ref;exports.refFromURL=refFromURL;exports.remove=remove;exports.runTransaction=runTransaction;exports.serverTimestamp=serverTimestamp;exports.set=set;exports.setPriority=setPriority;exports.setWithPriority=setWithPriority;exports.startAfter=startAfter;exports.startAt=startAt;exports.update=update;var _app=require("@firebase/app");var _component=require("@firebase/component");var _util=require("@firebase/util");var _logger=require("@firebase/logger");const name="@firebase/database";const version="0.13.10";/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** The semver (www.semver.org) version of the SDK. */let SDK_VERSION='';/**
 * SDK_VERSION should be set before any database instance is created
 * @internal
 */function setSDKVersion(version){SDK_VERSION=version;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Wraps a DOM Storage object and:
 * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.
 * - prefixes names with "firebase:" to avoid collisions with app data.
 *
 * We automatically (see storage.js) create two such wrappers, one for sessionStorage,
 * and one for localStorage.
 *
 */class DOMStorageWrapper{/**
     * @param domStorage_ - The underlying storage object (e.g. localStorage or sessionStorage)
     */constructor(domStorage_){this.domStorage_=domStorage_;// Use a prefix to avoid collisions with other stuff saved by the app.
this.prefix_='firebase:';}/**
     * @param key - The key to save the value under
     * @param value - The value being stored, or null to remove the key.
     */set(key,value){if(value==null){this.domStorage_.removeItem(this.prefixedName_(key));}else{this.domStorage_.setItem(this.prefixedName_(key),(0,_util.stringify)(value));}}/**
     * @returns The value that was stored under this key, or null
     */get(key){const storedVal=this.domStorage_.getItem(this.prefixedName_(key));if(storedVal==null){return null;}else{return(0,_util.jsonEval)(storedVal);}}remove(key){this.domStorage_.removeItem(this.prefixedName_(key));}prefixedName_(name){return this.prefix_+name;}toString(){return this.domStorage_.toString();}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An in-memory storage implementation that matches the API of DOMStorageWrapper
 * (TODO: create interface for both to implement).
 */class MemoryStorage{constructor(){this.cache_={};this.isInMemoryStorage=true;}set(key,value){if(value==null){delete this.cache_[key];}else{this.cache_[key]=value;}}get(key){if((0,_util.contains)(this.cache_,key)){return this.cache_[key];}return null;}remove(key){delete this.cache_[key];}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.
 * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change
 * to reflect this type
 *
 * @param domStorageName - Name of the underlying storage object
 *   (e.g. 'localStorage' or 'sessionStorage').
 * @returns Turning off type information until a common interface is defined.
 */const createStoragefor=function(domStorageName){try{// NOTE: just accessing "localStorage" or "window['localStorage']" may throw a security exception,
// so it must be inside the try/catch.
if(typeof window!=='undefined'&&typeof window[domStorageName]!=='undefined'){// Need to test cache. Just because it's here doesn't mean it works
const domStorage=window[domStorageName];domStorage.setItem('firebase:sentinel','cache');domStorage.removeItem('firebase:sentinel');return new DOMStorageWrapper(domStorage);}}catch(e){}// Failed to create wrapper.  Just return in-memory storage.
// TODO: log?
return new MemoryStorage();};/** A storage object that lasts across sessions */const PersistentStorage=createStoragefor('localStorage');/** A storage object that only lasts one session */const SessionStorage=createStoragefor('sessionStorage');/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const logClient=new _logger.Logger('@firebase/database');/**
 * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).
 */const LUIDGenerator=function(){let id=1;return function(){return id++;};}();/**
 * Sha1 hash of the input string
 * @param str - The string to hash
 * @returns {!string} The resulting hash
 */const sha1=function(str){const utf8Bytes=(0,_util.stringToByteArray)(str);const sha1=new _util.Sha1();sha1.update(utf8Bytes);const sha1Bytes=sha1.digest();return _util.base64.encodeByteArray(sha1Bytes);};const buildLogMessage_=function(...varArgs){let message='';for(let i=0;i<varArgs.length;i++){const arg=varArgs[i];if(Array.isArray(arg)||arg&&typeof arg==='object'&&// eslint-disable-next-line @typescript-eslint/no-explicit-any
typeof arg.length==='number'){message+=buildLogMessage_.apply(null,arg);}else if(typeof arg==='object'){message+=(0,_util.stringify)(arg);}else{message+=arg;}message+=' ';}return message;};/**
 * Use this for all debug messages in Firebase.
 */let logger=null;/**
 * Flag to check for log availability on first log message
 */let firstLog_=true;/**
 * The implementation of Firebase.enableLogging (defined here to break dependencies)
 * @param logger_ - A flag to turn on logging, or a custom logger
 * @param persistent - Whether or not to persist logging settings across refreshes
 */const enableLogging$1=function(logger_,persistent){(0,_util.assert)(!persistent||logger_===true||logger_===false,"Can't turn on custom loggers persistently.");if(logger_===true){logClient.logLevel=_logger.LogLevel.VERBOSE;logger=logClient.log.bind(logClient);if(persistent){SessionStorage.set('logging_enabled',true);}}else if(typeof logger_==='function'){logger=logger_;}else{logger=null;SessionStorage.remove('logging_enabled');}};const log=function(...varArgs){if(firstLog_===true){firstLog_=false;if(logger===null&&SessionStorage.get('logging_enabled')===true){enableLogging$1(true);}}if(logger){const message=buildLogMessage_.apply(null,varArgs);logger(message);}};const logWrapper=function(prefix){return function(...varArgs){log(prefix,...varArgs);};};const error=function(...varArgs){const message='FIREBASE INTERNAL ERROR: '+buildLogMessage_(...varArgs);logClient.error(message);};const fatal=function(...varArgs){const message=`FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;logClient.error(message);throw new Error(message);};const warn=function(...varArgs){const message='FIREBASE WARNING: '+buildLogMessage_(...varArgs);logClient.warn(message);};/**
 * Logs a warning if the containing page uses https. Called when a call to new Firebase
 * does not use https.
 */const warnIfPageIsSecure=function(){// Be very careful accessing browser globals. Who knows what may or may not exist.
if(typeof window!=='undefined'&&window.location&&window.location.protocol&&window.location.protocol.indexOf('https:')!==-1){warn('Insecure Firebase access from a secure page. '+'Please use https in calls to new Firebase().');}};/**
 * Returns true if data is NaN, or +/- Infinity.
 */const isInvalidJSONNumber=function(data){return typeof data==='number'&&(data!==data||// NaN
data===Number.POSITIVE_INFINITY||data===Number.NEGATIVE_INFINITY);};const executeWhenDOMReady=function(fn){if((0,_util.isNodeSdk)()||document.readyState==='complete'){fn();}else{// Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which
// fire before onload), but fall back to onload.
let called=false;const wrappedFn=function(){if(!document.body){setTimeout(wrappedFn,Math.floor(10));return;}if(!called){called=true;fn();}};if(document.addEventListener){document.addEventListener('DOMContentLoaded',wrappedFn,false);// fallback to onload.
window.addEventListener('load',wrappedFn,false);// eslint-disable-next-line @typescript-eslint/no-explicit-any
}else if(document.attachEvent){// IE.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
document.attachEvent('onreadystatechange',()=>{if(document.readyState==='complete'){wrappedFn();}});// fallback to onload.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
window.attachEvent('onload',wrappedFn);// jQuery has an extra hack for IE that we could employ (based on
// http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.
// I'm hoping we don't need it.
}}};/**
 * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names
 */const MIN_NAME='[MIN_NAME]';/**
 * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names
 */const MAX_NAME='[MAX_NAME]';/**
 * Compares valid Firebase key names, plus min and max name
 */const nameCompare=function(a,b){if(a===b){return 0;}else if(a===MIN_NAME||b===MAX_NAME){return-1;}else if(b===MIN_NAME||a===MAX_NAME){return 1;}else{const aAsInt=tryParseInt(a),bAsInt=tryParseInt(b);if(aAsInt!==null){if(bAsInt!==null){return aAsInt-bAsInt===0?a.length-b.length:aAsInt-bAsInt;}else{return-1;}}else if(bAsInt!==null){return 1;}else{return a<b?-1:1;}}};/**
 * @returns {!number} comparison result.
 */const stringCompare=function(a,b){if(a===b){return 0;}else if(a<b){return-1;}else{return 1;}};const requireKey=function(key,obj){if(obj&&key in obj){return obj[key];}else{throw new Error('Missing required key ('+key+') in object: '+(0,_util.stringify)(obj));}};const ObjectToUniqueKey=function(obj){if(typeof obj!=='object'||obj===null){return(0,_util.stringify)(obj);}const keys=[];// eslint-disable-next-line guard-for-in
for(const k in obj){keys.push(k);}// Export as json, but with the keys sorted.
keys.sort();let key='{';for(let i=0;i<keys.length;i++){if(i!==0){key+=',';}key+=(0,_util.stringify)(keys[i]);key+=':';key+=ObjectToUniqueKey(obj[keys[i]]);}key+='}';return key;};/**
 * Splits a string into a number of smaller segments of maximum size
 * @param str - The string
 * @param segsize - The maximum number of chars in the string.
 * @returns The string, split into appropriately-sized chunks
 */const splitStringBySize=function(str,segsize){const len=str.length;if(len<=segsize){return[str];}const dataSegs=[];for(let c=0;c<len;c+=segsize){if(c+segsize>len){dataSegs.push(str.substring(c,len));}else{dataSegs.push(str.substring(c,c+segsize));}}return dataSegs;};/**
 * Apply a function to each (key, value) pair in an object or
 * apply a function to each (index, value) pair in an array
 * @param obj - The object or array to iterate over
 * @param fn - The function to apply
 */function each(obj,fn){for(const key in obj){if(obj.hasOwnProperty(key)){fn(key,obj[key]);}}}/**
 * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)
 * I made one modification at the end and removed the NaN / Infinity
 * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.
 * @param v - A double
 *
 */const doubleToIEEE754String=function(v){(0,_util.assert)(!isInvalidJSONNumber(v),'Invalid JSON number');// MJL
const ebits=11,fbits=52;const bias=(1<<ebits-1)-1;let s,e,f,ln,i;// Compute sign, exponent, fraction
// Skip NaN / Infinity handling --MJL.
if(v===0){e=0;f=0;s=1/v===-Infinity?1:0;}else{s=v<0;v=Math.abs(v);if(v>=Math.pow(2,1-bias)){// Normalized
ln=Math.min(Math.floor(Math.log(v)/Math.LN2),bias);e=ln+bias;f=Math.round(v*Math.pow(2,fbits-ln)-Math.pow(2,fbits));}else{// Denormalized
e=0;f=Math.round(v/Math.pow(2,1-bias-fbits));}}// Pack sign, exponent, fraction
const bits=[];for(i=fbits;i;i-=1){bits.push(f%2?1:0);f=Math.floor(f/2);}for(i=ebits;i;i-=1){bits.push(e%2?1:0);e=Math.floor(e/2);}bits.push(s?1:0);bits.reverse();const str=bits.join('');// Return the data as a hex string. --MJL
let hexByteString='';for(i=0;i<64;i+=8){let hexByte=parseInt(str.substr(i,8),2).toString(16);if(hexByte.length===1){hexByte='0'+hexByte;}hexByteString=hexByteString+hexByte;}return hexByteString.toLowerCase();};/**
 * Used to detect if we're in a Chrome content script (which executes in an
 * isolated environment where long-polling doesn't work).
 */const isChromeExtensionContentScript=function(){return!!(typeof window==='object'&&window['chrome']&&window['chrome']['extension']&&!/^chrome/.test(window.location.href));};/**
 * Used to detect if we're in a Windows 8 Store app.
 */const isWindowsStoreApp=function(){// Check for the presence of a couple WinRT globals
return typeof Windows==='object'&&typeof Windows.UI==='object';};/**
 * Converts a server error code to a Javascript Error
 */function errorForServerCode(code,query){let reason='Unknown Error';if(code==='too_big'){reason='The data requested exceeds the maximum size '+'that can be accessed with a single request.';}else if(code==='permission_denied'){reason="Client doesn't have permission to access the desired data.";}else if(code==='unavailable'){reason='The service is unavailable';}const error=new Error(code+' at '+query._path.toString()+': '+reason);// eslint-disable-next-line @typescript-eslint/no-explicit-any
error.code=code.toUpperCase();return error;}/**
 * Used to test for integer-looking strings
 */const INTEGER_REGEXP_=new RegExp('^-?(0*)\\d{1,10}$');/**
 * For use in keys, the minimum possible 32-bit integer.
 */const INTEGER_32_MIN=-2147483648;/**
 * For use in kyes, the maximum possible 32-bit integer.
 */const INTEGER_32_MAX=2147483647;/**
 * If the string contains a 32-bit integer, return it.  Else return null.
 */const tryParseInt=function(str){if(INTEGER_REGEXP_.test(str)){const intVal=Number(str);if(intVal>=INTEGER_32_MIN&&intVal<=INTEGER_32_MAX){return intVal;}}return null;};/**
 * Helper to run some code but catch any exceptions and re-throw them later.
 * Useful for preventing user callbacks from breaking internal code.
 *
 * Re-throwing the exception from a setTimeout is a little evil, but it's very
 * convenient (we don't have to try to figure out when is a safe point to
 * re-throw it), and the behavior seems reasonable:
 *
 * * If you aren't pausing on exceptions, you get an error in the console with
 *   the correct stack trace.
 * * If you're pausing on all exceptions, the debugger will pause on your
 *   exception and then again when we rethrow it.
 * * If you're only pausing on uncaught exceptions, the debugger will only pause
 *   on us re-throwing it.
 *
 * @param fn - The code to guard.
 */const exceptionGuard=function(fn){try{fn();}catch(e){// Re-throw exception when it's safe.
setTimeout(()=>{// It used to be that "throw e" would result in a good console error with
// relevant context, but as of Chrome 39, you just get the firebase.js
// file/line number where we re-throw it, which is useless. So we log
// e.stack explicitly.
const stack=e.stack||'';warn('Exception was thrown by user callback.',stack);throw e;},Math.floor(0));}};/**
 * @returns {boolean} true if we think we're currently being crawled.
 */const beingCrawled=function(){const userAgent=typeof window==='object'&&window['navigator']&&window['navigator']['userAgent']||'';// For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we
// believe to support JavaScript/AJAX rendering.
// NOTE: Google Webmaster Tools doesn't really belong, but their "This is how a visitor to your website
// would have seen the page" is flaky if we don't treat it as a crawler.
return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i)>=0;};/**
 * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.
 *
 * It is removed with clearTimeout() as normal.
 *
 * @param fn - Function to run.
 * @param time - Milliseconds to wait before running.
 * @returns The setTimeout() return value.
 */const setTimeoutNonBlocking=function(fn,time){const timeout=setTimeout(fn,time);// Note: at the time of this comment, unrefTimer is under the unstable set of APIs. Run with --unstable to enable the API.
if(typeof timeout==='number'&&// @ts-ignore Is only defined in Deno environments.
typeof Deno!=='undefined'&&// @ts-ignore Deno and unrefTimer are only defined in Deno environments.
Deno['unrefTimer']){// @ts-ignore Deno and unrefTimer are only defined in Deno environments.
Deno.unrefTimer(timeout);// eslint-disable-next-line @typescript-eslint/no-explicit-any
}else if(typeof timeout==='object'&&timeout['unref']){// eslint-disable-next-line @typescript-eslint/no-explicit-any
timeout['unref']();}return timeout;};/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Abstraction around AppCheck's token fetching capabilities.
 */class AppCheckTokenProvider{constructor(appName_,appCheckProvider){this.appName_=appName_;this.appCheckProvider=appCheckProvider;this.appCheck=appCheckProvider===null||appCheckProvider===void 0?void 0:appCheckProvider.getImmediate({optional:true});if(!this.appCheck){appCheckProvider===null||appCheckProvider===void 0?void 0:appCheckProvider.get().then(appCheck=>this.appCheck=appCheck);}}getToken(forceRefresh){if(!this.appCheck){return new Promise((resolve,reject)=>{// Support delayed initialization of FirebaseAppCheck. This allows our
// customers to initialize the RTDB SDK before initializing Firebase
// AppCheck and ensures that all requests are authenticated if a token
// becomes available before the timoeout below expires.
setTimeout(()=>{if(this.appCheck){this.getToken(forceRefresh).then(resolve,reject);}else{resolve(null);}},0);});}return this.appCheck.getToken(forceRefresh);}addTokenChangeListener(listener){var _a;(_a=this.appCheckProvider)===null||_a===void 0?void 0:_a.get().then(appCheck=>appCheck.addTokenListener(listener));}notifyForInvalidToken(){warn(`Provided AppCheck credentials for the app named "${this.appName_}" `+'are invalid. This usually indicates your app was not initialized correctly.');}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Abstraction around FirebaseApp's token fetching capabilities.
 */class FirebaseAuthTokenProvider{constructor(appName_,firebaseOptions_,authProvider_){this.appName_=appName_;this.firebaseOptions_=firebaseOptions_;this.authProvider_=authProvider_;this.auth_=null;this.auth_=authProvider_.getImmediate({optional:true});if(!this.auth_){authProvider_.onInit(auth=>this.auth_=auth);}}getToken(forceRefresh){if(!this.auth_){return new Promise((resolve,reject)=>{// Support delayed initialization of FirebaseAuth. This allows our
// customers to initialize the RTDB SDK before initializing Firebase
// Auth and ensures that all requests are authenticated if a token
// becomes available before the timoeout below expires.
setTimeout(()=>{if(this.auth_){this.getToken(forceRefresh).then(resolve,reject);}else{resolve(null);}},0);});}return this.auth_.getToken(forceRefresh).catch(error=>{// TODO: Need to figure out all the cases this is raised and whether
// this makes sense.
if(error&&error.code==='auth/token-not-initialized'){log('Got auth/token-not-initialized error.  Treating as null token.');return null;}else{return Promise.reject(error);}});}addTokenChangeListener(listener){// TODO: We might want to wrap the listener and call it with no args to
// avoid a leaky abstraction, but that makes removing the listener harder.
if(this.auth_){this.auth_.addAuthTokenListener(listener);}else{this.authProvider_.get().then(auth=>auth.addAuthTokenListener(listener));}}removeTokenChangeListener(listener){this.authProvider_.get().then(auth=>auth.removeAuthTokenListener(listener));}notifyForInvalidToken(){let errorMessage='Provided authentication credentials for the app named "'+this.appName_+'" are invalid. This usually indicates your app was not '+'initialized correctly. ';if('credential'in this.firebaseOptions_){errorMessage+='Make sure the "credential" property provided to initializeApp() '+'is authorized to access the specified "databaseURL" and is from the correct '+'project.';}else if('serviceAccount'in this.firebaseOptions_){errorMessage+='Make sure the "serviceAccount" property provided to initializeApp() '+'is authorized to access the specified "databaseURL" and is from the correct '+'project.';}else{errorMessage+='Make sure the "apiKey" and "databaseURL" properties provided to '+'initializeApp() match the values provided for your app at '+'https://console.firebase.google.com/.';}warn(errorMessage);}}/* AuthTokenProvider that supplies a constant token. Used by Admin SDK or mockUserToken with emulators. */class EmulatorTokenProvider{constructor(accessToken){this.accessToken=accessToken;}getToken(forceRefresh){return Promise.resolve({accessToken:this.accessToken});}addTokenChangeListener(listener){// Invoke the listener immediately to match the behavior in Firebase Auth
// (see packages/auth/src/auth.js#L1807)
listener(this.accessToken);}removeTokenChangeListener(listener){}notifyForInvalidToken(){}}/** A string that is treated as an admin access token by the RTDB emulator. Used by Admin SDK. */EmulatorTokenProvider.OWNER='owner';/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const PROTOCOL_VERSION='5';const VERSION_PARAM='v';const TRANSPORT_SESSION_PARAM='s';const REFERER_PARAM='r';const FORGE_REF='f';// Matches console.firebase.google.com, firebase-console-*.corp.google.com and
// firebase.corp.google.com
const FORGE_DOMAIN_RE=/(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;const LAST_SESSION_PARAM='ls';const APPLICATION_ID_PARAM='p';const APP_CHECK_TOKEN_PARAM='ac';const WEBSOCKET='websocket';const LONG_POLLING='long_polling';/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A class that holds metadata about a Repo object
 */class RepoInfo{/**
     * @param host - Hostname portion of the url for the repo
     * @param secure - Whether or not this repo is accessed over ssl
     * @param namespace - The namespace represented by the repo
     * @param webSocketOnly - Whether to prefer websockets over all other transports (used by Nest).
     * @param nodeAdmin - Whether this instance uses Admin SDK credentials
     * @param persistenceKey - Override the default session persistence storage key
     */constructor(host,secure,namespace,webSocketOnly,nodeAdmin=false,persistenceKey='',includeNamespaceInQueryParams=false){this.secure=secure;this.namespace=namespace;this.webSocketOnly=webSocketOnly;this.nodeAdmin=nodeAdmin;this.persistenceKey=persistenceKey;this.includeNamespaceInQueryParams=includeNamespaceInQueryParams;this._host=host.toLowerCase();this._domain=this._host.substr(this._host.indexOf('.')+1);this.internalHost=PersistentStorage.get('host:'+host)||this._host;}isCacheableHost(){return this.internalHost.substr(0,2)==='s-';}isCustomHost(){return this._domain!=='firebaseio.com'&&this._domain!=='firebaseio-demo.com';}get host(){return this._host;}set host(newHost){if(newHost!==this.internalHost){this.internalHost=newHost;if(this.isCacheableHost()){PersistentStorage.set('host:'+this._host,this.internalHost);}}}toString(){let str=this.toURLString();if(this.persistenceKey){str+='<'+this.persistenceKey+'>';}return str;}toURLString(){const protocol=this.secure?'https://':'http://';const query=this.includeNamespaceInQueryParams?`?ns=${this.namespace}`:'';return`${protocol}${this.host}/${query}`;}}function repoInfoNeedsQueryParam(repoInfo){return repoInfo.host!==repoInfo.internalHost||repoInfo.isCustomHost()||repoInfo.includeNamespaceInQueryParams;}/**
 * Returns the websocket URL for this repo
 * @param repoInfo - RepoInfo object
 * @param type - of connection
 * @param params - list
 * @returns The URL for this repo
 */function repoInfoConnectionURL(repoInfo,type,params){(0,_util.assert)(typeof type==='string','typeof type must == string');(0,_util.assert)(typeof params==='object','typeof params must == object');let connURL;if(type===WEBSOCKET){connURL=(repoInfo.secure?'wss://':'ws://')+repoInfo.internalHost+'/.ws?';}else if(type===LONG_POLLING){connURL=(repoInfo.secure?'https://':'http://')+repoInfo.internalHost+'/.lp?';}else{throw new Error('Unknown connection type: '+type);}if(repoInfoNeedsQueryParam(repoInfo)){params['ns']=repoInfo.namespace;}const pairs=[];each(params,(key,value)=>{pairs.push(key+'='+value);});return connURL+pairs.join('&');}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Tracks a collection of stats.
 */class StatsCollection{constructor(){this.counters_={};}incrementCounter(name,amount=1){if(!(0,_util.contains)(this.counters_,name)){this.counters_[name]=0;}this.counters_[name]+=amount;}get(){return(0,_util.deepCopy)(this.counters_);}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const collections={};const reporters={};function statsManagerGetCollection(repoInfo){const hashString=repoInfo.toString();if(!collections[hashString]){collections[hashString]=new StatsCollection();}return collections[hashString];}function statsManagerGetOrCreateReporter(repoInfo,creatorFunction){const hashString=repoInfo.toString();if(!reporters[hashString]){reporters[hashString]=creatorFunction();}return reporters[hashString];}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * This class ensures the packets from the server arrive in order
 * This class takes data from the server and ensures it gets passed into the callbacks in order.
 */class PacketReceiver{/**
     * @param onMessage_
     */constructor(onMessage_){this.onMessage_=onMessage_;this.pendingResponses=[];this.currentResponseNum=0;this.closeAfterResponse=-1;this.onClose=null;}closeAfter(responseNum,callback){this.closeAfterResponse=responseNum;this.onClose=callback;if(this.closeAfterResponse<this.currentResponseNum){this.onClose();this.onClose=null;}}/**
     * Each message from the server comes with a response number, and an array of data. The responseNumber
     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all
     * browsers will respond in the same order as the requests we sent
     */handleResponse(requestNum,data){this.pendingResponses[requestNum]=data;while(this.pendingResponses[this.currentResponseNum]){const toProcess=this.pendingResponses[this.currentResponseNum];delete this.pendingResponses[this.currentResponseNum];for(let i=0;i<toProcess.length;++i){if(toProcess[i]){exceptionGuard(()=>{this.onMessage_(toProcess[i]);});}}if(this.currentResponseNum===this.closeAfterResponse){if(this.onClose){this.onClose();this.onClose=null;}break;}this.currentResponseNum++;}}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // URL query parameters associated with longpolling
const FIREBASE_LONGPOLL_START_PARAM='start';const FIREBASE_LONGPOLL_CLOSE_COMMAND='close';const FIREBASE_LONGPOLL_COMMAND_CB_NAME='pLPCommand';const FIREBASE_LONGPOLL_DATA_CB_NAME='pRTLPCB';const FIREBASE_LONGPOLL_ID_PARAM='id';const FIREBASE_LONGPOLL_PW_PARAM='pw';const FIREBASE_LONGPOLL_SERIAL_PARAM='ser';const FIREBASE_LONGPOLL_CALLBACK_ID_PARAM='cb';const FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM='seg';const FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET='ts';const FIREBASE_LONGPOLL_DATA_PARAM='d';const FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM='dframe';//Data size constants.
//TODO: Perf: the maximum length actually differs from browser to browser.
// We should check what browser we're on and set accordingly.
const MAX_URL_DATA_SIZE=1870;const SEG_HEADER_SIZE=30;//ie: &seg=8299234&ts=982389123&d=
const MAX_PAYLOAD_SIZE=MAX_URL_DATA_SIZE-SEG_HEADER_SIZE;/**
 * Keepalive period
 * send a fresh request at minimum every 25 seconds. Opera has a maximum request
 * length of 30 seconds that we can't exceed.
 */const KEEPALIVE_REQUEST_INTERVAL=25000;/**
 * How long to wait before aborting a long-polling connection attempt.
 */const LP_CONNECT_TIMEOUT=30000;/**
 * This class manages a single long-polling connection.
 */class BrowserPollConnection{/**
     * @param connId An identifier for this connection, used for logging
     * @param repoInfo The info for the endpoint to send data to.
     * @param applicationId The Firebase App ID for this project.
     * @param appCheckToken The AppCheck token for this client.
     * @param authToken The AuthToken to use for this connection.
     * @param transportSessionId Optional transportSessionid if we are
     * reconnecting for an existing transport session
     * @param lastSessionId Optional lastSessionId if the PersistentConnection has
     * already created a connection previously
     */constructor(connId,repoInfo,applicationId,appCheckToken,authToken,transportSessionId,lastSessionId){this.connId=connId;this.repoInfo=repoInfo;this.applicationId=applicationId;this.appCheckToken=appCheckToken;this.authToken=authToken;this.transportSessionId=transportSessionId;this.lastSessionId=lastSessionId;this.bytesSent=0;this.bytesReceived=0;this.everConnected_=false;this.log_=logWrapper(connId);this.stats_=statsManagerGetCollection(repoInfo);this.urlFn=params=>{// Always add the token if we have one.
if(this.appCheckToken){params[APP_CHECK_TOKEN_PARAM]=this.appCheckToken;}return repoInfoConnectionURL(repoInfo,LONG_POLLING,params);};}/**
     * @param onMessage - Callback when messages arrive
     * @param onDisconnect - Callback with connection lost.
     */open(onMessage,onDisconnect){this.curSegmentNum=0;this.onDisconnect_=onDisconnect;this.myPacketOrderer=new PacketReceiver(onMessage);this.isClosed_=false;this.connectTimeoutTimer_=setTimeout(()=>{this.log_('Timed out trying to connect.');// Make sure we clear the host cache
this.onClosed_();this.connectTimeoutTimer_=null;// eslint-disable-next-line @typescript-eslint/no-explicit-any
},Math.floor(LP_CONNECT_TIMEOUT));// Ensure we delay the creation of the iframe until the DOM is loaded.
executeWhenDOMReady(()=>{if(this.isClosed_){return;}//Set up a callback that gets triggered once a connection is set up.
this.scriptTagHolder=new FirebaseIFrameScriptHolder((...args)=>{const[command,arg1,arg2,arg3,arg4]=args;this.incrementIncomingBytes_(args);if(!this.scriptTagHolder){return;// we closed the connection.
}if(this.connectTimeoutTimer_){clearTimeout(this.connectTimeoutTimer_);this.connectTimeoutTimer_=null;}this.everConnected_=true;if(command===FIREBASE_LONGPOLL_START_PARAM){this.id=arg1;this.password=arg2;}else if(command===FIREBASE_LONGPOLL_CLOSE_COMMAND){// Don't clear the host cache. We got a response from the server, so we know it's reachable
if(arg1){// We aren't expecting any more data (other than what the server's already in the process of sending us
// through our already open polls), so don't send any more.
this.scriptTagHolder.sendNewPolls=false;// arg1 in this case is the last response number sent by the server. We should try to receive
// all of the responses up to this one before closing
this.myPacketOrderer.closeAfter(arg1,()=>{this.onClosed_();});}else{this.onClosed_();}}else{throw new Error('Unrecognized command received: '+command);}},(...args)=>{const[pN,data]=args;this.incrementIncomingBytes_(args);this.myPacketOrderer.handleResponse(pN,data);},()=>{this.onClosed_();},this.urlFn);//Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results
//from cache.
const urlParams={};urlParams[FIREBASE_LONGPOLL_START_PARAM]='t';urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM]=Math.floor(Math.random()*100000000);if(this.scriptTagHolder.uniqueCallbackIdentifier){urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM]=this.scriptTagHolder.uniqueCallbackIdentifier;}urlParams[VERSION_PARAM]=PROTOCOL_VERSION;if(this.transportSessionId){urlParams[TRANSPORT_SESSION_PARAM]=this.transportSessionId;}if(this.lastSessionId){urlParams[LAST_SESSION_PARAM]=this.lastSessionId;}if(this.applicationId){urlParams[APPLICATION_ID_PARAM]=this.applicationId;}if(this.appCheckToken){urlParams[APP_CHECK_TOKEN_PARAM]=this.appCheckToken;}if(typeof location!=='undefined'&&location.hostname&&FORGE_DOMAIN_RE.test(location.hostname)){urlParams[REFERER_PARAM]=FORGE_REF;}const connectURL=this.urlFn(urlParams);this.log_('Connecting via long-poll to '+connectURL);this.scriptTagHolder.addTag(connectURL,()=>{/* do nothing */});});}/**
     * Call this when a handshake has completed successfully and we want to consider the connection established
     */start(){this.scriptTagHolder.startLongPoll(this.id,this.password);this.addDisconnectPingFrame(this.id,this.password);}/**
     * Forces long polling to be considered as a potential transport
     */static forceAllow(){BrowserPollConnection.forceAllow_=true;}/**
     * Forces longpolling to not be considered as a potential transport
     */static forceDisallow(){BrowserPollConnection.forceDisallow_=true;}// Static method, use string literal so it can be accessed in a generic way
static isAvailable(){if((0,_util.isNodeSdk)()){return false;}else if(BrowserPollConnection.forceAllow_){return true;}else{// NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in
// the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).
return!BrowserPollConnection.forceDisallow_&&typeof document!=='undefined'&&document.createElement!=null&&!isChromeExtensionContentScript()&&!isWindowsStoreApp();}}/**
     * No-op for polling
     */markConnectionHealthy(){}/**
     * Stops polling and cleans up the iframe
     */shutdown_(){this.isClosed_=true;if(this.scriptTagHolder){this.scriptTagHolder.close();this.scriptTagHolder=null;}//remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.
if(this.myDisconnFrame){document.body.removeChild(this.myDisconnFrame);this.myDisconnFrame=null;}if(this.connectTimeoutTimer_){clearTimeout(this.connectTimeoutTimer_);this.connectTimeoutTimer_=null;}}/**
     * Triggered when this transport is closed
     */onClosed_(){if(!this.isClosed_){this.log_('Longpoll is closing itself');this.shutdown_();if(this.onDisconnect_){this.onDisconnect_(this.everConnected_);this.onDisconnect_=null;}}}/**
     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server
     * that we've left.
     */close(){if(!this.isClosed_){this.log_('Longpoll is being closed.');this.shutdown_();}}/**
     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then
     * broken into chunks (since URLs have a small maximum length).
     * @param data - The JSON data to transmit.
     */send(data){const dataStr=(0,_util.stringify)(data);this.bytesSent+=dataStr.length;this.stats_.incrementCounter('bytes_sent',dataStr.length);//first, lets get the base64-encoded data
const base64data=(0,_util.base64Encode)(dataStr);//We can only fit a certain amount in each URL, so we need to split this request
//up into multiple pieces if it doesn't fit in one request.
const dataSegs=splitStringBySize(base64data,MAX_PAYLOAD_SIZE);//Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number
//of segments so that we can reassemble the packet on the server.
for(let i=0;i<dataSegs.length;i++){this.scriptTagHolder.enqueueSegment(this.curSegmentNum,dataSegs.length,dataSegs[i]);this.curSegmentNum++;}}/**
     * This is how we notify the server that we're leaving.
     * We aren't able to send requests with DHTML on a window close event, but we can
     * trigger XHR requests in some browsers (everything but Opera basically).
     */addDisconnectPingFrame(id,pw){if((0,_util.isNodeSdk)()){return;}this.myDisconnFrame=document.createElement('iframe');const urlParams={};urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM]='t';urlParams[FIREBASE_LONGPOLL_ID_PARAM]=id;urlParams[FIREBASE_LONGPOLL_PW_PARAM]=pw;this.myDisconnFrame.src=this.urlFn(urlParams);this.myDisconnFrame.style.display='none';document.body.appendChild(this.myDisconnFrame);}/**
     * Used to track the bytes received by this client
     */incrementIncomingBytes_(args){// TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.
const bytesReceived=(0,_util.stringify)(args).length;this.bytesReceived+=bytesReceived;this.stats_.incrementCounter('bytes_received',bytesReceived);}}/*********************************************************************************************
 * A wrapper around an iframe that is used as a long-polling script holder.
 *********************************************************************************************/class FirebaseIFrameScriptHolder{/**
     * @param commandCB - The callback to be called when control commands are recevied from the server.
     * @param onMessageCB - The callback to be triggered when responses arrive from the server.
     * @param onDisconnect - The callback to be triggered when this tag holder is closed
     * @param urlFn - A function that provides the URL of the endpoint to send data to.
     */constructor(commandCB,onMessageCB,onDisconnect,urlFn){this.onDisconnect=onDisconnect;this.urlFn=urlFn;//We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause
//problems in some browsers.
this.outstandingRequests=new Set();//A queue of the pending segments waiting for transmission to the server.
this.pendingSegs=[];//A serial number. We use this for two things:
// 1) A way to ensure the browser doesn't cache responses to polls
// 2) A way to make the server aware when long-polls arrive in a different order than we started them. The
//    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute
//    JSONP code in the order it was added to the iframe.
this.currentSerial=Math.floor(Math.random()*100000000);// This gets set to false when we're "closing down" the connection (e.g. we're switching transports but there's still
// incoming data from the server that we're waiting for).
this.sendNewPolls=true;if(!(0,_util.isNodeSdk)()){//Each script holder registers a couple of uniquely named callbacks with the window. These are called from the
//iframes where we put the long-polling script tags. We have two callbacks:
//   1) Command Callback - Triggered for control issues, like starting a connection.
//   2) Message Callback - Triggered when new data arrives.
this.uniqueCallbackIdentifier=LUIDGenerator();window[FIREBASE_LONGPOLL_COMMAND_CB_NAME+this.uniqueCallbackIdentifier]=commandCB;window[FIREBASE_LONGPOLL_DATA_CB_NAME+this.uniqueCallbackIdentifier]=onMessageCB;//Create an iframe for us to add script tags to.
this.myIFrame=FirebaseIFrameScriptHolder.createIFrame_();// Set the iframe's contents.
let script='';// if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient
// for ie9, but ie8 needs to do it again in the document itself.
if(this.myIFrame.src&&this.myIFrame.src.substr(0,'javascript:'.length)==='javascript:'){const currentDomain=document.domain;script='<script>document.domain="'+currentDomain+'";</script>';}const iframeContents='<html><body>'+script+'</body></html>';try{this.myIFrame.doc.open();this.myIFrame.doc.write(iframeContents);this.myIFrame.doc.close();}catch(e){log('frame writing exception');if(e.stack){log(e.stack);}log(e);}}else{this.commandCB=commandCB;this.onMessageCB=onMessageCB;}}/**
     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can
     * actually use.
     */static createIFrame_(){const iframe=document.createElement('iframe');iframe.style.display='none';// This is necessary in order to initialize the document inside the iframe
if(document.body){document.body.appendChild(iframe);try{// If document.domain has been modified in IE, this will throw an error, and we need to set the
// domain of the iframe's document manually. We can do this via a javascript: url as the src attribute
// Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.
const a=iframe.contentWindow.document;if(!a){// Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.
log('No IE domain setting required');}}catch(e){const domain=document.domain;iframe.src="javascript:void((function(){document.open();document.domain='"+domain+"';document.close();})())";}}else{// LongPollConnection attempts to delay initialization until the document is ready, so hopefully this
// never gets hit.
throw'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';}// Get the document of the iframe in a browser-specific way.
if(iframe.contentDocument){iframe.doc=iframe.contentDocument;// Firefox, Opera, Safari
}else if(iframe.contentWindow){iframe.doc=iframe.contentWindow.document;// Internet Explorer
// eslint-disable-next-line @typescript-eslint/no-explicit-any
}else if(iframe.document){// eslint-disable-next-line @typescript-eslint/no-explicit-any
iframe.doc=iframe.document;//others?
}return iframe;}/**
     * Cancel all outstanding queries and remove the frame.
     */close(){//Mark this iframe as dead, so no new requests are sent.
this.alive=false;if(this.myIFrame){//We have to actually remove all of the html inside this iframe before removing it from the
//window, or IE will continue loading and executing the script tags we've already added, which
//can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.
this.myIFrame.doc.body.innerHTML='';setTimeout(()=>{if(this.myIFrame!==null){document.body.removeChild(this.myIFrame);this.myIFrame=null;}},Math.floor(0));}// Protect from being called recursively.
const onDisconnect=this.onDisconnect;if(onDisconnect){this.onDisconnect=null;onDisconnect();}}/**
     * Actually start the long-polling session by adding the first script tag(s) to the iframe.
     * @param id - The ID of this connection
     * @param pw - The password for this connection
     */startLongPoll(id,pw){this.myID=id;this.myPW=pw;this.alive=true;//send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.
while(this.newRequest_()){}}/**
     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't
     * too many outstanding requests and we are still alive.
     *
     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if
     * needed.
     */newRequest_(){// We keep one outstanding request open all the time to receive data, but if we need to send data
// (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically
// close the old request.
if(this.alive&&this.sendNewPolls&&this.outstandingRequests.size<(this.pendingSegs.length>0?2:1)){//construct our url
this.currentSerial++;const urlParams={};urlParams[FIREBASE_LONGPOLL_ID_PARAM]=this.myID;urlParams[FIREBASE_LONGPOLL_PW_PARAM]=this.myPW;urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM]=this.currentSerial;let theURL=this.urlFn(urlParams);//Now add as much data as we can.
let curDataString='';let i=0;while(this.pendingSegs.length>0){//first, lets see if the next segment will fit.
const nextSeg=this.pendingSegs[0];if(nextSeg.d.length+SEG_HEADER_SIZE+curDataString.length<=MAX_URL_DATA_SIZE){//great, the segment will fit. Lets append it.
const theSeg=this.pendingSegs.shift();curDataString=curDataString+'&'+FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM+i+'='+theSeg.seg+'&'+FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET+i+'='+theSeg.ts+'&'+FIREBASE_LONGPOLL_DATA_PARAM+i+'='+theSeg.d;i++;}else{break;}}theURL=theURL+curDataString;this.addLongPollTag_(theURL,this.currentSerial);return true;}else{return false;}}/**
     * Queue a packet for transmission to the server.
     * @param segnum - A sequential id for this packet segment used for reassembly
     * @param totalsegs - The total number of segments in this packet
     * @param data - The data for this segment.
     */enqueueSegment(segnum,totalsegs,data){//add this to the queue of segments to send.
this.pendingSegs.push({seg:segnum,ts:totalsegs,d:data});//send the data immediately if there isn't already data being transmitted, unless
//startLongPoll hasn't been called yet.
if(this.alive){this.newRequest_();}}/**
     * Add a script tag for a regular long-poll request.
     * @param url - The URL of the script tag.
     * @param serial - The serial number of the request.
     */addLongPollTag_(url,serial){//remember that we sent this request.
this.outstandingRequests.add(serial);const doNewRequest=()=>{this.outstandingRequests.delete(serial);this.newRequest_();};// If this request doesn't return on its own accord (by the server sending us some data), we'll
// create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.
const keepaliveTimeout=setTimeout(doNewRequest,Math.floor(KEEPALIVE_REQUEST_INTERVAL));const readyStateCB=()=>{// Request completed.  Cancel the keepalive.
clearTimeout(keepaliveTimeout);// Trigger a new request so we can continue receiving data.
doNewRequest();};this.addTag(url,readyStateCB);}/**
     * Add an arbitrary script tag to the iframe.
     * @param url - The URL for the script tag source.
     * @param loadCB - A callback to be triggered once the script has loaded.
     */addTag(url,loadCB){if((0,_util.isNodeSdk)()){// eslint-disable-next-line @typescript-eslint/no-explicit-any
this.doNodeLongPoll(url,loadCB);}else{setTimeout(()=>{try{// if we're already closed, don't add this poll
if(!this.sendNewPolls){return;}const newScript=this.myIFrame.doc.createElement('script');newScript.type='text/javascript';newScript.async=true;newScript.src=url;// eslint-disable-next-line @typescript-eslint/no-explicit-any
newScript.onload=newScript.onreadystatechange=function(){// eslint-disable-next-line @typescript-eslint/no-explicit-any
const rstate=newScript.readyState;if(!rstate||rstate==='loaded'||rstate==='complete'){// eslint-disable-next-line @typescript-eslint/no-explicit-any
newScript.onload=newScript.onreadystatechange=null;if(newScript.parentNode){newScript.parentNode.removeChild(newScript);}loadCB();}};newScript.onerror=()=>{log('Long-poll script failed to load: '+url);this.sendNewPolls=false;this.close();};this.myIFrame.doc.body.appendChild(newScript);}catch(e){// TODO: we should make this error visible somehow
}},Math.floor(1));}}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const WEBSOCKET_MAX_FRAME_SIZE=16384;const WEBSOCKET_KEEPALIVE_INTERVAL=45000;let WebSocketImpl=null;if(typeof MozWebSocket!=='undefined'){WebSocketImpl=MozWebSocket;}else if(typeof WebSocket!=='undefined'){WebSocketImpl=WebSocket;}/**
 * Create a new websocket connection with the given callbacks.
 */class WebSocketConnection{/**
     * @param connId identifier for this transport
     * @param repoInfo The info for the websocket endpoint.
     * @param applicationId The Firebase App ID for this project.
     * @param appCheckToken The App Check Token for this client.
     * @param authToken The Auth Token for this client.
     * @param transportSessionId Optional transportSessionId if this is connecting
     * to an existing transport session
     * @param lastSessionId Optional lastSessionId if there was a previous
     * connection
     */constructor(connId,repoInfo,applicationId,appCheckToken,authToken,transportSessionId,lastSessionId){this.connId=connId;this.applicationId=applicationId;this.appCheckToken=appCheckToken;this.authToken=authToken;this.keepaliveTimer=null;this.frames=null;this.totalFrames=0;this.bytesSent=0;this.bytesReceived=0;this.log_=logWrapper(this.connId);this.stats_=statsManagerGetCollection(repoInfo);this.connURL=WebSocketConnection.connectionURL_(repoInfo,transportSessionId,lastSessionId,appCheckToken,applicationId);this.nodeAdmin=repoInfo.nodeAdmin;}/**
     * @param repoInfo - The info for the websocket endpoint.
     * @param transportSessionId - Optional transportSessionId if this is connecting to an existing transport
     *                                         session
     * @param lastSessionId - Optional lastSessionId if there was a previous connection
     * @returns connection url
     */static connectionURL_(repoInfo,transportSessionId,lastSessionId,appCheckToken,applicationId){const urlParams={};urlParams[VERSION_PARAM]=PROTOCOL_VERSION;if(!(0,_util.isNodeSdk)()&&typeof location!=='undefined'&&location.hostname&&FORGE_DOMAIN_RE.test(location.hostname)){urlParams[REFERER_PARAM]=FORGE_REF;}if(transportSessionId){urlParams[TRANSPORT_SESSION_PARAM]=transportSessionId;}if(lastSessionId){urlParams[LAST_SESSION_PARAM]=lastSessionId;}if(appCheckToken){urlParams[APP_CHECK_TOKEN_PARAM]=appCheckToken;}if(applicationId){urlParams[APPLICATION_ID_PARAM]=applicationId;}return repoInfoConnectionURL(repoInfo,WEBSOCKET,urlParams);}/**
     * @param onMessage - Callback when messages arrive
     * @param onDisconnect - Callback with connection lost.
     */open(onMessage,onDisconnect){this.onDisconnect=onDisconnect;this.onMessage=onMessage;this.log_('Websocket connecting to '+this.connURL);this.everConnected_=false;// Assume failure until proven otherwise.
PersistentStorage.set('previous_websocket_failure',true);try{let options;if((0,_util.isNodeSdk)()){const device=this.nodeAdmin?'AdminNode':'Node';// UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>
options={headers:{'User-Agent':`Firebase/${PROTOCOL_VERSION}/${SDK_VERSION}/${process.platform}/${device}`,'X-Firebase-GMPID':this.applicationId||''}};// If using Node with admin creds, AppCheck-related checks are unnecessary.
// Note that we send the credentials here even if they aren't admin credentials, which is
// not a problem.
// Note that this header is just used to bypass appcheck, and the token should still be sent
// through the websocket connection once it is established.
if(this.authToken){options.headers['Authorization']=`Bearer ${this.authToken}`;}if(this.appCheckToken){options.headers['X-Firebase-AppCheck']=this.appCheckToken;}// Plumb appropriate http_proxy environment variable into faye-websocket if it exists.
const env=process['env'];const proxy=this.connURL.indexOf('wss://')===0?env['HTTPS_PROXY']||env['https_proxy']:env['HTTP_PROXY']||env['http_proxy'];if(proxy){options['proxy']={origin:proxy};}}this.mySock=new WebSocketImpl(this.connURL,[],options);}catch(e){this.log_('Error instantiating WebSocket.');const error=e.message||e.data;if(error){this.log_(error);}this.onClosed_();return;}this.mySock.onopen=()=>{this.log_('Websocket connected.');this.everConnected_=true;};this.mySock.onclose=()=>{this.log_('Websocket connection was disconnected.');this.mySock=null;this.onClosed_();};this.mySock.onmessage=m=>{this.handleIncomingFrame(m);};this.mySock.onerror=e=>{this.log_('WebSocket error.  Closing connection.');// eslint-disable-next-line @typescript-eslint/no-explicit-any
const error=e.message||e.data;if(error){this.log_(error);}this.onClosed_();};}/**
     * No-op for websockets, we don't need to do anything once the connection is confirmed as open
     */start(){}static forceDisallow(){WebSocketConnection.forceDisallow_=true;}static isAvailable(){let isOldAndroid=false;if(typeof navigator!=='undefined'&&navigator.userAgent){const oldAndroidRegex=/Android ([0-9]{0,}\.[0-9]{0,})/;const oldAndroidMatch=navigator.userAgent.match(oldAndroidRegex);if(oldAndroidMatch&&oldAndroidMatch.length>1){if(parseFloat(oldAndroidMatch[1])<4.4){isOldAndroid=true;}}}return!isOldAndroid&&WebSocketImpl!==null&&!WebSocketConnection.forceDisallow_;}/**
     * Returns true if we previously failed to connect with this transport.
     */static previouslyFailed(){// If our persistent storage is actually only in-memory storage,
// we default to assuming that it previously failed to be safe.
return PersistentStorage.isInMemoryStorage||PersistentStorage.get('previous_websocket_failure')===true;}markConnectionHealthy(){PersistentStorage.remove('previous_websocket_failure');}appendFrame_(data){this.frames.push(data);if(this.frames.length===this.totalFrames){const fullMess=this.frames.join('');this.frames=null;const jsonMess=(0,_util.jsonEval)(fullMess);//handle the message
this.onMessage(jsonMess);}}/**
     * @param frameCount - The number of frames we are expecting from the server
     */handleNewFrameCount_(frameCount){this.totalFrames=frameCount;this.frames=[];}/**
     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1
     * @returns Any remaining data to be process, or null if there is none
     */extractFrameCount_(data){(0,_util.assert)(this.frames===null,'We already have a frame buffer');// TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced
// currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508
if(data.length<=6){const frameCount=Number(data);if(!isNaN(frameCount)){this.handleNewFrameCount_(frameCount);return null;}}this.handleNewFrameCount_(1);return data;}/**
     * Process a websocket frame that has arrived from the server.
     * @param mess - The frame data
     */handleIncomingFrame(mess){if(this.mySock===null){return;// Chrome apparently delivers incoming packets even after we .close() the connection sometimes.
}const data=mess['data'];this.bytesReceived+=data.length;this.stats_.incrementCounter('bytes_received',data.length);this.resetKeepAlive();if(this.frames!==null){// we're buffering
this.appendFrame_(data);}else{// try to parse out a frame count, otherwise, assume 1 and process it
const remainingData=this.extractFrameCount_(data);if(remainingData!==null){this.appendFrame_(remainingData);}}}/**
     * Send a message to the server
     * @param data - The JSON object to transmit
     */send(data){this.resetKeepAlive();const dataStr=(0,_util.stringify)(data);this.bytesSent+=dataStr.length;this.stats_.incrementCounter('bytes_sent',dataStr.length);//We can only fit a certain amount in each websocket frame, so we need to split this request
//up into multiple pieces if it doesn't fit in one request.
const dataSegs=splitStringBySize(dataStr,WEBSOCKET_MAX_FRAME_SIZE);//Send the length header
if(dataSegs.length>1){this.sendString_(String(dataSegs.length));}//Send the actual data in segments.
for(let i=0;i<dataSegs.length;i++){this.sendString_(dataSegs[i]);}}shutdown_(){this.isClosed_=true;if(this.keepaliveTimer){clearInterval(this.keepaliveTimer);this.keepaliveTimer=null;}if(this.mySock){this.mySock.close();this.mySock=null;}}onClosed_(){if(!this.isClosed_){this.log_('WebSocket is closing itself');this.shutdown_();// since this is an internal close, trigger the close listener
if(this.onDisconnect){this.onDisconnect(this.everConnected_);this.onDisconnect=null;}}}/**
     * External-facing close handler.
     * Close the websocket and kill the connection.
     */close(){if(!this.isClosed_){this.log_('WebSocket is being closed');this.shutdown_();}}/**
     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after
     * the last activity.
     */resetKeepAlive(){clearInterval(this.keepaliveTimer);this.keepaliveTimer=setInterval(()=>{//If there has been no websocket activity for a while, send a no-op
if(this.mySock){this.sendString_('0');}this.resetKeepAlive();// eslint-disable-next-line @typescript-eslint/no-explicit-any
},Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));}/**
     * Send a string over the websocket.
     *
     * @param str - String to send.
     */sendString_(str){// Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()
// calls for some unknown reason.  We treat these as an error and disconnect.
// See https://app.asana.com/0/58926111402292/68021340250410
try{this.mySock.send(str);}catch(e){this.log_('Exception thrown from WebSocket.send():',e.message||e.data,'Closing connection.');setTimeout(this.onClosed_.bind(this),0);}}}/**
 * Number of response before we consider the connection "healthy."
 */WebSocketConnection.responsesRequiredToBeHealthy=2;/**
 * Time to wait for the connection te become healthy before giving up.
 */WebSocketConnection.healthyTimeout=30000;/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Currently simplistic, this class manages what transport a Connection should use at various stages of its
 * lifecycle.
 *
 * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if
 * they are available.
 */class TransportManager{/**
     * @param repoInfo - Metadata around the namespace we're connecting to
     */constructor(repoInfo){this.initTransports_(repoInfo);}static get ALL_TRANSPORTS(){return[BrowserPollConnection,WebSocketConnection];}/**
     * Returns whether transport has been selected to ensure WebSocketConnection or BrowserPollConnection are not called after
     * TransportManager has already set up transports_
     */static get IS_TRANSPORT_INITIALIZED(){return this.globalTransportInitialized_;}initTransports_(repoInfo){const isWebSocketsAvailable=WebSocketConnection&&WebSocketConnection['isAvailable']();let isSkipPollConnection=isWebSocketsAvailable&&!WebSocketConnection.previouslyFailed();if(repoInfo.webSocketOnly){if(!isWebSocketsAvailable){warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");}isSkipPollConnection=true;}if(isSkipPollConnection){this.transports_=[WebSocketConnection];}else{const transports=this.transports_=[];for(const transport of TransportManager.ALL_TRANSPORTS){if(transport&&transport['isAvailable']()){transports.push(transport);}}TransportManager.globalTransportInitialized_=true;}}/**
     * @returns The constructor for the initial transport to use
     */initialTransport(){if(this.transports_.length>0){return this.transports_[0];}else{throw new Error('No transports available');}}/**
     * @returns The constructor for the next transport, or null
     */upgradeTransport(){if(this.transports_.length>1){return this.transports_[1];}else{return null;}}}// Keeps track of whether the TransportManager has already chosen a transport to use
TransportManager.globalTransportInitialized_=false;/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Abort upgrade attempt if it takes longer than 60s.
const UPGRADE_TIMEOUT=60000;// For some transports (WebSockets), we need to "validate" the transport by exchanging a few requests and responses.
// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.
const DELAY_BEFORE_SENDING_EXTRA_REQUESTS=5000;// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)
// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout
// but we've sent/received enough bytes, we don't cancel the connection.
const BYTES_SENT_HEALTHY_OVERRIDE=10*1024;const BYTES_RECEIVED_HEALTHY_OVERRIDE=100*1024;const MESSAGE_TYPE='t';const MESSAGE_DATA='d';const CONTROL_SHUTDOWN='s';const CONTROL_RESET='r';const CONTROL_ERROR='e';const CONTROL_PONG='o';const SWITCH_ACK='a';const END_TRANSMISSION='n';const PING='p';const SERVER_HELLO='h';/**
 * Creates a new real-time connection to the server using whichever method works
 * best in the current browser.
 */class Connection{/**
     * @param id - an id for this connection
     * @param repoInfo_ - the info for the endpoint to connect to
     * @param applicationId_ - the Firebase App ID for this project
     * @param appCheckToken_ - The App Check Token for this device.
     * @param authToken_ - The auth token for this session.
     * @param onMessage_ - the callback to be triggered when a server-push message arrives
     * @param onReady_ - the callback to be triggered when this connection is ready to send messages.
     * @param onDisconnect_ - the callback to be triggered when a connection was lost
     * @param onKill_ - the callback to be triggered when this connection has permanently shut down.
     * @param lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server
     */constructor(id,repoInfo_,applicationId_,appCheckToken_,authToken_,onMessage_,onReady_,onDisconnect_,onKill_,lastSessionId){this.id=id;this.repoInfo_=repoInfo_;this.applicationId_=applicationId_;this.appCheckToken_=appCheckToken_;this.authToken_=authToken_;this.onMessage_=onMessage_;this.onReady_=onReady_;this.onDisconnect_=onDisconnect_;this.onKill_=onKill_;this.lastSessionId=lastSessionId;this.connectionCount=0;this.pendingDataMessages=[];this.state_=0/* CONNECTING */;this.log_=logWrapper('c:'+this.id+':');this.transportManager_=new TransportManager(repoInfo_);this.log_('Connection created');this.start_();}/**
     * Starts a connection attempt
     */start_(){const conn=this.transportManager_.initialTransport();this.conn_=new conn(this.nextTransportId_(),this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,null,this.lastSessionId);// For certain transports (WebSockets), we need to send and receive several messages back and forth before we
// can consider the transport healthy.
this.primaryResponsesRequired_=conn['responsesRequiredToBeHealthy']||0;const onMessageReceived=this.connReceiver_(this.conn_);const onConnectionLost=this.disconnReceiver_(this.conn_);this.tx_=this.conn_;this.rx_=this.conn_;this.secondaryConn_=null;this.isHealthy_=false;/*
         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.
         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.
         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should
         * still have the context of your originating frame.
         */setTimeout(()=>{// this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it
this.conn_&&this.conn_.open(onMessageReceived,onConnectionLost);},Math.floor(0));const healthyTimeoutMS=conn['healthyTimeout']||0;if(healthyTimeoutMS>0){this.healthyTimeout_=setTimeoutNonBlocking(()=>{this.healthyTimeout_=null;if(!this.isHealthy_){if(this.conn_&&this.conn_.bytesReceived>BYTES_RECEIVED_HEALTHY_OVERRIDE){this.log_('Connection exceeded healthy timeout but has received '+this.conn_.bytesReceived+' bytes.  Marking connection healthy.');this.isHealthy_=true;this.conn_.markConnectionHealthy();}else if(this.conn_&&this.conn_.bytesSent>BYTES_SENT_HEALTHY_OVERRIDE){this.log_('Connection exceeded healthy timeout but has sent '+this.conn_.bytesSent+' bytes.  Leaving connection alive.');// NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to
// the server.
}else{this.log_('Closing unhealthy connection after timeout.');this.close();}}// eslint-disable-next-line @typescript-eslint/no-explicit-any
},Math.floor(healthyTimeoutMS));}}nextTransportId_(){return'c:'+this.id+':'+this.connectionCount++;}disconnReceiver_(conn){return everConnected=>{if(conn===this.conn_){this.onConnectionLost_(everConnected);}else if(conn===this.secondaryConn_){this.log_('Secondary connection lost.');this.onSecondaryConnectionLost_();}else{this.log_('closing an old connection');}};}connReceiver_(conn){return message=>{if(this.state_!==2/* DISCONNECTED */){if(conn===this.rx_){this.onPrimaryMessageReceived_(message);}else if(conn===this.secondaryConn_){this.onSecondaryMessageReceived_(message);}else{this.log_('message on old connection');}}};}/**
     * @param dataMsg - An arbitrary data message to be sent to the server
     */sendRequest(dataMsg){// wrap in a data message envelope and send it on
const msg={t:'d',d:dataMsg};this.sendData_(msg);}tryCleanupConnection(){if(this.tx_===this.secondaryConn_&&this.rx_===this.secondaryConn_){this.log_('cleaning up and promoting a connection: '+this.secondaryConn_.connId);this.conn_=this.secondaryConn_;this.secondaryConn_=null;// the server will shutdown the old connection
}}onSecondaryControl_(controlData){if(MESSAGE_TYPE in controlData){const cmd=controlData[MESSAGE_TYPE];if(cmd===SWITCH_ACK){this.upgradeIfSecondaryHealthy_();}else if(cmd===CONTROL_RESET){// Most likely the session wasn't valid. Abandon the switch attempt
this.log_('Got a reset on secondary, closing it');this.secondaryConn_.close();// If we were already using this connection for something, than we need to fully close
if(this.tx_===this.secondaryConn_||this.rx_===this.secondaryConn_){this.close();}}else if(cmd===CONTROL_PONG){this.log_('got pong on secondary.');this.secondaryResponsesRequired_--;this.upgradeIfSecondaryHealthy_();}}}onSecondaryMessageReceived_(parsedData){const layer=requireKey('t',parsedData);const data=requireKey('d',parsedData);if(layer==='c'){this.onSecondaryControl_(data);}else if(layer==='d'){// got a data message, but we're still second connection. Need to buffer it up
this.pendingDataMessages.push(data);}else{throw new Error('Unknown protocol layer: '+layer);}}upgradeIfSecondaryHealthy_(){if(this.secondaryResponsesRequired_<=0){this.log_('Secondary connection is healthy.');this.isHealthy_=true;this.secondaryConn_.markConnectionHealthy();this.proceedWithUpgrade_();}else{// Send a ping to make sure the connection is healthy.
this.log_('sending ping on secondary.');this.secondaryConn_.send({t:'c',d:{t:PING,d:{}}});}}proceedWithUpgrade_(){// tell this connection to consider itself open
this.secondaryConn_.start();// send ack
this.log_('sending client ack on secondary');this.secondaryConn_.send({t:'c',d:{t:SWITCH_ACK,d:{}}});// send end packet on primary transport, switch to sending on this one
// can receive on this one, buffer responses until end received on primary transport
this.log_('Ending transmission on primary');this.conn_.send({t:'c',d:{t:END_TRANSMISSION,d:{}}});this.tx_=this.secondaryConn_;this.tryCleanupConnection();}onPrimaryMessageReceived_(parsedData){// Must refer to parsedData properties in quotes, so closure doesn't touch them.
const layer=requireKey('t',parsedData);const data=requireKey('d',parsedData);if(layer==='c'){this.onControl_(data);}else if(layer==='d'){this.onDataMessage_(data);}}onDataMessage_(message){this.onPrimaryResponse_();// We don't do anything with data messages, just kick them up a level
this.onMessage_(message);}onPrimaryResponse_(){if(!this.isHealthy_){this.primaryResponsesRequired_--;if(this.primaryResponsesRequired_<=0){this.log_('Primary connection is healthy.');this.isHealthy_=true;this.conn_.markConnectionHealthy();}}}onControl_(controlData){const cmd=requireKey(MESSAGE_TYPE,controlData);if(MESSAGE_DATA in controlData){const payload=controlData[MESSAGE_DATA];if(cmd===SERVER_HELLO){this.onHandshake_(payload);}else if(cmd===END_TRANSMISSION){this.log_('recvd end transmission on primary');this.rx_=this.secondaryConn_;for(let i=0;i<this.pendingDataMessages.length;++i){this.onDataMessage_(this.pendingDataMessages[i]);}this.pendingDataMessages=[];this.tryCleanupConnection();}else if(cmd===CONTROL_SHUTDOWN){// This was previously the 'onKill' callback passed to the lower-level connection
// payload in this case is the reason for the shutdown. Generally a human-readable error
this.onConnectionShutdown_(payload);}else if(cmd===CONTROL_RESET){// payload in this case is the host we should contact
this.onReset_(payload);}else if(cmd===CONTROL_ERROR){error('Server Error: '+payload);}else if(cmd===CONTROL_PONG){this.log_('got pong on primary.');this.onPrimaryResponse_();this.sendPingOnPrimaryIfNecessary_();}else{error('Unknown control packet command: '+cmd);}}}/**
     * @param handshake - The handshake data returned from the server
     */onHandshake_(handshake){const timestamp=handshake.ts;const version=handshake.v;const host=handshake.h;this.sessionId=handshake.s;this.repoInfo_.host=host;// if we've already closed the connection, then don't bother trying to progress further
if(this.state_===0/* CONNECTING */){this.conn_.start();this.onConnectionEstablished_(this.conn_,timestamp);if(PROTOCOL_VERSION!==version){warn('Protocol version mismatch detected');}// TODO: do we want to upgrade? when? maybe a delay?
this.tryStartUpgrade_();}}tryStartUpgrade_(){const conn=this.transportManager_.upgradeTransport();if(conn){this.startUpgrade_(conn);}}startUpgrade_(conn){this.secondaryConn_=new conn(this.nextTransportId_(),this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,this.sessionId);// For certain transports (WebSockets), we need to send and receive several messages back and forth before we
// can consider the transport healthy.
this.secondaryResponsesRequired_=conn['responsesRequiredToBeHealthy']||0;const onMessage=this.connReceiver_(this.secondaryConn_);const onDisconnect=this.disconnReceiver_(this.secondaryConn_);this.secondaryConn_.open(onMessage,onDisconnect);// If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.
setTimeoutNonBlocking(()=>{if(this.secondaryConn_){this.log_('Timed out trying to upgrade.');this.secondaryConn_.close();}},Math.floor(UPGRADE_TIMEOUT));}onReset_(host){this.log_('Reset packet received.  New host: '+host);this.repoInfo_.host=host;// TODO: if we're already "connected", we need to trigger a disconnect at the next layer up.
// We don't currently support resets after the connection has already been established
if(this.state_===1/* CONNECTED */){this.close();}else{// Close whatever connections we have open and start again.
this.closeConnections_();this.start_();}}onConnectionEstablished_(conn,timestamp){this.log_('Realtime connection established.');this.conn_=conn;this.state_=1/* CONNECTED */;if(this.onReady_){this.onReady_(timestamp,this.sessionId);this.onReady_=null;}// If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,
// send some pings.
if(this.primaryResponsesRequired_===0){this.log_('Primary connection is healthy.');this.isHealthy_=true;}else{setTimeoutNonBlocking(()=>{this.sendPingOnPrimaryIfNecessary_();},Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));}}sendPingOnPrimaryIfNecessary_(){// If the connection isn't considered healthy yet, we'll send a noop ping packet request.
if(!this.isHealthy_&&this.state_===1/* CONNECTED */){this.log_('sending ping on primary.');this.sendData_({t:'c',d:{t:PING,d:{}}});}}onSecondaryConnectionLost_(){const conn=this.secondaryConn_;this.secondaryConn_=null;if(this.tx_===conn||this.rx_===conn){// we are relying on this connection already in some capacity. Therefore, a failure is real
this.close();}}/**
     * @param everConnected - Whether or not the connection ever reached a server. Used to determine if
     * we should flush the host cache
     */onConnectionLost_(everConnected){this.conn_=null;// NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting
// called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.
if(!everConnected&&this.state_===0/* CONNECTING */){this.log_('Realtime connection failed.');// Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away
if(this.repoInfo_.isCacheableHost()){PersistentStorage.remove('host:'+this.repoInfo_.host);// reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com
this.repoInfo_.internalHost=this.repoInfo_.host;}}else if(this.state_===1/* CONNECTED */){this.log_('Realtime connection lost.');}this.close();}onConnectionShutdown_(reason){this.log_('Connection shutdown command received. Shutting down...');if(this.onKill_){this.onKill_(reason);this.onKill_=null;}// We intentionally don't want to fire onDisconnect (kill is a different case),
// so clear the callback.
this.onDisconnect_=null;this.close();}sendData_(data){if(this.state_!==1/* CONNECTED */){throw'Connection is not connected';}else{this.tx_.send(data);}}/**
     * Cleans up this connection, calling the appropriate callbacks
     */close(){if(this.state_!==2/* DISCONNECTED */){this.log_('Closing realtime connection.');this.state_=2/* DISCONNECTED */;this.closeConnections_();if(this.onDisconnect_){this.onDisconnect_();this.onDisconnect_=null;}}}closeConnections_(){this.log_('Shutting down all connections');if(this.conn_){this.conn_.close();this.conn_=null;}if(this.secondaryConn_){this.secondaryConn_.close();this.secondaryConn_=null;}if(this.healthyTimeout_){clearTimeout(this.healthyTimeout_);this.healthyTimeout_=null;}}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Interface defining the set of actions that can be performed against the Firebase server
 * (basically corresponds to our wire protocol).
 *
 * @interface
 */class ServerActions{put(pathString,data,onComplete,hash){}merge(pathString,data,onComplete,hash){}/**
     * Refreshes the auth token for the current connection.
     * @param token - The authentication token
     */refreshAuthToken(token){}/**
     * Refreshes the app check token for the current connection.
     * @param token The app check token
     */refreshAppCheckToken(token){}onDisconnectPut(pathString,data,onComplete){}onDisconnectMerge(pathString,data,onComplete){}onDisconnectCancel(pathString,onComplete){}reportStats(stats){}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Base class to be used if you want to emit events. Call the constructor with
 * the set of allowed event names.
 */class EventEmitter{constructor(allowedEvents_){this.allowedEvents_=allowedEvents_;this.listeners_={};(0,_util.assert)(Array.isArray(allowedEvents_)&&allowedEvents_.length>0,'Requires a non-empty array');}/**
     * To be called by derived classes to trigger events.
     */trigger(eventType,...varArgs){if(Array.isArray(this.listeners_[eventType])){// Clone the list, since callbacks could add/remove listeners.
const listeners=[...this.listeners_[eventType]];for(let i=0;i<listeners.length;i++){listeners[i].callback.apply(listeners[i].context,varArgs);}}}on(eventType,callback,context){this.validateEventType_(eventType);this.listeners_[eventType]=this.listeners_[eventType]||[];this.listeners_[eventType].push({callback,context});const eventData=this.getInitialEvent(eventType);if(eventData){callback.apply(context,eventData);}}off(eventType,callback,context){this.validateEventType_(eventType);const listeners=this.listeners_[eventType]||[];for(let i=0;i<listeners.length;i++){if(listeners[i].callback===callback&&(!context||context===listeners[i].context)){listeners.splice(i,1);return;}}}validateEventType_(eventType){(0,_util.assert)(this.allowedEvents_.find(et=>{return et===eventType;}),'Unknown event: '+eventType);}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Monitors online state (as reported by window.online/offline events).
 *
 * The expectation is that this could have many false positives (thinks we are online
 * when we're not), but no false negatives.  So we can safely use it to determine when
 * we definitely cannot reach the internet.
 */class OnlineMonitor extends EventEmitter{constructor(){super(['online']);this.online_=true;// We've had repeated complaints that Cordova apps can get stuck "offline", e.g.
// https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810
// It would seem that the 'online' event does not always fire consistently. So we disable it
// for Cordova.
if(typeof window!=='undefined'&&typeof window.addEventListener!=='undefined'&&!(0,_util.isMobileCordova)()){window.addEventListener('online',()=>{if(!this.online_){this.online_=true;this.trigger('online',true);}},false);window.addEventListener('offline',()=>{if(this.online_){this.online_=false;this.trigger('online',false);}},false);}}static getInstance(){return new OnlineMonitor();}getInitialEvent(eventType){(0,_util.assert)(eventType==='online','Unknown event type: '+eventType);return[this.online_];}currentlyOnline(){return this.online_;}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** Maximum key depth. */const MAX_PATH_DEPTH=32;/** Maximum number of (UTF8) bytes in a Firebase path. */const MAX_PATH_LENGTH_BYTES=768;/**
 * An immutable object representing a parsed path.  It's immutable so that you
 * can pass them around to other functions without worrying about them changing
 * it.
 */class Path{/**
     * @param pathOrString - Path string to parse, or another path, or the raw
     * tokens array
     */constructor(pathOrString,pieceNum){if(pieceNum===void 0){this.pieces_=pathOrString.split('/');// Remove empty pieces.
let copyTo=0;for(let i=0;i<this.pieces_.length;i++){if(this.pieces_[i].length>0){this.pieces_[copyTo]=this.pieces_[i];copyTo++;}}this.pieces_.length=copyTo;this.pieceNum_=0;}else{this.pieces_=pathOrString;this.pieceNum_=pieceNum;}}toString(){let pathString='';for(let i=this.pieceNum_;i<this.pieces_.length;i++){if(this.pieces_[i]!==''){pathString+='/'+this.pieces_[i];}}return pathString||'/';}}function newEmptyPath(){return new Path('');}function pathGetFront(path){if(path.pieceNum_>=path.pieces_.length){return null;}return path.pieces_[path.pieceNum_];}/**
 * @returns The number of segments in this path
 */function pathGetLength(path){return path.pieces_.length-path.pieceNum_;}function pathPopFront(path){let pieceNum=path.pieceNum_;if(pieceNum<path.pieces_.length){pieceNum++;}return new Path(path.pieces_,pieceNum);}function pathGetBack(path){if(path.pieceNum_<path.pieces_.length){return path.pieces_[path.pieces_.length-1];}return null;}function pathToUrlEncodedString(path){let pathString='';for(let i=path.pieceNum_;i<path.pieces_.length;i++){if(path.pieces_[i]!==''){pathString+='/'+encodeURIComponent(String(path.pieces_[i]));}}return pathString||'/';}/**
 * Shallow copy of the parts of the path.
 *
 */function pathSlice(path,begin=0){return path.pieces_.slice(path.pieceNum_+begin);}function pathParent(path){if(path.pieceNum_>=path.pieces_.length){return null;}const pieces=[];for(let i=path.pieceNum_;i<path.pieces_.length-1;i++){pieces.push(path.pieces_[i]);}return new Path(pieces,0);}function pathChild(path,childPathObj){const pieces=[];for(let i=path.pieceNum_;i<path.pieces_.length;i++){pieces.push(path.pieces_[i]);}if(childPathObj instanceof Path){for(let i=childPathObj.pieceNum_;i<childPathObj.pieces_.length;i++){pieces.push(childPathObj.pieces_[i]);}}else{const childPieces=childPathObj.split('/');for(let i=0;i<childPieces.length;i++){if(childPieces[i].length>0){pieces.push(childPieces[i]);}}}return new Path(pieces,0);}/**
 * @returns True if there are no segments in this path
 */function pathIsEmpty(path){return path.pieceNum_>=path.pieces_.length;}/**
 * @returns The path from outerPath to innerPath
 */function newRelativePath(outerPath,innerPath){const outer=pathGetFront(outerPath),inner=pathGetFront(innerPath);if(outer===null){return innerPath;}else if(outer===inner){return newRelativePath(pathPopFront(outerPath),pathPopFront(innerPath));}else{throw new Error('INTERNAL ERROR: innerPath ('+innerPath+') is not within '+'outerPath ('+outerPath+')');}}/**
 * @returns -1, 0, 1 if left is less, equal, or greater than the right.
 */function pathCompare(left,right){const leftKeys=pathSlice(left,0);const rightKeys=pathSlice(right,0);for(let i=0;i<leftKeys.length&&i<rightKeys.length;i++){const cmp=nameCompare(leftKeys[i],rightKeys[i]);if(cmp!==0){return cmp;}}if(leftKeys.length===rightKeys.length){return 0;}return leftKeys.length<rightKeys.length?-1:1;}/**
 * @returns true if paths are the same.
 */function pathEquals(path,other){if(pathGetLength(path)!==pathGetLength(other)){return false;}for(let i=path.pieceNum_,j=other.pieceNum_;i<=path.pieces_.length;i++,j++){if(path.pieces_[i]!==other.pieces_[j]){return false;}}return true;}/**
 * @returns True if this path is a parent of (or the same as) other
 */function pathContains(path,other){let i=path.pieceNum_;let j=other.pieceNum_;if(pathGetLength(path)>pathGetLength(other)){return false;}while(i<path.pieces_.length){if(path.pieces_[i]!==other.pieces_[j]){return false;}++i;++j;}return true;}/**
 * Dynamic (mutable) path used to count path lengths.
 *
 * This class is used to efficiently check paths for valid
 * length (in UTF8 bytes) and depth (used in path validation).
 *
 * Throws Error exception if path is ever invalid.
 *
 * The definition of a path always begins with '/'.
 */class ValidationPath{/**
     * @param path - Initial Path.
     * @param errorPrefix_ - Prefix for any error messages.
     */constructor(path,errorPrefix_){this.errorPrefix_=errorPrefix_;this.parts_=pathSlice(path,0);/** Initialize to number of '/' chars needed in path. */this.byteLength_=Math.max(1,this.parts_.length);for(let i=0;i<this.parts_.length;i++){this.byteLength_+=(0,_util.stringLength)(this.parts_[i]);}validationPathCheckValid(this);}}function validationPathPush(validationPath,child){// Count the needed '/'
if(validationPath.parts_.length>0){validationPath.byteLength_+=1;}validationPath.parts_.push(child);validationPath.byteLength_+=(0,_util.stringLength)(child);validationPathCheckValid(validationPath);}function validationPathPop(validationPath){const last=validationPath.parts_.pop();validationPath.byteLength_-=(0,_util.stringLength)(last);// Un-count the previous '/'
if(validationPath.parts_.length>0){validationPath.byteLength_-=1;}}function validationPathCheckValid(validationPath){if(validationPath.byteLength_>MAX_PATH_LENGTH_BYTES){throw new Error(validationPath.errorPrefix_+'has a key path longer than '+MAX_PATH_LENGTH_BYTES+' bytes ('+validationPath.byteLength_+').');}if(validationPath.parts_.length>MAX_PATH_DEPTH){throw new Error(validationPath.errorPrefix_+'path specified exceeds the maximum depth that can be written ('+MAX_PATH_DEPTH+') or object contains a cycle '+validationPathToErrorString(validationPath));}}/**
 * String for use in error messages - uses '.' notation for path.
 */function validationPathToErrorString(validationPath){if(validationPath.parts_.length===0){return'';}return"in property '"+validationPath.parts_.join('.')+"'";}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class VisibilityMonitor extends EventEmitter{constructor(){super(['visible']);let hidden;let visibilityChange;if(typeof document!=='undefined'&&typeof document.addEventListener!=='undefined'){if(typeof document['hidden']!=='undefined'){// Opera 12.10 and Firefox 18 and later support
visibilityChange='visibilitychange';hidden='hidden';}else if(typeof document['mozHidden']!=='undefined'){visibilityChange='mozvisibilitychange';hidden='mozHidden';}else if(typeof document['msHidden']!=='undefined'){visibilityChange='msvisibilitychange';hidden='msHidden';}else if(typeof document['webkitHidden']!=='undefined'){visibilityChange='webkitvisibilitychange';hidden='webkitHidden';}}// Initially, we always assume we are visible. This ensures that in browsers
// without page visibility support or in cases where we are never visible
// (e.g. chrome extension), we act as if we are visible, i.e. don't delay
// reconnects
this.visible_=true;if(visibilityChange){document.addEventListener(visibilityChange,()=>{const visible=!document[hidden];if(visible!==this.visible_){this.visible_=visible;this.trigger('visible',visible);}},false);}}static getInstance(){return new VisibilityMonitor();}getInitialEvent(eventType){(0,_util.assert)(eventType==='visible','Unknown event type: '+eventType);return[this.visible_];}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const RECONNECT_MIN_DELAY=1000;const RECONNECT_MAX_DELAY_DEFAULT=60*5*1000;// 5 minutes in milliseconds (Case: 1858)
const RECONNECT_MAX_DELAY_FOR_ADMINS=30*1000;// 30 seconds for admin clients (likely to be a backend server)
const RECONNECT_DELAY_MULTIPLIER=1.3;const RECONNECT_DELAY_RESET_TIMEOUT=30000;// Reset delay back to MIN_DELAY after being connected for 30sec.
const SERVER_KILL_INTERRUPT_REASON='server_kill';// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.
const INVALID_TOKEN_THRESHOLD=3;/**
 * Firebase connection.  Abstracts wire protocol and handles reconnecting.
 *
 * NOTE: All JSON objects sent to the realtime connection must have property names enclosed
 * in quotes to make sure the closure compiler does not minify them.
 */class PersistentConnection extends ServerActions{/**
     * @param repoInfo_ - Data about the namespace we are connecting to
     * @param applicationId_ - The Firebase App ID for this project
     * @param onDataUpdate_ - A callback for new data from the server
     */constructor(repoInfo_,applicationId_,onDataUpdate_,onConnectStatus_,onServerInfoUpdate_,authTokenProvider_,appCheckTokenProvider_,authOverride_){super();this.repoInfo_=repoInfo_;this.applicationId_=applicationId_;this.onDataUpdate_=onDataUpdate_;this.onConnectStatus_=onConnectStatus_;this.onServerInfoUpdate_=onServerInfoUpdate_;this.authTokenProvider_=authTokenProvider_;this.appCheckTokenProvider_=appCheckTokenProvider_;this.authOverride_=authOverride_;// Used for diagnostic logging.
this.id=PersistentConnection.nextPersistentConnectionId_++;this.log_=logWrapper('p:'+this.id+':');this.interruptReasons_={};this.listens=new Map();this.outstandingPuts_=[];this.outstandingGets_=[];this.outstandingPutCount_=0;this.outstandingGetCount_=0;this.onDisconnectRequestQueue_=[];this.connected_=false;this.reconnectDelay_=RECONNECT_MIN_DELAY;this.maxReconnectDelay_=RECONNECT_MAX_DELAY_DEFAULT;this.securityDebugCallback_=null;this.lastSessionId=null;this.establishConnectionTimer_=null;this.visible_=false;// Before we get connected, we keep a queue of pending messages to send.
this.requestCBHash_={};this.requestNumber_=0;this.realtime_=null;this.authToken_=null;this.appCheckToken_=null;this.forceTokenRefresh_=false;this.invalidAuthTokenCount_=0;this.invalidAppCheckTokenCount_=0;this.firstConnection_=true;this.lastConnectionAttemptTime_=null;this.lastConnectionEstablishedTime_=null;if(authOverride_&&!(0,_util.isNodeSdk)()){throw new Error('Auth override specified in options, but not supported on non Node.js platforms');}VisibilityMonitor.getInstance().on('visible',this.onVisible_,this);if(repoInfo_.host.indexOf('fblocal')===-1){OnlineMonitor.getInstance().on('online',this.onOnline_,this);}}sendRequest(action,body,onResponse){const curReqNum=++this.requestNumber_;const msg={r:curReqNum,a:action,b:body};this.log_((0,_util.stringify)(msg));(0,_util.assert)(this.connected_,"sendRequest call when we're not connected not allowed.");this.realtime_.sendRequest(msg);if(onResponse){this.requestCBHash_[curReqNum]=onResponse;}}get(query){this.initConnection_();const deferred=new _util.Deferred();const request={p:query._path.toString(),q:query._queryObject};const outstandingGet={action:'g',request,onComplete:message=>{const payload=message['d'];if(message['s']==='ok'){deferred.resolve(payload);}else{deferred.reject(payload);}}};this.outstandingGets_.push(outstandingGet);this.outstandingGetCount_++;const index=this.outstandingGets_.length-1;if(this.connected_){this.sendGet_(index);}return deferred.promise;}listen(query,currentHashFn,tag,onComplete){this.initConnection_();const queryId=query._queryIdentifier;const pathString=query._path.toString();this.log_('Listen called for '+pathString+' '+queryId);if(!this.listens.has(pathString)){this.listens.set(pathString,new Map());}(0,_util.assert)(query._queryParams.isDefault()||!query._queryParams.loadsAllData(),'listen() called for non-default but complete query');(0,_util.assert)(!this.listens.get(pathString).has(queryId),`listen() called twice for same path/queryId.`);const listenSpec={onComplete,hashFn:currentHashFn,query,tag};this.listens.get(pathString).set(queryId,listenSpec);if(this.connected_){this.sendListen_(listenSpec);}}sendGet_(index){const get=this.outstandingGets_[index];this.sendRequest('g',get.request,message=>{delete this.outstandingGets_[index];this.outstandingGetCount_--;if(this.outstandingGetCount_===0){this.outstandingGets_=[];}if(get.onComplete){get.onComplete(message);}});}sendListen_(listenSpec){const query=listenSpec.query;const pathString=query._path.toString();const queryId=query._queryIdentifier;this.log_('Listen on '+pathString+' for '+queryId);const req={/*path*/p:pathString};const action='q';// Only bother to send query if it's non-default.
if(listenSpec.tag){req['q']=query._queryObject;req['t']=listenSpec.tag;}req[/*hash*/'h']=listenSpec.hashFn();this.sendRequest(action,req,message=>{const payload=message[/*data*/'d'];const status=message[/*status*/'s'];// print warnings in any case...
PersistentConnection.warnOnListenWarnings_(payload,query);const currentListenSpec=this.listens.get(pathString)&&this.listens.get(pathString).get(queryId);// only trigger actions if the listen hasn't been removed and readded
if(currentListenSpec===listenSpec){this.log_('listen response',message);if(status!=='ok'){this.removeListen_(pathString,queryId);}if(listenSpec.onComplete){listenSpec.onComplete(status,payload);}}});}static warnOnListenWarnings_(payload,query){if(payload&&typeof payload==='object'&&(0,_util.contains)(payload,'w')){// eslint-disable-next-line @typescript-eslint/no-explicit-any
const warnings=(0,_util.safeGet)(payload,'w');if(Array.isArray(warnings)&&~warnings.indexOf('no_index')){const indexSpec='".indexOn": "'+query._queryParams.getIndex().toString()+'"';const indexPath=query._path.toString();warn(`Using an unspecified index. Your data will be downloaded and `+`filtered on the client. Consider adding ${indexSpec} at `+`${indexPath} to your security rules for better performance.`);}}}refreshAuthToken(token){this.authToken_=token;this.log_('Auth token refreshed');if(this.authToken_){this.tryAuth();}else{//If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete
//the credential so we dont become authenticated next time we connect.
if(this.connected_){this.sendRequest('unauth',{},()=>{});}}this.reduceReconnectDelayIfAdminCredential_(token);}reduceReconnectDelayIfAdminCredential_(credential){// NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).
// Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.
const isFirebaseSecret=credential&&credential.length===40;if(isFirebaseSecret||(0,_util.isAdmin)(credential)){this.log_('Admin auth credential detected.  Reducing max reconnect time.');this.maxReconnectDelay_=RECONNECT_MAX_DELAY_FOR_ADMINS;}}refreshAppCheckToken(token){this.appCheckToken_=token;this.log_('App check token refreshed');if(this.appCheckToken_){this.tryAppCheck();}else{//If we're connected we want to let the server know to unauthenticate us.
//If we're not connected, simply delete the credential so we dont become
// authenticated next time we connect.
if(this.connected_){this.sendRequest('unappeck',{},()=>{});}}}/**
     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like
     * a auth revoked (the connection is closed).
     */tryAuth(){if(this.connected_&&this.authToken_){const token=this.authToken_;const authMethod=(0,_util.isValidFormat)(token)?'auth':'gauth';const requestData={cred:token};if(this.authOverride_===null){requestData['noauth']=true;}else if(typeof this.authOverride_==='object'){requestData['authvar']=this.authOverride_;}this.sendRequest(authMethod,requestData,res=>{const status=res[/*status*/'s'];const data=res[/*data*/'d']||'error';if(this.authToken_===token){if(status==='ok'){this.invalidAuthTokenCount_=0;}else{// Triggers reconnect and force refresh for auth token
this.onAuthRevoked_(status,data);}}});}}/**
     * Attempts to authenticate with the given token. If the authentication
     * attempt fails, it's triggered like the token was revoked (the connection is
     * closed).
     */tryAppCheck(){if(this.connected_&&this.appCheckToken_){this.sendRequest('appcheck',{'token':this.appCheckToken_},res=>{const status=res[/*status*/'s'];const data=res[/*data*/'d']||'error';if(status==='ok'){this.invalidAppCheckTokenCount_=0;}else{this.onAppCheckRevoked_(status,data);}});}}/**
     * @inheritDoc
     */unlisten(query,tag){const pathString=query._path.toString();const queryId=query._queryIdentifier;this.log_('Unlisten called for '+pathString+' '+queryId);(0,_util.assert)(query._queryParams.isDefault()||!query._queryParams.loadsAllData(),'unlisten() called for non-default but complete query');const listen=this.removeListen_(pathString,queryId);if(listen&&this.connected_){this.sendUnlisten_(pathString,queryId,query._queryObject,tag);}}sendUnlisten_(pathString,queryId,queryObj,tag){this.log_('Unlisten on '+pathString+' for '+queryId);const req={/*path*/p:pathString};const action='n';// Only bother sending queryId if it's non-default.
if(tag){req['q']=queryObj;req['t']=tag;}this.sendRequest(action,req);}onDisconnectPut(pathString,data,onComplete){this.initConnection_();if(this.connected_){this.sendOnDisconnect_('o',pathString,data,onComplete);}else{this.onDisconnectRequestQueue_.push({pathString,action:'o',data,onComplete});}}onDisconnectMerge(pathString,data,onComplete){this.initConnection_();if(this.connected_){this.sendOnDisconnect_('om',pathString,data,onComplete);}else{this.onDisconnectRequestQueue_.push({pathString,action:'om',data,onComplete});}}onDisconnectCancel(pathString,onComplete){this.initConnection_();if(this.connected_){this.sendOnDisconnect_('oc',pathString,null,onComplete);}else{this.onDisconnectRequestQueue_.push({pathString,action:'oc',data:null,onComplete});}}sendOnDisconnect_(action,pathString,data,onComplete){const request={/*path*/p:pathString,/*data*/d:data};this.log_('onDisconnect '+action,request);this.sendRequest(action,request,response=>{if(onComplete){setTimeout(()=>{onComplete(response[/*status*/'s'],response[/* data */'d']);},Math.floor(0));}});}put(pathString,data,onComplete,hash){this.putInternal('p',pathString,data,onComplete,hash);}merge(pathString,data,onComplete,hash){this.putInternal('m',pathString,data,onComplete,hash);}putInternal(action,pathString,data,onComplete,hash){this.initConnection_();const request={/*path*/p:pathString,/*data*/d:data};if(hash!==undefined){request[/*hash*/'h']=hash;}// TODO: Only keep track of the most recent put for a given path?
this.outstandingPuts_.push({action,request,onComplete});this.outstandingPutCount_++;const index=this.outstandingPuts_.length-1;if(this.connected_){this.sendPut_(index);}else{this.log_('Buffering put: '+pathString);}}sendPut_(index){const action=this.outstandingPuts_[index].action;const request=this.outstandingPuts_[index].request;const onComplete=this.outstandingPuts_[index].onComplete;this.outstandingPuts_[index].queued=this.connected_;this.sendRequest(action,request,message=>{this.log_(action+' response',message);delete this.outstandingPuts_[index];this.outstandingPutCount_--;// Clean up array occasionally.
if(this.outstandingPutCount_===0){this.outstandingPuts_=[];}if(onComplete){onComplete(message[/*status*/'s'],message[/* data */'d']);}});}reportStats(stats){// If we're not connected, we just drop the stats.
if(this.connected_){const request={/*counters*/c:stats};this.log_('reportStats',request);this.sendRequest(/*stats*/'s',request,result=>{const status=result[/*status*/'s'];if(status!=='ok'){const errorReason=result[/* data */'d'];this.log_('reportStats','Error sending stats: '+errorReason);}});}}onDataMessage_(message){if('r'in message){// this is a response
this.log_('from server: '+(0,_util.stringify)(message));const reqNum=message['r'];const onResponse=this.requestCBHash_[reqNum];if(onResponse){delete this.requestCBHash_[reqNum];onResponse(message[/*body*/'b']);}}else if('error'in message){throw'A server-side error has occurred: '+message['error'];}else if('a'in message){// a and b are action and body, respectively
this.onDataPush_(message['a'],message['b']);}}onDataPush_(action,body){this.log_('handleServerMessage',action,body);if(action==='d'){this.onDataUpdate_(body[/*path*/'p'],body[/*data*/'d'],/*isMerge*/false,body['t']);}else if(action==='m'){this.onDataUpdate_(body[/*path*/'p'],body[/*data*/'d'],/*isMerge=*/true,body['t']);}else if(action==='c'){this.onListenRevoked_(body[/*path*/'p'],body[/*query*/'q']);}else if(action==='ac'){this.onAuthRevoked_(body[/*status code*/'s'],body[/* explanation */'d']);}else if(action==='apc'){this.onAppCheckRevoked_(body[/*status code*/'s'],body[/* explanation */'d']);}else if(action==='sd'){this.onSecurityDebugPacket_(body);}else{error('Unrecognized action received from server: '+(0,_util.stringify)(action)+'\nAre you using the latest client?');}}onReady_(timestamp,sessionId){this.log_('connection ready');this.connected_=true;this.lastConnectionEstablishedTime_=new Date().getTime();this.handleTimestamp_(timestamp);this.lastSessionId=sessionId;if(this.firstConnection_){this.sendConnectStats_();}this.restoreState_();this.firstConnection_=false;this.onConnectStatus_(true);}scheduleConnect_(timeout){(0,_util.assert)(!this.realtime_,"Scheduling a connect when we're already connected/ing?");if(this.establishConnectionTimer_){clearTimeout(this.establishConnectionTimer_);}// NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating "Security Error" in
// Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).
this.establishConnectionTimer_=setTimeout(()=>{this.establishConnectionTimer_=null;this.establishConnection_();// eslint-disable-next-line @typescript-eslint/no-explicit-any
},Math.floor(timeout));}initConnection_(){if(!this.realtime_&&this.firstConnection_){this.scheduleConnect_(0);}}onVisible_(visible){// NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.
if(visible&&!this.visible_&&this.reconnectDelay_===this.maxReconnectDelay_){this.log_('Window became visible.  Reducing delay.');this.reconnectDelay_=RECONNECT_MIN_DELAY;if(!this.realtime_){this.scheduleConnect_(0);}}this.visible_=visible;}onOnline_(online){if(online){this.log_('Browser went online.');this.reconnectDelay_=RECONNECT_MIN_DELAY;if(!this.realtime_){this.scheduleConnect_(0);}}else{this.log_('Browser went offline.  Killing connection.');if(this.realtime_){this.realtime_.close();}}}onRealtimeDisconnect_(){this.log_('data client disconnected');this.connected_=false;this.realtime_=null;// Since we don't know if our sent transactions succeeded or not, we need to cancel them.
this.cancelSentTransactions_();// Clear out the pending requests.
this.requestCBHash_={};if(this.shouldReconnect_()){if(!this.visible_){this.log_("Window isn't visible.  Delaying reconnect.");this.reconnectDelay_=this.maxReconnectDelay_;this.lastConnectionAttemptTime_=new Date().getTime();}else if(this.lastConnectionEstablishedTime_){// If we've been connected long enough, reset reconnect delay to minimum.
const timeSinceLastConnectSucceeded=new Date().getTime()-this.lastConnectionEstablishedTime_;if(timeSinceLastConnectSucceeded>RECONNECT_DELAY_RESET_TIMEOUT){this.reconnectDelay_=RECONNECT_MIN_DELAY;}this.lastConnectionEstablishedTime_=null;}const timeSinceLastConnectAttempt=new Date().getTime()-this.lastConnectionAttemptTime_;let reconnectDelay=Math.max(0,this.reconnectDelay_-timeSinceLastConnectAttempt);reconnectDelay=Math.random()*reconnectDelay;this.log_('Trying to reconnect in '+reconnectDelay+'ms');this.scheduleConnect_(reconnectDelay);// Adjust reconnect delay for next time.
this.reconnectDelay_=Math.min(this.maxReconnectDelay_,this.reconnectDelay_*RECONNECT_DELAY_MULTIPLIER);}this.onConnectStatus_(false);}async establishConnection_(){if(this.shouldReconnect_()){this.log_('Making a connection attempt');this.lastConnectionAttemptTime_=new Date().getTime();this.lastConnectionEstablishedTime_=null;const onDataMessage=this.onDataMessage_.bind(this);const onReady=this.onReady_.bind(this);const onDisconnect=this.onRealtimeDisconnect_.bind(this);const connId=this.id+':'+PersistentConnection.nextConnectionId_++;const lastSessionId=this.lastSessionId;let canceled=false;let connection=null;const closeFn=function(){if(connection){connection.close();}else{canceled=true;onDisconnect();}};const sendRequestFn=function(msg){(0,_util.assert)(connection,"sendRequest call when we're not connected not allowed.");connection.sendRequest(msg);};this.realtime_={close:closeFn,sendRequest:sendRequestFn};const forceRefresh=this.forceTokenRefresh_;this.forceTokenRefresh_=false;try{// First fetch auth and app check token, and establish connection after
// fetching the token was successful
const[authToken,appCheckToken]=await Promise.all([this.authTokenProvider_.getToken(forceRefresh),this.appCheckTokenProvider_.getToken(forceRefresh)]);if(!canceled){log('getToken() completed. Creating connection.');this.authToken_=authToken&&authToken.accessToken;this.appCheckToken_=appCheckToken&&appCheckToken.token;connection=new Connection(connId,this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,onDataMessage,onReady,onDisconnect,/* onKill= */reason=>{warn(reason+' ('+this.repoInfo_.toString()+')');this.interrupt(SERVER_KILL_INTERRUPT_REASON);},lastSessionId);}else{log('getToken() completed but was canceled');}}catch(error){this.log_('Failed to get token: '+error);if(!canceled){if(this.repoInfo_.nodeAdmin){// This may be a critical error for the Admin Node.js SDK, so log a warning.
// But getToken() may also just have temporarily failed, so we still want to
// continue retrying.
warn(error);}closeFn();}}}}interrupt(reason){log('Interrupting connection for reason: '+reason);this.interruptReasons_[reason]=true;if(this.realtime_){this.realtime_.close();}else{if(this.establishConnectionTimer_){clearTimeout(this.establishConnectionTimer_);this.establishConnectionTimer_=null;}if(this.connected_){this.onRealtimeDisconnect_();}}}resume(reason){log('Resuming connection for reason: '+reason);delete this.interruptReasons_[reason];if((0,_util.isEmpty)(this.interruptReasons_)){this.reconnectDelay_=RECONNECT_MIN_DELAY;if(!this.realtime_){this.scheduleConnect_(0);}}}handleTimestamp_(timestamp){const delta=timestamp-new Date().getTime();this.onServerInfoUpdate_({serverTimeOffset:delta});}cancelSentTransactions_(){for(let i=0;i<this.outstandingPuts_.length;i++){const put=this.outstandingPuts_[i];if(put&&/*hash*/'h'in put.request&&put.queued){if(put.onComplete){put.onComplete('disconnect');}delete this.outstandingPuts_[i];this.outstandingPutCount_--;}}// Clean up array occasionally.
if(this.outstandingPutCount_===0){this.outstandingPuts_=[];}}onListenRevoked_(pathString,query){// Remove the listen and manufacture a "permission_denied" error for the failed listen.
let queryId;if(!query){queryId='default';}else{queryId=query.map(q=>ObjectToUniqueKey(q)).join('$');}const listen=this.removeListen_(pathString,queryId);if(listen&&listen.onComplete){listen.onComplete('permission_denied');}}removeListen_(pathString,queryId){const normalizedPathString=new Path(pathString).toString();// normalize path.
let listen;if(this.listens.has(normalizedPathString)){const map=this.listens.get(normalizedPathString);listen=map.get(queryId);map.delete(queryId);if(map.size===0){this.listens.delete(normalizedPathString);}}else{// all listens for this path has already been removed
listen=undefined;}return listen;}onAuthRevoked_(statusCode,explanation){log('Auth token revoked: '+statusCode+'/'+explanation);this.authToken_=null;this.forceTokenRefresh_=true;this.realtime_.close();if(statusCode==='invalid_token'||statusCode==='permission_denied'){// We'll wait a couple times before logging the warning / increasing the
// retry period since oauth tokens will report as "invalid" if they're
// just expired. Plus there may be transient issues that resolve themselves.
this.invalidAuthTokenCount_++;if(this.invalidAuthTokenCount_>=INVALID_TOKEN_THRESHOLD){// Set a long reconnect delay because recovery is unlikely
this.reconnectDelay_=RECONNECT_MAX_DELAY_FOR_ADMINS;// Notify the auth token provider that the token is invalid, which will log
// a warning
this.authTokenProvider_.notifyForInvalidToken();}}}onAppCheckRevoked_(statusCode,explanation){log('App check token revoked: '+statusCode+'/'+explanation);this.appCheckToken_=null;this.forceTokenRefresh_=true;// Note: We don't close the connection as the developer may not have
// enforcement enabled. The backend closes connections with enforcements.
if(statusCode==='invalid_token'||statusCode==='permission_denied'){// We'll wait a couple times before logging the warning / increasing the
// retry period since oauth tokens will report as "invalid" if they're
// just expired. Plus there may be transient issues that resolve themselves.
this.invalidAppCheckTokenCount_++;if(this.invalidAppCheckTokenCount_>=INVALID_TOKEN_THRESHOLD){this.appCheckTokenProvider_.notifyForInvalidToken();}}}onSecurityDebugPacket_(body){if(this.securityDebugCallback_){this.securityDebugCallback_(body);}else{if('msg'in body){console.log('FIREBASE: '+body['msg'].replace('\n','\nFIREBASE: '));}}}restoreState_(){//Re-authenticate ourselves if we have a credential stored.
this.tryAuth();this.tryAppCheck();// Puts depend on having received the corresponding data update from the server before they complete, so we must
// make sure to send listens before puts.
for(const queries of this.listens.values()){for(const listenSpec of queries.values()){this.sendListen_(listenSpec);}}for(let i=0;i<this.outstandingPuts_.length;i++){if(this.outstandingPuts_[i]){this.sendPut_(i);}}while(this.onDisconnectRequestQueue_.length){const request=this.onDisconnectRequestQueue_.shift();this.sendOnDisconnect_(request.action,request.pathString,request.data,request.onComplete);}for(let i=0;i<this.outstandingGets_.length;i++){if(this.outstandingGets_[i]){this.sendGet_(i);}}}/**
     * Sends client stats for first connection
     */sendConnectStats_(){const stats={};let clientName='js';if((0,_util.isNodeSdk)()){if(this.repoInfo_.nodeAdmin){clientName='admin_node';}else{clientName='node';}}stats['sdk.'+clientName+'.'+SDK_VERSION.replace(/\./g,'-')]=1;if((0,_util.isMobileCordova)()){stats['framework.cordova']=1;}else if((0,_util.isReactNative)()){stats['framework.reactnative']=1;}this.reportStats(stats);}shouldReconnect_(){const online=OnlineMonitor.getInstance().currentlyOnline();return(0,_util.isEmpty)(this.interruptReasons_)&&online;}}PersistentConnection.nextPersistentConnectionId_=0;/**
 * Counter for number of connections created. Mainly used for tagging in the logs
 */PersistentConnection.nextConnectionId_=0;/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class NamedNode{constructor(name,node){this.name=name;this.node=node;}static Wrap(name,node){return new NamedNode(name,node);}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Index{/**
     * @returns A standalone comparison function for
     * this index
     */getCompare(){return this.compare.bind(this);}/**
     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,
     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.
     *
     *
     * @returns True if the portion of the snapshot being indexed changed between oldNode and newNode
     */indexedValueChanged(oldNode,newNode){const oldWrapped=new NamedNode(MIN_NAME,oldNode);const newWrapped=new NamedNode(MIN_NAME,newNode);return this.compare(oldWrapped,newWrapped)!==0;}/**
     * @returns a node wrapper that will sort equal to or less than
     * any other node wrapper, using this index
     */minPost(){// eslint-disable-next-line @typescript-eslint/no-explicit-any
return NamedNode.MIN;}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let __EMPTY_NODE;class KeyIndex extends Index{static get __EMPTY_NODE(){return __EMPTY_NODE;}static set __EMPTY_NODE(val){__EMPTY_NODE=val;}compare(a,b){return nameCompare(a.name,b.name);}isDefinedOn(node){// We could probably return true here (since every node has a key), but it's never called
// so just leaving unimplemented for now.
throw(0,_util.assertionError)('KeyIndex.isDefinedOn not expected to be called.');}indexedValueChanged(oldNode,newNode){return false;// The key for a node never changes.
}minPost(){// eslint-disable-next-line @typescript-eslint/no-explicit-any
return NamedNode.MIN;}maxPost(){// TODO: This should really be created once and cached in a static property, but
// NamedNode isn't defined yet, so I can't use it in a static.  Bleh.
return new NamedNode(MAX_NAME,__EMPTY_NODE);}makePost(indexValue,name){(0,_util.assert)(typeof indexValue==='string','KeyIndex indexValue must always be a string.');// We just use empty node, but it'll never be compared, since our comparator only looks at name.
return new NamedNode(indexValue,__EMPTY_NODE);}/**
     * @returns String representation for inclusion in a query spec
     */toString(){return'.key';}}const KEY_INDEX=new KeyIndex();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An iterator over an LLRBNode.
 */class SortedMapIterator{/**
     * @param node - Node to iterate.
     * @param isReverse_ - Whether or not to iterate in reverse
     */constructor(node,startKey,comparator,isReverse_,resultGenerator_=null){this.isReverse_=isReverse_;this.resultGenerator_=resultGenerator_;this.nodeStack_=[];let cmp=1;while(!node.isEmpty()){node=node;cmp=startKey?comparator(node.key,startKey):1;// flip the comparison if we're going in reverse
if(isReverse_){cmp*=-1;}if(cmp<0){// This node is less than our start key. ignore it
if(this.isReverse_){node=node.left;}else{node=node.right;}}else if(cmp===0){// This node is exactly equal to our start key. Push it on the stack, but stop iterating;
this.nodeStack_.push(node);break;}else{// This node is greater than our start key, add it to the stack and move to the next one
this.nodeStack_.push(node);if(this.isReverse_){node=node.right;}else{node=node.left;}}}}getNext(){if(this.nodeStack_.length===0){return null;}let node=this.nodeStack_.pop();let result;if(this.resultGenerator_){result=this.resultGenerator_(node.key,node.value);}else{result={key:node.key,value:node.value};}if(this.isReverse_){node=node.left;while(!node.isEmpty()){this.nodeStack_.push(node);node=node.right;}}else{node=node.right;while(!node.isEmpty()){this.nodeStack_.push(node);node=node.left;}}return result;}hasNext(){return this.nodeStack_.length>0;}peek(){if(this.nodeStack_.length===0){return null;}const node=this.nodeStack_[this.nodeStack_.length-1];if(this.resultGenerator_){return this.resultGenerator_(node.key,node.value);}else{return{key:node.key,value:node.value};}}}/**
 * Represents a node in a Left-leaning Red-Black tree.
 */class LLRBNode{/**
     * @param key - Key associated with this node.
     * @param value - Value associated with this node.
     * @param color - Whether this node is red.
     * @param left - Left child.
     * @param right - Right child.
     */constructor(key,value,color,left,right){this.key=key;this.value=value;this.color=color!=null?color:LLRBNode.RED;this.left=left!=null?left:SortedMap.EMPTY_NODE;this.right=right!=null?right:SortedMap.EMPTY_NODE;}/**
     * Returns a copy of the current node, optionally replacing pieces of it.
     *
     * @param key - New key for the node, or null.
     * @param value - New value for the node, or null.
     * @param color - New color for the node, or null.
     * @param left - New left child for the node, or null.
     * @param right - New right child for the node, or null.
     * @returns The node copy.
     */copy(key,value,color,left,right){return new LLRBNode(key!=null?key:this.key,value!=null?value:this.value,color!=null?color:this.color,left!=null?left:this.left,right!=null?right:this.right);}/**
     * @returns The total number of nodes in the tree.
     */count(){return this.left.count()+1+this.right.count();}/**
     * @returns True if the tree is empty.
     */isEmpty(){return false;}/**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     *   node.  If it returns true, traversal is aborted.
     * @returns The first truthy value returned by action, or the last falsey
     *   value returned by action
     */inorderTraversal(action){return this.left.inorderTraversal(action)||!!action(this.key,this.value)||this.right.inorderTraversal(action);}/**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */reverseTraversal(action){return this.right.reverseTraversal(action)||action(this.key,this.value)||this.left.reverseTraversal(action);}/**
     * @returns The minimum node in the tree.
     */min_(){if(this.left.isEmpty()){return this;}else{return this.left.min_();}}/**
     * @returns The maximum key in the tree.
     */minKey(){return this.min_().key;}/**
     * @returns The maximum key in the tree.
     */maxKey(){if(this.right.isEmpty()){return this.key;}else{return this.right.maxKey();}}/**
     * @param key - Key to insert.
     * @param value - Value to insert.
     * @param comparator - Comparator.
     * @returns New tree, with the key/value added.
     */insert(key,value,comparator){let n=this;const cmp=comparator(key,n.key);if(cmp<0){n=n.copy(null,null,null,n.left.insert(key,value,comparator),null);}else if(cmp===0){n=n.copy(null,value,null,null,null);}else{n=n.copy(null,null,null,null,n.right.insert(key,value,comparator));}return n.fixUp_();}/**
     * @returns New tree, with the minimum key removed.
     */removeMin_(){if(this.left.isEmpty()){return SortedMap.EMPTY_NODE;}let n=this;if(!n.left.isRed_()&&!n.left.left.isRed_()){n=n.moveRedLeft_();}n=n.copy(null,null,null,n.left.removeMin_(),null);return n.fixUp_();}/**
     * @param key - The key of the item to remove.
     * @param comparator - Comparator.
     * @returns New tree, with the specified item removed.
     */remove(key,comparator){let n,smallest;n=this;if(comparator(key,n.key)<0){if(!n.left.isEmpty()&&!n.left.isRed_()&&!n.left.left.isRed_()){n=n.moveRedLeft_();}n=n.copy(null,null,null,n.left.remove(key,comparator),null);}else{if(n.left.isRed_()){n=n.rotateRight_();}if(!n.right.isEmpty()&&!n.right.isRed_()&&!n.right.left.isRed_()){n=n.moveRedRight_();}if(comparator(key,n.key)===0){if(n.right.isEmpty()){return SortedMap.EMPTY_NODE;}else{smallest=n.right.min_();n=n.copy(smallest.key,smallest.value,null,null,n.right.removeMin_());}}n=n.copy(null,null,null,null,n.right.remove(key,comparator));}return n.fixUp_();}/**
     * @returns Whether this is a RED node.
     */isRed_(){return this.color;}/**
     * @returns New tree after performing any needed rotations.
     */fixUp_(){let n=this;if(n.right.isRed_()&&!n.left.isRed_()){n=n.rotateLeft_();}if(n.left.isRed_()&&n.left.left.isRed_()){n=n.rotateRight_();}if(n.left.isRed_()&&n.right.isRed_()){n=n.colorFlip_();}return n;}/**
     * @returns New tree, after moveRedLeft.
     */moveRedLeft_(){let n=this.colorFlip_();if(n.right.left.isRed_()){n=n.copy(null,null,null,null,n.right.rotateRight_());n=n.rotateLeft_();n=n.colorFlip_();}return n;}/**
     * @returns New tree, after moveRedRight.
     */moveRedRight_(){let n=this.colorFlip_();if(n.left.left.isRed_()){n=n.rotateRight_();n=n.colorFlip_();}return n;}/**
     * @returns New tree, after rotateLeft.
     */rotateLeft_(){const nl=this.copy(null,null,LLRBNode.RED,null,this.right.left);return this.right.copy(null,null,this.color,nl,null);}/**
     * @returns New tree, after rotateRight.
     */rotateRight_(){const nr=this.copy(null,null,LLRBNode.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,nr);}/**
     * @returns Newt ree, after colorFlip.
     */colorFlip_(){const left=this.left.copy(null,null,!this.left.color,null,null);const right=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,left,right);}/**
     * For testing.
     *
     * @returns True if all is well.
     */checkMaxDepth_(){const blackDepth=this.check_();return Math.pow(2.0,blackDepth)<=this.count()+1;}check_(){if(this.isRed_()&&this.left.isRed_()){throw new Error('Red node has red child('+this.key+','+this.value+')');}if(this.right.isRed_()){throw new Error('Right child of ('+this.key+','+this.value+') is red');}const blackDepth=this.left.check_();if(blackDepth!==this.right.check_()){throw new Error('Black depths differ');}else{return blackDepth+(this.isRed_()?0:1);}}}LLRBNode.RED=true;LLRBNode.BLACK=false;/**
 * Represents an empty node (a leaf node in the Red-Black Tree).
 */class LLRBEmptyNode{/**
     * Returns a copy of the current node.
     *
     * @returns The node copy.
     */copy(key,value,color,left,right){return this;}/**
     * Returns a copy of the tree, with the specified key/value added.
     *
     * @param key - Key to be added.
     * @param value - Value to be added.
     * @param comparator - Comparator.
     * @returns New tree, with item added.
     */insert(key,value,comparator){return new LLRBNode(key,value,null);}/**
     * Returns a copy of the tree, with the specified key removed.
     *
     * @param key - The key to remove.
     * @param comparator - Comparator.
     * @returns New tree, with item removed.
     */remove(key,comparator){return this;}/**
     * @returns The total number of nodes in the tree.
     */count(){return 0;}/**
     * @returns True if the tree is empty.
     */isEmpty(){return true;}/**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */inorderTraversal(action){return false;}/**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */reverseTraversal(action){return false;}minKey(){return null;}maxKey(){return null;}check_(){return 0;}/**
     * @returns Whether this node is red.
     */isRed_(){return false;}}/**
 * An immutable sorted map implementation, based on a Left-leaning Red-Black
 * tree.
 */class SortedMap{/**
     * @param comparator_ - Key comparator.
     * @param root_ - Optional root node for the map.
     */constructor(comparator_,root_=SortedMap.EMPTY_NODE){this.comparator_=comparator_;this.root_=root_;}/**
     * Returns a copy of the map, with the specified key/value added or replaced.
     * (TODO: We should perhaps rename this method to 'put')
     *
     * @param key - Key to be added.
     * @param value - Value to be added.
     * @returns New map, with item added.
     */insert(key,value){return new SortedMap(this.comparator_,this.root_.insert(key,value,this.comparator_).copy(null,null,LLRBNode.BLACK,null,null));}/**
     * Returns a copy of the map, with the specified key removed.
     *
     * @param key - The key to remove.
     * @returns New map, with item removed.
     */remove(key){return new SortedMap(this.comparator_,this.root_.remove(key,this.comparator_).copy(null,null,LLRBNode.BLACK,null,null));}/**
     * Returns the value of the node with the given key, or null.
     *
     * @param key - The key to look up.
     * @returns The value of the node with the given key, or null if the
     * key doesn't exist.
     */get(key){let cmp;let node=this.root_;while(!node.isEmpty()){cmp=this.comparator_(key,node.key);if(cmp===0){return node.value;}else if(cmp<0){node=node.left;}else if(cmp>0){node=node.right;}}return null;}/**
     * Returns the key of the item *before* the specified key, or null if key is the first item.
     * @param key - The key to find the predecessor of
     * @returns The predecessor key.
     */getPredecessorKey(key){let cmp,node=this.root_,rightParent=null;while(!node.isEmpty()){cmp=this.comparator_(key,node.key);if(cmp===0){if(!node.left.isEmpty()){node=node.left;while(!node.right.isEmpty()){node=node.right;}return node.key;}else if(rightParent){return rightParent.key;}else{return null;// first item.
}}else if(cmp<0){node=node.left;}else if(cmp>0){rightParent=node;node=node.right;}}throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');}/**
     * @returns True if the map is empty.
     */isEmpty(){return this.root_.isEmpty();}/**
     * @returns The total number of nodes in the map.
     */count(){return this.root_.count();}/**
     * @returns The minimum key in the map.
     */minKey(){return this.root_.minKey();}/**
     * @returns The maximum key in the map.
     */maxKey(){return this.root_.maxKey();}/**
     * Traverses the map in key order and calls the specified action function
     * for each key/value pair.
     *
     * @param action - Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @returns The first truthy value returned by action, or the last falsey
     *   value returned by action
     */inorderTraversal(action){return this.root_.inorderTraversal(action);}/**
     * Traverses the map in reverse key order and calls the specified action function
     * for each key/value pair.
     *
     * @param action - Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @returns True if the traversal was aborted.
     */reverseTraversal(action){return this.root_.reverseTraversal(action);}/**
     * Returns an iterator over the SortedMap.
     * @returns The iterator.
     */getIterator(resultGenerator){return new SortedMapIterator(this.root_,null,this.comparator_,false,resultGenerator);}getIteratorFrom(key,resultGenerator){return new SortedMapIterator(this.root_,key,this.comparator_,false,resultGenerator);}getReverseIteratorFrom(key,resultGenerator){return new SortedMapIterator(this.root_,key,this.comparator_,true,resultGenerator);}getReverseIterator(resultGenerator){return new SortedMapIterator(this.root_,null,this.comparator_,true,resultGenerator);}}/**
 * Always use the same empty node, to reduce memory.
 */SortedMap.EMPTY_NODE=new LLRBEmptyNode();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function NAME_ONLY_COMPARATOR(left,right){return nameCompare(left.name,right.name);}function NAME_COMPARATOR(left,right){return nameCompare(left,right);}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let MAX_NODE$2;function setMaxNode$1(val){MAX_NODE$2=val;}const priorityHashText=function(priority){if(typeof priority==='number'){return'number:'+doubleToIEEE754String(priority);}else{return'string:'+priority;}};/**
 * Validates that a priority snapshot Node is valid.
 */const validatePriorityNode=function(priorityNode){if(priorityNode.isLeafNode()){const val=priorityNode.val();(0,_util.assert)(typeof val==='string'||typeof val==='number'||typeof val==='object'&&(0,_util.contains)(val,'.sv'),'Priority must be a string or number.');}else{(0,_util.assert)(priorityNode===MAX_NODE$2||priorityNode.isEmpty(),'priority of unexpected type.');}// Don't call getPriority() on MAX_NODE to avoid hitting assertion.
(0,_util.assert)(priorityNode===MAX_NODE$2||priorityNode.getPriority().isEmpty(),"Priority nodes can't have a priority of their own.");};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let __childrenNodeConstructor;/**
 * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It
 * implements Node and stores the value of the node (a string,
 * number, or boolean) accessible via getValue().
 */class LeafNode{/**
     * @param value_ - The value to store in this leaf node. The object type is
     * possible in the event of a deferred value
     * @param priorityNode_ - The priority of this node.
     */constructor(value_,priorityNode_=LeafNode.__childrenNodeConstructor.EMPTY_NODE){this.value_=value_;this.priorityNode_=priorityNode_;this.lazyHash_=null;(0,_util.assert)(this.value_!==undefined&&this.value_!==null,"LeafNode shouldn't be created with null/undefined value.");validatePriorityNode(this.priorityNode_);}static set __childrenNodeConstructor(val){__childrenNodeConstructor=val;}static get __childrenNodeConstructor(){return __childrenNodeConstructor;}/** @inheritDoc */isLeafNode(){return true;}/** @inheritDoc */getPriority(){return this.priorityNode_;}/** @inheritDoc */updatePriority(newPriorityNode){return new LeafNode(this.value_,newPriorityNode);}/** @inheritDoc */getImmediateChild(childName){// Hack to treat priority as a regular child
if(childName==='.priority'){return this.priorityNode_;}else{return LeafNode.__childrenNodeConstructor.EMPTY_NODE;}}/** @inheritDoc */getChild(path){if(pathIsEmpty(path)){return this;}else if(pathGetFront(path)==='.priority'){return this.priorityNode_;}else{return LeafNode.__childrenNodeConstructor.EMPTY_NODE;}}hasChild(){return false;}/** @inheritDoc */getPredecessorChildName(childName,childNode){return null;}/** @inheritDoc */updateImmediateChild(childName,newChildNode){if(childName==='.priority'){return this.updatePriority(newChildNode);}else if(newChildNode.isEmpty()&&childName!=='.priority'){return this;}else{return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName,newChildNode).updatePriority(this.priorityNode_);}}/** @inheritDoc */updateChild(path,newChildNode){const front=pathGetFront(path);if(front===null){return newChildNode;}else if(newChildNode.isEmpty()&&front!=='.priority'){return this;}else{(0,_util.assert)(front!=='.priority'||pathGetLength(path)===1,'.priority must be the last token in a path');return this.updateImmediateChild(front,LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path),newChildNode));}}/** @inheritDoc */isEmpty(){return false;}/** @inheritDoc */numChildren(){return 0;}/** @inheritDoc */forEachChild(index,action){return false;}val(exportFormat){if(exportFormat&&!this.getPriority().isEmpty()){return{'.value':this.getValue(),'.priority':this.getPriority().val()};}else{return this.getValue();}}/** @inheritDoc */hash(){if(this.lazyHash_===null){let toHash='';if(!this.priorityNode_.isEmpty()){toHash+='priority:'+priorityHashText(this.priorityNode_.val())+':';}const type=typeof this.value_;toHash+=type+':';if(type==='number'){toHash+=doubleToIEEE754String(this.value_);}else{toHash+=this.value_;}this.lazyHash_=sha1(toHash);}return this.lazyHash_;}/**
     * Returns the value of the leaf node.
     * @returns The value of the node.
     */getValue(){return this.value_;}compareTo(other){if(other===LeafNode.__childrenNodeConstructor.EMPTY_NODE){return 1;}else if(other instanceof LeafNode.__childrenNodeConstructor){return-1;}else{(0,_util.assert)(other.isLeafNode(),'Unknown node type');return this.compareToLeafNode_(other);}}/**
     * Comparison specifically for two leaf nodes
     */compareToLeafNode_(otherLeaf){const otherLeafType=typeof otherLeaf.value_;const thisLeafType=typeof this.value_;const otherIndex=LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);const thisIndex=LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);(0,_util.assert)(otherIndex>=0,'Unknown leaf type: '+otherLeafType);(0,_util.assert)(thisIndex>=0,'Unknown leaf type: '+thisLeafType);if(otherIndex===thisIndex){// Same type, compare values
if(thisLeafType==='object'){// Deferred value nodes are all equal, but we should also never get to this point...
return 0;}else{// Note that this works because true > false, all others are number or string comparisons
if(this.value_<otherLeaf.value_){return-1;}else if(this.value_===otherLeaf.value_){return 0;}else{return 1;}}}else{return thisIndex-otherIndex;}}withIndex(){return this;}isIndexed(){return true;}equals(other){if(other===this){return true;}else if(other.isLeafNode()){const otherLeaf=other;return this.value_===otherLeaf.value_&&this.priorityNode_.equals(otherLeaf.priorityNode_);}else{return false;}}}/**
 * The sort order for comparing leaf nodes of different types. If two leaf nodes have
 * the same type, the comparison falls back to their value
 */LeafNode.VALUE_TYPE_ORDER=['object','boolean','number','string'];/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let nodeFromJSON$1;let MAX_NODE$1;function setNodeFromJSON(val){nodeFromJSON$1=val;}function setMaxNode(val){MAX_NODE$1=val;}class PriorityIndex extends Index{compare(a,b){const aPriority=a.node.getPriority();const bPriority=b.node.getPriority();const indexCmp=aPriority.compareTo(bPriority);if(indexCmp===0){return nameCompare(a.name,b.name);}else{return indexCmp;}}isDefinedOn(node){return!node.getPriority().isEmpty();}indexedValueChanged(oldNode,newNode){return!oldNode.getPriority().equals(newNode.getPriority());}minPost(){// eslint-disable-next-line @typescript-eslint/no-explicit-any
return NamedNode.MIN;}maxPost(){return new NamedNode(MAX_NAME,new LeafNode('[PRIORITY-POST]',MAX_NODE$1));}makePost(indexValue,name){const priorityNode=nodeFromJSON$1(indexValue);return new NamedNode(name,new LeafNode('[PRIORITY-POST]',priorityNode));}/**
     * @returns String representation for inclusion in a query spec
     */toString(){return'.priority';}}const PRIORITY_INDEX=new PriorityIndex();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const LOG_2=Math.log(2);class Base12Num{constructor(length){const logBase2=num=>// eslint-disable-next-line @typescript-eslint/no-explicit-any
parseInt(Math.log(num)/LOG_2,10);const bitMask=bits=>parseInt(Array(bits+1).join('1'),2);this.count=logBase2(length+1);this.current_=this.count-1;const mask=bitMask(this.count);this.bits_=length+1&mask;}nextBitIsOne(){//noinspection JSBitwiseOperatorUsage
const result=!(this.bits_&0x1<<this.current_);this.current_--;return result;}}/**
 * Takes a list of child nodes and constructs a SortedSet using the given comparison
 * function
 *
 * Uses the algorithm described in the paper linked here:
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458
 *
 * @param childList - Unsorted list of children
 * @param cmp - The comparison method to be used
 * @param keyFn - An optional function to extract K from a node wrapper, if K's
 * type is not NamedNode
 * @param mapSortFn - An optional override for comparator used by the generated sorted map
 */const buildChildSet=function(childList,cmp,keyFn,mapSortFn){childList.sort(cmp);const buildBalancedTree=function(low,high){const length=high-low;let namedNode;let key;if(length===0){return null;}else if(length===1){namedNode=childList[low];key=keyFn?keyFn(namedNode):namedNode;return new LLRBNode(key,namedNode.node,LLRBNode.BLACK,null,null);}else{// eslint-disable-next-line @typescript-eslint/no-explicit-any
const middle=parseInt(length/2,10)+low;const left=buildBalancedTree(low,middle);const right=buildBalancedTree(middle+1,high);namedNode=childList[middle];key=keyFn?keyFn(namedNode):namedNode;return new LLRBNode(key,namedNode.node,LLRBNode.BLACK,left,right);}};const buildFrom12Array=function(base12){let node=null;let root=null;let index=childList.length;const buildPennant=function(chunkSize,color){const low=index-chunkSize;const high=index;index-=chunkSize;const childTree=buildBalancedTree(low+1,high);const namedNode=childList[low];const key=keyFn?keyFn(namedNode):namedNode;attachPennant(new LLRBNode(key,namedNode.node,color,null,childTree));};const attachPennant=function(pennant){if(node){node.left=pennant;node=pennant;}else{root=pennant;node=pennant;}};for(let i=0;i<base12.count;++i){const isOne=base12.nextBitIsOne();// The number of nodes taken in each slice is 2^(arr.length - (i + 1))
const chunkSize=Math.pow(2,base12.count-(i+1));if(isOne){buildPennant(chunkSize,LLRBNode.BLACK);}else{// current == 2
buildPennant(chunkSize,LLRBNode.BLACK);buildPennant(chunkSize,LLRBNode.RED);}}return root;};const base12=new Base12Num(childList.length);const root=buildFrom12Array(base12);// eslint-disable-next-line @typescript-eslint/no-explicit-any
return new SortedMap(mapSortFn||cmp,root);};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let _defaultIndexMap;const fallbackObject={};class IndexMap{constructor(indexes_,indexSet_){this.indexes_=indexes_;this.indexSet_=indexSet_;}/**
     * The default IndexMap for nodes without a priority
     */static get Default(){(0,_util.assert)(fallbackObject&&PRIORITY_INDEX,'ChildrenNode.ts has not been loaded');_defaultIndexMap=_defaultIndexMap||new IndexMap({'.priority':fallbackObject},{'.priority':PRIORITY_INDEX});return _defaultIndexMap;}get(indexKey){const sortedMap=(0,_util.safeGet)(this.indexes_,indexKey);if(!sortedMap){throw new Error('No index defined for '+indexKey);}if(sortedMap instanceof SortedMap){return sortedMap;}else{// The index exists, but it falls back to just name comparison. Return null so that the calling code uses the
// regular child map
return null;}}hasIndex(indexDefinition){return(0,_util.contains)(this.indexSet_,indexDefinition.toString());}addIndex(indexDefinition,existingChildren){(0,_util.assert)(indexDefinition!==KEY_INDEX,"KeyIndex always exists and isn't meant to be added to the IndexMap.");const childList=[];let sawIndexedValue=false;const iter=existingChildren.getIterator(NamedNode.Wrap);let next=iter.getNext();while(next){sawIndexedValue=sawIndexedValue||indexDefinition.isDefinedOn(next.node);childList.push(next);next=iter.getNext();}let newIndex;if(sawIndexedValue){newIndex=buildChildSet(childList,indexDefinition.getCompare());}else{newIndex=fallbackObject;}const indexName=indexDefinition.toString();const newIndexSet=Object.assign({},this.indexSet_);newIndexSet[indexName]=indexDefinition;const newIndexes=Object.assign({},this.indexes_);newIndexes[indexName]=newIndex;return new IndexMap(newIndexes,newIndexSet);}/**
     * Ensure that this node is properly tracked in any indexes that we're maintaining
     */addToIndexes(namedNode,existingChildren){const newIndexes=(0,_util.map)(this.indexes_,(indexedChildren,indexName)=>{const index=(0,_util.safeGet)(this.indexSet_,indexName);(0,_util.assert)(index,'Missing index implementation for '+indexName);if(indexedChildren===fallbackObject){// Check to see if we need to index everything
if(index.isDefinedOn(namedNode.node)){// We need to build this index
const childList=[];const iter=existingChildren.getIterator(NamedNode.Wrap);let next=iter.getNext();while(next){if(next.name!==namedNode.name){childList.push(next);}next=iter.getNext();}childList.push(namedNode);return buildChildSet(childList,index.getCompare());}else{// No change, this remains a fallback
return fallbackObject;}}else{const existingSnap=existingChildren.get(namedNode.name);let newChildren=indexedChildren;if(existingSnap){newChildren=newChildren.remove(new NamedNode(namedNode.name,existingSnap));}return newChildren.insert(namedNode,namedNode.node);}});return new IndexMap(newIndexes,this.indexSet_);}/**
     * Create a new IndexMap instance with the given value removed
     */removeFromIndexes(namedNode,existingChildren){const newIndexes=(0,_util.map)(this.indexes_,indexedChildren=>{if(indexedChildren===fallbackObject){// This is the fallback. Just return it, nothing to do in this case
return indexedChildren;}else{const existingSnap=existingChildren.get(namedNode.name);if(existingSnap){return indexedChildren.remove(new NamedNode(namedNode.name,existingSnap));}else{// No record of this child
return indexedChildren;}}});return new IndexMap(newIndexes,this.indexSet_);}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // TODO: For memory savings, don't store priorityNode_ if it's empty.
let EMPTY_NODE;/**
 * ChildrenNode is a class for storing internal nodes in a DataSnapshot
 * (i.e. nodes with children).  It implements Node and stores the
 * list of children in the children property, sorted by child name.
 */class ChildrenNode{/**
     * @param children_ - List of children of this node..
     * @param priorityNode_ - The priority of this node (as a snapshot node).
     */constructor(children_,priorityNode_,indexMap_){this.children_=children_;this.priorityNode_=priorityNode_;this.indexMap_=indexMap_;this.lazyHash_=null;/**
         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use
         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own
         * class instead of an empty ChildrenNode.
         */if(this.priorityNode_){validatePriorityNode(this.priorityNode_);}if(this.children_.isEmpty()){(0,_util.assert)(!this.priorityNode_||this.priorityNode_.isEmpty(),'An empty node cannot have a priority');}}static get EMPTY_NODE(){return EMPTY_NODE||(EMPTY_NODE=new ChildrenNode(new SortedMap(NAME_COMPARATOR),null,IndexMap.Default));}/** @inheritDoc */isLeafNode(){return false;}/** @inheritDoc */getPriority(){return this.priorityNode_||EMPTY_NODE;}/** @inheritDoc */updatePriority(newPriorityNode){if(this.children_.isEmpty()){// Don't allow priorities on empty nodes
return this;}else{return new ChildrenNode(this.children_,newPriorityNode,this.indexMap_);}}/** @inheritDoc */getImmediateChild(childName){// Hack to treat priority as a regular child
if(childName==='.priority'){return this.getPriority();}else{const child=this.children_.get(childName);return child===null?EMPTY_NODE:child;}}/** @inheritDoc */getChild(path){const front=pathGetFront(path);if(front===null){return this;}return this.getImmediateChild(front).getChild(pathPopFront(path));}/** @inheritDoc */hasChild(childName){return this.children_.get(childName)!==null;}/** @inheritDoc */updateImmediateChild(childName,newChildNode){(0,_util.assert)(newChildNode,'We should always be passing snapshot nodes');if(childName==='.priority'){return this.updatePriority(newChildNode);}else{const namedNode=new NamedNode(childName,newChildNode);let newChildren,newIndexMap;if(newChildNode.isEmpty()){newChildren=this.children_.remove(childName);newIndexMap=this.indexMap_.removeFromIndexes(namedNode,this.children_);}else{newChildren=this.children_.insert(childName,newChildNode);newIndexMap=this.indexMap_.addToIndexes(namedNode,this.children_);}const newPriority=newChildren.isEmpty()?EMPTY_NODE:this.priorityNode_;return new ChildrenNode(newChildren,newPriority,newIndexMap);}}/** @inheritDoc */updateChild(path,newChildNode){const front=pathGetFront(path);if(front===null){return newChildNode;}else{(0,_util.assert)(pathGetFront(path)!=='.priority'||pathGetLength(path)===1,'.priority must be the last token in a path');const newImmediateChild=this.getImmediateChild(front).updateChild(pathPopFront(path),newChildNode);return this.updateImmediateChild(front,newImmediateChild);}}/** @inheritDoc */isEmpty(){return this.children_.isEmpty();}/** @inheritDoc */numChildren(){return this.children_.count();}/** @inheritDoc */val(exportFormat){if(this.isEmpty()){return null;}const obj={};let numKeys=0,maxKey=0,allIntegerKeys=true;this.forEachChild(PRIORITY_INDEX,(key,childNode)=>{obj[key]=childNode.val(exportFormat);numKeys++;if(allIntegerKeys&&ChildrenNode.INTEGER_REGEXP_.test(key)){maxKey=Math.max(maxKey,Number(key));}else{allIntegerKeys=false;}});if(!exportFormat&&allIntegerKeys&&maxKey<2*numKeys){// convert to array.
const array=[];// eslint-disable-next-line guard-for-in
for(const key in obj){array[key]=obj[key];}return array;}else{if(exportFormat&&!this.getPriority().isEmpty()){obj['.priority']=this.getPriority().val();}return obj;}}/** @inheritDoc */hash(){if(this.lazyHash_===null){let toHash='';if(!this.getPriority().isEmpty()){toHash+='priority:'+priorityHashText(this.getPriority().val())+':';}this.forEachChild(PRIORITY_INDEX,(key,childNode)=>{const childHash=childNode.hash();if(childHash!==''){toHash+=':'+key+':'+childHash;}});this.lazyHash_=toHash===''?'':sha1(toHash);}return this.lazyHash_;}/** @inheritDoc */getPredecessorChildName(childName,childNode,index){const idx=this.resolveIndex_(index);if(idx){const predecessor=idx.getPredecessorKey(new NamedNode(childName,childNode));return predecessor?predecessor.name:null;}else{return this.children_.getPredecessorKey(childName);}}getFirstChildName(indexDefinition){const idx=this.resolveIndex_(indexDefinition);if(idx){const minKey=idx.minKey();return minKey&&minKey.name;}else{return this.children_.minKey();}}getFirstChild(indexDefinition){const minKey=this.getFirstChildName(indexDefinition);if(minKey){return new NamedNode(minKey,this.children_.get(minKey));}else{return null;}}/**
     * Given an index, return the key name of the largest value we have, according to that index
     */getLastChildName(indexDefinition){const idx=this.resolveIndex_(indexDefinition);if(idx){const maxKey=idx.maxKey();return maxKey&&maxKey.name;}else{return this.children_.maxKey();}}getLastChild(indexDefinition){const maxKey=this.getLastChildName(indexDefinition);if(maxKey){return new NamedNode(maxKey,this.children_.get(maxKey));}else{return null;}}forEachChild(index,action){const idx=this.resolveIndex_(index);if(idx){return idx.inorderTraversal(wrappedNode=>{return action(wrappedNode.name,wrappedNode.node);});}else{return this.children_.inorderTraversal(action);}}getIterator(indexDefinition){return this.getIteratorFrom(indexDefinition.minPost(),indexDefinition);}getIteratorFrom(startPost,indexDefinition){const idx=this.resolveIndex_(indexDefinition);if(idx){return idx.getIteratorFrom(startPost,key=>key);}else{const iterator=this.children_.getIteratorFrom(startPost.name,NamedNode.Wrap);let next=iterator.peek();while(next!=null&&indexDefinition.compare(next,startPost)<0){iterator.getNext();next=iterator.peek();}return iterator;}}getReverseIterator(indexDefinition){return this.getReverseIteratorFrom(indexDefinition.maxPost(),indexDefinition);}getReverseIteratorFrom(endPost,indexDefinition){const idx=this.resolveIndex_(indexDefinition);if(idx){return idx.getReverseIteratorFrom(endPost,key=>{return key;});}else{const iterator=this.children_.getReverseIteratorFrom(endPost.name,NamedNode.Wrap);let next=iterator.peek();while(next!=null&&indexDefinition.compare(next,endPost)>0){iterator.getNext();next=iterator.peek();}return iterator;}}compareTo(other){if(this.isEmpty()){if(other.isEmpty()){return 0;}else{return-1;}}else if(other.isLeafNode()||other.isEmpty()){return 1;}else if(other===MAX_NODE){return-1;}else{// Must be another node with children.
return 0;}}withIndex(indexDefinition){if(indexDefinition===KEY_INDEX||this.indexMap_.hasIndex(indexDefinition)){return this;}else{const newIndexMap=this.indexMap_.addIndex(indexDefinition,this.children_);return new ChildrenNode(this.children_,this.priorityNode_,newIndexMap);}}isIndexed(index){return index===KEY_INDEX||this.indexMap_.hasIndex(index);}equals(other){if(other===this){return true;}else if(other.isLeafNode()){return false;}else{const otherChildrenNode=other;if(!this.getPriority().equals(otherChildrenNode.getPriority())){return false;}else if(this.children_.count()===otherChildrenNode.children_.count()){const thisIter=this.getIterator(PRIORITY_INDEX);const otherIter=otherChildrenNode.getIterator(PRIORITY_INDEX);let thisCurrent=thisIter.getNext();let otherCurrent=otherIter.getNext();while(thisCurrent&&otherCurrent){if(thisCurrent.name!==otherCurrent.name||!thisCurrent.node.equals(otherCurrent.node)){return false;}thisCurrent=thisIter.getNext();otherCurrent=otherIter.getNext();}return thisCurrent===null&&otherCurrent===null;}else{return false;}}}/**
     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used
     * instead.
     *
     */resolveIndex_(indexDefinition){if(indexDefinition===KEY_INDEX){return null;}else{return this.indexMap_.get(indexDefinition.toString());}}}ChildrenNode.INTEGER_REGEXP_=/^(0|[1-9]\d*)$/;class MaxNode extends ChildrenNode{constructor(){super(new SortedMap(NAME_COMPARATOR),ChildrenNode.EMPTY_NODE,IndexMap.Default);}compareTo(other){if(other===this){return 0;}else{return 1;}}equals(other){// Not that we every compare it, but MAX_NODE is only ever equal to itself
return other===this;}getPriority(){return this;}getImmediateChild(childName){return ChildrenNode.EMPTY_NODE;}isEmpty(){return false;}}/**
 * Marker that will sort higher than any other snapshot.
 */const MAX_NODE=new MaxNode();Object.defineProperties(NamedNode,{MIN:{value:new NamedNode(MIN_NAME,ChildrenNode.EMPTY_NODE)},MAX:{value:new NamedNode(MAX_NAME,MAX_NODE)}});/**
 * Reference Extensions
 */KeyIndex.__EMPTY_NODE=ChildrenNode.EMPTY_NODE;LeafNode.__childrenNodeConstructor=ChildrenNode;setMaxNode$1(MAX_NODE);setMaxNode(MAX_NODE);/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const USE_HINZE=true;/**
 * Constructs a snapshot node representing the passed JSON and returns it.
 * @param json - JSON to create a node for.
 * @param priority - Optional priority to use.  This will be ignored if the
 * passed JSON contains a .priority property.
 */function nodeFromJSON(json,priority=null){if(json===null){return ChildrenNode.EMPTY_NODE;}if(typeof json==='object'&&'.priority'in json){priority=json['.priority'];}(0,_util.assert)(priority===null||typeof priority==='string'||typeof priority==='number'||typeof priority==='object'&&'.sv'in priority,'Invalid priority type found: '+typeof priority);if(typeof json==='object'&&'.value'in json&&json['.value']!==null){json=json['.value'];}// Valid leaf nodes include non-objects or server-value wrapper objects
if(typeof json!=='object'||'.sv'in json){const jsonLeaf=json;return new LeafNode(jsonLeaf,nodeFromJSON(priority));}if(!(json instanceof Array)&&USE_HINZE){const children=[];let childrenHavePriority=false;const hinzeJsonObj=json;each(hinzeJsonObj,(key,child)=>{if(key.substring(0,1)!=='.'){// Ignore metadata nodes
const childNode=nodeFromJSON(child);if(!childNode.isEmpty()){childrenHavePriority=childrenHavePriority||!childNode.getPriority().isEmpty();children.push(new NamedNode(key,childNode));}}});if(children.length===0){return ChildrenNode.EMPTY_NODE;}const childSet=buildChildSet(children,NAME_ONLY_COMPARATOR,namedNode=>namedNode.name,NAME_COMPARATOR);if(childrenHavePriority){const sortedChildSet=buildChildSet(children,PRIORITY_INDEX.getCompare());return new ChildrenNode(childSet,nodeFromJSON(priority),new IndexMap({'.priority':sortedChildSet},{'.priority':PRIORITY_INDEX}));}else{return new ChildrenNode(childSet,nodeFromJSON(priority),IndexMap.Default);}}else{let node=ChildrenNode.EMPTY_NODE;each(json,(key,childData)=>{if((0,_util.contains)(json,key)){if(key.substring(0,1)!=='.'){// ignore metadata nodes.
const childNode=nodeFromJSON(childData);if(childNode.isLeafNode()||!childNode.isEmpty()){node=node.updateImmediateChild(key,childNode);}}}});return node.updatePriority(nodeFromJSON(priority));}}setNodeFromJSON(nodeFromJSON);/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class PathIndex extends Index{constructor(indexPath_){super();this.indexPath_=indexPath_;(0,_util.assert)(!pathIsEmpty(indexPath_)&&pathGetFront(indexPath_)!=='.priority',"Can't create PathIndex with empty path or .priority key");}extractChild(snap){return snap.getChild(this.indexPath_);}isDefinedOn(node){return!node.getChild(this.indexPath_).isEmpty();}compare(a,b){const aChild=this.extractChild(a.node);const bChild=this.extractChild(b.node);const indexCmp=aChild.compareTo(bChild);if(indexCmp===0){return nameCompare(a.name,b.name);}else{return indexCmp;}}makePost(indexValue,name){const valueNode=nodeFromJSON(indexValue);const node=ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_,valueNode);return new NamedNode(name,node);}maxPost(){const node=ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_,MAX_NODE);return new NamedNode(MAX_NAME,node);}toString(){return pathSlice(this.indexPath_,0).join('/');}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ValueIndex extends Index{compare(a,b){const indexCmp=a.node.compareTo(b.node);if(indexCmp===0){return nameCompare(a.name,b.name);}else{return indexCmp;}}isDefinedOn(node){return true;}indexedValueChanged(oldNode,newNode){return!oldNode.equals(newNode);}minPost(){// eslint-disable-next-line @typescript-eslint/no-explicit-any
return NamedNode.MIN;}maxPost(){// eslint-disable-next-line @typescript-eslint/no-explicit-any
return NamedNode.MAX;}makePost(indexValue,name){const valueNode=nodeFromJSON(indexValue);return new NamedNode(name,valueNode);}/**
     * @returns String representation for inclusion in a query spec
     */toString(){return'.value';}}const VALUE_INDEX=new ValueIndex();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Modeled after base64 web-safe chars, but ordered by ASCII.
const PUSH_CHARS='-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';const MIN_PUSH_CHAR='-';const MAX_PUSH_CHAR='z';const MAX_KEY_LEN=786;/**
 * Fancy ID generator that creates 20-character string identifiers with the
 * following properties:
 *
 * 1. They're based on timestamp so that they sort *after* any existing ids.
 * 2. They contain 72-bits of random data after the timestamp so that IDs won't
 *    collide with other clients' IDs.
 * 3. They sort *lexicographically* (so the timestamp is converted to characters
 *    that will sort properly).
 * 4. They're monotonically increasing. Even if you generate more than one in
 *    the same timestamp, the latter ones will sort after the former ones. We do
 *    this by using the previous random bits but "incrementing" them by 1 (only
 *    in the case of a timestamp collision).
 */const nextPushId=function(){// Timestamp of last push, used to prevent local collisions if you push twice
// in one ms.
let lastPushTime=0;// We generate 72-bits of randomness which get turned into 12 characters and
// appended to the timestamp to prevent collisions with other clients. We
// store the last characters we generated because in the event of a collision,
// we'll use those same characters except "incremented" by one.
const lastRandChars=[];return function(now){const duplicateTime=now===lastPushTime;lastPushTime=now;let i;const timeStampChars=new Array(8);for(i=7;i>=0;i--){timeStampChars[i]=PUSH_CHARS.charAt(now%64);// NOTE: Can't use << here because javascript will convert to int and lose
// the upper bits.
now=Math.floor(now/64);}(0,_util.assert)(now===0,'Cannot push at time == 0');let id=timeStampChars.join('');if(!duplicateTime){for(i=0;i<12;i++){lastRandChars[i]=Math.floor(Math.random()*64);}}else{// If the timestamp hasn't changed since last push, use the same random
// number, except incremented by 1.
for(i=11;i>=0&&lastRandChars[i]===63;i--){lastRandChars[i]=0;}lastRandChars[i]++;}for(i=0;i<12;i++){id+=PUSH_CHARS.charAt(lastRandChars[i]);}(0,_util.assert)(id.length===20,'nextPushId: Length should be 20.');return id;};}();const successor=function(key){if(key===''+INTEGER_32_MAX){// See https://firebase.google.com/docs/database/web/lists-of-data#data-order
return MIN_PUSH_CHAR;}const keyAsInt=tryParseInt(key);if(keyAsInt!=null){return''+(keyAsInt+1);}const next=new Array(key.length);for(let i=0;i<next.length;i++){next[i]=key.charAt(i);}if(next.length<MAX_KEY_LEN){next.push(MIN_PUSH_CHAR);return next.join('');}let i=next.length-1;while(i>=0&&next[i]===MAX_PUSH_CHAR){i--;}// `successor` was called on the largest possible key, so return the
// MAX_NAME, which sorts larger than all keys.
if(i===-1){return MAX_NAME;}const source=next[i];const sourcePlusOne=PUSH_CHARS.charAt(PUSH_CHARS.indexOf(source)+1);next[i]=sourcePlusOne;return next.slice(0,i+1).join('');};// `key` is assumed to be non-empty.
const predecessor=function(key){if(key===''+INTEGER_32_MIN){return MIN_NAME;}const keyAsInt=tryParseInt(key);if(keyAsInt!=null){return''+(keyAsInt-1);}const next=new Array(key.length);for(let i=0;i<next.length;i++){next[i]=key.charAt(i);}// If `key` ends in `MIN_PUSH_CHAR`, the largest key lexicographically
// smaller than `key`, is `key[0:key.length - 1]`. The next key smaller
// than that, `predecessor(predecessor(key))`, is
//
// `key[0:key.length - 2] + (key[key.length - 1] - 1) + \
//   { MAX_PUSH_CHAR repeated MAX_KEY_LEN - (key.length - 1) times }
//
// analogous to increment/decrement for base-10 integers.
//
// This works because lexigographic comparison works character-by-character,
// using length as a tie-breaker if one key is a prefix of the other.
if(next[next.length-1]===MIN_PUSH_CHAR){if(next.length===1){// See https://firebase.google.com/docs/database/web/lists-of-data#orderbykey
return''+INTEGER_32_MAX;}delete next[next.length-1];return next.join('');}// Replace the last character with it's immediate predecessor, and
// fill the suffix of the key with MAX_PUSH_CHAR. This is the
// lexicographically largest possible key smaller than `key`.
next[next.length-1]=PUSH_CHARS.charAt(PUSH_CHARS.indexOf(next[next.length-1])-1);return next.join('')+MAX_PUSH_CHAR.repeat(MAX_KEY_LEN-next.length);};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function changeValue(snapshotNode){return{type:"value"/* VALUE */,snapshotNode};}function changeChildAdded(childName,snapshotNode){return{type:"child_added"/* CHILD_ADDED */,snapshotNode,childName};}function changeChildRemoved(childName,snapshotNode){return{type:"child_removed"/* CHILD_REMOVED */,snapshotNode,childName};}function changeChildChanged(childName,snapshotNode,oldSnap){return{type:"child_changed"/* CHILD_CHANGED */,snapshotNode,childName,oldSnap};}function changeChildMoved(childName,snapshotNode){return{type:"child_moved"/* CHILD_MOVED */,snapshotNode,childName};}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Doesn't really filter nodes but applies an index to the node and keeps track of any changes
 */class IndexedFilter{constructor(index_){this.index_=index_;}updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator){(0,_util.assert)(snap.isIndexed(this.index_),'A node must be indexed if only a child is updated');const oldChild=snap.getImmediateChild(key);// Check if anything actually changed.
if(oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))){// There's an edge case where a child can enter or leave the view because affectedPath was set to null.
// In this case, affectedPath will appear null in both the old and new snapshots.  So we need
// to avoid treating these cases as "nothing changed."
if(oldChild.isEmpty()===newChild.isEmpty()){// Nothing changed.
// This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.
//assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');
return snap;}}if(optChangeAccumulator!=null){if(newChild.isEmpty()){if(snap.hasChild(key)){optChangeAccumulator.trackChildChange(changeChildRemoved(key,oldChild));}else{(0,_util.assert)(snap.isLeafNode(),'A child remove without an old child only makes sense on a leaf node');}}else if(oldChild.isEmpty()){optChangeAccumulator.trackChildChange(changeChildAdded(key,newChild));}else{optChangeAccumulator.trackChildChange(changeChildChanged(key,newChild,oldChild));}}if(snap.isLeafNode()&&newChild.isEmpty()){return snap;}else{// Make sure the node is indexed
return snap.updateImmediateChild(key,newChild).withIndex(this.index_);}}updateFullNode(oldSnap,newSnap,optChangeAccumulator){if(optChangeAccumulator!=null){if(!oldSnap.isLeafNode()){oldSnap.forEachChild(PRIORITY_INDEX,(key,childNode)=>{if(!newSnap.hasChild(key)){optChangeAccumulator.trackChildChange(changeChildRemoved(key,childNode));}});}if(!newSnap.isLeafNode()){newSnap.forEachChild(PRIORITY_INDEX,(key,childNode)=>{if(oldSnap.hasChild(key)){const oldChild=oldSnap.getImmediateChild(key);if(!oldChild.equals(childNode)){optChangeAccumulator.trackChildChange(changeChildChanged(key,childNode,oldChild));}}else{optChangeAccumulator.trackChildChange(changeChildAdded(key,childNode));}});}}return newSnap.withIndex(this.index_);}updatePriority(oldSnap,newPriority){if(oldSnap.isEmpty()){return ChildrenNode.EMPTY_NODE;}else{return oldSnap.updatePriority(newPriority);}}filtersNodes(){return false;}getIndexedFilter(){return this;}getIndex(){return this.index_;}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node
 */class RangedFilter{constructor(params){this.indexedFilter_=new IndexedFilter(params.getIndex());this.index_=params.getIndex();this.startPost_=RangedFilter.getStartPost_(params);this.endPost_=RangedFilter.getEndPost_(params);}getStartPost(){return this.startPost_;}getEndPost(){return this.endPost_;}matches(node){return this.index_.compare(this.getStartPost(),node)<=0&&this.index_.compare(node,this.getEndPost())<=0;}updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator){if(!this.matches(new NamedNode(key,newChild))){newChild=ChildrenNode.EMPTY_NODE;}return this.indexedFilter_.updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator);}updateFullNode(oldSnap,newSnap,optChangeAccumulator){if(newSnap.isLeafNode()){// Make sure we have a children node with the correct index, not a leaf node;
newSnap=ChildrenNode.EMPTY_NODE;}let filtered=newSnap.withIndex(this.index_);// Don't support priorities on queries
filtered=filtered.updatePriority(ChildrenNode.EMPTY_NODE);const self=this;newSnap.forEachChild(PRIORITY_INDEX,(key,childNode)=>{if(!self.matches(new NamedNode(key,childNode))){filtered=filtered.updateImmediateChild(key,ChildrenNode.EMPTY_NODE);}});return this.indexedFilter_.updateFullNode(oldSnap,filtered,optChangeAccumulator);}updatePriority(oldSnap,newPriority){// Don't support priorities on queries
return oldSnap;}filtersNodes(){return true;}getIndexedFilter(){return this.indexedFilter_;}getIndex(){return this.index_;}static getStartPost_(params){if(params.hasStart()){const startName=params.getIndexStartName();return params.getIndex().makePost(params.getIndexStartValue(),startName);}else{return params.getIndex().minPost();}}static getEndPost_(params){if(params.hasEnd()){const endName=params.getIndexEndName();return params.getIndex().makePost(params.getIndexEndValue(),endName);}else{return params.getIndex().maxPost();}}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible
 */class LimitedFilter{constructor(params){this.rangedFilter_=new RangedFilter(params);this.index_=params.getIndex();this.limit_=params.getLimit();this.reverse_=!params.isViewFromLeft();}updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator){if(!this.rangedFilter_.matches(new NamedNode(key,newChild))){newChild=ChildrenNode.EMPTY_NODE;}if(snap.getImmediateChild(key).equals(newChild)){// No change
return snap;}else if(snap.numChildren()<this.limit_){return this.rangedFilter_.getIndexedFilter().updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator);}else{return this.fullLimitUpdateChild_(snap,key,newChild,source,optChangeAccumulator);}}updateFullNode(oldSnap,newSnap,optChangeAccumulator){let filtered;if(newSnap.isLeafNode()||newSnap.isEmpty()){// Make sure we have a children node with the correct index, not a leaf node;
filtered=ChildrenNode.EMPTY_NODE.withIndex(this.index_);}else{if(this.limit_*2<newSnap.numChildren()&&newSnap.isIndexed(this.index_)){// Easier to build up a snapshot, since what we're given has more than twice the elements we want
filtered=ChildrenNode.EMPTY_NODE.withIndex(this.index_);// anchor to the startPost, endPost, or last element as appropriate
let iterator;if(this.reverse_){iterator=newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(),this.index_);}else{iterator=newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(),this.index_);}let count=0;while(iterator.hasNext()&&count<this.limit_){const next=iterator.getNext();let inRange;if(this.reverse_){inRange=this.index_.compare(this.rangedFilter_.getStartPost(),next)<=0;}else{inRange=this.index_.compare(next,this.rangedFilter_.getEndPost())<=0;}if(inRange){filtered=filtered.updateImmediateChild(next.name,next.node);count++;}else{// if we have reached the end post, we cannot keep adding elemments
break;}}}else{// The snap contains less than twice the limit. Faster to delete from the snap than build up a new one
filtered=newSnap.withIndex(this.index_);// Don't support priorities on queries
filtered=filtered.updatePriority(ChildrenNode.EMPTY_NODE);let startPost;let endPost;let cmp;let iterator;if(this.reverse_){iterator=filtered.getReverseIterator(this.index_);startPost=this.rangedFilter_.getEndPost();endPost=this.rangedFilter_.getStartPost();const indexCompare=this.index_.getCompare();cmp=(a,b)=>indexCompare(b,a);}else{iterator=filtered.getIterator(this.index_);startPost=this.rangedFilter_.getStartPost();endPost=this.rangedFilter_.getEndPost();cmp=this.index_.getCompare();}let count=0;let foundStartPost=false;while(iterator.hasNext()){const next=iterator.getNext();if(!foundStartPost&&cmp(startPost,next)<=0){// start adding
foundStartPost=true;}const inRange=foundStartPost&&count<this.limit_&&cmp(next,endPost)<=0;if(inRange){count++;}else{filtered=filtered.updateImmediateChild(next.name,ChildrenNode.EMPTY_NODE);}}}}return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap,filtered,optChangeAccumulator);}updatePriority(oldSnap,newPriority){// Don't support priorities on queries
return oldSnap;}filtersNodes(){return true;}getIndexedFilter(){return this.rangedFilter_.getIndexedFilter();}getIndex(){return this.index_;}fullLimitUpdateChild_(snap,childKey,childSnap,source,changeAccumulator){// TODO: rename all cache stuff etc to general snap terminology
let cmp;if(this.reverse_){const indexCmp=this.index_.getCompare();cmp=(a,b)=>indexCmp(b,a);}else{cmp=this.index_.getCompare();}const oldEventCache=snap;(0,_util.assert)(oldEventCache.numChildren()===this.limit_,'');const newChildNamedNode=new NamedNode(childKey,childSnap);const windowBoundary=this.reverse_?oldEventCache.getFirstChild(this.index_):oldEventCache.getLastChild(this.index_);const inRange=this.rangedFilter_.matches(newChildNamedNode);if(oldEventCache.hasChild(childKey)){const oldChildSnap=oldEventCache.getImmediateChild(childKey);let nextChild=source.getChildAfterChild(this.index_,windowBoundary,this.reverse_);while(nextChild!=null&&(nextChild.name===childKey||oldEventCache.hasChild(nextChild.name))){// There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't
// been applied to the limited filter yet. Ignore this next child which will be updated later in
// the limited filter...
nextChild=source.getChildAfterChild(this.index_,nextChild,this.reverse_);}const compareNext=nextChild==null?1:cmp(nextChild,newChildNamedNode);const remainsInWindow=inRange&&!childSnap.isEmpty()&&compareNext>=0;if(remainsInWindow){if(changeAccumulator!=null){changeAccumulator.trackChildChange(changeChildChanged(childKey,childSnap,oldChildSnap));}return oldEventCache.updateImmediateChild(childKey,childSnap);}else{if(changeAccumulator!=null){changeAccumulator.trackChildChange(changeChildRemoved(childKey,oldChildSnap));}const newEventCache=oldEventCache.updateImmediateChild(childKey,ChildrenNode.EMPTY_NODE);const nextChildInRange=nextChild!=null&&this.rangedFilter_.matches(nextChild);if(nextChildInRange){if(changeAccumulator!=null){changeAccumulator.trackChildChange(changeChildAdded(nextChild.name,nextChild.node));}return newEventCache.updateImmediateChild(nextChild.name,nextChild.node);}else{return newEventCache;}}}else if(childSnap.isEmpty()){// we're deleting a node, but it was not in the window, so ignore it
return snap;}else if(inRange){if(cmp(windowBoundary,newChildNamedNode)>=0){if(changeAccumulator!=null){changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name,windowBoundary.node));changeAccumulator.trackChildChange(changeChildAdded(childKey,childSnap));}return oldEventCache.updateImmediateChild(childKey,childSnap).updateImmediateChild(windowBoundary.name,ChildrenNode.EMPTY_NODE);}else{return snap;}}else{return snap;}}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a
 * range to be returned for a particular location. It is assumed that validation of parameters is done at the
 * user-facing API level, so it is not done here.
 *
 * @internal
 */class QueryParams{constructor(){this.limitSet_=false;this.startSet_=false;this.startNameSet_=false;this.startAfterSet_=false;this.endSet_=false;this.endNameSet_=false;this.endBeforeSet_=false;this.limit_=0;this.viewFrom_='';this.indexStartValue_=null;this.indexStartName_='';this.indexEndValue_=null;this.indexEndName_='';this.index_=PRIORITY_INDEX;}hasStart(){return this.startSet_;}hasStartAfter(){return this.startAfterSet_;}hasEndBefore(){return this.endBeforeSet_;}/**
     * @returns True if it would return from left.
     */isViewFromLeft(){if(this.viewFrom_===''){// limit(), rather than limitToFirst or limitToLast was called.
// This means that only one of startSet_ and endSet_ is true. Use them
// to calculate which side of the view to anchor to. If neither is set,
// anchor to the end.
return this.startSet_;}else{return this.viewFrom_==="l"/* VIEW_FROM_LEFT */;}}/**
     * Only valid to call if hasStart() returns true
     */getIndexStartValue(){(0,_util.assert)(this.startSet_,'Only valid if start has been set');return this.indexStartValue_;}/**
     * Only valid to call if hasStart() returns true.
     * Returns the starting key name for the range defined by these query parameters
     */getIndexStartName(){(0,_util.assert)(this.startSet_,'Only valid if start has been set');if(this.startNameSet_){return this.indexStartName_;}else{return MIN_NAME;}}hasEnd(){return this.endSet_;}/**
     * Only valid to call if hasEnd() returns true.
     */getIndexEndValue(){(0,_util.assert)(this.endSet_,'Only valid if end has been set');return this.indexEndValue_;}/**
     * Only valid to call if hasEnd() returns true.
     * Returns the end key name for the range defined by these query parameters
     */getIndexEndName(){(0,_util.assert)(this.endSet_,'Only valid if end has been set');if(this.endNameSet_){return this.indexEndName_;}else{return MAX_NAME;}}hasLimit(){return this.limitSet_;}/**
     * @returns True if a limit has been set and it has been explicitly anchored
     */hasAnchoredLimit(){return this.limitSet_&&this.viewFrom_!=='';}/**
     * Only valid to call if hasLimit() returns true
     */getLimit(){(0,_util.assert)(this.limitSet_,'Only valid if limit has been set');return this.limit_;}getIndex(){return this.index_;}loadsAllData(){return!(this.startSet_||this.endSet_||this.limitSet_);}isDefault(){return this.loadsAllData()&&this.index_===PRIORITY_INDEX;}copy(){const copy=new QueryParams();copy.limitSet_=this.limitSet_;copy.limit_=this.limit_;copy.startSet_=this.startSet_;copy.indexStartValue_=this.indexStartValue_;copy.startNameSet_=this.startNameSet_;copy.indexStartName_=this.indexStartName_;copy.endSet_=this.endSet_;copy.indexEndValue_=this.indexEndValue_;copy.endNameSet_=this.endNameSet_;copy.indexEndName_=this.indexEndName_;copy.index_=this.index_;copy.viewFrom_=this.viewFrom_;return copy;}}exports._QueryParams=QueryParams;function queryParamsGetNodeFilter(queryParams){if(queryParams.loadsAllData()){return new IndexedFilter(queryParams.getIndex());}else if(queryParams.hasLimit()){return new LimitedFilter(queryParams);}else{return new RangedFilter(queryParams);}}function queryParamsLimitToFirst(queryParams,newLimit){const newParams=queryParams.copy();newParams.limitSet_=true;newParams.limit_=newLimit;newParams.viewFrom_="l"/* VIEW_FROM_LEFT */;return newParams;}function queryParamsLimitToLast(queryParams,newLimit){const newParams=queryParams.copy();newParams.limitSet_=true;newParams.limit_=newLimit;newParams.viewFrom_="r"/* VIEW_FROM_RIGHT */;return newParams;}function queryParamsStartAt(queryParams,indexValue,key){const newParams=queryParams.copy();newParams.startSet_=true;if(indexValue===undefined){indexValue=null;}newParams.indexStartValue_=indexValue;if(key!=null){newParams.startNameSet_=true;newParams.indexStartName_=key;}else{newParams.startNameSet_=false;newParams.indexStartName_='';}return newParams;}function queryParamsStartAfter(queryParams,indexValue,key){let params;if(queryParams.index_===KEY_INDEX){if(typeof indexValue==='string'){indexValue=successor(indexValue);}params=queryParamsStartAt(queryParams,indexValue,key);}else{let childKey;if(key==null){childKey=MAX_NAME;}else{childKey=successor(key);}params=queryParamsStartAt(queryParams,indexValue,childKey);}params.startAfterSet_=true;return params;}function queryParamsEndAt(queryParams,indexValue,key){const newParams=queryParams.copy();newParams.endSet_=true;if(indexValue===undefined){indexValue=null;}newParams.indexEndValue_=indexValue;if(key!==undefined){newParams.endNameSet_=true;newParams.indexEndName_=key;}else{newParams.endNameSet_=false;newParams.indexEndName_='';}return newParams;}function queryParamsEndBefore(queryParams,indexValue,key){let childKey;let params;if(queryParams.index_===KEY_INDEX){if(typeof indexValue==='string'){indexValue=predecessor(indexValue);}params=queryParamsEndAt(queryParams,indexValue,key);}else{if(key==null){childKey=MIN_NAME;}else{childKey=predecessor(key);}params=queryParamsEndAt(queryParams,indexValue,childKey);}params.endBeforeSet_=true;return params;}function queryParamsOrderBy(queryParams,index){const newParams=queryParams.copy();newParams.index_=index;return newParams;}/**
 * Returns a set of REST query string parameters representing this query.
 *
 * @returns query string parameters
 */function queryParamsToRestQueryStringParameters(queryParams){const qs={};if(queryParams.isDefault()){return qs;}let orderBy;if(queryParams.index_===PRIORITY_INDEX){orderBy="$priority"/* PRIORITY_INDEX */;}else if(queryParams.index_===VALUE_INDEX){orderBy="$value"/* VALUE_INDEX */;}else if(queryParams.index_===KEY_INDEX){orderBy="$key"/* KEY_INDEX */;}else{(0,_util.assert)(queryParams.index_ instanceof PathIndex,'Unrecognized index type!');orderBy=queryParams.index_.toString();}qs["orderBy"/* ORDER_BY */]=(0,_util.stringify)(orderBy);if(queryParams.startSet_){qs["startAt"/* START_AT */]=(0,_util.stringify)(queryParams.indexStartValue_);if(queryParams.startNameSet_){qs["startAt"/* START_AT */]+=','+(0,_util.stringify)(queryParams.indexStartName_);}}if(queryParams.endSet_){qs["endAt"/* END_AT */]=(0,_util.stringify)(queryParams.indexEndValue_);if(queryParams.endNameSet_){qs["endAt"/* END_AT */]+=','+(0,_util.stringify)(queryParams.indexEndName_);}}if(queryParams.limitSet_){if(queryParams.isViewFromLeft()){qs["limitToFirst"/* LIMIT_TO_FIRST */]=queryParams.limit_;}else{qs["limitToLast"/* LIMIT_TO_LAST */]=queryParams.limit_;}}return qs;}function queryParamsGetQueryObject(queryParams){const obj={};if(queryParams.startSet_){obj["sp"/* INDEX_START_VALUE */]=queryParams.indexStartValue_;if(queryParams.startNameSet_){obj["sn"/* INDEX_START_NAME */]=queryParams.indexStartName_;}}if(queryParams.endSet_){obj["ep"/* INDEX_END_VALUE */]=queryParams.indexEndValue_;if(queryParams.endNameSet_){obj["en"/* INDEX_END_NAME */]=queryParams.indexEndName_;}}if(queryParams.limitSet_){obj["l"/* LIMIT */]=queryParams.limit_;let viewFrom=queryParams.viewFrom_;if(viewFrom===''){if(queryParams.isViewFromLeft()){viewFrom="l"/* VIEW_FROM_LEFT */;}else{viewFrom="r"/* VIEW_FROM_RIGHT */;}}obj["vf"/* VIEW_FROM */]=viewFrom;}// For now, priority index is the default, so we only specify if it's some other index
if(queryParams.index_!==PRIORITY_INDEX){obj["i"/* INDEX */]=queryParams.index_.toString();}return obj;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An implementation of ServerActions that communicates with the server via REST requests.
 * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full
 * persistent connection (using WebSockets or long-polling)
 */class ReadonlyRestClient extends ServerActions{/**
     * @param repoInfo_ - Data about the namespace we are connecting to
     * @param onDataUpdate_ - A callback for new data from the server
     */constructor(repoInfo_,onDataUpdate_,authTokenProvider_,appCheckTokenProvider_){super();this.repoInfo_=repoInfo_;this.onDataUpdate_=onDataUpdate_;this.authTokenProvider_=authTokenProvider_;this.appCheckTokenProvider_=appCheckTokenProvider_;/** @private {function(...[*])} */this.log_=logWrapper('p:rest:');/**
         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen
         * that's been removed. :-/
         */this.listens_={};}reportStats(stats){throw new Error('Method not implemented.');}static getListenId_(query,tag){if(tag!==undefined){return'tag$'+tag;}else{(0,_util.assert)(query._queryParams.isDefault(),"should have a tag if it's not a default query.");return query._path.toString();}}/** @inheritDoc */listen(query,currentHashFn,tag,onComplete){const pathString=query._path.toString();this.log_('Listen called for '+pathString+' '+query._queryIdentifier);// Mark this listener so we can tell if it's removed.
const listenId=ReadonlyRestClient.getListenId_(query,tag);const thisListen={};this.listens_[listenId]=thisListen;const queryStringParameters=queryParamsToRestQueryStringParameters(query._queryParams);this.restRequest_(pathString+'.json',queryStringParameters,(error,result)=>{let data=result;if(error===404){data=null;error=null;}if(error===null){this.onDataUpdate_(pathString,data,/*isMerge=*/false,tag);}if((0,_util.safeGet)(this.listens_,listenId)===thisListen){let status;if(!error){status='ok';}else if(error===401){status='permission_denied';}else{status='rest_error:'+error;}onComplete(status,null);}});}/** @inheritDoc */unlisten(query,tag){const listenId=ReadonlyRestClient.getListenId_(query,tag);delete this.listens_[listenId];}get(query){const queryStringParameters=queryParamsToRestQueryStringParameters(query._queryParams);const pathString=query._path.toString();const deferred=new _util.Deferred();this.restRequest_(pathString+'.json',queryStringParameters,(error,result)=>{let data=result;if(error===404){data=null;error=null;}if(error===null){this.onDataUpdate_(pathString,data,/*isMerge=*/false,/*tag=*/null);deferred.resolve(data);}else{deferred.reject(new Error(data));}});return deferred.promise;}/** @inheritDoc */refreshAuthToken(token){// no-op since we just always call getToken.
}/**
     * Performs a REST request to the given path, with the provided query string parameters,
     * and any auth credentials we have.
     */restRequest_(pathString,queryStringParameters={},callback){queryStringParameters['format']='export';return Promise.all([this.authTokenProvider_.getToken(/*forceRefresh=*/false),this.appCheckTokenProvider_.getToken(/*forceRefresh=*/false)]).then(([authToken,appCheckToken])=>{if(authToken&&authToken.accessToken){queryStringParameters['auth']=authToken.accessToken;}if(appCheckToken&&appCheckToken.token){queryStringParameters['ac']=appCheckToken.token;}const url=(this.repoInfo_.secure?'https://':'http://')+this.repoInfo_.host+pathString+'?'+'ns='+this.repoInfo_.namespace+(0,_util.querystring)(queryStringParameters);this.log_('Sending REST request for '+url);const xhr=new XMLHttpRequest();xhr.onreadystatechange=()=>{if(callback&&xhr.readyState===4){this.log_('REST Response for '+url+' received. status:',xhr.status,'response:',xhr.responseText);let res=null;if(xhr.status>=200&&xhr.status<300){try{res=(0,_util.jsonEval)(xhr.responseText);}catch(e){warn('Failed to parse JSON response for '+url+': '+xhr.responseText);}callback(null,res);}else{// 401 and 404 are expected.
if(xhr.status!==401&&xhr.status!==404){warn('Got unsuccessful REST response for '+url+' Status: '+xhr.status);}callback(xhr.status);}callback=null;}};xhr.open('GET',url,/*asynchronous=*/true);xhr.send();});}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Mutable object which basically just stores a reference to the "latest" immutable snapshot.
 */class SnapshotHolder{constructor(){this.rootNode_=ChildrenNode.EMPTY_NODE;}getNode(path){return this.rootNode_.getChild(path);}updateSnapshot(path,newSnapshotNode){this.rootNode_=this.rootNode_.updateChild(path,newSnapshotNode);}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function newSparseSnapshotTree(){return{value:null,children:new Map()};}/**
 * Stores the given node at the specified path. If there is already a node
 * at a shallower path, it merges the new data into that snapshot node.
 *
 * @param path - Path to look up snapshot for.
 * @param data - The new data, or null.
 */function sparseSnapshotTreeRemember(sparseSnapshotTree,path,data){if(pathIsEmpty(path)){sparseSnapshotTree.value=data;sparseSnapshotTree.children.clear();}else if(sparseSnapshotTree.value!==null){sparseSnapshotTree.value=sparseSnapshotTree.value.updateChild(path,data);}else{const childKey=pathGetFront(path);if(!sparseSnapshotTree.children.has(childKey)){sparseSnapshotTree.children.set(childKey,newSparseSnapshotTree());}const child=sparseSnapshotTree.children.get(childKey);path=pathPopFront(path);sparseSnapshotTreeRemember(child,path,data);}}/**
 * Purge the data at path from the cache.
 *
 * @param path - Path to look up snapshot for.
 * @returns True if this node should now be removed.
 */function sparseSnapshotTreeForget(sparseSnapshotTree,path){if(pathIsEmpty(path)){sparseSnapshotTree.value=null;sparseSnapshotTree.children.clear();return true;}else{if(sparseSnapshotTree.value!==null){if(sparseSnapshotTree.value.isLeafNode()){// We're trying to forget a node that doesn't exist
return false;}else{const value=sparseSnapshotTree.value;sparseSnapshotTree.value=null;value.forEachChild(PRIORITY_INDEX,(key,tree)=>{sparseSnapshotTreeRemember(sparseSnapshotTree,new Path(key),tree);});return sparseSnapshotTreeForget(sparseSnapshotTree,path);}}else if(sparseSnapshotTree.children.size>0){const childKey=pathGetFront(path);path=pathPopFront(path);if(sparseSnapshotTree.children.has(childKey)){const safeToRemove=sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey),path);if(safeToRemove){sparseSnapshotTree.children.delete(childKey);}}return sparseSnapshotTree.children.size===0;}else{return true;}}}/**
 * Recursively iterates through all of the stored tree and calls the
 * callback on each one.
 *
 * @param prefixPath - Path to look up node for.
 * @param func - The function to invoke for each tree.
 */function sparseSnapshotTreeForEachTree(sparseSnapshotTree,prefixPath,func){if(sparseSnapshotTree.value!==null){func(prefixPath,sparseSnapshotTree.value);}else{sparseSnapshotTreeForEachChild(sparseSnapshotTree,(key,tree)=>{const path=new Path(prefixPath.toString()+'/'+key);sparseSnapshotTreeForEachTree(tree,path,func);});}}/**
 * Iterates through each immediate child and triggers the callback.
 * Only seems to be used in tests.
 *
 * @param func - The function to invoke for each child.
 */function sparseSnapshotTreeForEachChild(sparseSnapshotTree,func){sparseSnapshotTree.children.forEach((tree,key)=>{func(key,tree);});}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Returns the delta from the previous call to get stats.
 *
 * @param collection_ - The collection to "listen" to.
 */class StatsListener{constructor(collection_){this.collection_=collection_;this.last_=null;}get(){const newStats=this.collection_.get();const delta=Object.assign({},newStats);if(this.last_){each(this.last_,(stat,value)=>{delta[stat]=delta[stat]-value;});}this.last_=newStats;return delta;}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably
// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10
// seconds to try to ensure the Firebase connection is established / settled.
const FIRST_STATS_MIN_TIME=10*1000;const FIRST_STATS_MAX_TIME=30*1000;// We'll continue to report stats on average every 5 minutes.
const REPORT_STATS_INTERVAL=5*60*1000;class StatsReporter{constructor(collection,server_){this.server_=server_;this.statsToReport_={};this.statsListener_=new StatsListener(collection);const timeout=FIRST_STATS_MIN_TIME+(FIRST_STATS_MAX_TIME-FIRST_STATS_MIN_TIME)*Math.random();setTimeoutNonBlocking(this.reportStats_.bind(this),Math.floor(timeout));}reportStats_(){const stats=this.statsListener_.get();const reportedStats={};let haveStatsToReport=false;each(stats,(stat,value)=>{if(value>0&&(0,_util.contains)(this.statsToReport_,stat)){reportedStats[stat]=value;haveStatsToReport=true;}});if(haveStatsToReport){this.server_.reportStats(reportedStats);}// queue our next run.
setTimeoutNonBlocking(this.reportStats_.bind(this),Math.floor(Math.random()*2*REPORT_STATS_INTERVAL));}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 *
 * @enum
 */var OperationType;(function(OperationType){OperationType[OperationType["OVERWRITE"]=0]="OVERWRITE";OperationType[OperationType["MERGE"]=1]="MERGE";OperationType[OperationType["ACK_USER_WRITE"]=2]="ACK_USER_WRITE";OperationType[OperationType["LISTEN_COMPLETE"]=3]="LISTEN_COMPLETE";})(OperationType||(OperationType={}));function newOperationSourceUser(){return{fromUser:true,fromServer:false,queryId:null,tagged:false};}function newOperationSourceServer(){return{fromUser:false,fromServer:true,queryId:null,tagged:false};}function newOperationSourceServerTaggedQuery(queryId){return{fromUser:false,fromServer:true,queryId,tagged:true};}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class AckUserWrite{/**
     * @param affectedTree - A tree containing true for each affected path. Affected paths can't overlap.
     */constructor(/** @inheritDoc */path,/** @inheritDoc */affectedTree,/** @inheritDoc */revert){this.path=path;this.affectedTree=affectedTree;this.revert=revert;/** @inheritDoc */this.type=OperationType.ACK_USER_WRITE;/** @inheritDoc */this.source=newOperationSourceUser();}operationForChild(childName){if(!pathIsEmpty(this.path)){(0,_util.assert)(pathGetFront(this.path)===childName,'operationForChild called for unrelated child.');return new AckUserWrite(pathPopFront(this.path),this.affectedTree,this.revert);}else if(this.affectedTree.value!=null){(0,_util.assert)(this.affectedTree.children.isEmpty(),'affectedTree should not have overlapping affected paths.');// All child locations are affected as well; just return same operation.
return this;}else{const childTree=this.affectedTree.subtree(new Path(childName));return new AckUserWrite(newEmptyPath(),childTree,this.revert);}}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ListenComplete{constructor(source,path){this.source=source;this.path=path;/** @inheritDoc */this.type=OperationType.LISTEN_COMPLETE;}operationForChild(childName){if(pathIsEmpty(this.path)){return new ListenComplete(this.source,newEmptyPath());}else{return new ListenComplete(this.source,pathPopFront(this.path));}}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Overwrite{constructor(source,path,snap){this.source=source;this.path=path;this.snap=snap;/** @inheritDoc */this.type=OperationType.OVERWRITE;}operationForChild(childName){if(pathIsEmpty(this.path)){return new Overwrite(this.source,newEmptyPath(),this.snap.getImmediateChild(childName));}else{return new Overwrite(this.source,pathPopFront(this.path),this.snap);}}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Merge{constructor(/** @inheritDoc */source,/** @inheritDoc */path,/** @inheritDoc */children){this.source=source;this.path=path;this.children=children;/** @inheritDoc */this.type=OperationType.MERGE;}operationForChild(childName){if(pathIsEmpty(this.path)){const childTree=this.children.subtree(new Path(childName));if(childTree.isEmpty()){// This child is unaffected
return null;}else if(childTree.value){// We have a snapshot for the child in question.  This becomes an overwrite of the child.
return new Overwrite(this.source,newEmptyPath(),childTree.value);}else{// This is a merge at a deeper level
return new Merge(this.source,newEmptyPath(),childTree);}}else{(0,_util.assert)(pathGetFront(this.path)===childName,"Can't get a merge for a child not on the path of the operation");return new Merge(this.source,pathPopFront(this.path),this.children);}}toString(){return'Operation('+this.path+': '+this.source.toString()+' merge: '+this.children.toString()+')';}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully
 * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.
 * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks
 * whether a node potentially had children removed due to a filter.
 */class CacheNode{constructor(node_,fullyInitialized_,filtered_){this.node_=node_;this.fullyInitialized_=fullyInitialized_;this.filtered_=filtered_;}/**
     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client
     */isFullyInitialized(){return this.fullyInitialized_;}/**
     * Returns whether this node is potentially missing children due to a filter applied to the node
     */isFiltered(){return this.filtered_;}isCompleteForPath(path){if(pathIsEmpty(path)){return this.isFullyInitialized()&&!this.filtered_;}const childKey=pathGetFront(path);return this.isCompleteForChild(childKey);}isCompleteForChild(key){return this.isFullyInitialized()&&!this.filtered_||this.node_.hasChild(key);}getNode(){return this.node_;}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An EventGenerator is used to convert "raw" changes (Change) as computed by the
 * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()
 * for details.
 *
 */class EventGenerator{constructor(query_){this.query_=query_;this.index_=this.query_._queryParams.getIndex();}}/**
 * Given a set of raw changes (no moved events and prevName not specified yet), and a set of
 * EventRegistrations that should be notified of these changes, generate the actual events to be raised.
 *
 * Notes:
 *  - child_moved events will be synthesized at this time for any child_changed events that affect
 *    our index.
 *  - prevName will be calculated based on the index ordering.
 */function eventGeneratorGenerateEventsForChanges(eventGenerator,changes,eventCache,eventRegistrations){const events=[];const moves=[];changes.forEach(change=>{if(change.type==="child_changed"/* CHILD_CHANGED */&&eventGenerator.index_.indexedValueChanged(change.oldSnap,change.snapshotNode)){moves.push(changeChildMoved(change.childName,change.snapshotNode));}});eventGeneratorGenerateEventsForType(eventGenerator,events,"child_removed"/* CHILD_REMOVED */,changes,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,"child_added"/* CHILD_ADDED */,changes,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,"child_moved"/* CHILD_MOVED */,moves,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,"child_changed"/* CHILD_CHANGED */,changes,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,"value"/* VALUE */,changes,eventRegistrations,eventCache);return events;}/**
 * Given changes of a single change type, generate the corresponding events.
 */function eventGeneratorGenerateEventsForType(eventGenerator,events,eventType,changes,registrations,eventCache){const filteredChanges=changes.filter(change=>change.type===eventType);filteredChanges.sort((a,b)=>eventGeneratorCompareChanges(eventGenerator,a,b));filteredChanges.forEach(change=>{const materializedChange=eventGeneratorMaterializeSingleChange(eventGenerator,change,eventCache);registrations.forEach(registration=>{if(registration.respondsTo(change.type)){events.push(registration.createEvent(materializedChange,eventGenerator.query_));}});});}function eventGeneratorMaterializeSingleChange(eventGenerator,change,eventCache){if(change.type==='value'||change.type==='child_removed'){return change;}else{change.prevName=eventCache.getPredecessorChildName(change.childName,change.snapshotNode,eventGenerator.index_);return change;}}function eventGeneratorCompareChanges(eventGenerator,a,b){if(a.childName==null||b.childName==null){throw(0,_util.assertionError)('Should only compare child_ events.');}const aWrapped=new NamedNode(a.childName,a.snapshotNode);const bWrapped=new NamedNode(b.childName,b.snapshotNode);return eventGenerator.index_.compare(aWrapped,bWrapped);}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function newViewCache(eventCache,serverCache){return{eventCache,serverCache};}function viewCacheUpdateEventSnap(viewCache,eventSnap,complete,filtered){return newViewCache(new CacheNode(eventSnap,complete,filtered),viewCache.serverCache);}function viewCacheUpdateServerSnap(viewCache,serverSnap,complete,filtered){return newViewCache(viewCache.eventCache,new CacheNode(serverSnap,complete,filtered));}function viewCacheGetCompleteEventSnap(viewCache){return viewCache.eventCache.isFullyInitialized()?viewCache.eventCache.getNode():null;}function viewCacheGetCompleteServerSnap(viewCache){return viewCache.serverCache.isFullyInitialized()?viewCache.serverCache.getNode():null;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let emptyChildrenSingleton;/**
 * Singleton empty children collection.
 *
 */const EmptyChildren=()=>{if(!emptyChildrenSingleton){emptyChildrenSingleton=new SortedMap(stringCompare);}return emptyChildrenSingleton;};/**
 * A tree with immutable elements.
 */class ImmutableTree{constructor(value,children=EmptyChildren()){this.value=value;this.children=children;}static fromObject(obj){let tree=new ImmutableTree(null);each(obj,(childPath,childSnap)=>{tree=tree.set(new Path(childPath),childSnap);});return tree;}/**
     * True if the value is empty and there are no children
     */isEmpty(){return this.value===null&&this.children.isEmpty();}/**
     * Given a path and predicate, return the first node and the path to that node
     * where the predicate returns true.
     *
     * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`
     * objects on the way back out, it may be better to pass down a pathSoFar obj.
     *
     * @param relativePath - The remainder of the path
     * @param predicate - The predicate to satisfy to return a node
     */findRootMostMatchingPathAndValue(relativePath,predicate){if(this.value!=null&&predicate(this.value)){return{path:newEmptyPath(),value:this.value};}else{if(pathIsEmpty(relativePath)){return null;}else{const front=pathGetFront(relativePath);const child=this.children.get(front);if(child!==null){const childExistingPathAndValue=child.findRootMostMatchingPathAndValue(pathPopFront(relativePath),predicate);if(childExistingPathAndValue!=null){const fullPath=pathChild(new Path(front),childExistingPathAndValue.path);return{path:fullPath,value:childExistingPathAndValue.value};}else{return null;}}else{return null;}}}}/**
     * Find, if it exists, the shortest subpath of the given path that points a defined
     * value in the tree
     */findRootMostValueAndPath(relativePath){return this.findRootMostMatchingPathAndValue(relativePath,()=>true);}/**
     * @returns The subtree at the given path
     */subtree(relativePath){if(pathIsEmpty(relativePath)){return this;}else{const front=pathGetFront(relativePath);const childTree=this.children.get(front);if(childTree!==null){return childTree.subtree(pathPopFront(relativePath));}else{return new ImmutableTree(null);}}}/**
     * Sets a value at the specified path.
     *
     * @param relativePath - Path to set value at.
     * @param toSet - Value to set.
     * @returns Resulting tree.
     */set(relativePath,toSet){if(pathIsEmpty(relativePath)){return new ImmutableTree(toSet,this.children);}else{const front=pathGetFront(relativePath);const child=this.children.get(front)||new ImmutableTree(null);const newChild=child.set(pathPopFront(relativePath),toSet);const newChildren=this.children.insert(front,newChild);return new ImmutableTree(this.value,newChildren);}}/**
     * Removes the value at the specified path.
     *
     * @param relativePath - Path to value to remove.
     * @returns Resulting tree.
     */remove(relativePath){if(pathIsEmpty(relativePath)){if(this.children.isEmpty()){return new ImmutableTree(null);}else{return new ImmutableTree(null,this.children);}}else{const front=pathGetFront(relativePath);const child=this.children.get(front);if(child){const newChild=child.remove(pathPopFront(relativePath));let newChildren;if(newChild.isEmpty()){newChildren=this.children.remove(front);}else{newChildren=this.children.insert(front,newChild);}if(this.value===null&&newChildren.isEmpty()){return new ImmutableTree(null);}else{return new ImmutableTree(this.value,newChildren);}}else{return this;}}}/**
     * Gets a value from the tree.
     *
     * @param relativePath - Path to get value for.
     * @returns Value at path, or null.
     */get(relativePath){if(pathIsEmpty(relativePath)){return this.value;}else{const front=pathGetFront(relativePath);const child=this.children.get(front);if(child){return child.get(pathPopFront(relativePath));}else{return null;}}}/**
     * Replace the subtree at the specified path with the given new tree.
     *
     * @param relativePath - Path to replace subtree for.
     * @param newTree - New tree.
     * @returns Resulting tree.
     */setTree(relativePath,newTree){if(pathIsEmpty(relativePath)){return newTree;}else{const front=pathGetFront(relativePath);const child=this.children.get(front)||new ImmutableTree(null);const newChild=child.setTree(pathPopFront(relativePath),newTree);let newChildren;if(newChild.isEmpty()){newChildren=this.children.remove(front);}else{newChildren=this.children.insert(front,newChild);}return new ImmutableTree(this.value,newChildren);}}/**
     * Performs a depth first fold on this tree. Transforms a tree into a single
     * value, given a function that operates on the path to a node, an optional
     * current value, and a map of child names to folded subtrees
     */fold(fn){return this.fold_(newEmptyPath(),fn);}/**
     * Recursive helper for public-facing fold() method
     */fold_(pathSoFar,fn){const accum={};this.children.inorderTraversal((childKey,childTree)=>{accum[childKey]=childTree.fold_(pathChild(pathSoFar,childKey),fn);});return fn(pathSoFar,this.value,accum);}/**
     * Find the first matching value on the given path. Return the result of applying f to it.
     */findOnPath(path,f){return this.findOnPath_(path,newEmptyPath(),f);}findOnPath_(pathToFollow,pathSoFar,f){const result=this.value?f(pathSoFar,this.value):false;if(result){return result;}else{if(pathIsEmpty(pathToFollow)){return null;}else{const front=pathGetFront(pathToFollow);const nextChild=this.children.get(front);if(nextChild){return nextChild.findOnPath_(pathPopFront(pathToFollow),pathChild(pathSoFar,front),f);}else{return null;}}}}foreachOnPath(path,f){return this.foreachOnPath_(path,newEmptyPath(),f);}foreachOnPath_(pathToFollow,currentRelativePath,f){if(pathIsEmpty(pathToFollow)){return this;}else{if(this.value){f(currentRelativePath,this.value);}const front=pathGetFront(pathToFollow);const nextChild=this.children.get(front);if(nextChild){return nextChild.foreachOnPath_(pathPopFront(pathToFollow),pathChild(currentRelativePath,front),f);}else{return new ImmutableTree(null);}}}/**
     * Calls the given function for each node in the tree that has a value.
     *
     * @param f - A function to be called with the path from the root of the tree to
     * a node, and the value at that node. Called in depth-first order.
     */foreach(f){this.foreach_(newEmptyPath(),f);}foreach_(currentRelativePath,f){this.children.inorderTraversal((childName,childTree)=>{childTree.foreach_(pathChild(currentRelativePath,childName),f);});if(this.value){f(currentRelativePath,this.value);}}foreachChild(f){this.children.inorderTraversal((childName,childTree)=>{if(childTree.value){f(childName,childTree.value);}});}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with
 * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write
 * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write
 * to reflect the write added.
 */class CompoundWrite{constructor(writeTree_){this.writeTree_=writeTree_;}static empty(){return new CompoundWrite(new ImmutableTree(null));}}function compoundWriteAddWrite(compoundWrite,path,node){if(pathIsEmpty(path)){return new CompoundWrite(new ImmutableTree(node));}else{const rootmost=compoundWrite.writeTree_.findRootMostValueAndPath(path);if(rootmost!=null){const rootMostPath=rootmost.path;let value=rootmost.value;const relativePath=newRelativePath(rootMostPath,path);value=value.updateChild(relativePath,node);return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath,value));}else{const subtree=new ImmutableTree(node);const newWriteTree=compoundWrite.writeTree_.setTree(path,subtree);return new CompoundWrite(newWriteTree);}}}function compoundWriteAddWrites(compoundWrite,path,updates){let newWrite=compoundWrite;each(updates,(childKey,node)=>{newWrite=compoundWriteAddWrite(newWrite,pathChild(path,childKey),node);});return newWrite;}/**
 * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher
 * location, which must be removed by calling this method with that path.
 *
 * @param compoundWrite - The CompoundWrite to remove.
 * @param path - The path at which a write and all deeper writes should be removed
 * @returns The new CompoundWrite with the removed path
 */function compoundWriteRemoveWrite(compoundWrite,path){if(pathIsEmpty(path)){return CompoundWrite.empty();}else{const newWriteTree=compoundWrite.writeTree_.setTree(path,new ImmutableTree(null));return new CompoundWrite(newWriteTree);}}/**
 * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be
 * considered "complete".
 *
 * @param compoundWrite - The CompoundWrite to check.
 * @param path - The path to check for
 * @returns Whether there is a complete write at that path
 */function compoundWriteHasCompleteWrite(compoundWrite,path){return compoundWriteGetCompleteNode(compoundWrite,path)!=null;}/**
 * Returns a node for a path if and only if the node is a "complete" overwrite at that path. This will not aggregate
 * writes from deeper paths, but will return child nodes from a more shallow path.
 *
 * @param compoundWrite - The CompoundWrite to get the node from.
 * @param path - The path to get a complete write
 * @returns The node if complete at that path, or null otherwise.
 */function compoundWriteGetCompleteNode(compoundWrite,path){const rootmost=compoundWrite.writeTree_.findRootMostValueAndPath(path);if(rootmost!=null){return compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path,path));}else{return null;}}/**
 * Returns all children that are guaranteed to be a complete overwrite.
 *
 * @param compoundWrite - The CompoundWrite to get children from.
 * @returns A list of all complete children.
 */function compoundWriteGetCompleteChildren(compoundWrite){const children=[];const node=compoundWrite.writeTree_.value;if(node!=null){// If it's a leaf node, it has no children; so nothing to do.
if(!node.isLeafNode()){node.forEachChild(PRIORITY_INDEX,(childName,childNode)=>{children.push(new NamedNode(childName,childNode));});}}else{compoundWrite.writeTree_.children.inorderTraversal((childName,childTree)=>{if(childTree.value!=null){children.push(new NamedNode(childName,childTree.value));}});}return children;}function compoundWriteChildCompoundWrite(compoundWrite,path){if(pathIsEmpty(path)){return compoundWrite;}else{const shadowingNode=compoundWriteGetCompleteNode(compoundWrite,path);if(shadowingNode!=null){return new CompoundWrite(new ImmutableTree(shadowingNode));}else{return new CompoundWrite(compoundWrite.writeTree_.subtree(path));}}}/**
 * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.
 * @returns Whether this CompoundWrite is empty
 */function compoundWriteIsEmpty(compoundWrite){return compoundWrite.writeTree_.isEmpty();}/**
 * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the
 * node
 * @param node - The node to apply this CompoundWrite to
 * @returns The node with all writes applied
 */function compoundWriteApply(compoundWrite,node){return applySubtreeWrite(newEmptyPath(),compoundWrite.writeTree_,node);}function applySubtreeWrite(relativePath,writeTree,node){if(writeTree.value!=null){// Since there a write is always a leaf, we're done here
return node.updateChild(relativePath,writeTree.value);}else{let priorityWrite=null;writeTree.children.inorderTraversal((childKey,childTree)=>{if(childKey==='.priority'){// Apply priorities at the end so we don't update priorities for either empty nodes or forget
// to apply priorities to empty nodes that are later filled
(0,_util.assert)(childTree.value!==null,'Priority writes must always be leaf nodes');priorityWrite=childTree.value;}else{node=applySubtreeWrite(pathChild(relativePath,childKey),childTree,node);}});// If there was a priority write, we only apply it if the node is not empty
if(!node.getChild(relativePath).isEmpty()&&priorityWrite!==null){node=node.updateChild(pathChild(relativePath,'.priority'),priorityWrite);}return node;}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.
 *
 */function writeTreeChildWrites(writeTree,path){return newWriteTreeRef(path,writeTree);}/**
 * Record a new overwrite from user code.
 *
 * @param visible - This is set to false by some transactions. It should be excluded from event caches
 */function writeTreeAddOverwrite(writeTree,path,snap,writeId,visible){(0,_util.assert)(writeId>writeTree.lastWriteId,'Stacking an older write on top of newer ones');if(visible===undefined){visible=true;}writeTree.allWrites.push({path,snap,writeId,visible});if(visible){writeTree.visibleWrites=compoundWriteAddWrite(writeTree.visibleWrites,path,snap);}writeTree.lastWriteId=writeId;}/**
 * Record a new merge from user code.
 */function writeTreeAddMerge(writeTree,path,changedChildren,writeId){(0,_util.assert)(writeId>writeTree.lastWriteId,'Stacking an older merge on top of newer ones');writeTree.allWrites.push({path,children:changedChildren,writeId,visible:true});writeTree.visibleWrites=compoundWriteAddWrites(writeTree.visibleWrites,path,changedChildren);writeTree.lastWriteId=writeId;}function writeTreeGetWrite(writeTree,writeId){for(let i=0;i<writeTree.allWrites.length;i++){const record=writeTree.allWrites[i];if(record.writeId===writeId){return record;}}return null;}/**
 * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates
 * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.
 *
 * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise
 * events as a result).
 */function writeTreeRemoveWrite(writeTree,writeId){// Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied
// out of order.
//const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;
//assert(validClear, "Either we don't have this write, or it's the first one in the queue");
const idx=writeTree.allWrites.findIndex(s=>{return s.writeId===writeId;});(0,_util.assert)(idx>=0,'removeWrite called with nonexistent writeId.');const writeToRemove=writeTree.allWrites[idx];writeTree.allWrites.splice(idx,1);let removedWriteWasVisible=writeToRemove.visible;let removedWriteOverlapsWithOtherWrites=false;let i=writeTree.allWrites.length-1;while(removedWriteWasVisible&&i>=0){const currentWrite=writeTree.allWrites[i];if(currentWrite.visible){if(i>=idx&&writeTreeRecordContainsPath_(currentWrite,writeToRemove.path)){// The removed write was completely shadowed by a subsequent write.
removedWriteWasVisible=false;}else if(pathContains(writeToRemove.path,currentWrite.path)){// Either we're covering some writes or they're covering part of us (depending on which came first).
removedWriteOverlapsWithOtherWrites=true;}}i--;}if(!removedWriteWasVisible){return false;}else if(removedWriteOverlapsWithOtherWrites){// There's some shadowing going on. Just rebuild the visible writes from scratch.
writeTreeResetTree_(writeTree);return true;}else{// There's no shadowing.  We can safely just remove the write(s) from visibleWrites.
if(writeToRemove.snap){writeTree.visibleWrites=compoundWriteRemoveWrite(writeTree.visibleWrites,writeToRemove.path);}else{const children=writeToRemove.children;each(children,childName=>{writeTree.visibleWrites=compoundWriteRemoveWrite(writeTree.visibleWrites,pathChild(writeToRemove.path,childName));});}return true;}}function writeTreeRecordContainsPath_(writeRecord,path){if(writeRecord.snap){return pathContains(writeRecord.path,path);}else{for(const childName in writeRecord.children){if(writeRecord.children.hasOwnProperty(childName)&&pathContains(pathChild(writeRecord.path,childName),path)){return true;}}return false;}}/**
 * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots
 */function writeTreeResetTree_(writeTree){writeTree.visibleWrites=writeTreeLayerTree_(writeTree.allWrites,writeTreeDefaultFilter_,newEmptyPath());if(writeTree.allWrites.length>0){writeTree.lastWriteId=writeTree.allWrites[writeTree.allWrites.length-1].writeId;}else{writeTree.lastWriteId=-1;}}/**
 * The default filter used when constructing the tree. Keep everything that's visible.
 */function writeTreeDefaultFilter_(write){return write.visible;}/**
 * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of
 * event data at that path.
 */function writeTreeLayerTree_(writes,filter,treeRoot){let compoundWrite=CompoundWrite.empty();for(let i=0;i<writes.length;++i){const write=writes[i];// Theory, a later set will either:
// a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction
// b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction
if(filter(write)){const writePath=write.path;let relativePath;if(write.snap){if(pathContains(treeRoot,writePath)){relativePath=newRelativePath(treeRoot,writePath);compoundWrite=compoundWriteAddWrite(compoundWrite,relativePath,write.snap);}else if(pathContains(writePath,treeRoot)){relativePath=newRelativePath(writePath,treeRoot);compoundWrite=compoundWriteAddWrite(compoundWrite,newEmptyPath(),write.snap.getChild(relativePath));}else;}else if(write.children){if(pathContains(treeRoot,writePath)){relativePath=newRelativePath(treeRoot,writePath);compoundWrite=compoundWriteAddWrites(compoundWrite,relativePath,write.children);}else if(pathContains(writePath,treeRoot)){relativePath=newRelativePath(writePath,treeRoot);if(pathIsEmpty(relativePath)){compoundWrite=compoundWriteAddWrites(compoundWrite,newEmptyPath(),write.children);}else{const child=(0,_util.safeGet)(write.children,pathGetFront(relativePath));if(child){// There exists a child in this node that matches the root path
const deepNode=child.getChild(pathPopFront(relativePath));compoundWrite=compoundWriteAddWrite(compoundWrite,newEmptyPath(),deepNode);}}}else;}else{throw(0,_util.assertionError)('WriteRecord should have .snap or .children');}}}return compoundWrite;}/**
 * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden
 * writes), attempt to calculate a complete snapshot for the given path
 *
 * @param writeIdsToExclude - An optional set to be excluded
 * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false
 */function writeTreeCalcCompleteEventCache(writeTree,treePath,completeServerCache,writeIdsToExclude,includeHiddenWrites){if(!writeIdsToExclude&&!includeHiddenWrites){const shadowingNode=compoundWriteGetCompleteNode(writeTree.visibleWrites,treePath);if(shadowingNode!=null){return shadowingNode;}else{const subMerge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);if(compoundWriteIsEmpty(subMerge)){return completeServerCache;}else if(completeServerCache==null&&!compoundWriteHasCompleteWrite(subMerge,newEmptyPath())){// We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow
return null;}else{const layeredCache=completeServerCache||ChildrenNode.EMPTY_NODE;return compoundWriteApply(subMerge,layeredCache);}}}else{const merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);if(!includeHiddenWrites&&compoundWriteIsEmpty(merge)){return completeServerCache;}else{// If the server cache is null, and we don't have a complete cache, we need to return null
if(!includeHiddenWrites&&completeServerCache==null&&!compoundWriteHasCompleteWrite(merge,newEmptyPath())){return null;}else{const filter=function(write){return(write.visible||includeHiddenWrites)&&(!writeIdsToExclude||!~writeIdsToExclude.indexOf(write.writeId))&&(pathContains(write.path,treePath)||pathContains(treePath,write.path));};const mergeAtPath=writeTreeLayerTree_(writeTree.allWrites,filter,treePath);const layeredCache=completeServerCache||ChildrenNode.EMPTY_NODE;return compoundWriteApply(mergeAtPath,layeredCache);}}}}/**
 * With optional, underlying server data, attempt to return a children node of children that we have complete data for.
 * Used when creating new views, to pre-fill their complete event children snapshot.
 */function writeTreeCalcCompleteEventChildren(writeTree,treePath,completeServerChildren){let completeChildren=ChildrenNode.EMPTY_NODE;const topLevelSet=compoundWriteGetCompleteNode(writeTree.visibleWrites,treePath);if(topLevelSet){if(!topLevelSet.isLeafNode()){// we're shadowing everything. Return the children.
topLevelSet.forEachChild(PRIORITY_INDEX,(childName,childSnap)=>{completeChildren=completeChildren.updateImmediateChild(childName,childSnap);});}return completeChildren;}else if(completeServerChildren){// Layer any children we have on top of this
// We know we don't have a top-level set, so just enumerate existing children
const merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);completeServerChildren.forEachChild(PRIORITY_INDEX,(childName,childNode)=>{const node=compoundWriteApply(compoundWriteChildCompoundWrite(merge,new Path(childName)),childNode);completeChildren=completeChildren.updateImmediateChild(childName,node);});// Add any complete children we have from the set
compoundWriteGetCompleteChildren(merge).forEach(namedNode=>{completeChildren=completeChildren.updateImmediateChild(namedNode.name,namedNode.node);});return completeChildren;}else{// We don't have anything to layer on top of. Layer on any children we have
// Note that we can return an empty snap if we have a defined delete
const merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);compoundWriteGetCompleteChildren(merge).forEach(namedNode=>{completeChildren=completeChildren.updateImmediateChild(namedNode.name,namedNode.node);});return completeChildren;}}/**
 * Given that the underlying server data has updated, determine what, if anything, needs to be
 * applied to the event cache.
 *
 * Possibilities:
 *
 * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
 *
 * 2. Some write is completely shadowing. No events to be raised
 *
 * 3. Is partially shadowed. Events
 *
 * Either existingEventSnap or existingServerSnap must exist
 */function writeTreeCalcEventCacheAfterServerOverwrite(writeTree,treePath,childPath,existingEventSnap,existingServerSnap){(0,_util.assert)(existingEventSnap||existingServerSnap,'Either existingEventSnap or existingServerSnap must exist');const path=pathChild(treePath,childPath);if(compoundWriteHasCompleteWrite(writeTree.visibleWrites,path)){// At this point we can probably guarantee that we're in case 2, meaning no events
// May need to check visibility while doing the findRootMostValueAndPath call
return null;}else{// No complete shadowing. We're either partially shadowing or not shadowing at all.
const childMerge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,path);if(compoundWriteIsEmpty(childMerge)){// We're not shadowing at all. Case 1
return existingServerSnap.getChild(childPath);}else{// This could be more efficient if the serverNode + updates doesn't change the eventSnap
// However this is tricky to find out, since user updates don't necessary change the server
// snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server
// adds nodes, but doesn't change any existing writes. It is therefore not enough to
// only check if the updates change the serverNode.
// Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?
return compoundWriteApply(childMerge,existingServerSnap.getChild(childPath));}}}/**
 * Returns a complete child for a given server snap after applying all user writes or null if there is no
 * complete child for this ChildKey.
 */function writeTreeCalcCompleteChild(writeTree,treePath,childKey,existingServerSnap){const path=pathChild(treePath,childKey);const shadowingNode=compoundWriteGetCompleteNode(writeTree.visibleWrites,path);if(shadowingNode!=null){return shadowingNode;}else{if(existingServerSnap.isCompleteForChild(childKey)){const childMerge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,path);return compoundWriteApply(childMerge,existingServerSnap.getNode().getImmediateChild(childKey));}else{return null;}}}/**
 * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
 * a higher path, this will return the child of that write relative to the write and this path.
 * Returns null if there is no write at this path.
 */function writeTreeShadowingWrite(writeTree,path){return compoundWriteGetCompleteNode(writeTree.visibleWrites,path);}/**
 * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
 * the window, but may now be in the window.
 */function writeTreeCalcIndexedSlice(writeTree,treePath,completeServerData,startPost,count,reverse,index){let toIterate;const merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);const shadowingNode=compoundWriteGetCompleteNode(merge,newEmptyPath());if(shadowingNode!=null){toIterate=shadowingNode;}else if(completeServerData!=null){toIterate=compoundWriteApply(merge,completeServerData);}else{// no children to iterate on
return[];}toIterate=toIterate.withIndex(index);if(!toIterate.isEmpty()&&!toIterate.isLeafNode()){const nodes=[];const cmp=index.getCompare();const iter=reverse?toIterate.getReverseIteratorFrom(startPost,index):toIterate.getIteratorFrom(startPost,index);let next=iter.getNext();while(next&&nodes.length<count){if(cmp(next,startPost)!==0){nodes.push(next);}next=iter.getNext();}return nodes;}else{return[];}}function newWriteTree(){return{visibleWrites:CompoundWrite.empty(),allWrites:[],lastWriteId:-1};}/**
 * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used
 * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node
 * can lead to a more expensive calculation.
 *
 * @param writeIdsToExclude - Optional writes to exclude.
 * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false
 */function writeTreeRefCalcCompleteEventCache(writeTreeRef,completeServerCache,writeIdsToExclude,includeHiddenWrites){return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree,writeTreeRef.treePath,completeServerCache,writeIdsToExclude,includeHiddenWrites);}/**
 * If possible, returns a children node containing all of the complete children we have data for. The returned data is a
 * mix of the given server data and write data.
 *
 */function writeTreeRefCalcCompleteEventChildren(writeTreeRef,completeServerChildren){return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree,writeTreeRef.treePath,completeServerChildren);}/**
 * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,
 * if anything, needs to be applied to the event cache.
 *
 * Possibilities:
 *
 * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
 *
 * 2. Some write is completely shadowing. No events to be raised
 *
 * 3. Is partially shadowed. Events should be raised
 *
 * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert
 *
 *
 */function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef,path,existingEventSnap,existingServerSnap){return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree,writeTreeRef.treePath,path,existingEventSnap,existingServerSnap);}/**
 * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
 * a higher path, this will return the child of that write relative to the write and this path.
 * Returns null if there is no write at this path.
 *
 */function writeTreeRefShadowingWrite(writeTreeRef,path){return writeTreeShadowingWrite(writeTreeRef.writeTree,pathChild(writeTreeRef.treePath,path));}/**
 * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
 * the window, but may now be in the window
 */function writeTreeRefCalcIndexedSlice(writeTreeRef,completeServerData,startPost,count,reverse,index){return writeTreeCalcIndexedSlice(writeTreeRef.writeTree,writeTreeRef.treePath,completeServerData,startPost,count,reverse,index);}/**
 * Returns a complete child for a given server snap after applying all user writes or null if there is no
 * complete child for this ChildKey.
 */function writeTreeRefCalcCompleteChild(writeTreeRef,childKey,existingServerCache){return writeTreeCalcCompleteChild(writeTreeRef.writeTree,writeTreeRef.treePath,childKey,existingServerCache);}/**
 * Return a WriteTreeRef for a child.
 */function writeTreeRefChild(writeTreeRef,childName){return newWriteTreeRef(pathChild(writeTreeRef.treePath,childName),writeTreeRef.writeTree);}function newWriteTreeRef(path,writeTree){return{treePath:path,writeTree};}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ChildChangeAccumulator{constructor(){this.changeMap=new Map();}trackChildChange(change){const type=change.type;const childKey=change.childName;(0,_util.assert)(type==="child_added"/* CHILD_ADDED */||type==="child_changed"/* CHILD_CHANGED */||type==="child_removed"/* CHILD_REMOVED */,'Only child changes supported for tracking');(0,_util.assert)(childKey!=='.priority','Only non-priority child changes can be tracked.');const oldChange=this.changeMap.get(childKey);if(oldChange){const oldType=oldChange.type;if(type==="child_added"/* CHILD_ADDED */&&oldType==="child_removed"/* CHILD_REMOVED */){this.changeMap.set(childKey,changeChildChanged(childKey,change.snapshotNode,oldChange.snapshotNode));}else if(type==="child_removed"/* CHILD_REMOVED */&&oldType==="child_added"/* CHILD_ADDED */){this.changeMap.delete(childKey);}else if(type==="child_removed"/* CHILD_REMOVED */&&oldType==="child_changed"/* CHILD_CHANGED */){this.changeMap.set(childKey,changeChildRemoved(childKey,oldChange.oldSnap));}else if(type==="child_changed"/* CHILD_CHANGED */&&oldType==="child_added"/* CHILD_ADDED */){this.changeMap.set(childKey,changeChildAdded(childKey,change.snapshotNode));}else if(type==="child_changed"/* CHILD_CHANGED */&&oldType==="child_changed"/* CHILD_CHANGED */){this.changeMap.set(childKey,changeChildChanged(childKey,change.snapshotNode,oldChange.oldSnap));}else{throw(0,_util.assertionError)('Illegal combination of changes: '+change+' occurred after '+oldChange);}}else{this.changeMap.set(childKey,change);}}getChanges(){return Array.from(this.changeMap.values());}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An implementation of CompleteChildSource that never returns any additional children
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
class NoCompleteChildSource_{getCompleteChild(childKey){return null;}getChildAfterChild(index,child,reverse){return null;}}/**
 * Singleton instance.
 */const NO_COMPLETE_CHILD_SOURCE=new NoCompleteChildSource_();/**
 * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or
 * old event caches available to calculate complete children.
 */class WriteTreeCompleteChildSource{constructor(writes_,viewCache_,optCompleteServerCache_=null){this.writes_=writes_;this.viewCache_=viewCache_;this.optCompleteServerCache_=optCompleteServerCache_;}getCompleteChild(childKey){const node=this.viewCache_.eventCache;if(node.isCompleteForChild(childKey)){return node.getNode().getImmediateChild(childKey);}else{const serverNode=this.optCompleteServerCache_!=null?new CacheNode(this.optCompleteServerCache_,true,false):this.viewCache_.serverCache;return writeTreeRefCalcCompleteChild(this.writes_,childKey,serverNode);}}getChildAfterChild(index,child,reverse){const completeServerData=this.optCompleteServerCache_!=null?this.optCompleteServerCache_:viewCacheGetCompleteServerSnap(this.viewCache_);const nodes=writeTreeRefCalcIndexedSlice(this.writes_,completeServerData,child,1,reverse,index);if(nodes.length===0){return null;}else{return nodes[0];}}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function newViewProcessor(filter){return{filter};}function viewProcessorAssertIndexed(viewProcessor,viewCache){(0,_util.assert)(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()),'Event snap not indexed');(0,_util.assert)(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()),'Server snap not indexed');}function viewProcessorApplyOperation(viewProcessor,oldViewCache,operation,writesCache,completeCache){const accumulator=new ChildChangeAccumulator();let newViewCache,filterServerNode;if(operation.type===OperationType.OVERWRITE){const overwrite=operation;if(overwrite.source.fromUser){newViewCache=viewProcessorApplyUserOverwrite(viewProcessor,oldViewCache,overwrite.path,overwrite.snap,writesCache,completeCache,accumulator);}else{(0,_util.assert)(overwrite.source.fromServer,'Unknown source.');// We filter the node if it's a tagged update or the node has been previously filtered  and the
// update is not at the root in which case it is ok (and necessary) to mark the node unfiltered
// again
filterServerNode=overwrite.source.tagged||oldViewCache.serverCache.isFiltered()&&!pathIsEmpty(overwrite.path);newViewCache=viewProcessorApplyServerOverwrite(viewProcessor,oldViewCache,overwrite.path,overwrite.snap,writesCache,completeCache,filterServerNode,accumulator);}}else if(operation.type===OperationType.MERGE){const merge=operation;if(merge.source.fromUser){newViewCache=viewProcessorApplyUserMerge(viewProcessor,oldViewCache,merge.path,merge.children,writesCache,completeCache,accumulator);}else{(0,_util.assert)(merge.source.fromServer,'Unknown source.');// We filter the node if it's a tagged update or the node has been previously filtered
filterServerNode=merge.source.tagged||oldViewCache.serverCache.isFiltered();newViewCache=viewProcessorApplyServerMerge(viewProcessor,oldViewCache,merge.path,merge.children,writesCache,completeCache,filterServerNode,accumulator);}}else if(operation.type===OperationType.ACK_USER_WRITE){const ackUserWrite=operation;if(!ackUserWrite.revert){newViewCache=viewProcessorAckUserWrite(viewProcessor,oldViewCache,ackUserWrite.path,ackUserWrite.affectedTree,writesCache,completeCache,accumulator);}else{newViewCache=viewProcessorRevertUserWrite(viewProcessor,oldViewCache,ackUserWrite.path,writesCache,completeCache,accumulator);}}else if(operation.type===OperationType.LISTEN_COMPLETE){newViewCache=viewProcessorListenComplete(viewProcessor,oldViewCache,operation.path,writesCache,accumulator);}else{throw(0,_util.assertionError)('Unknown operation type: '+operation.type);}const changes=accumulator.getChanges();viewProcessorMaybeAddValueEvent(oldViewCache,newViewCache,changes);return{viewCache:newViewCache,changes};}function viewProcessorMaybeAddValueEvent(oldViewCache,newViewCache,accumulator){const eventSnap=newViewCache.eventCache;if(eventSnap.isFullyInitialized()){const isLeafOrEmpty=eventSnap.getNode().isLeafNode()||eventSnap.getNode().isEmpty();const oldCompleteSnap=viewCacheGetCompleteEventSnap(oldViewCache);if(accumulator.length>0||!oldViewCache.eventCache.isFullyInitialized()||isLeafOrEmpty&&!eventSnap.getNode().equals(oldCompleteSnap)||!eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())){accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache)));}}}function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor,viewCache,changePath,writesCache,source,accumulator){const oldEventSnap=viewCache.eventCache;if(writeTreeRefShadowingWrite(writesCache,changePath)!=null){// we have a shadowing write, ignore changes
return viewCache;}else{let newEventCache,serverNode;if(pathIsEmpty(changePath)){// TODO: figure out how this plays with "sliding ack windows"
(0,_util.assert)(viewCache.serverCache.isFullyInitialized(),'If change path is empty, we must have complete server data');if(viewCache.serverCache.isFiltered()){// We need to special case this, because we need to only apply writes to complete children, or
// we might end up raising events for incomplete children. If the server data is filtered deep
// writes cannot be guaranteed to be complete
const serverCache=viewCacheGetCompleteServerSnap(viewCache);const completeChildren=serverCache instanceof ChildrenNode?serverCache:ChildrenNode.EMPTY_NODE;const completeEventChildren=writeTreeRefCalcCompleteEventChildren(writesCache,completeChildren);newEventCache=viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(),completeEventChildren,accumulator);}else{const completeNode=writeTreeRefCalcCompleteEventCache(writesCache,viewCacheGetCompleteServerSnap(viewCache));newEventCache=viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(),completeNode,accumulator);}}else{const childKey=pathGetFront(changePath);if(childKey==='.priority'){(0,_util.assert)(pathGetLength(changePath)===1,"Can't have a priority with additional path components");const oldEventNode=oldEventSnap.getNode();serverNode=viewCache.serverCache.getNode();// we might have overwrites for this priority
const updatedPriority=writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache,changePath,oldEventNode,serverNode);if(updatedPriority!=null){newEventCache=viewProcessor.filter.updatePriority(oldEventNode,updatedPriority);}else{// priority didn't change, keep old node
newEventCache=oldEventSnap.getNode();}}else{const childChangePath=pathPopFront(changePath);// update child
let newEventChild;if(oldEventSnap.isCompleteForChild(childKey)){serverNode=viewCache.serverCache.getNode();const eventChildUpdate=writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache,changePath,oldEventSnap.getNode(),serverNode);if(eventChildUpdate!=null){newEventChild=oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath,eventChildUpdate);}else{// Nothing changed, just keep the old child
newEventChild=oldEventSnap.getNode().getImmediateChild(childKey);}}else{newEventChild=writeTreeRefCalcCompleteChild(writesCache,childKey,viewCache.serverCache);}if(newEventChild!=null){newEventCache=viewProcessor.filter.updateChild(oldEventSnap.getNode(),childKey,newEventChild,childChangePath,source,accumulator);}else{// no complete child available or no change
newEventCache=oldEventSnap.getNode();}}}return viewCacheUpdateEventSnap(viewCache,newEventCache,oldEventSnap.isFullyInitialized()||pathIsEmpty(changePath),viewProcessor.filter.filtersNodes());}}function viewProcessorApplyServerOverwrite(viewProcessor,oldViewCache,changePath,changedSnap,writesCache,completeCache,filterServerNode,accumulator){const oldServerSnap=oldViewCache.serverCache;let newServerCache;const serverFilter=filterServerNode?viewProcessor.filter:viewProcessor.filter.getIndexedFilter();if(pathIsEmpty(changePath)){newServerCache=serverFilter.updateFullNode(oldServerSnap.getNode(),changedSnap,null);}else if(serverFilter.filtersNodes()&&!oldServerSnap.isFiltered()){// we want to filter the server node, but we didn't filter the server node yet, so simulate a full update
const newServerNode=oldServerSnap.getNode().updateChild(changePath,changedSnap);newServerCache=serverFilter.updateFullNode(oldServerSnap.getNode(),newServerNode,null);}else{const childKey=pathGetFront(changePath);if(!oldServerSnap.isCompleteForPath(changePath)&&pathGetLength(changePath)>1){// We don't update incomplete nodes with updates intended for other listeners
return oldViewCache;}const childChangePath=pathPopFront(changePath);const childNode=oldServerSnap.getNode().getImmediateChild(childKey);const newChildNode=childNode.updateChild(childChangePath,changedSnap);if(childKey==='.priority'){newServerCache=serverFilter.updatePriority(oldServerSnap.getNode(),newChildNode);}else{newServerCache=serverFilter.updateChild(oldServerSnap.getNode(),childKey,newChildNode,childChangePath,NO_COMPLETE_CHILD_SOURCE,null);}}const newViewCache=viewCacheUpdateServerSnap(oldViewCache,newServerCache,oldServerSnap.isFullyInitialized()||pathIsEmpty(changePath),serverFilter.filtersNodes());const source=new WriteTreeCompleteChildSource(writesCache,newViewCache,completeCache);return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor,newViewCache,changePath,writesCache,source,accumulator);}function viewProcessorApplyUserOverwrite(viewProcessor,oldViewCache,changePath,changedSnap,writesCache,completeCache,accumulator){const oldEventSnap=oldViewCache.eventCache;let newViewCache,newEventCache;const source=new WriteTreeCompleteChildSource(writesCache,oldViewCache,completeCache);if(pathIsEmpty(changePath)){newEventCache=viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(),changedSnap,accumulator);newViewCache=viewCacheUpdateEventSnap(oldViewCache,newEventCache,true,viewProcessor.filter.filtersNodes());}else{const childKey=pathGetFront(changePath);if(childKey==='.priority'){newEventCache=viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(),changedSnap);newViewCache=viewCacheUpdateEventSnap(oldViewCache,newEventCache,oldEventSnap.isFullyInitialized(),oldEventSnap.isFiltered());}else{const childChangePath=pathPopFront(changePath);const oldChild=oldEventSnap.getNode().getImmediateChild(childKey);let newChild;if(pathIsEmpty(childChangePath)){// Child overwrite, we can replace the child
newChild=changedSnap;}else{const childNode=source.getCompleteChild(childKey);if(childNode!=null){if(pathGetBack(childChangePath)==='.priority'&&childNode.getChild(pathParent(childChangePath)).isEmpty()){// This is a priority update on an empty node. If this node exists on the server, the
// server will send down the priority in the update, so ignore for now
newChild=childNode;}else{newChild=childNode.updateChild(childChangePath,changedSnap);}}else{// There is no complete child node available
newChild=ChildrenNode.EMPTY_NODE;}}if(!oldChild.equals(newChild)){const newEventSnap=viewProcessor.filter.updateChild(oldEventSnap.getNode(),childKey,newChild,childChangePath,source,accumulator);newViewCache=viewCacheUpdateEventSnap(oldViewCache,newEventSnap,oldEventSnap.isFullyInitialized(),viewProcessor.filter.filtersNodes());}else{newViewCache=oldViewCache;}}}return newViewCache;}function viewProcessorCacheHasChild(viewCache,childKey){return viewCache.eventCache.isCompleteForChild(childKey);}function viewProcessorApplyUserMerge(viewProcessor,viewCache,path,changedChildren,writesCache,serverCache,accumulator){// HACK: In the case of a limit query, there may be some changes that bump things out of the
// window leaving room for new items.  It's important we process these changes first, so we
// iterate the changes twice, first processing any that affect items currently in view.
// TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
// and event snap.  I'm not sure if this will result in edge cases when a child is in one but
// not the other.
let curViewCache=viewCache;changedChildren.foreach((relativePath,childNode)=>{const writePath=pathChild(path,relativePath);if(viewProcessorCacheHasChild(viewCache,pathGetFront(writePath))){curViewCache=viewProcessorApplyUserOverwrite(viewProcessor,curViewCache,writePath,childNode,writesCache,serverCache,accumulator);}});changedChildren.foreach((relativePath,childNode)=>{const writePath=pathChild(path,relativePath);if(!viewProcessorCacheHasChild(viewCache,pathGetFront(writePath))){curViewCache=viewProcessorApplyUserOverwrite(viewProcessor,curViewCache,writePath,childNode,writesCache,serverCache,accumulator);}});return curViewCache;}function viewProcessorApplyMerge(viewProcessor,node,merge){merge.foreach((relativePath,childNode)=>{node=node.updateChild(relativePath,childNode);});return node;}function viewProcessorApplyServerMerge(viewProcessor,viewCache,path,changedChildren,writesCache,serverCache,filterServerNode,accumulator){// If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and
// wait for the complete data update coming soon.
if(viewCache.serverCache.getNode().isEmpty()&&!viewCache.serverCache.isFullyInitialized()){return viewCache;}// HACK: In the case of a limit query, there may be some changes that bump things out of the
// window leaving room for new items.  It's important we process these changes first, so we
// iterate the changes twice, first processing any that affect items currently in view.
// TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
// and event snap.  I'm not sure if this will result in edge cases when a child is in one but
// not the other.
let curViewCache=viewCache;let viewMergeTree;if(pathIsEmpty(path)){viewMergeTree=changedChildren;}else{viewMergeTree=new ImmutableTree(null).setTree(path,changedChildren);}const serverNode=viewCache.serverCache.getNode();viewMergeTree.children.inorderTraversal((childKey,childTree)=>{if(serverNode.hasChild(childKey)){const serverChild=viewCache.serverCache.getNode().getImmediateChild(childKey);const newChild=viewProcessorApplyMerge(viewProcessor,serverChild,childTree);curViewCache=viewProcessorApplyServerOverwrite(viewProcessor,curViewCache,new Path(childKey),newChild,writesCache,serverCache,filterServerNode,accumulator);}});viewMergeTree.children.inorderTraversal((childKey,childMergeTree)=>{const isUnknownDeepMerge=!viewCache.serverCache.isCompleteForChild(childKey)&&childMergeTree.value===null;if(!serverNode.hasChild(childKey)&&!isUnknownDeepMerge){const serverChild=viewCache.serverCache.getNode().getImmediateChild(childKey);const newChild=viewProcessorApplyMerge(viewProcessor,serverChild,childMergeTree);curViewCache=viewProcessorApplyServerOverwrite(viewProcessor,curViewCache,new Path(childKey),newChild,writesCache,serverCache,filterServerNode,accumulator);}});return curViewCache;}function viewProcessorAckUserWrite(viewProcessor,viewCache,ackPath,affectedTree,writesCache,completeCache,accumulator){if(writeTreeRefShadowingWrite(writesCache,ackPath)!=null){return viewCache;}// Only filter server node if it is currently filtered
const filterServerNode=viewCache.serverCache.isFiltered();// Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update
// now that it won't be shadowed.
const serverCache=viewCache.serverCache;if(affectedTree.value!=null){// This is an overwrite.
if(pathIsEmpty(ackPath)&&serverCache.isFullyInitialized()||serverCache.isCompleteForPath(ackPath)){return viewProcessorApplyServerOverwrite(viewProcessor,viewCache,ackPath,serverCache.getNode().getChild(ackPath),writesCache,completeCache,filterServerNode,accumulator);}else if(pathIsEmpty(ackPath)){// This is a goofy edge case where we are acking data at this location but don't have full data.  We
// should just re-apply whatever we have in our cache as a merge.
let changedChildren=new ImmutableTree(null);serverCache.getNode().forEachChild(KEY_INDEX,(name,node)=>{changedChildren=changedChildren.set(new Path(name),node);});return viewProcessorApplyServerMerge(viewProcessor,viewCache,ackPath,changedChildren,writesCache,completeCache,filterServerNode,accumulator);}else{return viewCache;}}else{// This is a merge.
let changedChildren=new ImmutableTree(null);affectedTree.foreach((mergePath,value)=>{const serverCachePath=pathChild(ackPath,mergePath);if(serverCache.isCompleteForPath(serverCachePath)){changedChildren=changedChildren.set(mergePath,serverCache.getNode().getChild(serverCachePath));}});return viewProcessorApplyServerMerge(viewProcessor,viewCache,ackPath,changedChildren,writesCache,completeCache,filterServerNode,accumulator);}}function viewProcessorListenComplete(viewProcessor,viewCache,path,writesCache,accumulator){const oldServerNode=viewCache.serverCache;const newViewCache=viewCacheUpdateServerSnap(viewCache,oldServerNode.getNode(),oldServerNode.isFullyInitialized()||pathIsEmpty(path),oldServerNode.isFiltered());return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor,newViewCache,path,writesCache,NO_COMPLETE_CHILD_SOURCE,accumulator);}function viewProcessorRevertUserWrite(viewProcessor,viewCache,path,writesCache,completeServerCache,accumulator){let complete;if(writeTreeRefShadowingWrite(writesCache,path)!=null){return viewCache;}else{const source=new WriteTreeCompleteChildSource(writesCache,viewCache,completeServerCache);const oldEventCache=viewCache.eventCache.getNode();let newEventCache;if(pathIsEmpty(path)||pathGetFront(path)==='.priority'){let newNode;if(viewCache.serverCache.isFullyInitialized()){newNode=writeTreeRefCalcCompleteEventCache(writesCache,viewCacheGetCompleteServerSnap(viewCache));}else{const serverChildren=viewCache.serverCache.getNode();(0,_util.assert)(serverChildren instanceof ChildrenNode,'serverChildren would be complete if leaf node');newNode=writeTreeRefCalcCompleteEventChildren(writesCache,serverChildren);}newNode=newNode;newEventCache=viewProcessor.filter.updateFullNode(oldEventCache,newNode,accumulator);}else{const childKey=pathGetFront(path);let newChild=writeTreeRefCalcCompleteChild(writesCache,childKey,viewCache.serverCache);if(newChild==null&&viewCache.serverCache.isCompleteForChild(childKey)){newChild=oldEventCache.getImmediateChild(childKey);}if(newChild!=null){newEventCache=viewProcessor.filter.updateChild(oldEventCache,childKey,newChild,pathPopFront(path),source,accumulator);}else if(viewCache.eventCache.getNode().hasChild(childKey)){// No complete child available, delete the existing one, if any
newEventCache=viewProcessor.filter.updateChild(oldEventCache,childKey,ChildrenNode.EMPTY_NODE,pathPopFront(path),source,accumulator);}else{newEventCache=oldEventCache;}if(newEventCache.isEmpty()&&viewCache.serverCache.isFullyInitialized()){// We might have reverted all child writes. Maybe the old event was a leaf node
complete=writeTreeRefCalcCompleteEventCache(writesCache,viewCacheGetCompleteServerSnap(viewCache));if(complete.isLeafNode()){newEventCache=viewProcessor.filter.updateFullNode(newEventCache,complete,accumulator);}}}complete=viewCache.serverCache.isFullyInitialized()||writeTreeRefShadowingWrite(writesCache,newEmptyPath())!=null;return viewCacheUpdateEventSnap(viewCache,newEventCache,complete,viewProcessor.filter.filtersNodes());}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A view represents a specific location and query that has 1 or more event registrations.
 *
 * It does several things:
 *  - Maintains the list of event registrations for this location/query.
 *  - Maintains a cache of the data visible for this location/query.
 *  - Applies new operations (via applyOperation), updates the cache, and based on the event
 *    registrations returns the set of events to be raised.
 */class View{constructor(query_,initialViewCache){this.query_=query_;this.eventRegistrations_=[];const params=this.query_._queryParams;const indexFilter=new IndexedFilter(params.getIndex());const filter=queryParamsGetNodeFilter(params);this.processor_=newViewProcessor(filter);const initialServerCache=initialViewCache.serverCache;const initialEventCache=initialViewCache.eventCache;// Don't filter server node with other filter than index, wait for tagged listen
const serverSnap=indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE,initialServerCache.getNode(),null);const eventSnap=filter.updateFullNode(ChildrenNode.EMPTY_NODE,initialEventCache.getNode(),null);const newServerCache=new CacheNode(serverSnap,initialServerCache.isFullyInitialized(),indexFilter.filtersNodes());const newEventCache=new CacheNode(eventSnap,initialEventCache.isFullyInitialized(),filter.filtersNodes());this.viewCache_=newViewCache(newEventCache,newServerCache);this.eventGenerator_=new EventGenerator(this.query_);}get query(){return this.query_;}}function viewGetServerCache(view){return view.viewCache_.serverCache.getNode();}function viewGetCompleteNode(view){return viewCacheGetCompleteEventSnap(view.viewCache_);}function viewGetCompleteServerCache(view,path){const cache=viewCacheGetCompleteServerSnap(view.viewCache_);if(cache){// If this isn't a "loadsAllData" view, then cache isn't actually a complete cache and
// we need to see if it contains the child we're interested in.
if(view.query._queryParams.loadsAllData()||!pathIsEmpty(path)&&!cache.getImmediateChild(pathGetFront(path)).isEmpty()){return cache.getChild(path);}}return null;}function viewIsEmpty(view){return view.eventRegistrations_.length===0;}function viewAddEventRegistration(view,eventRegistration){view.eventRegistrations_.push(eventRegistration);}/**
 * @param eventRegistration - If null, remove all callbacks.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @returns Cancel events, if cancelError was provided.
 */function viewRemoveEventRegistration(view,eventRegistration,cancelError){const cancelEvents=[];if(cancelError){(0,_util.assert)(eventRegistration==null,'A cancel should cancel all event registrations.');const path=view.query._path;view.eventRegistrations_.forEach(registration=>{const maybeEvent=registration.createCancelEvent(cancelError,path);if(maybeEvent){cancelEvents.push(maybeEvent);}});}if(eventRegistration){let remaining=[];for(let i=0;i<view.eventRegistrations_.length;++i){const existing=view.eventRegistrations_[i];if(!existing.matches(eventRegistration)){remaining.push(existing);}else if(eventRegistration.hasAnyCallback()){// We're removing just this one
remaining=remaining.concat(view.eventRegistrations_.slice(i+1));break;}}view.eventRegistrations_=remaining;}else{view.eventRegistrations_=[];}return cancelEvents;}/**
 * Applies the given Operation, updates our cache, and returns the appropriate events.
 */function viewApplyOperation(view,operation,writesCache,completeServerCache){if(operation.type===OperationType.MERGE&&operation.source.queryId!==null){(0,_util.assert)(viewCacheGetCompleteServerSnap(view.viewCache_),'We should always have a full cache before handling merges');(0,_util.assert)(viewCacheGetCompleteEventSnap(view.viewCache_),'Missing event cache, even though we have a server cache');}const oldViewCache=view.viewCache_;const result=viewProcessorApplyOperation(view.processor_,oldViewCache,operation,writesCache,completeServerCache);viewProcessorAssertIndexed(view.processor_,result.viewCache);(0,_util.assert)(result.viewCache.serverCache.isFullyInitialized()||!oldViewCache.serverCache.isFullyInitialized(),'Once a server snap is complete, it should never go back');view.viewCache_=result.viewCache;return viewGenerateEventsForChanges_(view,result.changes,result.viewCache.eventCache.getNode(),null);}function viewGetInitialEvents(view,registration){const eventSnap=view.viewCache_.eventCache;const initialChanges=[];if(!eventSnap.getNode().isLeafNode()){const eventNode=eventSnap.getNode();eventNode.forEachChild(PRIORITY_INDEX,(key,childNode)=>{initialChanges.push(changeChildAdded(key,childNode));});}if(eventSnap.isFullyInitialized()){initialChanges.push(changeValue(eventSnap.getNode()));}return viewGenerateEventsForChanges_(view,initialChanges,eventSnap.getNode(),registration);}function viewGenerateEventsForChanges_(view,changes,eventCache,eventRegistration){const registrations=eventRegistration?[eventRegistration]:view.eventRegistrations_;return eventGeneratorGenerateEventsForChanges(view.eventGenerator_,changes,eventCache,registrations);}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let referenceConstructor$1;/**
 * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to
 * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes
 * and user writes (set, transaction, update).
 *
 * It's responsible for:
 *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).
 *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,
 *    applyUserOverwrite, etc.)
 */class SyncPoint{constructor(){/**
         * The Views being tracked at this location in the tree, stored as a map where the key is a
         * queryId and the value is the View for that query.
         *
         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).
         */this.views=new Map();}}function syncPointSetReferenceConstructor(val){(0,_util.assert)(!referenceConstructor$1,'__referenceConstructor has already been defined');referenceConstructor$1=val;}function syncPointGetReferenceConstructor(){(0,_util.assert)(referenceConstructor$1,'Reference.ts has not been loaded');return referenceConstructor$1;}function syncPointIsEmpty(syncPoint){return syncPoint.views.size===0;}function syncPointApplyOperation(syncPoint,operation,writesCache,optCompleteServerCache){const queryId=operation.source.queryId;if(queryId!==null){const view=syncPoint.views.get(queryId);(0,_util.assert)(view!=null,'SyncTree gave us an op for an invalid query.');return viewApplyOperation(view,operation,writesCache,optCompleteServerCache);}else{let events=[];for(const view of syncPoint.views.values()){events=events.concat(viewApplyOperation(view,operation,writesCache,optCompleteServerCache));}return events;}}/**
 * Get a view for the specified query.
 *
 * @param query - The query to return a view for
 * @param writesCache
 * @param serverCache
 * @param serverCacheComplete
 * @returns Events to raise.
 */function syncPointGetView(syncPoint,query,writesCache,serverCache,serverCacheComplete){const queryId=query._queryIdentifier;const view=syncPoint.views.get(queryId);if(!view){// TODO: make writesCache take flag for complete server node
let eventCache=writeTreeRefCalcCompleteEventCache(writesCache,serverCacheComplete?serverCache:null);let eventCacheComplete=false;if(eventCache){eventCacheComplete=true;}else if(serverCache instanceof ChildrenNode){eventCache=writeTreeRefCalcCompleteEventChildren(writesCache,serverCache);eventCacheComplete=false;}else{eventCache=ChildrenNode.EMPTY_NODE;eventCacheComplete=false;}const viewCache=newViewCache(new CacheNode(eventCache,eventCacheComplete,false),new CacheNode(serverCache,serverCacheComplete,false));return new View(query,viewCache);}return view;}/**
 * Add an event callback for the specified query.
 *
 * @param query
 * @param eventRegistration
 * @param writesCache
 * @param serverCache - Complete server cache, if we have it.
 * @param serverCacheComplete
 * @returns Events to raise.
 */function syncPointAddEventRegistration(syncPoint,query,eventRegistration,writesCache,serverCache,serverCacheComplete){const view=syncPointGetView(syncPoint,query,writesCache,serverCache,serverCacheComplete);if(!syncPoint.views.has(query._queryIdentifier)){syncPoint.views.set(query._queryIdentifier,view);}// This is guaranteed to exist now, we just created anything that was missing
viewAddEventRegistration(view,eventRegistration);return viewGetInitialEvents(view,eventRegistration);}/**
 * Remove event callback(s).  Return cancelEvents if a cancelError is specified.
 *
 * If query is the default query, we'll check all views for the specified eventRegistration.
 * If eventRegistration is null, we'll remove all callbacks for the specified view(s).
 *
 * @param eventRegistration - If null, remove all callbacks.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @returns removed queries and any cancel events
 */function syncPointRemoveEventRegistration(syncPoint,query,eventRegistration,cancelError){const queryId=query._queryIdentifier;const removed=[];let cancelEvents=[];const hadCompleteView=syncPointHasCompleteView(syncPoint);if(queryId==='default'){// When you do ref.off(...), we search all views for the registration to remove.
for(const[viewQueryId,view]of syncPoint.views.entries()){cancelEvents=cancelEvents.concat(viewRemoveEventRegistration(view,eventRegistration,cancelError));if(viewIsEmpty(view)){syncPoint.views.delete(viewQueryId);// We'll deal with complete views later.
if(!view.query._queryParams.loadsAllData()){removed.push(view.query);}}}}else{// remove the callback from the specific view.
const view=syncPoint.views.get(queryId);if(view){cancelEvents=cancelEvents.concat(viewRemoveEventRegistration(view,eventRegistration,cancelError));if(viewIsEmpty(view)){syncPoint.views.delete(queryId);// We'll deal with complete views later.
if(!view.query._queryParams.loadsAllData()){removed.push(view.query);}}}}if(hadCompleteView&&!syncPointHasCompleteView(syncPoint)){// We removed our last complete view.
removed.push(new(syncPointGetReferenceConstructor())(query._repo,query._path));}return{removed,events:cancelEvents};}function syncPointGetQueryViews(syncPoint){const result=[];for(const view of syncPoint.views.values()){if(!view.query._queryParams.loadsAllData()){result.push(view);}}return result;}/**
 * @param path - The path to the desired complete snapshot
 * @returns A complete cache, if it exists
 */function syncPointGetCompleteServerCache(syncPoint,path){let serverCache=null;for(const view of syncPoint.views.values()){serverCache=serverCache||viewGetCompleteServerCache(view,path);}return serverCache;}function syncPointViewForQuery(syncPoint,query){const params=query._queryParams;if(params.loadsAllData()){return syncPointGetCompleteView(syncPoint);}else{const queryId=query._queryIdentifier;return syncPoint.views.get(queryId);}}function syncPointViewExistsForQuery(syncPoint,query){return syncPointViewForQuery(syncPoint,query)!=null;}function syncPointHasCompleteView(syncPoint){return syncPointGetCompleteView(syncPoint)!=null;}function syncPointGetCompleteView(syncPoint){for(const view of syncPoint.views.values()){if(view.query._queryParams.loadsAllData()){return view;}}return null;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let referenceConstructor;function syncTreeSetReferenceConstructor(val){(0,_util.assert)(!referenceConstructor,'__referenceConstructor has already been defined');referenceConstructor=val;}function syncTreeGetReferenceConstructor(){(0,_util.assert)(referenceConstructor,'Reference.ts has not been loaded');return referenceConstructor;}/**
 * Static tracker for next query tag.
 */let syncTreeNextQueryTag_=1;/**
 * SyncTree is the central class for managing event callback registration, data caching, views
 * (query processing), and event generation.  There are typically two SyncTree instances for
 * each Repo, one for the normal Firebase data, and one for the .info data.
 *
 * It has a number of responsibilities, including:
 *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).
 *  - Applying and caching data changes for user set(), transaction(), and update() calls
 *    (applyUserOverwrite(), applyUserMerge()).
 *  - Applying and caching data changes for server data changes (applyServerOverwrite(),
 *    applyServerMerge()).
 *  - Generating user-facing events for server and user changes (all of the apply* methods
 *    return the set of events that need to be raised as a result).
 *  - Maintaining the appropriate set of server listens to ensure we are always subscribed
 *    to the correct set of paths and queries to satisfy the current set of user event
 *    callbacks (listens are started/stopped using the provided listenProvider).
 *
 * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual
 * events are returned to the caller rather than raised synchronously.
 *
 */class SyncTree{/**
     * @param listenProvider_ - Used by SyncTree to start / stop listening
     *   to server data.
     */constructor(listenProvider_){this.listenProvider_=listenProvider_;/**
         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.
         */this.syncPointTree_=new ImmutableTree(null);/**
         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).
         */this.pendingWriteTree_=newWriteTree();this.tagToQueryMap=new Map();this.queryToTagMap=new Map();}}/**
 * Apply the data changes for a user-generated set() or transaction() call.
 *
 * @returns Events to raise.
 */function syncTreeApplyUserOverwrite(syncTree,path,newData,writeId,visible){// Record pending write.
writeTreeAddOverwrite(syncTree.pendingWriteTree_,path,newData,writeId,visible);if(!visible){return[];}else{return syncTreeApplyOperationToSyncPoints_(syncTree,new Overwrite(newOperationSourceUser(),path,newData));}}/**
 * Apply the data from a user-generated update() call
 *
 * @returns Events to raise.
 */function syncTreeApplyUserMerge(syncTree,path,changedChildren,writeId){// Record pending merge.
writeTreeAddMerge(syncTree.pendingWriteTree_,path,changedChildren,writeId);const changeTree=ImmutableTree.fromObject(changedChildren);return syncTreeApplyOperationToSyncPoints_(syncTree,new Merge(newOperationSourceUser(),path,changeTree));}/**
 * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().
 *
 * @param revert - True if the given write failed and needs to be reverted
 * @returns Events to raise.
 */function syncTreeAckUserWrite(syncTree,writeId,revert=false){const write=writeTreeGetWrite(syncTree.pendingWriteTree_,writeId);const needToReevaluate=writeTreeRemoveWrite(syncTree.pendingWriteTree_,writeId);if(!needToReevaluate){return[];}else{let affectedTree=new ImmutableTree(null);if(write.snap!=null){// overwrite
affectedTree=affectedTree.set(newEmptyPath(),true);}else{each(write.children,pathString=>{affectedTree=affectedTree.set(new Path(pathString),true);});}return syncTreeApplyOperationToSyncPoints_(syncTree,new AckUserWrite(write.path,affectedTree,revert));}}/**
 * Apply new server data for the specified path..
 *
 * @returns Events to raise.
 */function syncTreeApplyServerOverwrite(syncTree,path,newData){return syncTreeApplyOperationToSyncPoints_(syncTree,new Overwrite(newOperationSourceServer(),path,newData));}/**
 * Apply new server data to be merged in at the specified path.
 *
 * @returns Events to raise.
 */function syncTreeApplyServerMerge(syncTree,path,changedChildren){const changeTree=ImmutableTree.fromObject(changedChildren);return syncTreeApplyOperationToSyncPoints_(syncTree,new Merge(newOperationSourceServer(),path,changeTree));}/**
 * Apply a listen complete for a query
 *
 * @returns Events to raise.
 */function syncTreeApplyListenComplete(syncTree,path){return syncTreeApplyOperationToSyncPoints_(syncTree,new ListenComplete(newOperationSourceServer(),path));}/**
 * Apply a listen complete for a tagged query
 *
 * @returns Events to raise.
 */function syncTreeApplyTaggedListenComplete(syncTree,path,tag){const queryKey=syncTreeQueryKeyForTag_(syncTree,tag);if(queryKey){const r=syncTreeParseQueryKey_(queryKey);const queryPath=r.path,queryId=r.queryId;const relativePath=newRelativePath(queryPath,path);const op=new ListenComplete(newOperationSourceServerTaggedQuery(queryId),relativePath);return syncTreeApplyTaggedOperation_(syncTree,queryPath,op);}else{// We've already removed the query. No big deal, ignore the update
return[];}}/**
 * Remove event callback(s).
 *
 * If query is the default query, we'll check all queries for the specified eventRegistration.
 * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.
 *
 * @param eventRegistration - If null, all callbacks are removed.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @param skipListenerDedup - When performing a `get()`, we don't add any new listeners, so no
 *  deduping needs to take place. This flag allows toggling of that behavior
 * @returns Cancel events, if cancelError was provided.
 */function syncTreeRemoveEventRegistration(syncTree,query,eventRegistration,cancelError,skipListenerDedup=false){// Find the syncPoint first. Then deal with whether or not it has matching listeners
const path=query._path;const maybeSyncPoint=syncTree.syncPointTree_.get(path);let cancelEvents=[];// A removal on a default query affects all queries at that location. A removal on an indexed query, even one without
// other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and
// not loadsAllData().
if(maybeSyncPoint&&(query._queryIdentifier==='default'||syncPointViewExistsForQuery(maybeSyncPoint,query))){const removedAndEvents=syncPointRemoveEventRegistration(maybeSyncPoint,query,eventRegistration,cancelError);if(syncPointIsEmpty(maybeSyncPoint)){syncTree.syncPointTree_=syncTree.syncPointTree_.remove(path);}const removed=removedAndEvents.removed;cancelEvents=removedAndEvents.events;if(!skipListenerDedup){/**
             * We may have just removed one of many listeners and can short-circuit this whole process
             * We may also not have removed a default listener, in which case all of the descendant listeners should already be
             * properly set up.
             */ // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of
// queryId === 'default'
const removingDefault=-1!==removed.findIndex(query=>{return query._queryParams.loadsAllData();});const covered=syncTree.syncPointTree_.findOnPath(path,(relativePath,parentSyncPoint)=>syncPointHasCompleteView(parentSyncPoint));if(removingDefault&&!covered){const subtree=syncTree.syncPointTree_.subtree(path);// There are potentially child listeners. Determine what if any listens we need to send before executing the
// removal
if(!subtree.isEmpty()){// We need to fold over our subtree and collect the listeners to send
const newViews=syncTreeCollectDistinctViewsForSubTree_(subtree);// Ok, we've collected all the listens we need. Set them up.
for(let i=0;i<newViews.length;++i){const view=newViews[i],newQuery=view.query;const listener=syncTreeCreateListenerForView_(syncTree,view);syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery),syncTreeTagForQuery(syncTree,newQuery),listener.hashFn,listener.onComplete);}}// Otherwise there's nothing below us, so nothing we need to start listening on
}// If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query
// The above block has us covered in terms of making sure we're set up on listens lower in the tree.
// Also, note that if we have a cancelError, it's already been removed at the provider level.
if(!covered&&removed.length>0&&!cancelError){// If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one
// default. Otherwise, we need to iterate through and cancel each individual query
if(removingDefault){// We don't tag default listeners
const defaultTag=null;syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query),defaultTag);}else{removed.forEach(queryToRemove=>{const tagToRemove=syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove),tagToRemove);});}}}// Now, clear all of the tags we're tracking for the removed listens
syncTreeRemoveTags_(syncTree,removed);}return cancelEvents;}/**
 * Apply new server data for the specified tagged query.
 *
 * @returns Events to raise.
 */function syncTreeApplyTaggedQueryOverwrite(syncTree,path,snap,tag){const queryKey=syncTreeQueryKeyForTag_(syncTree,tag);if(queryKey!=null){const r=syncTreeParseQueryKey_(queryKey);const queryPath=r.path,queryId=r.queryId;const relativePath=newRelativePath(queryPath,path);const op=new Overwrite(newOperationSourceServerTaggedQuery(queryId),relativePath,snap);return syncTreeApplyTaggedOperation_(syncTree,queryPath,op);}else{// Query must have been removed already
return[];}}/**
 * Apply server data to be merged in for the specified tagged query.
 *
 * @returns Events to raise.
 */function syncTreeApplyTaggedQueryMerge(syncTree,path,changedChildren,tag){const queryKey=syncTreeQueryKeyForTag_(syncTree,tag);if(queryKey){const r=syncTreeParseQueryKey_(queryKey);const queryPath=r.path,queryId=r.queryId;const relativePath=newRelativePath(queryPath,path);const changeTree=ImmutableTree.fromObject(changedChildren);const op=new Merge(newOperationSourceServerTaggedQuery(queryId),relativePath,changeTree);return syncTreeApplyTaggedOperation_(syncTree,queryPath,op);}else{// We've already removed the query. No big deal, ignore the update
return[];}}/**
 * Add an event callback for the specified query.
 *
 * @returns Events to raise.
 */function syncTreeAddEventRegistration(syncTree,query,eventRegistration,skipSetupListener=false){const path=query._path;let serverCache=null;let foundAncestorDefaultView=false;// Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
// Consider optimizing this once there's a better understanding of what actual behavior will be.
syncTree.syncPointTree_.foreachOnPath(path,(pathToSyncPoint,sp)=>{const relativePath=newRelativePath(pathToSyncPoint,path);serverCache=serverCache||syncPointGetCompleteServerCache(sp,relativePath);foundAncestorDefaultView=foundAncestorDefaultView||syncPointHasCompleteView(sp);});let syncPoint=syncTree.syncPointTree_.get(path);if(!syncPoint){syncPoint=new SyncPoint();syncTree.syncPointTree_=syncTree.syncPointTree_.set(path,syncPoint);}else{foundAncestorDefaultView=foundAncestorDefaultView||syncPointHasCompleteView(syncPoint);serverCache=serverCache||syncPointGetCompleteServerCache(syncPoint,newEmptyPath());}let serverCacheComplete;if(serverCache!=null){serverCacheComplete=true;}else{serverCacheComplete=false;serverCache=ChildrenNode.EMPTY_NODE;const subtree=syncTree.syncPointTree_.subtree(path);subtree.foreachChild((childName,childSyncPoint)=>{const completeCache=syncPointGetCompleteServerCache(childSyncPoint,newEmptyPath());if(completeCache){serverCache=serverCache.updateImmediateChild(childName,completeCache);}});}const viewAlreadyExists=syncPointViewExistsForQuery(syncPoint,query);if(!viewAlreadyExists&&!query._queryParams.loadsAllData()){// We need to track a tag for this query
const queryKey=syncTreeMakeQueryKey_(query);(0,_util.assert)(!syncTree.queryToTagMap.has(queryKey),'View does not exist, but we have a tag');const tag=syncTreeGetNextQueryTag_();syncTree.queryToTagMap.set(queryKey,tag);syncTree.tagToQueryMap.set(tag,queryKey);}const writesCache=writeTreeChildWrites(syncTree.pendingWriteTree_,path);let events=syncPointAddEventRegistration(syncPoint,query,eventRegistration,writesCache,serverCache,serverCacheComplete);if(!viewAlreadyExists&&!foundAncestorDefaultView&&!skipSetupListener){const view=syncPointViewForQuery(syncPoint,query);events=events.concat(syncTreeSetupListener_(syncTree,query,view));}return events;}/**
 * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a
 * listener above it, we will get a false "null". This shouldn't be a problem because transactions will always
 * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->
 *     <incremented total> as the write is applied locally and then acknowledged at the server.
 *
 * Note: this method will *include* hidden writes from transaction with applyLocally set to false.
 *
 * @param path - The path to the data we want
 * @param writeIdsToExclude - A specific set to be excluded
 */function syncTreeCalcCompleteEventCache(syncTree,path,writeIdsToExclude){const includeHiddenSets=true;const writeTree=syncTree.pendingWriteTree_;const serverCache=syncTree.syncPointTree_.findOnPath(path,(pathSoFar,syncPoint)=>{const relativePath=newRelativePath(pathSoFar,path);const serverCache=syncPointGetCompleteServerCache(syncPoint,relativePath);if(serverCache){return serverCache;}});return writeTreeCalcCompleteEventCache(writeTree,path,serverCache,writeIdsToExclude,includeHiddenSets);}function syncTreeGetServerValue(syncTree,query){const path=query._path;let serverCache=null;// Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
// Consider optimizing this once there's a better understanding of what actual behavior will be.
syncTree.syncPointTree_.foreachOnPath(path,(pathToSyncPoint,sp)=>{const relativePath=newRelativePath(pathToSyncPoint,path);serverCache=serverCache||syncPointGetCompleteServerCache(sp,relativePath);});let syncPoint=syncTree.syncPointTree_.get(path);if(!syncPoint){syncPoint=new SyncPoint();syncTree.syncPointTree_=syncTree.syncPointTree_.set(path,syncPoint);}else{serverCache=serverCache||syncPointGetCompleteServerCache(syncPoint,newEmptyPath());}const serverCacheComplete=serverCache!=null;const serverCacheNode=serverCacheComplete?new CacheNode(serverCache,true,false):null;const writesCache=writeTreeChildWrites(syncTree.pendingWriteTree_,query._path);const view=syncPointGetView(syncPoint,query,writesCache,serverCacheComplete?serverCacheNode.getNode():ChildrenNode.EMPTY_NODE,serverCacheComplete);return viewGetCompleteNode(view);}/**
 * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.
 *
 * NOTES:
 * - Descendant SyncPoints will be visited first (since we raise events depth-first).
 *
 * - We call applyOperation() on each SyncPoint passing three things:
 *   1. A version of the Operation that has been made relative to the SyncPoint location.
 *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.
 *   3. A snapshot Node with cached server data, if we have it.
 *
 * - We concatenate all of the events returned by each SyncPoint and return the result.
 */function syncTreeApplyOperationToSyncPoints_(syncTree,operation){return syncTreeApplyOperationHelper_(operation,syncTree.syncPointTree_,/*serverCache=*/null,writeTreeChildWrites(syncTree.pendingWriteTree_,newEmptyPath()));}/**
 * Recursive helper for applyOperationToSyncPoints_
 */function syncTreeApplyOperationHelper_(operation,syncPointTree,serverCache,writesCache){if(pathIsEmpty(operation.path)){return syncTreeApplyOperationDescendantsHelper_(operation,syncPointTree,serverCache,writesCache);}else{const syncPoint=syncPointTree.get(newEmptyPath());// If we don't have cached server data, see if we can get it from this SyncPoint.
if(serverCache==null&&syncPoint!=null){serverCache=syncPointGetCompleteServerCache(syncPoint,newEmptyPath());}let events=[];const childName=pathGetFront(operation.path);const childOperation=operation.operationForChild(childName);const childTree=syncPointTree.children.get(childName);if(childTree&&childOperation){const childServerCache=serverCache?serverCache.getImmediateChild(childName):null;const childWritesCache=writeTreeRefChild(writesCache,childName);events=events.concat(syncTreeApplyOperationHelper_(childOperation,childTree,childServerCache,childWritesCache));}if(syncPoint){events=events.concat(syncPointApplyOperation(syncPoint,operation,writesCache,serverCache));}return events;}}/**
 * Recursive helper for applyOperationToSyncPoints_
 */function syncTreeApplyOperationDescendantsHelper_(operation,syncPointTree,serverCache,writesCache){const syncPoint=syncPointTree.get(newEmptyPath());// If we don't have cached server data, see if we can get it from this SyncPoint.
if(serverCache==null&&syncPoint!=null){serverCache=syncPointGetCompleteServerCache(syncPoint,newEmptyPath());}let events=[];syncPointTree.children.inorderTraversal((childName,childTree)=>{const childServerCache=serverCache?serverCache.getImmediateChild(childName):null;const childWritesCache=writeTreeRefChild(writesCache,childName);const childOperation=operation.operationForChild(childName);if(childOperation){events=events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation,childTree,childServerCache,childWritesCache));}});if(syncPoint){events=events.concat(syncPointApplyOperation(syncPoint,operation,writesCache,serverCache));}return events;}function syncTreeCreateListenerForView_(syncTree,view){const query=view.query;const tag=syncTreeTagForQuery(syncTree,query);return{hashFn:()=>{const cache=viewGetServerCache(view)||ChildrenNode.EMPTY_NODE;return cache.hash();},onComplete:status=>{if(status==='ok'){if(tag){return syncTreeApplyTaggedListenComplete(syncTree,query._path,tag);}else{return syncTreeApplyListenComplete(syncTree,query._path);}}else{// If a listen failed, kill all of the listeners here, not just the one that triggered the error.
// Note that this may need to be scoped to just this listener if we change permissions on filtered children
const error=errorForServerCode(status,query);return syncTreeRemoveEventRegistration(syncTree,query,/*eventRegistration*/null,error);}}};}/**
 * Return the tag associated with the given query.
 */function syncTreeTagForQuery(syncTree,query){const queryKey=syncTreeMakeQueryKey_(query);return syncTree.queryToTagMap.get(queryKey);}/**
 * Given a query, computes a "queryKey" suitable for use in our queryToTagMap_.
 */function syncTreeMakeQueryKey_(query){return query._path.toString()+'$'+query._queryIdentifier;}/**
 * Return the query associated with the given tag, if we have one
 */function syncTreeQueryKeyForTag_(syncTree,tag){return syncTree.tagToQueryMap.get(tag);}/**
 * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.
 */function syncTreeParseQueryKey_(queryKey){const splitIndex=queryKey.indexOf('$');(0,_util.assert)(splitIndex!==-1&&splitIndex<queryKey.length-1,'Bad queryKey.');return{queryId:queryKey.substr(splitIndex+1),path:new Path(queryKey.substr(0,splitIndex))};}/**
 * A helper method to apply tagged operations
 */function syncTreeApplyTaggedOperation_(syncTree,queryPath,operation){const syncPoint=syncTree.syncPointTree_.get(queryPath);(0,_util.assert)(syncPoint,"Missing sync point for query tag that we're tracking");const writesCache=writeTreeChildWrites(syncTree.pendingWriteTree_,queryPath);return syncPointApplyOperation(syncPoint,operation,writesCache,null);}/**
 * This collapses multiple unfiltered views into a single view, since we only need a single
 * listener for them.
 */function syncTreeCollectDistinctViewsForSubTree_(subtree){return subtree.fold((relativePath,maybeChildSyncPoint,childMap)=>{if(maybeChildSyncPoint&&syncPointHasCompleteView(maybeChildSyncPoint)){const completeView=syncPointGetCompleteView(maybeChildSyncPoint);return[completeView];}else{// No complete view here, flatten any deeper listens into an array
let views=[];if(maybeChildSyncPoint){views=syncPointGetQueryViews(maybeChildSyncPoint);}each(childMap,(_key,childViews)=>{views=views.concat(childViews);});return views;}});}/**
 * Normalizes a query to a query we send the server for listening
 *
 * @returns The normalized query
 */function syncTreeQueryForListening_(query){if(query._queryParams.loadsAllData()&&!query._queryParams.isDefault()){// We treat queries that load all data as default queries
// Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits
// from Query
return new(syncTreeGetReferenceConstructor())(query._repo,query._path);}else{return query;}}function syncTreeRemoveTags_(syncTree,queries){for(let j=0;j<queries.length;++j){const removedQuery=queries[j];if(!removedQuery._queryParams.loadsAllData()){// We should have a tag for this
const removedQueryKey=syncTreeMakeQueryKey_(removedQuery);const removedQueryTag=syncTree.queryToTagMap.get(removedQueryKey);syncTree.queryToTagMap.delete(removedQueryKey);syncTree.tagToQueryMap.delete(removedQueryTag);}}}/**
 * Static accessor for query tags.
 */function syncTreeGetNextQueryTag_(){return syncTreeNextQueryTag_++;}/**
 * For a given new listen, manage the de-duplication of outstanding subscriptions.
 *
 * @returns This method can return events to support synchronous data sources
 */function syncTreeSetupListener_(syncTree,query,view){const path=query._path;const tag=syncTreeTagForQuery(syncTree,query);const listener=syncTreeCreateListenerForView_(syncTree,view);const events=syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query),tag,listener.hashFn,listener.onComplete);const subtree=syncTree.syncPointTree_.subtree(path);// The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we
// may need to shadow other listens as well.
if(tag){(0,_util.assert)(!syncPointHasCompleteView(subtree.value),"If we're adding a query, it shouldn't be shadowed");}else{// Shadow everything at or below this location, this is a default listener.
const queriesToStop=subtree.fold((relativePath,maybeChildSyncPoint,childMap)=>{if(!pathIsEmpty(relativePath)&&maybeChildSyncPoint&&syncPointHasCompleteView(maybeChildSyncPoint)){return[syncPointGetCompleteView(maybeChildSyncPoint).query];}else{// No default listener here, flatten any deeper queries into an array
let queries=[];if(maybeChildSyncPoint){queries=queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(view=>view.query));}each(childMap,(_key,childQueries)=>{queries=queries.concat(childQueries);});return queries;}});for(let i=0;i<queriesToStop.length;++i){const queryToStop=queriesToStop[i];syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop),syncTreeTagForQuery(syncTree,queryToStop));}}return events;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ExistingValueProvider{constructor(node_){this.node_=node_;}getImmediateChild(childName){const child=this.node_.getImmediateChild(childName);return new ExistingValueProvider(child);}node(){return this.node_;}}class DeferredValueProvider{constructor(syncTree,path){this.syncTree_=syncTree;this.path_=path;}getImmediateChild(childName){const childPath=pathChild(this.path_,childName);return new DeferredValueProvider(this.syncTree_,childPath);}node(){return syncTreeCalcCompleteEventCache(this.syncTree_,this.path_);}}/**
 * Generate placeholders for deferred values.
 */const generateWithValues=function(values){values=values||{};values['timestamp']=values['timestamp']||new Date().getTime();return values;};/**
 * Value to use when firing local events. When writing server values, fire
 * local events with an approximate value, otherwise return value as-is.
 */const resolveDeferredLeafValue=function(value,existingVal,serverValues){if(!value||typeof value!=='object'){return value;}(0,_util.assert)('.sv'in value,'Unexpected leaf node or priority contents');if(typeof value['.sv']==='string'){return resolveScalarDeferredValue(value['.sv'],existingVal,serverValues);}else if(typeof value['.sv']==='object'){return resolveComplexDeferredValue(value['.sv'],existingVal);}else{(0,_util.assert)(false,'Unexpected server value: '+JSON.stringify(value,null,2));}};const resolveScalarDeferredValue=function(op,existing,serverValues){switch(op){case'timestamp':return serverValues['timestamp'];default:(0,_util.assert)(false,'Unexpected server value: '+op);}};const resolveComplexDeferredValue=function(op,existing,unused){if(!op.hasOwnProperty('increment')){(0,_util.assert)(false,'Unexpected server value: '+JSON.stringify(op,null,2));}const delta=op['increment'];if(typeof delta!=='number'){(0,_util.assert)(false,'Unexpected increment value: '+delta);}const existingNode=existing.node();(0,_util.assert)(existingNode!==null&&typeof existingNode!=='undefined','Expected ChildrenNode.EMPTY_NODE for nulls');// Incrementing a non-number sets the value to the incremented amount
if(!existingNode.isLeafNode()){return delta;}const leaf=existingNode;const existingVal=leaf.getValue();if(typeof existingVal!=='number'){return delta;}// No need to do over/underflow arithmetic here because JS only handles floats under the covers
return existingVal+delta;};/**
 * Recursively replace all deferred values and priorities in the tree with the
 * specified generated replacement values.
 * @param path - path to which write is relative
 * @param node - new data written at path
 * @param syncTree - current data
 */const resolveDeferredValueTree=function(path,node,syncTree,serverValues){return resolveDeferredValue(node,new DeferredValueProvider(syncTree,path),serverValues);};/**
 * Recursively replace all deferred values and priorities in the node with the
 * specified generated replacement values.  If there are no server values in the node,
 * it'll be returned as-is.
 */const resolveDeferredValueSnapshot=function(node,existing,serverValues){return resolveDeferredValue(node,new ExistingValueProvider(existing),serverValues);};function resolveDeferredValue(node,existingVal,serverValues){const rawPri=node.getPriority().val();const priority=resolveDeferredLeafValue(rawPri,existingVal.getImmediateChild('.priority'),serverValues);let newNode;if(node.isLeafNode()){const leafNode=node;const value=resolveDeferredLeafValue(leafNode.getValue(),existingVal,serverValues);if(value!==leafNode.getValue()||priority!==leafNode.getPriority().val()){return new LeafNode(value,nodeFromJSON(priority));}else{return node;}}else{const childrenNode=node;newNode=childrenNode;if(priority!==childrenNode.getPriority().val()){newNode=newNode.updatePriority(new LeafNode(priority));}childrenNode.forEachChild(PRIORITY_INDEX,(childName,childNode)=>{const newChildNode=resolveDeferredValue(childNode,existingVal.getImmediateChild(childName),serverValues);if(newChildNode!==childNode){newNode=newNode.updateImmediateChild(childName,newChildNode);}});return newNode;}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A light-weight tree, traversable by path.  Nodes can have both values and children.
 * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty
 * children.
 */class Tree{/**
     * @param name - Optional name of the node.
     * @param parent - Optional parent node.
     * @param node - Optional node to wrap.
     */constructor(name='',parent=null,node={children:{},childCount:0}){this.name=name;this.parent=parent;this.node=node;}}/**
 * Returns a sub-Tree for the given path.
 *
 * @param pathObj - Path to look up.
 * @returns Tree for path.
 */function treeSubTree(tree,pathObj){// TODO: Require pathObj to be Path?
let path=pathObj instanceof Path?pathObj:new Path(pathObj);let child=tree,next=pathGetFront(path);while(next!==null){const childNode=(0,_util.safeGet)(child.node.children,next)||{children:{},childCount:0};child=new Tree(next,child,childNode);path=pathPopFront(path);next=pathGetFront(path);}return child;}/**
 * Returns the data associated with this tree node.
 *
 * @returns The data or null if no data exists.
 */function treeGetValue(tree){return tree.node.value;}/**
 * Sets data to this tree node.
 *
 * @param value - Value to set.
 */function treeSetValue(tree,value){tree.node.value=value;treeUpdateParents(tree);}/**
 * @returns Whether the tree has any children.
 */function treeHasChildren(tree){return tree.node.childCount>0;}/**
 * @returns Whethe rthe tree is empty (no value or children).
 */function treeIsEmpty(tree){return treeGetValue(tree)===undefined&&!treeHasChildren(tree);}/**
 * Calls action for each child of this tree node.
 *
 * @param action - Action to be called for each child.
 */function treeForEachChild(tree,action){each(tree.node.children,(child,childTree)=>{action(new Tree(child,tree,childTree));});}/**
 * Does a depth-first traversal of this node's descendants, calling action for each one.
 *
 * @param action - Action to be called for each child.
 * @param includeSelf - Whether to call action on this node as well. Defaults to
 *   false.
 * @param childrenFirst - Whether to call action on children before calling it on
 *   parent.
 */function treeForEachDescendant(tree,action,includeSelf,childrenFirst){if(includeSelf&&!childrenFirst){action(tree);}treeForEachChild(tree,child=>{treeForEachDescendant(child,action,true,childrenFirst);});if(includeSelf&&childrenFirst){action(tree);}}/**
 * Calls action on each ancestor node.
 *
 * @param action - Action to be called on each parent; return
 *   true to abort.
 * @param includeSelf - Whether to call action on this node as well.
 * @returns true if the action callback returned true.
 */function treeForEachAncestor(tree,action,includeSelf){let node=includeSelf?tree:tree.parent;while(node!==null){if(action(node)){return true;}node=node.parent;}return false;}/**
 * @returns The path of this tree node, as a Path.
 */function treeGetPath(tree){return new Path(tree.parent===null?tree.name:treeGetPath(tree.parent)+'/'+tree.name);}/**
 * Adds or removes this child from its parent based on whether it's empty or not.
 */function treeUpdateParents(tree){if(tree.parent!==null){treeUpdateChild(tree.parent,tree.name,tree);}}/**
 * Adds or removes the passed child to this tree node, depending on whether it's empty.
 *
 * @param childName - The name of the child to update.
 * @param child - The child to update.
 */function treeUpdateChild(tree,childName,child){const childEmpty=treeIsEmpty(child);const childExists=(0,_util.contains)(tree.node.children,childName);if(childEmpty&&childExists){delete tree.node.children[childName];tree.node.childCount--;treeUpdateParents(tree);}else if(!childEmpty&&!childExists){tree.node.children[childName]=child.node;tree.node.childCount++;treeUpdateParents(tree);}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * True for invalid Firebase keys
 */const INVALID_KEY_REGEX_=/[\[\].#$\/\u0000-\u001F\u007F]/;/**
 * True for invalid Firebase paths.
 * Allows '/' in paths.
 */const INVALID_PATH_REGEX_=/[\[\].#$\u0000-\u001F\u007F]/;/**
 * Maximum number of characters to allow in leaf value
 */const MAX_LEAF_SIZE_=10*1024*1024;const isValidKey=function(key){return typeof key==='string'&&key.length!==0&&!INVALID_KEY_REGEX_.test(key);};const isValidPathString=function(pathString){return typeof pathString==='string'&&pathString.length!==0&&!INVALID_PATH_REGEX_.test(pathString);};const isValidRootPathString=function(pathString){if(pathString){// Allow '/.info/' at the beginning.
pathString=pathString.replace(/^\/*\.info(\/|$)/,'/');}return isValidPathString(pathString);};const isValidPriority=function(priority){return priority===null||typeof priority==='string'||typeof priority==='number'&&!isInvalidJSONNumber(priority)||priority&&typeof priority==='object'&&// eslint-disable-next-line @typescript-eslint/no-explicit-any
(0,_util.contains)(priority,'.sv');};/**
 * Pre-validate a datum passed as an argument to Firebase function.
 */const validateFirebaseDataArg=function(fnName,value,path,optional){if(optional&&value===undefined){return;}validateFirebaseData((0,_util.errorPrefix)(fnName,'value'),value,path);};/**
 * Validate a data object client-side before sending to server.
 */const validateFirebaseData=function(errorPrefix,data,path_){const path=path_ instanceof Path?new ValidationPath(path_,errorPrefix):path_;if(data===undefined){throw new Error(errorPrefix+'contains undefined '+validationPathToErrorString(path));}if(typeof data==='function'){throw new Error(errorPrefix+'contains a function '+validationPathToErrorString(path)+' with contents = '+data.toString());}if(isInvalidJSONNumber(data)){throw new Error(errorPrefix+'contains '+data.toString()+' '+validationPathToErrorString(path));}// Check max leaf size, but try to avoid the utf8 conversion if we can.
if(typeof data==='string'&&data.length>MAX_LEAF_SIZE_/3&&(0,_util.stringLength)(data)>MAX_LEAF_SIZE_){throw new Error(errorPrefix+'contains a string greater than '+MAX_LEAF_SIZE_+' utf8 bytes '+validationPathToErrorString(path)+" ('"+data.substring(0,50)+"...')");}// TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON
// to save extra walking of large objects.
if(data&&typeof data==='object'){let hasDotValue=false;let hasActualChild=false;each(data,(key,value)=>{if(key==='.value'){hasDotValue=true;}else if(key!=='.priority'&&key!=='.sv'){hasActualChild=true;if(!isValidKey(key)){throw new Error(errorPrefix+' contains an invalid key ('+key+') '+validationPathToErrorString(path)+'.  Keys must be non-empty strings '+'and can\'t contain ".", "#", "$", "/", "[", or "]"');}}validationPathPush(path,key);validateFirebaseData(errorPrefix,value,path);validationPathPop(path);});if(hasDotValue&&hasActualChild){throw new Error(errorPrefix+' contains ".value" child '+validationPathToErrorString(path)+' in addition to actual children.');}}};/**
 * Pre-validate paths passed in the firebase function.
 */const validateFirebaseMergePaths=function(errorPrefix,mergePaths){let i,curPath;for(i=0;i<mergePaths.length;i++){curPath=mergePaths[i];const keys=pathSlice(curPath);for(let j=0;j<keys.length;j++){if(keys[j]==='.priority'&&j===keys.length-1);else if(!isValidKey(keys[j])){throw new Error(errorPrefix+'contains an invalid key ('+keys[j]+') in path '+curPath.toString()+'. Keys must be non-empty strings '+'and can\'t contain ".", "#", "$", "/", "[", or "]"');}}}// Check that update keys are not descendants of each other.
// We rely on the property that sorting guarantees that ancestors come
// right before descendants.
mergePaths.sort(pathCompare);let prevPath=null;for(i=0;i<mergePaths.length;i++){curPath=mergePaths[i];if(prevPath!==null&&pathContains(prevPath,curPath)){throw new Error(errorPrefix+'contains a path '+prevPath.toString()+' that is ancestor of another path '+curPath.toString());}prevPath=curPath;}};/**
 * pre-validate an object passed as an argument to firebase function (
 * must be an object - e.g. for firebase.update()).
 */const validateFirebaseMergeDataArg=function(fnName,data,path,optional){if(optional&&data===undefined){return;}const errorPrefix$1=(0,_util.errorPrefix)(fnName,'values');if(!(data&&typeof data==='object')||Array.isArray(data)){throw new Error(errorPrefix$1+' must be an object containing the children to replace.');}const mergePaths=[];each(data,(key,value)=>{const curPath=new Path(key);validateFirebaseData(errorPrefix$1,value,pathChild(path,curPath));if(pathGetBack(curPath)==='.priority'){if(!isValidPriority(value)){throw new Error(errorPrefix$1+"contains an invalid value for '"+curPath.toString()+"', which must be a valid "+'Firebase priority (a string, finite number, server value, or null).');}}mergePaths.push(curPath);});validateFirebaseMergePaths(errorPrefix$1,mergePaths);};const validatePriority=function(fnName,priority,optional){if(optional&&priority===undefined){return;}if(isInvalidJSONNumber(priority)){throw new Error((0,_util.errorPrefix)(fnName,'priority')+'is '+priority.toString()+', but must be a valid Firebase priority (a string, finite number, '+'server value, or null).');}// Special case to allow importing data with a .sv.
if(!isValidPriority(priority)){throw new Error((0,_util.errorPrefix)(fnName,'priority')+'must be a valid Firebase priority '+'(a string, finite number, server value, or null).');}};const validateKey=function(fnName,argumentName,key,optional){if(optional&&key===undefined){return;}if(!isValidKey(key)){throw new Error((0,_util.errorPrefix)(fnName,argumentName)+'was an invalid key = "'+key+'".  Firebase keys must be non-empty strings and '+'can\'t contain ".", "#", "$", "/", "[", or "]").');}};/**
 * @internal
 */const validatePathString=function(fnName,argumentName,pathString,optional){if(optional&&pathString===undefined){return;}if(!isValidPathString(pathString)){throw new Error((0,_util.errorPrefix)(fnName,argumentName)+'was an invalid path = "'+pathString+'". Paths must be non-empty strings and '+'can\'t contain ".", "#", "$", "[", or "]"');}};exports._validatePathString=validatePathString;const validateRootPathString=function(fnName,argumentName,pathString,optional){if(pathString){// Allow '/.info/' at the beginning.
pathString=pathString.replace(/^\/*\.info(\/|$)/,'/');}validatePathString(fnName,argumentName,pathString,optional);};/**
 * @internal
 */const validateWritablePath=function(fnName,path){if(pathGetFront(path)==='.info'){throw new Error(fnName+" failed = Can't modify data under /.info/");}};exports._validateWritablePath=validateWritablePath;const validateUrl=function(fnName,parsedUrl){// TODO = Validate server better.
const pathString=parsedUrl.path.toString();if(!(typeof parsedUrl.repoInfo.host==='string')||parsedUrl.repoInfo.host.length===0||!isValidKey(parsedUrl.repoInfo.namespace)&&parsedUrl.repoInfo.host.split(':')[0]!=='localhost'||pathString.length!==0&&!isValidRootPathString(pathString)){throw new Error((0,_util.errorPrefix)(fnName,'url')+'must be a valid firebase URL and '+'the path can\'t contain ".", "#", "$", "[", or "]".');}};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * The event queue serves a few purposes:
 * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more
 *    events being queued.
 * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,
 *    raiseQueuedEvents() is called again, the "inner" call will pick up raising events where the "outer" call
 *    left off, ensuring that the events are still raised synchronously and in order.
 * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued
 *    events are raised synchronously.
 *
 * NOTE: This can all go away if/when we move to async events.
 *
 */class EventQueue{constructor(){this.eventLists_=[];/**
         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.
         */this.recursionDepth_=0;}}/**
 * @param eventDataList - The new events to queue.
 */function eventQueueQueueEvents(eventQueue,eventDataList){// We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.
let currList=null;for(let i=0;i<eventDataList.length;i++){const data=eventDataList[i];const path=data.getPath();if(currList!==null&&!pathEquals(path,currList.path)){eventQueue.eventLists_.push(currList);currList=null;}if(currList===null){currList={events:[],path};}currList.events.push(data);}if(currList){eventQueue.eventLists_.push(currList);}}/**
 * Queues the specified events and synchronously raises all events (including previously queued ones)
 * for the specified path.
 *
 * It is assumed that the new events are all for the specified path.
 *
 * @param path - The path to raise events for.
 * @param eventDataList - The new events to raise.
 */function eventQueueRaiseEventsAtPath(eventQueue,path,eventDataList){eventQueueQueueEvents(eventQueue,eventDataList);eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue,eventPath=>pathEquals(eventPath,path));}/**
 * Queues the specified events and synchronously raises all events (including previously queued ones) for
 * locations related to the specified change path (i.e. all ancestors and descendants).
 *
 * It is assumed that the new events are all related (ancestor or descendant) to the specified path.
 *
 * @param changedPath - The path to raise events for.
 * @param eventDataList - The events to raise
 */function eventQueueRaiseEventsForChangedPath(eventQueue,changedPath,eventDataList){eventQueueQueueEvents(eventQueue,eventDataList);eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue,eventPath=>pathContains(eventPath,changedPath)||pathContains(changedPath,eventPath));}function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue,predicate){eventQueue.recursionDepth_++;let sentAll=true;for(let i=0;i<eventQueue.eventLists_.length;i++){const eventList=eventQueue.eventLists_[i];if(eventList){const eventPath=eventList.path;if(predicate(eventPath)){eventListRaise(eventQueue.eventLists_[i]);eventQueue.eventLists_[i]=null;}else{sentAll=false;}}}if(sentAll){eventQueue.eventLists_=[];}eventQueue.recursionDepth_--;}/**
 * Iterates through the list and raises each event
 */function eventListRaise(eventList){for(let i=0;i<eventList.events.length;i++){const eventData=eventList.events[i];if(eventData!==null){eventList.events[i]=null;const eventFn=eventData.getEventRunner();if(logger){log('event: '+eventData.toString());}exceptionGuard(eventFn);}}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const INTERRUPT_REASON='repo_interrupt';/**
 * If a transaction does not succeed after 25 retries, we abort it. Among other
 * things this ensure that if there's ever a bug causing a mismatch between
 * client / server hashes for some data, we won't retry indefinitely.
 */const MAX_TRANSACTION_RETRIES=25;/**
 * A connection to a single data repository.
 */class Repo{constructor(repoInfo_,forceRestClient_,authTokenProvider_,appCheckProvider_){this.repoInfo_=repoInfo_;this.forceRestClient_=forceRestClient_;this.authTokenProvider_=authTokenProvider_;this.appCheckProvider_=appCheckProvider_;this.dataUpdateCount=0;this.statsListener_=null;this.eventQueue_=new EventQueue();this.nextWriteId_=1;this.interceptServerDataCallback_=null;/** A list of data pieces and paths to be set when this client disconnects. */this.onDisconnect_=newSparseSnapshotTree();/** Stores queues of outstanding transactions for Firebase locations. */this.transactionQueueTree_=new Tree();// TODO: This should be @private but it's used by test_access.js and internal.js
this.persistentConnection_=null;// This key is intentionally not updated if RepoInfo is later changed or replaced
this.key=this.repoInfo_.toURLString();}/**
     * @returns The URL corresponding to the root of this Firebase.
     */toString(){return(this.repoInfo_.secure?'https://':'http://')+this.repoInfo_.host;}}function repoStart(repo,appId,authOverride){repo.stats_=statsManagerGetCollection(repo.repoInfo_);if(repo.forceRestClient_||beingCrawled()){repo.server_=new ReadonlyRestClient(repo.repoInfo_,(pathString,data,isMerge,tag)=>{repoOnDataUpdate(repo,pathString,data,isMerge,tag);},repo.authTokenProvider_,repo.appCheckProvider_);// Minor hack: Fire onConnect immediately, since there's no actual connection.
setTimeout(()=>repoOnConnectStatus(repo,/* connectStatus= */true),0);}else{// Validate authOverride
if(typeof authOverride!=='undefined'&&authOverride!==null){if(typeof authOverride!=='object'){throw new Error('Only objects are supported for option databaseAuthVariableOverride');}try{(0,_util.stringify)(authOverride);}catch(e){throw new Error('Invalid authOverride provided: '+e);}}repo.persistentConnection_=new PersistentConnection(repo.repoInfo_,appId,(pathString,data,isMerge,tag)=>{repoOnDataUpdate(repo,pathString,data,isMerge,tag);},connectStatus=>{repoOnConnectStatus(repo,connectStatus);},updates=>{repoOnServerInfoUpdate(repo,updates);},repo.authTokenProvider_,repo.appCheckProvider_,authOverride);repo.server_=repo.persistentConnection_;}repo.authTokenProvider_.addTokenChangeListener(token=>{repo.server_.refreshAuthToken(token);});repo.appCheckProvider_.addTokenChangeListener(result=>{repo.server_.refreshAppCheckToken(result.token);});// In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),
// we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.
repo.statsReporter_=statsManagerGetOrCreateReporter(repo.repoInfo_,()=>new StatsReporter(repo.stats_,repo.server_));// Used for .info.
repo.infoData_=new SnapshotHolder();repo.infoSyncTree_=new SyncTree({startListening:(query,tag,currentHashFn,onComplete)=>{let infoEvents=[];const node=repo.infoData_.getNode(query._path);// This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events
// on initial data...
if(!node.isEmpty()){infoEvents=syncTreeApplyServerOverwrite(repo.infoSyncTree_,query._path,node);setTimeout(()=>{onComplete('ok');},0);}return infoEvents;},stopListening:()=>{}});repoUpdateInfo(repo,'connected',false);repo.serverSyncTree_=new SyncTree({startListening:(query,tag,currentHashFn,onComplete)=>{repo.server_.listen(query,currentHashFn,tag,(status,data)=>{const events=onComplete(status,data);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,query._path,events);});// No synchronous events for network-backed sync trees
return[];},stopListening:(query,tag)=>{repo.server_.unlisten(query,tag);}});}/**
 * @returns The time in milliseconds, taking the server offset into account if we have one.
 */function repoServerTime(repo){const offsetNode=repo.infoData_.getNode(new Path('.info/serverTimeOffset'));const offset=offsetNode.val()||0;return new Date().getTime()+offset;}/**
 * Generate ServerValues using some variables from the repo object.
 */function repoGenerateServerValues(repo){return generateWithValues({timestamp:repoServerTime(repo)});}/**
 * Called by realtime when we get new messages from the server.
 */function repoOnDataUpdate(repo,pathString,data,isMerge,tag){// For testing.
repo.dataUpdateCount++;const path=new Path(pathString);data=repo.interceptServerDataCallback_?repo.interceptServerDataCallback_(pathString,data):data;let events=[];if(tag){if(isMerge){const taggedChildren=(0,_util.map)(data,raw=>nodeFromJSON(raw));events=syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_,path,taggedChildren,tag);}else{const taggedSnap=nodeFromJSON(data);events=syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_,path,taggedSnap,tag);}}else if(isMerge){const changedChildren=(0,_util.map)(data,raw=>nodeFromJSON(raw));events=syncTreeApplyServerMerge(repo.serverSyncTree_,path,changedChildren);}else{const snap=nodeFromJSON(data);events=syncTreeApplyServerOverwrite(repo.serverSyncTree_,path,snap);}let affectedPath=path;if(events.length>0){// Since we have a listener outstanding for each transaction, receiving any events
// is a proxy for some change having occurred.
affectedPath=repoRerunTransactions(repo,path);}eventQueueRaiseEventsForChangedPath(repo.eventQueue_,affectedPath,events);}function repoOnConnectStatus(repo,connectStatus){repoUpdateInfo(repo,'connected',connectStatus);if(connectStatus===false){repoRunOnDisconnectEvents(repo);}}function repoOnServerInfoUpdate(repo,updates){each(updates,(key,value)=>{repoUpdateInfo(repo,key,value);});}function repoUpdateInfo(repo,pathString,value){const path=new Path('/.info/'+pathString);const newNode=nodeFromJSON(value);repo.infoData_.updateSnapshot(path,newNode);const events=syncTreeApplyServerOverwrite(repo.infoSyncTree_,path,newNode);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);}function repoGetNextWriteId(repo){return repo.nextWriteId_++;}/**
 * The purpose of `getValue` is to return the latest known value
 * satisfying `query`.
 *
 * This method will first check for in-memory cached values
 * belonging to active listeners. If they are found, such values
 * are considered to be the most up-to-date.
 *
 * If the client is not connected, this method will wait until the
 *  repo has established a connection and then request the value for `query`.
 * If the client is not able to retrieve the query result for another reason,
 * it reports an error.
 *
 * @param query - The query to surface a value for.
 */function repoGetValue(repo,query,eventRegistration){// Only active queries are cached. There is no persisted cache.
const cached=syncTreeGetServerValue(repo.serverSyncTree_,query);if(cached!=null){return Promise.resolve(cached);}return repo.server_.get(query).then(payload=>{const node=nodeFromJSON(payload).withIndex(query._queryParams.getIndex());/**
         * Below we simulate the actions of an `onlyOnce` `onValue()` event where:
         * Add an event registration,
         * Update data at the path,
         * Raise any events,
         * Cleanup the SyncTree
         */syncTreeAddEventRegistration(repo.serverSyncTree_,query,eventRegistration,true);let events;if(query._queryParams.loadsAllData()){events=syncTreeApplyServerOverwrite(repo.serverSyncTree_,query._path,node);}else{const tag=syncTreeTagForQuery(repo.serverSyncTree_,query);events=syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_,query._path,node,tag);}/*
         * We need to raise events in the scenario where `get()` is called at a parent path, and
         * while the `get()` is pending, `onValue` is called at a child location. While get() is waiting
         * for the data, `onValue` will register a new event. Then, get() will come back, and update the syncTree
         * and its corresponding serverCache, including the child location where `onValue` is called. Then,
         * `onValue` will receive the event from the server, but look at the syncTree and see that the data received
         * from the server is already at the SyncPoint, and so the `onValue` callback will never get fired.
         * Calling `eventQueueRaiseEventsForChangedPath()` is the correct way to propagate the events and
         * ensure the corresponding child events will get fired.
         */eventQueueRaiseEventsForChangedPath(repo.eventQueue_,query._path,events);syncTreeRemoveEventRegistration(repo.serverSyncTree_,query,eventRegistration,null,true);return node;},err=>{repoLog(repo,'get for query '+(0,_util.stringify)(query)+' failed: '+err);return Promise.reject(new Error(err));});}function repoSetWithPriority(repo,path,newVal,newPriority,onComplete){repoLog(repo,'set',{path:path.toString(),value:newVal,priority:newPriority});// TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or
// (b) store unresolved paths on JSON parse
const serverValues=repoGenerateServerValues(repo);const newNodeUnresolved=nodeFromJSON(newVal,newPriority);const existing=syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path);const newNode=resolveDeferredValueSnapshot(newNodeUnresolved,existing,serverValues);const writeId=repoGetNextWriteId(repo);const events=syncTreeApplyUserOverwrite(repo.serverSyncTree_,path,newNode,writeId,true);eventQueueQueueEvents(repo.eventQueue_,events);repo.server_.put(path.toString(),newNodeUnresolved.val(/*export=*/true),(status,errorReason)=>{const success=status==='ok';if(!success){warn('set at '+path+' failed: '+status);}const clearEvents=syncTreeAckUserWrite(repo.serverSyncTree_,writeId,!success);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,clearEvents);repoCallOnCompleteCallback(repo,onComplete,status,errorReason);});const affectedPath=repoAbortTransactions(repo,path);repoRerunTransactions(repo,affectedPath);// We queued the events above, so just flush the queue here
eventQueueRaiseEventsForChangedPath(repo.eventQueue_,affectedPath,[]);}function repoUpdate(repo,path,childrenToMerge,onComplete){repoLog(repo,'update',{path:path.toString(),value:childrenToMerge});// Start with our existing data and merge each child into it.
let empty=true;const serverValues=repoGenerateServerValues(repo);const changedChildren={};each(childrenToMerge,(changedKey,changedValue)=>{empty=false;changedChildren[changedKey]=resolveDeferredValueTree(pathChild(path,changedKey),nodeFromJSON(changedValue),repo.serverSyncTree_,serverValues);});if(!empty){const writeId=repoGetNextWriteId(repo);const events=syncTreeApplyUserMerge(repo.serverSyncTree_,path,changedChildren,writeId);eventQueueQueueEvents(repo.eventQueue_,events);repo.server_.merge(path.toString(),childrenToMerge,(status,errorReason)=>{const success=status==='ok';if(!success){warn('update at '+path+' failed: '+status);}const clearEvents=syncTreeAckUserWrite(repo.serverSyncTree_,writeId,!success);const affectedPath=clearEvents.length>0?repoRerunTransactions(repo,path):path;eventQueueRaiseEventsForChangedPath(repo.eventQueue_,affectedPath,clearEvents);repoCallOnCompleteCallback(repo,onComplete,status,errorReason);});each(childrenToMerge,changedPath=>{const affectedPath=repoAbortTransactions(repo,pathChild(path,changedPath));repoRerunTransactions(repo,affectedPath);});// We queued the events above, so just flush the queue here
eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,[]);}else{log("update() called with empty data.  Don't do anything.");repoCallOnCompleteCallback(repo,onComplete,'ok',undefined);}}/**
 * Applies all of the changes stored up in the onDisconnect_ tree.
 */function repoRunOnDisconnectEvents(repo){repoLog(repo,'onDisconnectEvents');const serverValues=repoGenerateServerValues(repo);const resolvedOnDisconnectTree=newSparseSnapshotTree();sparseSnapshotTreeForEachTree(repo.onDisconnect_,newEmptyPath(),(path,node)=>{const resolved=resolveDeferredValueTree(path,node,repo.serverSyncTree_,serverValues);sparseSnapshotTreeRemember(resolvedOnDisconnectTree,path,resolved);});let events=[];sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree,newEmptyPath(),(path,snap)=>{events=events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_,path,snap));const affectedPath=repoAbortTransactions(repo,path);repoRerunTransactions(repo,affectedPath);});repo.onDisconnect_=newSparseSnapshotTree();eventQueueRaiseEventsForChangedPath(repo.eventQueue_,newEmptyPath(),events);}function repoOnDisconnectCancel(repo,path,onComplete){repo.server_.onDisconnectCancel(path.toString(),(status,errorReason)=>{if(status==='ok'){sparseSnapshotTreeForget(repo.onDisconnect_,path);}repoCallOnCompleteCallback(repo,onComplete,status,errorReason);});}function repoOnDisconnectSet(repo,path,value,onComplete){const newNode=nodeFromJSON(value);repo.server_.onDisconnectPut(path.toString(),newNode.val(/*export=*/true),(status,errorReason)=>{if(status==='ok'){sparseSnapshotTreeRemember(repo.onDisconnect_,path,newNode);}repoCallOnCompleteCallback(repo,onComplete,status,errorReason);});}function repoOnDisconnectSetWithPriority(repo,path,value,priority,onComplete){const newNode=nodeFromJSON(value,priority);repo.server_.onDisconnectPut(path.toString(),newNode.val(/*export=*/true),(status,errorReason)=>{if(status==='ok'){sparseSnapshotTreeRemember(repo.onDisconnect_,path,newNode);}repoCallOnCompleteCallback(repo,onComplete,status,errorReason);});}function repoOnDisconnectUpdate(repo,path,childrenToMerge,onComplete){if((0,_util.isEmpty)(childrenToMerge)){log("onDisconnect().update() called with empty data.  Don't do anything.");repoCallOnCompleteCallback(repo,onComplete,'ok',undefined);return;}repo.server_.onDisconnectMerge(path.toString(),childrenToMerge,(status,errorReason)=>{if(status==='ok'){each(childrenToMerge,(childName,childNode)=>{const newChildNode=nodeFromJSON(childNode);sparseSnapshotTreeRemember(repo.onDisconnect_,pathChild(path,childName),newChildNode);});}repoCallOnCompleteCallback(repo,onComplete,status,errorReason);});}function repoAddEventCallbackForQuery(repo,query,eventRegistration){let events;if(pathGetFront(query._path)==='.info'){events=syncTreeAddEventRegistration(repo.infoSyncTree_,query,eventRegistration);}else{events=syncTreeAddEventRegistration(repo.serverSyncTree_,query,eventRegistration);}eventQueueRaiseEventsAtPath(repo.eventQueue_,query._path,events);}function repoRemoveEventCallbackForQuery(repo,query,eventRegistration){// These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof
// a little bit by handling the return values anyways.
let events;if(pathGetFront(query._path)==='.info'){events=syncTreeRemoveEventRegistration(repo.infoSyncTree_,query,eventRegistration);}else{events=syncTreeRemoveEventRegistration(repo.serverSyncTree_,query,eventRegistration);}eventQueueRaiseEventsAtPath(repo.eventQueue_,query._path,events);}function repoInterrupt(repo){if(repo.persistentConnection_){repo.persistentConnection_.interrupt(INTERRUPT_REASON);}}function repoResume(repo){if(repo.persistentConnection_){repo.persistentConnection_.resume(INTERRUPT_REASON);}}function repoLog(repo,...varArgs){let prefix='';if(repo.persistentConnection_){prefix=repo.persistentConnection_.id+':';}log(prefix,...varArgs);}function repoCallOnCompleteCallback(repo,callback,status,errorReason){if(callback){exceptionGuard(()=>{if(status==='ok'){callback(null);}else{const code=(status||'error').toUpperCase();let message=code;if(errorReason){message+=': '+errorReason;}const error=new Error(message);// eslint-disable-next-line @typescript-eslint/no-explicit-any
error.code=code;callback(error);}});}}/**
 * Creates a new transaction, adds it to the transactions we're tracking, and
 * sends it to the server if possible.
 *
 * @param path - Path at which to do transaction.
 * @param transactionUpdate - Update callback.
 * @param onComplete - Completion callback.
 * @param unwatcher - Function that will be called when the transaction no longer
 * need data updates for `path`.
 * @param applyLocally - Whether or not to make intermediate results visible
 */function repoStartTransaction(repo,path,transactionUpdate,onComplete,unwatcher,applyLocally){repoLog(repo,'transaction on '+path);// Initialize transaction.
const transaction={path,update:transactionUpdate,onComplete,// One of TransactionStatus enums.
status:null,// Used when combining transactions at different locations to figure out
// which one goes first.
order:LUIDGenerator(),// Whether to raise local events for this transaction.
applyLocally,// Count of how many times we've retried the transaction.
retryCount:0,// Function to call to clean up our .on() listener.
unwatcher,// Stores why a transaction was aborted.
abortReason:null,currentWriteId:null,currentInputSnapshot:null,currentOutputSnapshotRaw:null,currentOutputSnapshotResolved:null};// Run transaction initially.
const currentState=repoGetLatestState(repo,path,undefined);transaction.currentInputSnapshot=currentState;const newVal=transaction.update(currentState.val());if(newVal===undefined){// Abort transaction.
transaction.unwatcher();transaction.currentOutputSnapshotRaw=null;transaction.currentOutputSnapshotResolved=null;if(transaction.onComplete){transaction.onComplete(null,false,transaction.currentInputSnapshot);}}else{validateFirebaseData('transaction failed: Data returned ',newVal,transaction.path);// Mark as run and add to our queue.
transaction.status=0/* RUN */;const queueNode=treeSubTree(repo.transactionQueueTree_,path);const nodeQueue=treeGetValue(queueNode)||[];nodeQueue.push(transaction);treeSetValue(queueNode,nodeQueue);// Update visibleData and raise events
// Note: We intentionally raise events after updating all of our
// transaction state, since the user could start new transactions from the
// event callbacks.
let priorityForNode;if(typeof newVal==='object'&&newVal!==null&&(0,_util.contains)(newVal,'.priority')){// eslint-disable-next-line @typescript-eslint/no-explicit-any
priorityForNode=(0,_util.safeGet)(newVal,'.priority');(0,_util.assert)(isValidPriority(priorityForNode),'Invalid priority returned by transaction. '+'Priority must be a valid string, finite number, server value, or null.');}else{const currentNode=syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path)||ChildrenNode.EMPTY_NODE;priorityForNode=currentNode.getPriority().val();}const serverValues=repoGenerateServerValues(repo);const newNodeUnresolved=nodeFromJSON(newVal,priorityForNode);const newNode=resolveDeferredValueSnapshot(newNodeUnresolved,currentState,serverValues);transaction.currentOutputSnapshotRaw=newNodeUnresolved;transaction.currentOutputSnapshotResolved=newNode;transaction.currentWriteId=repoGetNextWriteId(repo);const events=syncTreeApplyUserOverwrite(repo.serverSyncTree_,path,newNode,transaction.currentWriteId,transaction.applyLocally);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);repoSendReadyTransactions(repo,repo.transactionQueueTree_);}}/**
 * @param excludeSets - A specific set to exclude
 */function repoGetLatestState(repo,path,excludeSets){return syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path,excludeSets)||ChildrenNode.EMPTY_NODE;}/**
 * Sends any already-run transactions that aren't waiting for outstanding
 * transactions to complete.
 *
 * Externally it's called with no arguments, but it calls itself recursively
 * with a particular transactionQueueTree node to recurse through the tree.
 *
 * @param node - transactionQueueTree node to start at.
 */function repoSendReadyTransactions(repo,node=repo.transactionQueueTree_){// Before recursing, make sure any completed transactions are removed.
if(!node){repoPruneCompletedTransactionsBelowNode(repo,node);}if(treeGetValue(node)){const queue=repoBuildTransactionQueue(repo,node);(0,_util.assert)(queue.length>0,'Sending zero length transaction queue');const allRun=queue.every(transaction=>transaction.status===0/* RUN */);// If they're all run (and not sent), we can send them.  Else, we must wait.
if(allRun){repoSendTransactionQueue(repo,treeGetPath(node),queue);}}else if(treeHasChildren(node)){treeForEachChild(node,childNode=>{repoSendReadyTransactions(repo,childNode);});}}/**
 * Given a list of run transactions, send them to the server and then handle
 * the result (success or failure).
 *
 * @param path - The location of the queue.
 * @param queue - Queue of transactions under the specified location.
 */function repoSendTransactionQueue(repo,path,queue){// Mark transactions as sent and increment retry count!
const setsToIgnore=queue.map(txn=>{return txn.currentWriteId;});const latestState=repoGetLatestState(repo,path,setsToIgnore);let snapToSend=latestState;const latestHash=latestState.hash();for(let i=0;i<queue.length;i++){const txn=queue[i];(0,_util.assert)(txn.status===0/* RUN */,'tryToSendTransactionQueue_: items in queue should all be run.');txn.status=1/* SENT */;txn.retryCount++;const relativePath=newRelativePath(path,txn.path);// If we've gotten to this point, the output snapshot must be defined.
snapToSend=snapToSend.updateChild(relativePath/** @type {!Node} */,txn.currentOutputSnapshotRaw);}const dataToSend=snapToSend.val(true);const pathToSend=path;// Send the put.
repo.server_.put(pathToSend.toString(),dataToSend,status=>{repoLog(repo,'transaction put response',{path:pathToSend.toString(),status});let events=[];if(status==='ok'){// Queue up the callbacks and fire them after cleaning up all of our
// transaction state, since the callback could trigger more
// transactions or sets.
const callbacks=[];for(let i=0;i<queue.length;i++){queue[i].status=2/* COMPLETED */;events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,queue[i].currentWriteId));if(queue[i].onComplete){// We never unset the output snapshot, and given that this
// transaction is complete, it should be set
callbacks.push(()=>queue[i].onComplete(null,true,queue[i].currentOutputSnapshotResolved));}queue[i].unwatcher();}// Now remove the completed transactions.
repoPruneCompletedTransactionsBelowNode(repo,treeSubTree(repo.transactionQueueTree_,path));// There may be pending transactions that we can now send.
repoSendReadyTransactions(repo,repo.transactionQueueTree_);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);// Finally, trigger onComplete callbacks.
for(let i=0;i<callbacks.length;i++){exceptionGuard(callbacks[i]);}}else{// transactions are no longer sent.  Update their status appropriately.
if(status==='datastale'){for(let i=0;i<queue.length;i++){if(queue[i].status===3/* SENT_NEEDS_ABORT */){queue[i].status=4/* NEEDS_ABORT */;}else{queue[i].status=0/* RUN */;}}}else{warn('transaction at '+pathToSend.toString()+' failed: '+status);for(let i=0;i<queue.length;i++){queue[i].status=4/* NEEDS_ABORT */;queue[i].abortReason=status;}}repoRerunTransactions(repo,path);}},latestHash);}/**
 * Finds all transactions dependent on the data at changedPath and reruns them.
 *
 * Should be called any time cached data changes.
 *
 * Return the highest path that was affected by rerunning transactions. This
 * is the path at which events need to be raised for.
 *
 * @param changedPath - The path in mergedData that changed.
 * @returns The rootmost path that was affected by rerunning transactions.
 */function repoRerunTransactions(repo,changedPath){const rootMostTransactionNode=repoGetAncestorTransactionNode(repo,changedPath);const path=treeGetPath(rootMostTransactionNode);const queue=repoBuildTransactionQueue(repo,rootMostTransactionNode);repoRerunTransactionQueue(repo,queue,path);return path;}/**
 * Does all the work of rerunning transactions (as well as cleans up aborted
 * transactions and whatnot).
 *
 * @param queue - The queue of transactions to run.
 * @param path - The path the queue is for.
 */function repoRerunTransactionQueue(repo,queue,path){if(queue.length===0){return;// Nothing to do!
}// Queue up the callbacks and fire them after cleaning up all of our
// transaction state, since the callback could trigger more transactions or
// sets.
const callbacks=[];let events=[];// Ignore all of the sets we're going to re-run.
const txnsToRerun=queue.filter(q=>{return q.status===0/* RUN */;});const setsToIgnore=txnsToRerun.map(q=>{return q.currentWriteId;});for(let i=0;i<queue.length;i++){const transaction=queue[i];const relativePath=newRelativePath(path,transaction.path);let abortTransaction=false,abortReason;(0,_util.assert)(relativePath!==null,'rerunTransactionsUnderNode_: relativePath should not be null.');if(transaction.status===4/* NEEDS_ABORT */){abortTransaction=true;abortReason=transaction.abortReason;events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,transaction.currentWriteId,true));}else if(transaction.status===0/* RUN */){if(transaction.retryCount>=MAX_TRANSACTION_RETRIES){abortTransaction=true;abortReason='maxretry';events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,transaction.currentWriteId,true));}else{// This code reruns a transaction
const currentNode=repoGetLatestState(repo,transaction.path,setsToIgnore);transaction.currentInputSnapshot=currentNode;const newData=queue[i].update(currentNode.val());if(newData!==undefined){validateFirebaseData('transaction failed: Data returned ',newData,transaction.path);let newDataNode=nodeFromJSON(newData);const hasExplicitPriority=typeof newData==='object'&&newData!=null&&(0,_util.contains)(newData,'.priority');if(!hasExplicitPriority){// Keep the old priority if there wasn't a priority explicitly specified.
newDataNode=newDataNode.updatePriority(currentNode.getPriority());}const oldWriteId=transaction.currentWriteId;const serverValues=repoGenerateServerValues(repo);const newNodeResolved=resolveDeferredValueSnapshot(newDataNode,currentNode,serverValues);transaction.currentOutputSnapshotRaw=newDataNode;transaction.currentOutputSnapshotResolved=newNodeResolved;transaction.currentWriteId=repoGetNextWriteId(repo);// Mutates setsToIgnore in place
setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId),1);events=events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_,transaction.path,newNodeResolved,transaction.currentWriteId,transaction.applyLocally));events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,oldWriteId,true));}else{abortTransaction=true;abortReason='nodata';events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,transaction.currentWriteId,true));}}}eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);events=[];if(abortTransaction){// Abort.
queue[i].status=2/* COMPLETED */;// Removing a listener can trigger pruning which can muck with
// mergedData/visibleData (as it prunes data). So defer the unwatcher
// until we're done.
(function(unwatcher){setTimeout(unwatcher,Math.floor(0));})(queue[i].unwatcher);if(queue[i].onComplete){if(abortReason==='nodata'){callbacks.push(()=>queue[i].onComplete(null,false,queue[i].currentInputSnapshot));}else{callbacks.push(()=>queue[i].onComplete(new Error(abortReason),false,null));}}}}// Clean up completed transactions.
repoPruneCompletedTransactionsBelowNode(repo,repo.transactionQueueTree_);// Now fire callbacks, now that we're in a good, known state.
for(let i=0;i<callbacks.length;i++){exceptionGuard(callbacks[i]);}// Try to send the transaction result to the server.
repoSendReadyTransactions(repo,repo.transactionQueueTree_);}/**
 * Returns the rootmost ancestor node of the specified path that has a pending
 * transaction on it, or just returns the node for the given path if there are
 * no pending transactions on any ancestor.
 *
 * @param path - The location to start at.
 * @returns The rootmost node with a transaction.
 */function repoGetAncestorTransactionNode(repo,path){let front;// Start at the root and walk deeper into the tree towards path until we
// find a node with pending transactions.
let transactionNode=repo.transactionQueueTree_;front=pathGetFront(path);while(front!==null&&treeGetValue(transactionNode)===undefined){transactionNode=treeSubTree(transactionNode,front);path=pathPopFront(path);front=pathGetFront(path);}return transactionNode;}/**
 * Builds the queue of all transactions at or below the specified
 * transactionNode.
 *
 * @param transactionNode
 * @returns The generated queue.
 */function repoBuildTransactionQueue(repo,transactionNode){// Walk any child transaction queues and aggregate them into a single queue.
const transactionQueue=[];repoAggregateTransactionQueuesForNode(repo,transactionNode,transactionQueue);// Sort them by the order the transactions were created.
transactionQueue.sort((a,b)=>a.order-b.order);return transactionQueue;}function repoAggregateTransactionQueuesForNode(repo,node,queue){const nodeQueue=treeGetValue(node);if(nodeQueue){for(let i=0;i<nodeQueue.length;i++){queue.push(nodeQueue[i]);}}treeForEachChild(node,child=>{repoAggregateTransactionQueuesForNode(repo,child,queue);});}/**
 * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.
 */function repoPruneCompletedTransactionsBelowNode(repo,node){const queue=treeGetValue(node);if(queue){let to=0;for(let from=0;from<queue.length;from++){if(queue[from].status!==2/* COMPLETED */){queue[to]=queue[from];to++;}}queue.length=to;treeSetValue(node,queue.length>0?queue:undefined);}treeForEachChild(node,childNode=>{repoPruneCompletedTransactionsBelowNode(repo,childNode);});}/**
 * Aborts all transactions on ancestors or descendants of the specified path.
 * Called when doing a set() or update() since we consider them incompatible
 * with transactions.
 *
 * @param path - Path for which we want to abort related transactions.
 */function repoAbortTransactions(repo,path){const affectedPath=treeGetPath(repoGetAncestorTransactionNode(repo,path));const transactionNode=treeSubTree(repo.transactionQueueTree_,path);treeForEachAncestor(transactionNode,node=>{repoAbortTransactionsOnNode(repo,node);});repoAbortTransactionsOnNode(repo,transactionNode);treeForEachDescendant(transactionNode,node=>{repoAbortTransactionsOnNode(repo,node);});return affectedPath;}/**
 * Abort transactions stored in this transaction queue node.
 *
 * @param node - Node to abort transactions for.
 */function repoAbortTransactionsOnNode(repo,node){const queue=treeGetValue(node);if(queue){// Queue up the callbacks and fire them after cleaning up all of our
// transaction state, since the callback could trigger more transactions
// or sets.
const callbacks=[];// Go through queue.  Any already-sent transactions must be marked for
// abort, while the unsent ones can be immediately aborted and removed.
let events=[];let lastSent=-1;for(let i=0;i<queue.length;i++){if(queue[i].status===3/* SENT_NEEDS_ABORT */);else if(queue[i].status===1/* SENT */){(0,_util.assert)(lastSent===i-1,'All SENT items should be at beginning of queue.');lastSent=i;// Mark transaction for abort when it comes back.
queue[i].status=3/* SENT_NEEDS_ABORT */;queue[i].abortReason='set';}else{(0,_util.assert)(queue[i].status===0/* RUN */,'Unexpected transaction status in abort');// We can abort it immediately.
queue[i].unwatcher();events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,queue[i].currentWriteId,true));if(queue[i].onComplete){callbacks.push(queue[i].onComplete.bind(null,new Error('set'),false,null));}}}if(lastSent===-1){// We're not waiting for any sent transactions.  We can clear the queue.
treeSetValue(node,undefined);}else{// Remove the transactions we aborted.
queue.length=lastSent+1;}// Now fire the callbacks.
eventQueueRaiseEventsForChangedPath(repo.eventQueue_,treeGetPath(node),events);for(let i=0;i<callbacks.length;i++){exceptionGuard(callbacks[i]);}}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function decodePath(pathString){let pathStringDecoded='';const pieces=pathString.split('/');for(let i=0;i<pieces.length;i++){if(pieces[i].length>0){let piece=pieces[i];try{piece=decodeURIComponent(piece.replace(/\+/g,' '));}catch(e){}pathStringDecoded+='/'+piece;}}return pathStringDecoded;}/**
 * @returns key value hash
 */function decodeQuery(queryString){const results={};if(queryString.charAt(0)==='?'){queryString=queryString.substring(1);}for(const segment of queryString.split('&')){if(segment.length===0){continue;}const kv=segment.split('=');if(kv.length===2){results[decodeURIComponent(kv[0])]=decodeURIComponent(kv[1]);}else{warn(`Invalid query segment '${segment}' in query '${queryString}'`);}}return results;}const parseRepoInfo=function(dataURL,nodeAdmin){const parsedUrl=parseDatabaseURL(dataURL),namespace=parsedUrl.namespace;if(parsedUrl.domain==='firebase.com'){fatal(parsedUrl.host+' is no longer supported. '+'Please use <YOUR FIREBASE>.firebaseio.com instead');}// Catch common error of uninitialized namespace value.
if((!namespace||namespace==='undefined')&&parsedUrl.domain!=='localhost'){fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');}if(!parsedUrl.secure){warnIfPageIsSecure();}const webSocketOnly=parsedUrl.scheme==='ws'||parsedUrl.scheme==='wss';return{repoInfo:new RepoInfo(parsedUrl.host,parsedUrl.secure,namespace,webSocketOnly,nodeAdmin,/*persistenceKey=*/'',/*includeNamespaceInQueryParams=*/namespace!==parsedUrl.subdomain),path:new Path(parsedUrl.pathString)};};const parseDatabaseURL=function(dataURL){// Default to empty strings in the event of a malformed string.
let host='',domain='',subdomain='',pathString='',namespace='';// Always default to SSL, unless otherwise specified.
let secure=true,scheme='https',port=443;// Don't do any validation here. The caller is responsible for validating the result of parsing.
if(typeof dataURL==='string'){// Parse scheme.
let colonInd=dataURL.indexOf('//');if(colonInd>=0){scheme=dataURL.substring(0,colonInd-1);dataURL=dataURL.substring(colonInd+2);}// Parse host, path, and query string.
let slashInd=dataURL.indexOf('/');if(slashInd===-1){slashInd=dataURL.length;}let questionMarkInd=dataURL.indexOf('?');if(questionMarkInd===-1){questionMarkInd=dataURL.length;}host=dataURL.substring(0,Math.min(slashInd,questionMarkInd));if(slashInd<questionMarkInd){// For pathString, questionMarkInd will always come after slashInd
pathString=decodePath(dataURL.substring(slashInd,questionMarkInd));}const queryParams=decodeQuery(dataURL.substring(Math.min(dataURL.length,questionMarkInd)));// If we have a port, use scheme for determining if it's secure.
colonInd=host.indexOf(':');if(colonInd>=0){secure=scheme==='https'||scheme==='wss';port=parseInt(host.substring(colonInd+1),10);}else{colonInd=host.length;}const hostWithoutPort=host.slice(0,colonInd);if(hostWithoutPort.toLowerCase()==='localhost'){domain='localhost';}else if(hostWithoutPort.split('.').length<=2){domain=hostWithoutPort;}else{// Interpret the subdomain of a 3 or more component URL as the namespace name.
const dotInd=host.indexOf('.');subdomain=host.substring(0,dotInd).toLowerCase();domain=host.substring(dotInd+1);// Normalize namespaces to lowercase to share storage / connection.
namespace=subdomain;}// Always treat the value of the `ns` as the namespace name if it is present.
if('ns'in queryParams){namespace=queryParams['ns'];}}return{host,port,domain,subdomain,secure,scheme,pathString,namespace};};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Encapsulates the data needed to raise an event
 */class DataEvent{/**
     * @param eventType - One of: value, child_added, child_changed, child_moved, child_removed
     * @param eventRegistration - The function to call to with the event data. User provided
     * @param snapshot - The data backing the event
     * @param prevName - Optional, the name of the previous child for child_* events.
     */constructor(eventType,eventRegistration,snapshot,prevName){this.eventType=eventType;this.eventRegistration=eventRegistration;this.snapshot=snapshot;this.prevName=prevName;}getPath(){const ref=this.snapshot.ref;if(this.eventType==='value'){return ref._path;}else{return ref.parent._path;}}getEventType(){return this.eventType;}getEventRunner(){return this.eventRegistration.getEventRunner(this);}toString(){return this.getPath().toString()+':'+this.eventType+':'+(0,_util.stringify)(this.snapshot.exportVal());}}class CancelEvent{constructor(eventRegistration,error,path){this.eventRegistration=eventRegistration;this.error=error;this.path=path;}getPath(){return this.path;}getEventType(){return'cancel';}getEventRunner(){return this.eventRegistration.getEventRunner(this);}toString(){return this.path.toString()+':cancel';}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A wrapper class that converts events from the database@exp SDK to the legacy
 * Database SDK. Events are not converted directly as event registration relies
 * on reference comparison of the original user callback (see `matches()`) and
 * relies on equality of the legacy SDK's `context` object.
 */class CallbackContext{constructor(snapshotCallback,cancelCallback){this.snapshotCallback=snapshotCallback;this.cancelCallback=cancelCallback;}onValue(expDataSnapshot,previousChildName){this.snapshotCallback.call(null,expDataSnapshot,previousChildName);}onCancel(error){(0,_util.assert)(this.hasCancelCallback,'Raising a cancel event on a listener with no cancel callback');return this.cancelCallback.call(null,error);}get hasCancelCallback(){return!!this.cancelCallback;}matches(other){return this.snapshotCallback===other.snapshotCallback||this.snapshotCallback.userCallback!==undefined&&this.snapshotCallback.userCallback===other.snapshotCallback.userCallback&&this.snapshotCallback.context===other.snapshotCallback.context;}}/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * The `onDisconnect` class allows you to write or clear data when your client
 * disconnects from the Database server. These updates occur whether your
 * client disconnects cleanly or not, so you can rely on them to clean up data
 * even if a connection is dropped or a client crashes.
 *
 * The `onDisconnect` class is most commonly used to manage presence in
 * applications where it is useful to detect how many clients are connected and
 * when other clients disconnect. See
 * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
 * for more information.
 *
 * To avoid problems when a connection is dropped before the requests can be
 * transferred to the Database server, these functions should be called before
 * writing any data.
 *
 * Note that `onDisconnect` operations are only triggered once. If you want an
 * operation to occur each time a disconnect occurs, you'll need to re-establish
 * the `onDisconnect` operations each time you reconnect.
 */class OnDisconnect{/** @hideconstructor */constructor(_repo,_path){this._repo=_repo;this._path=_path;}/**
     * Cancels all previously queued `onDisconnect()` set or update events for this
     * location and all children.
     *
     * If a write has been queued for this location via a `set()` or `update()` at a
     * parent location, the write at this location will be canceled, though writes
     * to sibling locations will still occur.
     *
     * @returns Resolves when synchronization to the server is complete.
     */cancel(){const deferred=new _util.Deferred();repoOnDisconnectCancel(this._repo,this._path,deferred.wrapCallback(()=>{}));return deferred.promise;}/**
     * Ensures the data at this location is deleted when the client is disconnected
     * (due to closing the browser, navigating to a new page, or network issues).
     *
     * @returns Resolves when synchronization to the server is complete.
     */remove(){validateWritablePath('OnDisconnect.remove',this._path);const deferred=new _util.Deferred();repoOnDisconnectSet(this._repo,this._path,null,deferred.wrapCallback(()=>{}));return deferred.promise;}/**
     * Ensures the data at this location is set to the specified value when the
     * client is disconnected (due to closing the browser, navigating to a new page,
     * or network issues).
     *
     * `set()` is especially useful for implementing "presence" systems, where a
     * value should be changed or cleared when a user disconnects so that they
     * appear "offline" to other users. See
     * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
     * for more information.
     *
     * Note that `onDisconnect` operations are only triggered once. If you want an
     * operation to occur each time a disconnect occurs, you'll need to re-establish
     * the `onDisconnect` operations each time.
     *
     * @param value - The value to be written to this location on disconnect (can
     * be an object, array, string, number, boolean, or null).
     * @returns Resolves when synchronization to the Database is complete.
     */set(value){validateWritablePath('OnDisconnect.set',this._path);validateFirebaseDataArg('OnDisconnect.set',value,this._path,false);const deferred=new _util.Deferred();repoOnDisconnectSet(this._repo,this._path,value,deferred.wrapCallback(()=>{}));return deferred.promise;}/**
     * Ensures the data at this location is set to the specified value and priority
     * when the client is disconnected (due to closing the browser, navigating to a
     * new page, or network issues).
     *
     * @param value - The value to be written to this location on disconnect (can
     * be an object, array, string, number, boolean, or null).
     * @param priority - The priority to be written (string, number, or null).
     * @returns Resolves when synchronization to the Database is complete.
     */setWithPriority(value,priority){validateWritablePath('OnDisconnect.setWithPriority',this._path);validateFirebaseDataArg('OnDisconnect.setWithPriority',value,this._path,false);validatePriority('OnDisconnect.setWithPriority',priority,false);const deferred=new _util.Deferred();repoOnDisconnectSetWithPriority(this._repo,this._path,value,priority,deferred.wrapCallback(()=>{}));return deferred.promise;}/**
     * Writes multiple values at this location when the client is disconnected (due
     * to closing the browser, navigating to a new page, or network issues).
     *
     * The `values` argument contains multiple property-value pairs that will be
     * written to the Database together. Each child property can either be a simple
     * property (for example, "name") or a relative path (for example, "name/first")
     * from the current location to the data to update.
     *
     * As opposed to the `set()` method, `update()` can be use to selectively update
     * only the referenced properties at the current location (instead of replacing
     * all the child properties at the current location).
     *
     * @param values - Object containing multiple values.
     * @returns Resolves when synchronization to the Database is complete.
     */update(values){validateWritablePath('OnDisconnect.update',this._path);validateFirebaseMergeDataArg('OnDisconnect.update',values,this._path,false);const deferred=new _util.Deferred();repoOnDisconnectUpdate(this._repo,this._path,values,deferred.wrapCallback(()=>{}));return deferred.promise;}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @internal
 */exports.OnDisconnect=OnDisconnect;class QueryImpl{/**
     * @hideconstructor
     */constructor(_repo,_path,_queryParams,_orderByCalled){this._repo=_repo;this._path=_path;this._queryParams=_queryParams;this._orderByCalled=_orderByCalled;}get key(){if(pathIsEmpty(this._path)){return null;}else{return pathGetBack(this._path);}}get ref(){return new ReferenceImpl(this._repo,this._path);}get _queryIdentifier(){const obj=queryParamsGetQueryObject(this._queryParams);const id=ObjectToUniqueKey(obj);return id==='{}'?'default':id;}/**
     * An object representation of the query parameters used by this Query.
     */get _queryObject(){return queryParamsGetQueryObject(this._queryParams);}isEqual(other){other=(0,_util.getModularInstance)(other);if(!(other instanceof QueryImpl)){return false;}const sameRepo=this._repo===other._repo;const samePath=pathEquals(this._path,other._path);const sameQueryIdentifier=this._queryIdentifier===other._queryIdentifier;return sameRepo&&samePath&&sameQueryIdentifier;}toJSON(){return this.toString();}toString(){return this._repo.toString()+pathToUrlEncodedString(this._path);}}/**
 * Validates that no other order by call has been made
 */exports._QueryImpl=QueryImpl;function validateNoPreviousOrderByCall(query,fnName){if(query._orderByCalled===true){throw new Error(fnName+": You can't combine multiple orderBy calls.");}}/**
 * Validates start/end values for queries.
 */function validateQueryEndpoints(params){let startNode=null;let endNode=null;if(params.hasStart()){startNode=params.getIndexStartValue();}if(params.hasEnd()){endNode=params.getIndexEndValue();}if(params.getIndex()===KEY_INDEX){const tooManyArgsError='Query: When ordering by key, you may only pass one argument to '+'startAt(), endAt(), or equalTo().';const wrongArgTypeError='Query: When ordering by key, the argument passed to startAt(), startAfter(), '+'endAt(), endBefore(), or equalTo() must be a string.';if(params.hasStart()){const startName=params.getIndexStartName();if(startName!==MIN_NAME){throw new Error(tooManyArgsError);}else if(typeof startNode!=='string'){throw new Error(wrongArgTypeError);}}if(params.hasEnd()){const endName=params.getIndexEndName();if(endName!==MAX_NAME){throw new Error(tooManyArgsError);}else if(typeof endNode!=='string'){throw new Error(wrongArgTypeError);}}}else if(params.getIndex()===PRIORITY_INDEX){if(startNode!=null&&!isValidPriority(startNode)||endNode!=null&&!isValidPriority(endNode)){throw new Error('Query: When ordering by priority, the first argument passed to startAt(), '+'startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value '+'(null, a number, or a string).');}}else{(0,_util.assert)(params.getIndex()instanceof PathIndex||params.getIndex()===VALUE_INDEX,'unknown index type.');if(startNode!=null&&typeof startNode==='object'||endNode!=null&&typeof endNode==='object'){throw new Error('Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or '+'equalTo() cannot be an object.');}}}/**
 * Validates that limit* has been called with the correct combination of parameters
 */function validateLimit(params){if(params.hasStart()&&params.hasEnd()&&params.hasLimit()&&!params.hasAnchoredLimit()){throw new Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use "+'limitToFirst() or limitToLast() instead.');}}/**
 * @internal
 */class ReferenceImpl extends QueryImpl{/** @hideconstructor */constructor(repo,path){super(repo,path,new QueryParams(),false);}get parent(){const parentPath=pathParent(this._path);return parentPath===null?null:new ReferenceImpl(this._repo,parentPath);}get root(){let ref=this;while(ref.parent!==null){ref=ref.parent;}return ref;}}/**
 * A `DataSnapshot` contains data from a Database location.
 *
 * Any time you read data from the Database, you receive the data as a
 * `DataSnapshot`. A `DataSnapshot` is passed to the event callbacks you attach
 * with `on()` or `once()`. You can extract the contents of the snapshot as a
 * JavaScript object by calling the `val()` method. Alternatively, you can
 * traverse into the snapshot by calling `child()` to return child snapshots
 * (which you could then call `val()` on).
 *
 * A `DataSnapshot` is an efficiently generated, immutable copy of the data at
 * a Database location. It cannot be modified and will never change (to modify
 * data, you always call the `set()` method on a `Reference` directly).
 */exports._ReferenceImpl=ReferenceImpl;class DataSnapshot{/**
     * @param _node - A SnapshotNode to wrap.
     * @param ref - The location this snapshot came from.
     * @param _index - The iteration order for this snapshot
     * @hideconstructor
     */constructor(_node,/**
     * The location of this DataSnapshot.
     */ref,_index){this._node=_node;this.ref=ref;this._index=_index;}/**
     * Gets the priority value of the data in this `DataSnapshot`.
     *
     * Applications need not use priority but can order collections by
     * ordinary properties (see
     * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}
     * ).
     */get priority(){// typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)
return this._node.getPriority().val();}/**
     * The key (last part of the path) of the location of this `DataSnapshot`.
     *
     * The last token in a Database location is considered its key. For example,
     * "ada" is the key for the /users/ada/ node. Accessing the key on any
     * `DataSnapshot` will return the key for the location that generated it.
     * However, accessing the key on the root URL of a Database will return
     * `null`.
     */get key(){return this.ref.key;}/** Returns the number of child properties of this `DataSnapshot`. */get size(){return this._node.numChildren();}/**
     * Gets another `DataSnapshot` for the location at the specified relative path.
     *
     * Passing a relative path to the `child()` method of a DataSnapshot returns
     * another `DataSnapshot` for the location at the specified relative path. The
     * relative path can either be a simple child name (for example, "ada") or a
     * deeper, slash-separated path (for example, "ada/name/first"). If the child
     * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`
     * whose value is `null`) is returned.
     *
     * @param path - A relative path to the location of child data.
     */child(path){const childPath=new Path(path);const childRef=child(this.ref,path);return new DataSnapshot(this._node.getChild(childPath),childRef,PRIORITY_INDEX);}/**
     * Returns true if this `DataSnapshot` contains any data. It is slightly more
     * efficient than using `snapshot.val() !== null`.
     */exists(){return!this._node.isEmpty();}/**
     * Exports the entire contents of the DataSnapshot as a JavaScript object.
     *
     * The `exportVal()` method is similar to `val()`, except priority information
     * is included (if available), making it suitable for backing up your data.
     *
     * @returns The DataSnapshot's contents as a JavaScript value (Object,
     *   Array, string, number, boolean, or `null`).
     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
exportVal(){return this._node.val(true);}/**
     * Enumerates the top-level children in the `DataSnapshot`.
     *
     * Because of the way JavaScript objects work, the ordering of data in the
     * JavaScript object returned by `val()` is not guaranteed to match the
     * ordering on the server nor the ordering of `onChildAdded()` events. That is
     * where `forEach()` comes in handy. It guarantees the children of a
     * `DataSnapshot` will be iterated in their query order.
     *
     * If no explicit `orderBy*()` method is used, results are returned
     * ordered by key (unless priorities are used, in which case, results are
     * returned by priority).
     *
     * @param action - A function that will be called for each child DataSnapshot.
     * The callback can return true to cancel further enumeration.
     * @returns true if enumeration was canceled due to your callback returning
     * true.
     */forEach(action){if(this._node.isLeafNode()){return false;}const childrenNode=this._node;// Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...
return!!childrenNode.forEachChild(this._index,(key,node)=>{return action(new DataSnapshot(node,child(this.ref,key),PRIORITY_INDEX));});}/**
     * Returns true if the specified child path has (non-null) data.
     *
     * @param path - A relative path to the location of a potential child.
     * @returns `true` if data exists at the specified child path; else
     *  `false`.
     */hasChild(path){const childPath=new Path(path);return!this._node.getChild(childPath).isEmpty();}/**
     * Returns whether or not the `DataSnapshot` has any non-`null` child
     * properties.
     *
     * You can use `hasChildren()` to determine if a `DataSnapshot` has any
     * children. If it does, you can enumerate them using `forEach()`. If it
     * doesn't, then either this snapshot contains a primitive value (which can be
     * retrieved with `val()`) or it is empty (in which case, `val()` will return
     * `null`).
     *
     * @returns true if this snapshot has any children; else false.
     */hasChildren(){if(this._node.isLeafNode()){return false;}else{return!this._node.isEmpty();}}/**
     * Returns a JSON-serializable representation of this object.
     */toJSON(){return this.exportVal();}/**
     * Extracts a JavaScript value from a `DataSnapshot`.
     *
     * Depending on the data in a `DataSnapshot`, the `val()` method may return a
     * scalar type (string, number, or boolean), an array, or an object. It may
     * also return null, indicating that the `DataSnapshot` is empty (contains no
     * data).
     *
     * @returns The DataSnapshot's contents as a JavaScript value (Object,
     *   Array, string, number, boolean, or `null`).
     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
val(){return this._node.val();}}/**
 *
 * Returns a `Reference` representing the location in the Database
 * corresponding to the provided path. If no path is provided, the `Reference`
 * will point to the root of the Database.
 *
 * @param db - The database instance to obtain a reference for.
 * @param path - Optional path representing the location the returned
 *   `Reference` will point. If not provided, the returned `Reference` will
 *   point to the root of the Database.
 * @returns If a path is provided, a `Reference`
 *   pointing to the provided path. Otherwise, a `Reference` pointing to the
 *   root of the Database.
 */exports.DataSnapshot=DataSnapshot;function ref(db,path){db=(0,_util.getModularInstance)(db);db._checkNotDeleted('ref');return path!==undefined?child(db._root,path):db._root;}/**
 * Returns a `Reference` representing the location in the Database
 * corresponding to the provided Firebase URL.
 *
 * An exception is thrown if the URL is not a valid Firebase Database URL or it
 * has a different domain than the current `Database` instance.
 *
 * Note that all query parameters (`orderBy`, `limitToLast`, etc.) are ignored
 * and are not applied to the returned `Reference`.
 *
 * @param db - The database instance to obtain a reference for.
 * @param url - The Firebase URL at which the returned `Reference` will
 *   point.
 * @returns A `Reference` pointing to the provided
 *   Firebase URL.
 */function refFromURL(db,url){db=(0,_util.getModularInstance)(db);db._checkNotDeleted('refFromURL');const parsedURL=parseRepoInfo(url,db._repo.repoInfo_.nodeAdmin);validateUrl('refFromURL',parsedURL);const repoInfo=parsedURL.repoInfo;if(!db._repo.repoInfo_.isCustomHost()&&repoInfo.host!==db._repo.repoInfo_.host){fatal('refFromURL'+': Host name does not match the current database: '+'(found '+repoInfo.host+' but expected '+db._repo.repoInfo_.host+')');}return ref(db,parsedURL.path.toString());}/**
 * Gets a `Reference` for the location at the specified relative path.
 *
 * The relative path can either be a simple child name (for example, "ada") or
 * a deeper slash-separated path (for example, "ada/name/first").
 *
 * @param parent - The parent location.
 * @param path - A relative path from this location to the desired child
 *   location.
 * @returns The specified child location.
 */function child(parent,path){parent=(0,_util.getModularInstance)(parent);if(pathGetFront(parent._path)===null){validateRootPathString('child','path',path,false);}else{validatePathString('child','path',path,false);}return new ReferenceImpl(parent._repo,pathChild(parent._path,path));}/**
 * Returns an `OnDisconnect` object - see
 * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
 * for more information on how to use it.
 *
 * @param ref - The reference to add OnDisconnect triggers for.
 */function onDisconnect(ref){ref=(0,_util.getModularInstance)(ref);return new OnDisconnect(ref._repo,ref._path);}/**
 * Generates a new child location using a unique key and returns its
 * `Reference`.
 *
 * This is the most common pattern for adding data to a collection of items.
 *
 * If you provide a value to `push()`, the value is written to the
 * generated location. If you don't pass a value, nothing is written to the
 * database and the child remains empty (but you can use the `Reference`
 * elsewhere).
 *
 * The unique keys generated by `push()` are ordered by the current time, so the
 * resulting list of items is chronologically sorted. The keys are also
 * designed to be unguessable (they contain 72 random bits of entropy).
 *
 * See {@link https://firebase.google.com/docs/database/web/lists-of-data#append_to_a_list_of_data | Append to a list of data}.
 * See {@link https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html | The 2^120 Ways to Ensure Unique Identifiers}.
 *
 * @param parent - The parent location.
 * @param value - Optional value to be written at the generated location.
 * @returns Combined `Promise` and `Reference`; resolves when write is complete,
 * but can be used immediately as the `Reference` to the child location.
 */function push(parent,value){parent=(0,_util.getModularInstance)(parent);validateWritablePath('push',parent._path);validateFirebaseDataArg('push',value,parent._path,true);const now=repoServerTime(parent._repo);const name=nextPushId(now);// push() returns a ThennableReference whose promise is fulfilled with a
// regular Reference. We use child() to create handles to two different
// references. The first is turned into a ThennableReference below by adding
// then() and catch() methods and is used as the return value of push(). The
// second remains a regular Reference and is used as the fulfilled value of
// the first ThennableReference.
const thennablePushRef=child(parent,name);const pushRef=child(parent,name);let promise;if(value!=null){promise=set(pushRef,value).then(()=>pushRef);}else{promise=Promise.resolve(pushRef);}thennablePushRef.then=promise.then.bind(promise);thennablePushRef.catch=promise.then.bind(promise,undefined);return thennablePushRef;}/**
 * Removes the data at this Database location.
 *
 * Any data at child locations will also be deleted.
 *
 * The effect of the remove will be visible immediately and the corresponding
 * event 'value' will be triggered. Synchronization of the remove to the
 * Firebase servers will also be started, and the returned Promise will resolve
 * when complete. If provided, the onComplete callback will be called
 * asynchronously after synchronization has finished.
 *
 * @param ref - The location to remove.
 * @returns Resolves when remove on server is complete.
 */function remove(ref){validateWritablePath('remove',ref._path);return set(ref,null);}/**
 * Writes data to this Database location.
 *
 * This will overwrite any data at this location and all child locations.
 *
 * The effect of the write will be visible immediately, and the corresponding
 * events ("value", "child_added", etc.) will be triggered. Synchronization of
 * the data to the Firebase servers will also be started, and the returned
 * Promise will resolve when complete. If provided, the `onComplete` callback
 * will be called asynchronously after synchronization has finished.
 *
 * Passing `null` for the new value is equivalent to calling `remove()`; namely,
 * all data at this location and all child locations will be deleted.
 *
 * `set()` will remove any priority stored at this location, so if priority is
 * meant to be preserved, you need to use `setWithPriority()` instead.
 *
 * Note that modifying data with `set()` will cancel any pending transactions
 * at that location, so extreme care should be taken if mixing `set()` and
 * `transaction()` to modify the same data.
 *
 * A single `set()` will generate a single "value" event at the location where
 * the `set()` was performed.
 *
 * @param ref - The location to write to.
 * @param value - The value to be written (string, number, boolean, object,
 *   array, or null).
 * @returns Resolves when write to server is complete.
 */function set(ref,value){ref=(0,_util.getModularInstance)(ref);validateWritablePath('set',ref._path);validateFirebaseDataArg('set',value,ref._path,false);const deferred=new _util.Deferred();repoSetWithPriority(ref._repo,ref._path,value,/*priority=*/null,deferred.wrapCallback(()=>{}));return deferred.promise;}/**
 * Sets a priority for the data at this Database location.
 *
 * Applications need not use priority but can order collections by
 * ordinary properties (see
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}
 * ).
 *
 * @param ref - The location to write to.
 * @param priority - The priority to be written (string, number, or null).
 * @returns Resolves when write to server is complete.
 */function setPriority(ref,priority){ref=(0,_util.getModularInstance)(ref);validateWritablePath('setPriority',ref._path);validatePriority('setPriority',priority,false);const deferred=new _util.Deferred();repoSetWithPriority(ref._repo,pathChild(ref._path,'.priority'),priority,null,deferred.wrapCallback(()=>{}));return deferred.promise;}/**
 * Writes data the Database location. Like `set()` but also specifies the
 * priority for that data.
 *
 * Applications need not use priority but can order collections by
 * ordinary properties (see
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}
 * ).
 *
 * @param ref - The location to write to.
 * @param value - The value to be written (string, number, boolean, object,
 *   array, or null).
 * @param priority - The priority to be written (string, number, or null).
 * @returns Resolves when write to server is complete.
 */function setWithPriority(ref,value,priority){validateWritablePath('setWithPriority',ref._path);validateFirebaseDataArg('setWithPriority',value,ref._path,false);validatePriority('setWithPriority',priority,false);if(ref.key==='.length'||ref.key==='.keys'){throw'setWithPriority failed: '+ref.key+' is a read-only object.';}const deferred=new _util.Deferred();repoSetWithPriority(ref._repo,ref._path,value,priority,deferred.wrapCallback(()=>{}));return deferred.promise;}/**
 * Writes multiple values to the Database at once.
 *
 * The `values` argument contains multiple property-value pairs that will be
 * written to the Database together. Each child property can either be a simple
 * property (for example, "name") or a relative path (for example,
 * "name/first") from the current location to the data to update.
 *
 * As opposed to the `set()` method, `update()` can be use to selectively update
 * only the referenced properties at the current location (instead of replacing
 * all the child properties at the current location).
 *
 * The effect of the write will be visible immediately, and the corresponding
 * events ('value', 'child_added', etc.) will be triggered. Synchronization of
 * the data to the Firebase servers will also be started, and the returned
 * Promise will resolve when complete. If provided, the `onComplete` callback
 * will be called asynchronously after synchronization has finished.
 *
 * A single `update()` will generate a single "value" event at the location
 * where the `update()` was performed, regardless of how many children were
 * modified.
 *
 * Note that modifying data with `update()` will cancel any pending
 * transactions at that location, so extreme care should be taken if mixing
 * `update()` and `transaction()` to modify the same data.
 *
 * Passing `null` to `update()` will remove the data at this location.
 *
 * See
 * {@link https://firebase.googleblog.com/2015/09/introducing-multi-location-updates-and_86.html | Introducing multi-location updates and more}.
 *
 * @param ref - The location to write to.
 * @param values - Object containing multiple values.
 * @returns Resolves when update on server is complete.
 */function update(ref,values){validateFirebaseMergeDataArg('update',values,ref._path,false);const deferred=new _util.Deferred();repoUpdate(ref._repo,ref._path,values,deferred.wrapCallback(()=>{}));return deferred.promise;}/**
 * Gets the most up-to-date result for this query.
 *
 * @param query - The query to run.
 * @returns A `Promise` which resolves to the resulting DataSnapshot if a value is
 * available, or rejects if the client is unable to return a value (e.g., if the
 * server is unreachable and there is nothing cached).
 */function get(query){query=(0,_util.getModularInstance)(query);const callbackContext=new CallbackContext(()=>{});const container=new ValueEventRegistration(callbackContext);return repoGetValue(query._repo,query,container).then(node=>{return new DataSnapshot(node,new ReferenceImpl(query._repo,query._path),query._queryParams.getIndex());});}/**
 * Represents registration for 'value' events.
 */class ValueEventRegistration{constructor(callbackContext){this.callbackContext=callbackContext;}respondsTo(eventType){return eventType==='value';}createEvent(change,query){const index=query._queryParams.getIndex();return new DataEvent('value',this,new DataSnapshot(change.snapshotNode,new ReferenceImpl(query._repo,query._path),index));}getEventRunner(eventData){if(eventData.getEventType()==='cancel'){return()=>this.callbackContext.onCancel(eventData.error);}else{return()=>this.callbackContext.onValue(eventData.snapshot,null);}}createCancelEvent(error,path){if(this.callbackContext.hasCancelCallback){return new CancelEvent(this,error,path);}else{return null;}}matches(other){if(!(other instanceof ValueEventRegistration)){return false;}else if(!other.callbackContext||!this.callbackContext){// If no callback specified, we consider it to match any callback.
return true;}else{return other.callbackContext.matches(this.callbackContext);}}hasAnyCallback(){return this.callbackContext!==null;}}/**
 * Represents the registration of a child_x event.
 */class ChildEventRegistration{constructor(eventType,callbackContext){this.eventType=eventType;this.callbackContext=callbackContext;}respondsTo(eventType){let eventToCheck=eventType==='children_added'?'child_added':eventType;eventToCheck=eventToCheck==='children_removed'?'child_removed':eventToCheck;return this.eventType===eventToCheck;}createCancelEvent(error,path){if(this.callbackContext.hasCancelCallback){return new CancelEvent(this,error,path);}else{return null;}}createEvent(change,query){(0,_util.assert)(change.childName!=null,'Child events should have a childName.');const childRef=child(new ReferenceImpl(query._repo,query._path),change.childName);const index=query._queryParams.getIndex();return new DataEvent(change.type,this,new DataSnapshot(change.snapshotNode,childRef,index),change.prevName);}getEventRunner(eventData){if(eventData.getEventType()==='cancel'){return()=>this.callbackContext.onCancel(eventData.error);}else{return()=>this.callbackContext.onValue(eventData.snapshot,eventData.prevName);}}matches(other){if(other instanceof ChildEventRegistration){return this.eventType===other.eventType&&(!this.callbackContext||!other.callbackContext||this.callbackContext.matches(other.callbackContext));}return false;}hasAnyCallback(){return!!this.callbackContext;}}function addEventListener(query,eventType,callback,cancelCallbackOrListenOptions,options){let cancelCallback;if(typeof cancelCallbackOrListenOptions==='object'){cancelCallback=undefined;options=cancelCallbackOrListenOptions;}if(typeof cancelCallbackOrListenOptions==='function'){cancelCallback=cancelCallbackOrListenOptions;}if(options&&options.onlyOnce){const userCallback=callback;const onceCallback=(dataSnapshot,previousChildName)=>{repoRemoveEventCallbackForQuery(query._repo,query,container);userCallback(dataSnapshot,previousChildName);};onceCallback.userCallback=callback.userCallback;onceCallback.context=callback.context;callback=onceCallback;}const callbackContext=new CallbackContext(callback,cancelCallback||undefined);const container=eventType==='value'?new ValueEventRegistration(callbackContext):new ChildEventRegistration(eventType,callbackContext);repoAddEventCallbackForQuery(query._repo,query,container);return()=>repoRemoveEventCallbackForQuery(query._repo,query,container);}function onValue(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,'value',callback,cancelCallbackOrListenOptions,options);}function onChildAdded(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,'child_added',callback,cancelCallbackOrListenOptions,options);}function onChildChanged(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,'child_changed',callback,cancelCallbackOrListenOptions,options);}function onChildMoved(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,'child_moved',callback,cancelCallbackOrListenOptions,options);}function onChildRemoved(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,'child_removed',callback,cancelCallbackOrListenOptions,options);}/**
 * Detaches a callback previously attached with the corresponding `on*()` (`onValue`, `onChildAdded`) listener.
 * Note: This is not the recommended way to remove a listener. Instead, please use the returned callback function from
 * the respective `on*` callbacks.
 *
 * Detach a callback previously attached with `on*()`. Calling `off()` on a parent listener
 * will not automatically remove listeners registered on child nodes, `off()`
 * must also be called on any child listeners to remove the callback.
 *
 * If a callback is not specified, all callbacks for the specified eventType
 * will be removed. Similarly, if no eventType is specified, all callbacks
 * for the `Reference` will be removed.
 *
 * Individual listeners can also be removed by invoking their unsubscribe
 * callbacks.
 *
 * @param query - The query that the listener was registered with.
 * @param eventType - One of the following strings: "value", "child_added",
 * "child_changed", "child_removed", or "child_moved." If omitted, all callbacks
 * for the `Reference` will be removed.
 * @param callback - The callback function that was passed to `on()` or
 * `undefined` to remove all callbacks.
 */function off(query,eventType,callback){let container=null;const expCallback=callback?new CallbackContext(callback):null;if(eventType==='value'){container=new ValueEventRegistration(expCallback);}else if(eventType){container=new ChildEventRegistration(eventType,expCallback);}repoRemoveEventCallbackForQuery(query._repo,query,container);}/**
 * A `QueryConstraint` is used to narrow the set of documents returned by a
 * Database query. `QueryConstraint`s are created by invoking {@link endAt},
 * {@link endBefore}, {@link startAt}, {@link startAfter}, {@link
 * limitToFirst}, {@link limitToLast}, {@link orderByChild},
 * {@link orderByChild}, {@link orderByKey} , {@link orderByPriority} ,
 * {@link orderByValue}  or {@link equalTo} and
 * can then be passed to {@link query} to create a new query instance that
 * also contains this `QueryConstraint`.
 */class QueryConstraint{}exports.QueryConstraint=QueryConstraint;class QueryEndAtConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;}_apply(query){validateFirebaseDataArg('endAt',this._value,query._path,true);const newParams=queryParamsEndAt(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasEnd()){throw new Error('endAt: Starting point was already set (by another call to endAt, '+'endBefore or equalTo).');}return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled);}}/**
 * Creates a `QueryConstraint` with the specified ending point.
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The ending point is inclusive, so children with exactly the specified value
 * will be included in the query. The optional key argument can be used to
 * further limit the range of the query. If it is specified, then children that
 * have exactly the specified value must also have a key name less than or equal
 * to the specified key.
 *
 * You can read more about `endAt()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param value - The value to end at. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to end at, among the children with the previously
 * specified priority. This argument is only allowed if ordering by child,
 * value, or priority.
 */function endAt(value,key){validateKey('endAt','key',key,true);return new QueryEndAtConstraint(value,key);}class QueryEndBeforeConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;}_apply(query){validateFirebaseDataArg('endBefore',this._value,query._path,false);const newParams=queryParamsEndBefore(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasEnd()){throw new Error('endBefore: Starting point was already set (by another call to endAt, '+'endBefore or equalTo).');}return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled);}}/**
 * Creates a `QueryConstraint` with the specified ending point (exclusive).
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The ending point is exclusive. If only a value is provided, children
 * with a value less than the specified value will be included in the query.
 * If a key is specified, then children must have a value less than or equal
 * to the specified value and a key name less than the specified key.
 *
 * @param value - The value to end before. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to end before, among the children with the
 * previously specified priority. This argument is only allowed if ordering by
 * child, value, or priority.
 */function endBefore(value,key){validateKey('endBefore','key',key,true);return new QueryEndBeforeConstraint(value,key);}class QueryStartAtConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;}_apply(query){validateFirebaseDataArg('startAt',this._value,query._path,true);const newParams=queryParamsStartAt(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasStart()){throw new Error('startAt: Starting point was already set (by another call to startAt, '+'startBefore or equalTo).');}return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled);}}/**
 * Creates a `QueryConstraint` with the specified starting point.
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The starting point is inclusive, so children with exactly the specified value
 * will be included in the query. The optional key argument can be used to
 * further limit the range of the query. If it is specified, then children that
 * have exactly the specified value must also have a key name greater than or
 * equal to the specified key.
 *
 * You can read more about `startAt()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param value - The value to start at. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to start at. This argument is only allowed if
 * ordering by child, value, or priority.
 */function startAt(value=null,key){validateKey('startAt','key',key,true);return new QueryStartAtConstraint(value,key);}class QueryStartAfterConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;}_apply(query){validateFirebaseDataArg('startAfter',this._value,query._path,false);const newParams=queryParamsStartAfter(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasStart()){throw new Error('startAfter: Starting point was already set (by another call to startAt, '+'startAfter, or equalTo).');}return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled);}}/**
 * Creates a `QueryConstraint` with the specified starting point (exclusive).
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The starting point is exclusive. If only a value is provided, children
 * with a value greater than the specified value will be included in the query.
 * If a key is specified, then children must have a value greater than or equal
 * to the specified value and a a key name greater than the specified key.
 *
 * @param value - The value to start after. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to start after. This argument is only allowed if
 * ordering by child, value, or priority.
 */function startAfter(value,key){validateKey('startAfter','key',key,true);return new QueryStartAfterConstraint(value,key);}class QueryLimitToFirstConstraint extends QueryConstraint{constructor(_limit){super();this._limit=_limit;}_apply(query){if(query._queryParams.hasLimit()){throw new Error('limitToFirst: Limit was already set (by another call to limitToFirst '+'or limitToLast).');}return new QueryImpl(query._repo,query._path,queryParamsLimitToFirst(query._queryParams,this._limit),query._orderByCalled);}}/**
 * Creates a new `QueryConstraint` that if limited to the first specific number
 * of children.
 *
 * The `limitToFirst()` method is used to set a maximum number of children to be
 * synced for a given callback. If we set a limit of 100, we will initially only
 * receive up to 100 `child_added` events. If we have fewer than 100 messages
 * stored in our Database, a `child_added` event will fire for each message.
 * However, if we have over 100 messages, we will only receive a `child_added`
 * event for the first 100 ordered messages. As items change, we will receive
 * `child_removed` events for each item that drops out of the active list so
 * that the total number stays at 100.
 *
 * You can read more about `limitToFirst()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param limit - The maximum number of nodes to include in this query.
 */function limitToFirst(limit){if(typeof limit!=='number'||Math.floor(limit)!==limit||limit<=0){throw new Error('limitToFirst: First argument must be a positive integer.');}return new QueryLimitToFirstConstraint(limit);}class QueryLimitToLastConstraint extends QueryConstraint{constructor(_limit){super();this._limit=_limit;}_apply(query){if(query._queryParams.hasLimit()){throw new Error('limitToLast: Limit was already set (by another call to limitToFirst '+'or limitToLast).');}return new QueryImpl(query._repo,query._path,queryParamsLimitToLast(query._queryParams,this._limit),query._orderByCalled);}}/**
 * Creates a new `QueryConstraint` that is limited to return only the last
 * specified number of children.
 *
 * The `limitToLast()` method is used to set a maximum number of children to be
 * synced for a given callback. If we set a limit of 100, we will initially only
 * receive up to 100 `child_added` events. If we have fewer than 100 messages
 * stored in our Database, a `child_added` event will fire for each message.
 * However, if we have over 100 messages, we will only receive a `child_added`
 * event for the last 100 ordered messages. As items change, we will receive
 * `child_removed` events for each item that drops out of the active list so
 * that the total number stays at 100.
 *
 * You can read more about `limitToLast()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param limit - The maximum number of nodes to include in this query.
 */function limitToLast(limit){if(typeof limit!=='number'||Math.floor(limit)!==limit||limit<=0){throw new Error('limitToLast: First argument must be a positive integer.');}return new QueryLimitToLastConstraint(limit);}class QueryOrderByChildConstraint extends QueryConstraint{constructor(_path){super();this._path=_path;}_apply(query){validateNoPreviousOrderByCall(query,'orderByChild');const parsedPath=new Path(this._path);if(pathIsEmpty(parsedPath)){throw new Error('orderByChild: cannot pass in empty path. Use orderByValue() instead.');}const index=new PathIndex(parsedPath);const newParams=queryParamsOrderBy(query._queryParams,index);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,/*orderByCalled=*/true);}}/**
 * Creates a new `QueryConstraint` that orders by the specified child key.
 *
 * Queries can only order by one key at a time. Calling `orderByChild()`
 * multiple times on the same query is an error.
 *
 * Firebase queries allow you to order your data by any child key on the fly.
 * However, if you know in advance what your indexes will be, you can define
 * them via the .indexOn rule in your Security Rules for better performance. See
 * the{@link https://firebase.google.com/docs/database/security/indexing-data}
 * rule for more information.
 *
 * You can read more about `orderByChild()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 *
 * @param path - The path to order by.
 */function orderByChild(path){if(path==='$key'){throw new Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.');}else if(path==='$priority'){throw new Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.');}else if(path==='$value'){throw new Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.');}validatePathString('orderByChild','path',path,false);return new QueryOrderByChildConstraint(path);}class QueryOrderByKeyConstraint extends QueryConstraint{_apply(query){validateNoPreviousOrderByCall(query,'orderByKey');const newParams=queryParamsOrderBy(query._queryParams,KEY_INDEX);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,/*orderByCalled=*/true);}}/**
 * Creates a new `QueryConstraint` that orders by the key.
 *
 * Sorts the results of a query by their (ascending) key values.
 *
 * You can read more about `orderByKey()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 */function orderByKey(){return new QueryOrderByKeyConstraint();}class QueryOrderByPriorityConstraint extends QueryConstraint{_apply(query){validateNoPreviousOrderByCall(query,'orderByPriority');const newParams=queryParamsOrderBy(query._queryParams,PRIORITY_INDEX);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,/*orderByCalled=*/true);}}/**
 * Creates a new `QueryConstraint` that orders by priority.
 *
 * Applications need not use priority but can order collections by
 * ordinary properties (see
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}
 * for alternatives to priority.
 */function orderByPriority(){return new QueryOrderByPriorityConstraint();}class QueryOrderByValueConstraint extends QueryConstraint{_apply(query){validateNoPreviousOrderByCall(query,'orderByValue');const newParams=queryParamsOrderBy(query._queryParams,VALUE_INDEX);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,/*orderByCalled=*/true);}}/**
 * Creates a new `QueryConstraint` that orders by value.
 *
 * If the children of a query are all scalar values (string, number, or
 * boolean), you can order the results by their (ascending) values.
 *
 * You can read more about `orderByValue()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 */function orderByValue(){return new QueryOrderByValueConstraint();}class QueryEqualToValueConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key;}_apply(query){validateFirebaseDataArg('equalTo',this._value,query._path,false);if(query._queryParams.hasStart()){throw new Error('equalTo: Starting point was already set (by another call to startAt/startAfter or '+'equalTo).');}if(query._queryParams.hasEnd()){throw new Error('equalTo: Ending point was already set (by another call to endAt/endBefore or '+'equalTo).');}return new QueryEndAtConstraint(this._value,this._key)._apply(new QueryStartAtConstraint(this._value,this._key)._apply(query));}}/**
 * Creates a `QueryConstraint` that includes children that match the specified
 * value.
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The optional key argument can be used to further limit the range of the
 * query. If it is specified, then children that have exactly the specified
 * value must also have exactly the specified key as their key name. This can be
 * used to filter result sets with many matches for the same value.
 *
 * You can read more about `equalTo()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param value - The value to match for. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to start at, among the children with the
 * previously specified priority. This argument is only allowed if ordering by
 * child, value, or priority.
 */function equalTo(value,key){validateKey('equalTo','key',key,true);return new QueryEqualToValueConstraint(value,key);}/**
 * Creates a new immutable instance of `Query` that is extended to also include
 * additional query constraints.
 *
 * @param query - The Query instance to use as a base for the new constraints.
 * @param queryConstraints - The list of `QueryConstraint`s to apply.
 * @throws if any of the provided query constraints cannot be combined with the
 * existing or new constraints.
 */function query(query,...queryConstraints){let queryImpl=(0,_util.getModularInstance)(query);for(const constraint of queryConstraints){queryImpl=constraint._apply(queryImpl);}return queryImpl;}/**
 * Define reference constructor in various modules
 *
 * We are doing this here to avoid several circular
 * dependency issues
 */syncPointSetReferenceConstructor(ReferenceImpl);syncTreeSetReferenceConstructor(ReferenceImpl);/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * This variable is also defined in the firebase Node.js Admin SDK. Before
 * modifying this definition, consult the definition in:
 *
 * https://github.com/firebase/firebase-admin-node
 *
 * and make sure the two are consistent.
 */const FIREBASE_DATABASE_EMULATOR_HOST_VAR='FIREBASE_DATABASE_EMULATOR_HOST';/**
 * Creates and caches `Repo` instances.
 */const repos={};/**
 * If true, any new `Repo` will be created to use `ReadonlyRestClient` (for testing purposes).
 */let useRestClient=false;/**
 * Update an existing `Repo` in place to point to a new host/port.
 */function repoManagerApplyEmulatorSettings(repo,host,port,tokenProvider){repo.repoInfo_=new RepoInfo(`${host}:${port}`,/* secure= */false,repo.repoInfo_.namespace,repo.repoInfo_.webSocketOnly,repo.repoInfo_.nodeAdmin,repo.repoInfo_.persistenceKey,repo.repoInfo_.includeNamespaceInQueryParams);if(tokenProvider){repo.authTokenProvider_=tokenProvider;}}/**
 * This function should only ever be called to CREATE a new database instance.
 * @internal
 */function repoManagerDatabaseFromApp(app,authProvider,appCheckProvider,url,nodeAdmin){let dbUrl=url||app.options.databaseURL;if(dbUrl===undefined){if(!app.options.projectId){fatal("Can't determine Firebase Database URL. Be sure to include "+' a Project ID when calling firebase.initializeApp().');}log('Using default host for project ',app.options.projectId);dbUrl=`${app.options.projectId}-default-rtdb.firebaseio.com`;}let parsedUrl=parseRepoInfo(dbUrl,nodeAdmin);let repoInfo=parsedUrl.repoInfo;let isEmulator;let dbEmulatorHost=undefined;if(typeof process!=='undefined'&&process.env){dbEmulatorHost=process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];}if(dbEmulatorHost){isEmulator=true;dbUrl=`http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;parsedUrl=parseRepoInfo(dbUrl,nodeAdmin);repoInfo=parsedUrl.repoInfo;}else{isEmulator=!parsedUrl.repoInfo.secure;}const authTokenProvider=nodeAdmin&&isEmulator?new EmulatorTokenProvider(EmulatorTokenProvider.OWNER):new FirebaseAuthTokenProvider(app.name,app.options,authProvider);validateUrl('Invalid Firebase Database URL',parsedUrl);if(!pathIsEmpty(parsedUrl.path)){fatal('Database URL must point to the root of a Firebase Database '+'(not including a child path).');}const repo=repoManagerCreateRepo(repoInfo,app,authTokenProvider,new AppCheckTokenProvider(app.name,appCheckProvider));return new Database(repo,app);}/**
 * Remove the repo and make sure it is disconnected.
 *
 */function repoManagerDeleteRepo(repo,appName){const appRepos=repos[appName];// This should never happen...
if(!appRepos||appRepos[repo.key]!==repo){fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);}repoInterrupt(repo);delete appRepos[repo.key];}/**
 * Ensures a repo doesn't already exist and then creates one using the
 * provided app.
 *
 * @param repoInfo - The metadata about the Repo
 * @returns The Repo object for the specified server / repoName.
 */function repoManagerCreateRepo(repoInfo,app,authTokenProvider,appCheckProvider){let appRepos=repos[app.name];if(!appRepos){appRepos={};repos[app.name]=appRepos;}let repo=appRepos[repoInfo.toURLString()];if(repo){fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');}repo=new Repo(repoInfo,useRestClient,authTokenProvider,appCheckProvider);appRepos[repoInfo.toURLString()]=repo;return repo;}/**
 * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.
 */function repoManagerForceRestClient(forceRestClient){useRestClient=forceRestClient;}/**
 * Class representing a Firebase Realtime Database.
 */class Database{/** @hideconstructor */constructor(_repoInternal,/** The {@link @firebase/app#FirebaseApp} associated with this Realtime Database instance. */app){this._repoInternal=_repoInternal;this.app=app;/** Represents a `Database` instance. */this['type']='database';/** Track if the instance has been used (root or repo accessed) */this._instanceStarted=false;}get _repo(){if(!this._instanceStarted){repoStart(this._repoInternal,this.app.options.appId,this.app.options['databaseAuthVariableOverride']);this._instanceStarted=true;}return this._repoInternal;}get _root(){if(!this._rootInternal){this._rootInternal=new ReferenceImpl(this._repo,newEmptyPath());}return this._rootInternal;}_delete(){if(this._rootInternal!==null){repoManagerDeleteRepo(this._repo,this.app.name);this._repoInternal=null;this._rootInternal=null;}return Promise.resolve();}_checkNotDeleted(apiName){if(this._rootInternal===null){fatal('Cannot call '+apiName+' on a deleted database.');}}}exports.Database=Database;function checkTransportInit(){if(TransportManager.IS_TRANSPORT_INITIALIZED){warn('Transport has already been initialized. Please call this function before calling ref or setting up a listener');}}/**
 * Force the use of websockets instead of longPolling.
 */function forceWebSockets(){checkTransportInit();BrowserPollConnection.forceDisallow();}/**
 * Force the use of longPolling instead of websockets. This will be ignored if websocket protocol is used in databaseURL.
 */function forceLongPolling(){checkTransportInit();WebSocketConnection.forceDisallow();BrowserPollConnection.forceAllow();}/**
 * Returns the instance of the Realtime Database SDK that is associated
 * with the provided {@link @firebase/app#FirebaseApp}. Initializes a new instance with
 * with default settings if no instance exists or if the existing instance uses
 * a custom database URL.
 *
 * @param app - The {@link @firebase/app#FirebaseApp} instance that the returned Realtime
 * Database instance is associated with.
 * @param url - The URL of the Realtime Database instance to connect to. If not
 * provided, the SDK connects to the default instance of the Firebase App.
 * @returns The `Database` instance of the provided app.
 */function getDatabase(app=(0,_app.getApp)(),url){const db=(0,_app._getProvider)(app,'database').getImmediate({identifier:url});const emulator=(0,_util.getDefaultEmulatorHostnameAndPort)('database');if(emulator){connectDatabaseEmulator(db,...emulator);}return db;}/**
 * Modify the provided instance to communicate with the Realtime Database
 * emulator.
 *
 * <p>Note: This method must be called before performing any other operation.
 *
 * @param db - The instance to modify.
 * @param host - The emulator host (ex: localhost)
 * @param port - The emulator port (ex: 8080)
 * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules
 */function connectDatabaseEmulator(db,host,port,options={}){db=(0,_util.getModularInstance)(db);db._checkNotDeleted('useEmulator');if(db._instanceStarted){fatal('Cannot call useEmulator() after instance has already been initialized.');}const repo=db._repoInternal;let tokenProvider=undefined;if(repo.repoInfo_.nodeAdmin){if(options.mockUserToken){fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".');}tokenProvider=new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);}else if(options.mockUserToken){const token=typeof options.mockUserToken==='string'?options.mockUserToken:(0,_util.createMockUserToken)(options.mockUserToken,db.app.options.projectId);tokenProvider=new EmulatorTokenProvider(token);}// Modify the repo to apply emulator settings
repoManagerApplyEmulatorSettings(repo,host,port,tokenProvider);}/**
 * Disconnects from the server (all Database operations will be completed
 * offline).
 *
 * The client automatically maintains a persistent connection to the Database
 * server, which will remain active indefinitely and reconnect when
 * disconnected. However, the `goOffline()` and `goOnline()` methods may be used
 * to control the client connection in cases where a persistent connection is
 * undesirable.
 *
 * While offline, the client will no longer receive data updates from the
 * Database. However, all Database operations performed locally will continue to
 * immediately fire events, allowing your application to continue behaving
 * normally. Additionally, each operation performed locally will automatically
 * be queued and retried upon reconnection to the Database server.
 *
 * To reconnect to the Database and begin receiving remote events, see
 * `goOnline()`.
 *
 * @param db - The instance to disconnect.
 */function goOffline(db){db=(0,_util.getModularInstance)(db);db._checkNotDeleted('goOffline');repoInterrupt(db._repo);}/**
 * Reconnects to the server and synchronizes the offline Database state
 * with the server state.
 *
 * This method should be used after disabling the active connection with
 * `goOffline()`. Once reconnected, the client will transmit the proper data
 * and fire the appropriate events so that your client "catches up"
 * automatically.
 *
 * @param db - The instance to reconnect.
 */function goOnline(db){db=(0,_util.getModularInstance)(db);db._checkNotDeleted('goOnline');repoResume(db._repo);}function enableLogging(logger,persistent){enableLogging$1(logger,persistent);}/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function registerDatabase(variant){setSDKVersion(_app.SDK_VERSION);(0,_app._registerComponent)(new _component.Component('database',(container,{instanceIdentifier:url})=>{const app=container.getProvider('app').getImmediate();const authProvider=container.getProvider('auth-internal');const appCheckProvider=container.getProvider('app-check-internal');return repoManagerDatabaseFromApp(app,authProvider,appCheckProvider,url);},"PUBLIC"/* PUBLIC */).setMultipleInstances(true));(0,_app.registerVersion)(name,version,variant);// BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
(0,_app.registerVersion)(name,version,'esm2017');}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const SERVER_TIMESTAMP={'.sv':'timestamp'};/**
 * Returns a placeholder value for auto-populating the current timestamp (time
 * since the Unix epoch, in milliseconds) as determined by the Firebase
 * servers.
 */function serverTimestamp(){return SERVER_TIMESTAMP;}/**
 * Returns a placeholder value that can be used to atomically increment the
 * current database value by the provided delta.
 *
 * @param delta - the amount to modify the current value atomically.
 * @returns A placeholder value for modifying data atomically server-side.
 */function increment(delta){return{'.sv':{'increment':delta}};}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A type for the resolve value of {@link runTransaction}.
 */class TransactionResult{/** @hideconstructor */constructor(/** Whether the transaction was successfully committed. */committed,/** The resulting data snapshot. */snapshot){this.committed=committed;this.snapshot=snapshot;}/** Returns a JSON-serializable representation of this object. */toJSON(){return{committed:this.committed,snapshot:this.snapshot.toJSON()};}}/**
 * Atomically modifies the data at this location.
 *
 * Atomically modify the data at this location. Unlike a normal `set()`, which
 * just overwrites the data regardless of its previous value, `runTransaction()` is
 * used to modify the existing value to a new value, ensuring there are no
 * conflicts with other clients writing to the same location at the same time.
 *
 * To accomplish this, you pass `runTransaction()` an update function which is
 * used to transform the current value into a new value. If another client
 * writes to the location before your new value is successfully written, your
 * update function will be called again with the new current value, and the
 * write will be retried. This will happen repeatedly until your write succeeds
 * without conflict or you abort the transaction by not returning a value from
 * your update function.
 *
 * Note: Modifying data with `set()` will cancel any pending transactions at
 * that location, so extreme care should be taken if mixing `set()` and
 * `runTransaction()` to update the same data.
 *
 * Note: When using transactions with Security and Firebase Rules in place, be
 * aware that a client needs `.read` access in addition to `.write` access in
 * order to perform a transaction. This is because the client-side nature of
 * transactions requires the client to read the data in order to transactionally
 * update it.
 *
 * @param ref - The location to atomically modify.
 * @param transactionUpdate - A developer-supplied function which will be passed
 * the current data stored at this location (as a JavaScript object). The
 * function should return the new value it would like written (as a JavaScript
 * object). If `undefined` is returned (i.e. you return with no arguments) the
 * transaction will be aborted and the data at this location will not be
 * modified.
 * @param options - An options object to configure transactions.
 * @returns A `Promise` that can optionally be used instead of the `onComplete`
 * callback to handle success and failure.
 */exports.TransactionResult=TransactionResult;function runTransaction(ref,// eslint-disable-next-line @typescript-eslint/no-explicit-any
transactionUpdate,options){var _a;ref=(0,_util.getModularInstance)(ref);validateWritablePath('Reference.transaction',ref._path);if(ref.key==='.length'||ref.key==='.keys'){throw'Reference.transaction failed: '+ref.key+' is a read-only object.';}const applyLocally=(_a=options===null||options===void 0?void 0:options.applyLocally)!==null&&_a!==void 0?_a:true;const deferred=new _util.Deferred();const promiseComplete=(error,committed,node)=>{let dataSnapshot=null;if(error){deferred.reject(error);}else{dataSnapshot=new DataSnapshot(node,new ReferenceImpl(ref._repo,ref._path),PRIORITY_INDEX);deferred.resolve(new TransactionResult(committed,dataSnapshot));}};// Add a watch to make sure we get server updates.
const unwatcher=onValue(ref,()=>{});repoStartTransaction(ref._repo,ref._path,transactionUpdate,promiseComplete,unwatcher,applyLocally);return deferred.promise;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */PersistentConnection;// eslint-disable-next-line @typescript-eslint/no-explicit-any
PersistentConnection.prototype.simpleListen=function(pathString,onComplete){this.sendRequest('q',{p:pathString},onComplete);};// eslint-disable-next-line @typescript-eslint/no-explicit-any
PersistentConnection.prototype.echo=function(data,onEcho){this.sendRequest('echo',{d:data},onEcho);};// RealTimeConnection properties that we use in tests.
Connection;/**
 * @internal
 */const hijackHash=function(newHash){const oldPut=PersistentConnection.prototype.put;PersistentConnection.prototype.put=function(pathString,data,onComplete,hash){if(hash!==undefined){hash=newHash();}oldPut.call(this,pathString,data,onComplete,hash);};return function(){PersistentConnection.prototype.put=oldPut;};};exports._TEST_ACCESS_hijackHash=hijackHash;RepoInfo;/**
 * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.
 * @internal
 */const forceRestClient=function(forceRestClient){repoManagerForceRestClient(forceRestClient);};/**
 * Firebase Realtime Database
 *
 * @packageDocumentation
 */exports._TEST_ACCESS_forceRestClient=forceRestClient;registerDatabase();

}).call(this)}).call(this,require('_process'))
},{"@firebase/app":66,"@firebase/component":67,"@firebase/logger":69,"@firebase/util":70,"_process":81}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = exports.LogLevel = void 0;
exports.setLogLevel = setLogLevel;
exports.setUserLogHandler = setUserLogHandler;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A container for all of the Logger instances
 */
const instances = [];
/**
 * The JS SDK supports 5 log levels and also allows a user the ability to
 * silence the logs altogether.
 *
 * The order is a follows:
 * DEBUG < VERBOSE < INFO < WARN < ERROR
 *
 * All of the log types above the current log level will be captured (i.e. if
 * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and
 * `VERBOSE` logs will not)
 */
var LogLevel;
exports.LogLevel = LogLevel;
(function (LogLevel) {
  LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
  LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
  LogLevel[LogLevel["INFO"] = 2] = "INFO";
  LogLevel[LogLevel["WARN"] = 3] = "WARN";
  LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
  LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
const levelStringToEnum = {
  'debug': LogLevel.DEBUG,
  'verbose': LogLevel.VERBOSE,
  'info': LogLevel.INFO,
  'warn': LogLevel.WARN,
  'error': LogLevel.ERROR,
  'silent': LogLevel.SILENT
};
/**
 * The default log level
 */
const defaultLogLevel = LogLevel.INFO;
/**
 * By default, `console.debug` is not displayed in the developer console (in
 * chrome). To avoid forcing users to have to opt-in to these logs twice
 * (i.e. once for firebase, and once in the console), we are sending `DEBUG`
 * logs to the `console.log` function.
 */
const ConsoleMethod = {
  [LogLevel.DEBUG]: 'log',
  [LogLevel.VERBOSE]: 'log',
  [LogLevel.INFO]: 'info',
  [LogLevel.WARN]: 'warn',
  [LogLevel.ERROR]: 'error'
};
/**
 * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR
 * messages on to their corresponding console counterparts (if the log method
 * is supported by the current log level)
 */
const defaultLogHandler = (instance, logType, ...args) => {
  if (logType < instance.logLevel) {
    return;
  }
  const now = new Date().toISOString();
  const method = ConsoleMethod[logType];
  if (method) {
    console[method](`[${now}]  ${instance.name}:`, ...args);
  } else {
    throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
  }
};
class Logger {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(name) {
    this.name = name;
    /**
     * The log level of the given Logger instance.
     */
    this._logLevel = defaultLogLevel;
    /**
     * The main (internal) log handler for the Logger instance.
     * Can be set to a new function in internal package code but not by user.
     */
    this._logHandler = defaultLogHandler;
    /**
     * The optional, additional, user-defined log handler for the Logger instance.
     */
    this._userLogHandler = null;
    /**
     * Capture the current instance for later use
     */
    instances.push(this);
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(val) {
    if (!(val in LogLevel)) {
      throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
    }
    this._logLevel = val;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(val) {
    this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(val) {
    if (typeof val !== 'function') {
      throw new TypeError('Value assigned to `logHandler` must be a function');
    }
    this._logHandler = val;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(val) {
    this._userLogHandler = val;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
    this._logHandler(this, LogLevel.DEBUG, ...args);
  }
  log(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);
    this._logHandler(this, LogLevel.VERBOSE, ...args);
  }
  info(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
    this._logHandler(this, LogLevel.INFO, ...args);
  }
  warn(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
    this._logHandler(this, LogLevel.WARN, ...args);
  }
  error(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
    this._logHandler(this, LogLevel.ERROR, ...args);
  }
}
exports.Logger = Logger;
function setLogLevel(level) {
  instances.forEach(inst => {
    inst.setLogLevel(level);
  });
}
function setUserLogHandler(logCallback, options) {
  for (const instance of instances) {
    let customLogLevel = null;
    if (options && options.level) {
      customLogLevel = levelStringToEnum[options.level];
    }
    if (logCallback === null) {
      instance.userLogHandler = null;
    } else {
      instance.userLogHandler = (instance, level, ...args) => {
        const message = args.map(arg => {
          if (arg == null) {
            return null;
          } else if (typeof arg === 'string') {
            return arg;
          } else if (typeof arg === 'number' || typeof arg === 'boolean') {
            return arg.toString();
          } else if (arg instanceof Error) {
            return arg.message;
          } else {
            try {
              return JSON.stringify(arg);
            } catch (ignored) {
              return null;
            }
          }
        }).filter(arg => arg).join(' ');
        if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {
          logCallback({
            level: LogLevel[level].toLowerCase(),
            message,
            args,
            type: instance.name
          });
        }
      };
    }
  }
}

},{}],70:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sha1 = exports.RANDOM_FACTOR = exports.MAX_VALUE_MILLIS = exports.FirebaseError = exports.ErrorFactory = exports.Deferred = exports.CONSTANTS = void 0;
exports.areCookiesEnabled = areCookiesEnabled;
exports.assertionError = exports.assert = void 0;
exports.async = async;
exports.base64urlEncodeWithoutPadding = exports.base64Encode = exports.base64Decode = exports.base64 = void 0;
exports.calculateBackoffMillis = calculateBackoffMillis;
exports.contains = contains;
exports.createMockUserToken = createMockUserToken;
exports.createSubscribe = createSubscribe;
exports.decode = void 0;
exports.deepCopy = deepCopy;
exports.deepEqual = deepEqual;
exports.deepExtend = deepExtend;
exports.errorPrefix = errorPrefix;
exports.extractQuerystring = extractQuerystring;
exports.getExperimentalSetting = exports.getDefaultEmulatorHostnameAndPort = exports.getDefaultEmulatorHost = exports.getDefaultAppConfig = void 0;
exports.getGlobal = getGlobal;
exports.getModularInstance = getModularInstance;
exports.getUA = getUA;
exports.isAdmin = void 0;
exports.isBrowser = isBrowser;
exports.isBrowserExtension = isBrowserExtension;
exports.isElectron = isElectron;
exports.isEmpty = isEmpty;
exports.isIE = isIE;
exports.isIndexedDBAvailable = isIndexedDBAvailable;
exports.isMobileCordova = isMobileCordova;
exports.isNode = isNode;
exports.isNodeSdk = isNodeSdk;
exports.isReactNative = isReactNative;
exports.isSafari = isSafari;
exports.isUWP = isUWP;
exports.issuedAtTime = exports.isValidTimestamp = exports.isValidFormat = void 0;
exports.jsonEval = jsonEval;
exports.map = map;
exports.ordinal = ordinal;
exports.promiseWithTimeout = promiseWithTimeout;
exports.querystring = querystring;
exports.querystringDecode = querystringDecode;
exports.safeGet = safeGet;
exports.stringToByteArray = exports.stringLength = void 0;
exports.stringify = stringify;
exports.validateArgCount = exports.uuidv4 = void 0;
exports.validateCallback = validateCallback;
exports.validateContextObject = validateContextObject;
exports.validateIndexedDBOpenable = validateIndexedDBOpenable;
exports.validateNamespace = validateNamespace;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.
 */
const CONSTANTS = {
  /**
   * @define {boolean} Whether this is the client Node.js SDK.
   */
  NODE_CLIENT: false,
  /**
   * @define {boolean} Whether this is the Admin Node.js SDK.
   */
  NODE_ADMIN: false,
  /**
   * Firebase SDK Version
   */
  SDK_VERSION: '${JSCORE_VERSION}'
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Throws an error if the provided assertion is falsy
 */
exports.CONSTANTS = CONSTANTS;
const assert = function (assertion, message) {
  if (!assertion) {
    throw assertionError(message);
  }
};
/**
 * Returns an Error object suitable for throwing.
 */
exports.assert = assert;
const assertionError = function (message) {
  return new Error('Firebase Database (' + CONSTANTS.SDK_VERSION + ') INTERNAL ASSERT FAILED: ' + message);
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.assertionError = assertionError;
const stringToByteArray$1 = function (str) {
  // TODO(user): Use native implementations if/when available
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 0xfc00) === 0xd800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
      // Surrogate Pair
      c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param bytes Array of numbers representing characters.
 * @return Stringification of the array.
 */
const byteArrayToString = function (bytes) {
  // TODO(user): Use native implementations if/when available
  const out = [];
  let pos = 0,
    c = 0;
  while (pos < bytes.length) {
    const c1 = bytes[pos++];
    if (c1 < 128) {
      out[c++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      const c2 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
    } else if (c1 > 239 && c1 < 365) {
      // Surrogate Pair
      const c2 = bytes[pos++];
      const c3 = bytes[pos++];
      const c4 = bytes[pos++];
      const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;
      out[c++] = String.fromCharCode(0xd800 + (u >> 10));
      out[c++] = String.fromCharCode(0xdc00 + (u & 1023));
    } else {
      const c2 = bytes[pos++];
      const c3 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
    }
  }
  return out.join('');
};
// We define it as an object literal instead of a class because a class compiled down to es5 can't
// be treeshaked. https://github.com/rollup/rollup/issues/1691
// Static lookup maps, lazily populated by init_()
const base64 = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + '+/=';
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + '-_.';
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob === 'function',
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(input, webSafe) {
    if (!Array.isArray(input)) {
      throw Error('encodeByteArray takes an array as a parameter');
    }
    this.init_();
    const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
    const output = [];
    for (let i = 0; i < input.length; i += 3) {
      const byte1 = input[i];
      const haveByte2 = i + 1 < input.length;
      const byte2 = haveByte2 ? input[i + 1] : 0;
      const haveByte3 = i + 2 < input.length;
      const byte3 = haveByte3 ? input[i + 2] : 0;
      const outByte1 = byte1 >> 2;
      const outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;
      let outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;
      let outByte4 = byte3 & 0x3f;
      if (!haveByte3) {
        outByte4 = 64;
        if (!haveByte2) {
          outByte3 = 64;
        }
      }
      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
    }
    return output.join('');
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(input, webSafe) {
    // Shortcut for Mozilla browsers that implement
    // a native base64 encoder in the form of "btoa/atob"
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return btoa(input);
    }
    return this.encodeByteArray(stringToByteArray$1(input), webSafe);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(input, webSafe) {
    // Shortcut for Mozilla browsers that implement
    // a native base64 encoder in the form of "btoa/atob"
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return atob(input);
    }
    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(input, webSafe) {
    this.init_();
    const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
    const output = [];
    for (let i = 0; i < input.length;) {
      const byte1 = charToByteMap[input.charAt(i++)];
      const haveByte2 = i < input.length;
      const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
      ++i;
      const haveByte3 = i < input.length;
      const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      const haveByte4 = i < input.length;
      const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
        throw Error();
      }
      const outByte1 = byte1 << 2 | byte2 >> 4;
      output.push(outByte1);
      if (byte3 !== 64) {
        const outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;
        output.push(outByte2);
        if (byte4 !== 64) {
          const outByte3 = byte3 << 6 & 0xc0 | byte4;
          output.push(outByte3);
        }
      }
    }
    return output;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {};
      this.charToByteMap_ = {};
      this.byteToCharMapWebSafe_ = {};
      this.charToByteMapWebSafe_ = {};
      // We want quick mappings back and forth, so we precompute two maps.
      for (let i = 0; i < this.ENCODED_VALS.length; i++) {
        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
        this.charToByteMap_[this.byteToCharMap_[i]] = i;
        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
        // Be forgiving when decoding and correctly decode both encodings.
        if (i >= this.ENCODED_VALS_BASE.length) {
          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
        }
      }
    }
  }
};
/**
 * URL-safe base64 encoding
 */
exports.base64 = base64;
const base64Encode = function (str) {
  const utf8Bytes = stringToByteArray$1(str);
  return base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 encoding (without "." padding in the end).
 * e.g. Used in JSON Web Token (JWT) parts.
 */
exports.base64Encode = base64Encode;
const base64urlEncodeWithoutPadding = function (str) {
  // Use base64url encoding and remove padding in the end (dot characters).
  return base64Encode(str).replace(/\./g, '');
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param str To be decoded
 * @return Decoded result, if possible
 */
exports.base64urlEncodeWithoutPadding = base64urlEncodeWithoutPadding;
const base64Decode = function (str) {
  try {
    return base64.decodeString(str, true);
  } catch (e) {
    console.error('base64Decode failed: ', e);
  }
  return null;
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Do a deep-copy of basic JavaScript Objects or Arrays.
 */
exports.base64Decode = base64Decode;
function deepCopy(value) {
  return deepExtend(undefined, value);
}
/**
 * Copy properties from source to target (recursively allows extension
 * of Objects and Arrays).  Scalar values in the target are over-written.
 * If target is undefined, an object of the appropriate type will be created
 * (and returned).
 *
 * We recursively copy all child properties of plain Objects in the source- so
 * that namespace- like dictionaries are merged.
 *
 * Note that the target can be a function, in which case the properties in
 * the source Object are copied onto it as static properties of the Function.
 *
 * Note: we don't merge __proto__ to prevent prototype pollution
 */
function deepExtend(target, source) {
  if (!(source instanceof Object)) {
    return source;
  }
  switch (source.constructor) {
    case Date:
      // Treat Dates like scalars; if the target date object had any child
      // properties - they will be lost!
      const dateValue = source;
      return new Date(dateValue.getTime());
    case Object:
      if (target === undefined) {
        target = {};
      }
      break;
    case Array:
      // Always copy the array source and overwrite the target.
      target = [];
      break;
    default:
      // Not a plain Object - treat it as a scalar.
      return source;
  }
  for (const prop in source) {
    // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202
    if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
      continue;
    }
    target[prop] = deepExtend(target[prop], source[prop]);
  }
  return target;
}
function isValidKey(key) {
  return key !== '__proto__';
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns navigator.userAgent string or '' if it's not defined.
 * @return user agent string
 */
function getUA() {
  if (typeof navigator !== 'undefined' && typeof navigator['userAgent'] === 'string') {
    return navigator['userAgent'];
  } else {
    return '';
  }
}
/**
 * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.
 *
 * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap
 * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally
 * wait for a callback.
 */
function isMobileCordova() {
  return typeof window !== 'undefined' &&
  // @ts-ignore Setting up an broadly applicable index signature for Window
  // just to deal with this case would probably be a bad idea.
  !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
}
/**
 * Detect Node.js.
 *
 * @return true if Node.js environment is detected.
 */
// Node detection logic from: https://github.com/iliakan/detect-node/
function isNode() {
  try {
    return Object.prototype.toString.call(global.process) === '[object process]';
  } catch (e) {
    return false;
  }
}
/**
 * Detect Browser Environment
 */
function isBrowser() {
  return typeof self === 'object' && self.self === self;
}
function isBrowserExtension() {
  const runtime = typeof chrome === 'object' ? chrome.runtime : typeof browser === 'object' ? browser.runtime : undefined;
  return typeof runtime === 'object' && runtime.id !== undefined;
}
/**
 * Detect React Native.
 *
 * @return true if ReactNative environment is detected.
 */
function isReactNative() {
  return typeof navigator === 'object' && navigator['product'] === 'ReactNative';
}
/** Detects Electron apps. */
function isElectron() {
  return getUA().indexOf('Electron/') >= 0;
}
/** Detects Internet Explorer. */
function isIE() {
  const ua = getUA();
  return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
}
/** Detects Universal Windows Platform apps. */
function isUWP() {
  return getUA().indexOf('MSAppHost/') >= 0;
}
/**
 * Detect whether the current SDK build is the Node version.
 *
 * @return true if it's the Node SDK build.
 */
function isNodeSdk() {
  return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
}
/** Returns true if we are running in Safari. */
function isSafari() {
  return !isNode() && navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome');
}
/**
 * This method checks if indexedDB is supported by current browser/service worker context
 * @return true if indexedDB is supported by current browser/service worker context
 */
function isIndexedDBAvailable() {
  return typeof indexedDB === 'object';
}
/**
 * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject
 * if errors occur during the database open operation.
 *
 * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox
 * private browsing)
 */
function validateIndexedDBOpenable() {
  return new Promise((resolve, reject) => {
    try {
      let preExist = true;
      const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';
      const request = self.indexedDB.open(DB_CHECK_NAME);
      request.onsuccess = () => {
        request.result.close();
        // delete database only when it doesn't pre-exist
        if (!preExist) {
          self.indexedDB.deleteDatabase(DB_CHECK_NAME);
        }
        resolve(true);
      };
      request.onupgradeneeded = () => {
        preExist = false;
      };
      request.onerror = () => {
        var _a;
        reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');
      };
    } catch (error) {
      reject(error);
    }
  });
}
/**
 *
 * This method checks whether cookie is enabled within current browser
 * @return true if cookie is enabled within current browser
 */
function areCookiesEnabled() {
  if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {
    return false;
  }
  return true;
}
/**
 * Polyfill for `globalThis` object.
 * @returns the `globalThis` object for the given environment.
 */
function getGlobal() {
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  throw new Error('Unable to locate global object.');
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;
/**
 * Attempt to read defaults from a JSON string provided to
 * process.env.__FIREBASE_DEFAULTS__ or a JSON file whose path is in
 * process.env.__FIREBASE_DEFAULTS_PATH__
 */
const getDefaultsFromEnvVariable = () => {
  if (typeof process === 'undefined' || typeof process.env === 'undefined') {
    return;
  }
  const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;
  if (defaultsJsonString) {
    return JSON.parse(defaultsJsonString);
  }
};
const getDefaultsFromCookie = () => {
  if (typeof document === 'undefined') {
    return;
  }
  let match;
  try {
    match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch (e) {
    // Some environments such as Angular Universal SSR have a
    // `document` object but error on accessing `document.cookie`.
    return;
  }
  const decoded = match && base64Decode(match[1]);
  return decoded && JSON.parse(decoded);
};
/**
 * Get the __FIREBASE_DEFAULTS__ object. It checks in order:
 * (1) if such an object exists as a property of `globalThis`
 * (2) if such an object was provided on a shell environment variable
 * (3) if such an object exists in a cookie
 */
const getDefaults = () => {
  try {
    return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();
  } catch (e) {
    /**
     * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due
     * to any environment case we have not accounted for. Log to
     * info instead of swallowing so we can find these unknown cases
     * and add paths for them if needed.
     */
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
    return;
  }
};
/**
 * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object
 * for the given product.
 * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available
 * @public
 */
const getDefaultEmulatorHost = productName => {
  var _a, _b;
  return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName];
};
/**
 * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object
 * for the given product.
 * @returns a pair of hostname and port like `["::1", 4000]` if available
 * @public
 */
exports.getDefaultEmulatorHost = getDefaultEmulatorHost;
const getDefaultEmulatorHostnameAndPort = productName => {
  const host = getDefaultEmulatorHost(productName);
  if (!host) {
    return undefined;
  }
  const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.
  if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {
    throw new Error(`Invalid host ${host} with no separate hostname and port!`);
  }
  // eslint-disable-next-line no-restricted-globals
  const port = parseInt(host.substring(separatorIndex + 1), 10);
  if (host[0] === '[') {
    // Bracket-quoted `[ipv6addr]:port` => return "ipv6addr" (without brackets).
    return [host.substring(1, separatorIndex - 1), port];
  } else {
    return [host.substring(0, separatorIndex), port];
  }
};
/**
 * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.
 * @public
 */
exports.getDefaultEmulatorHostnameAndPort = getDefaultEmulatorHostnameAndPort;
const getDefaultAppConfig = () => {
  var _a;
  return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;
};
/**
 * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties
 * prefixed by "_")
 * @public
 */
exports.getDefaultAppConfig = getDefaultAppConfig;
const getExperimentalSetting = name => {
  var _a;
  return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`];
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.getExperimentalSetting = getExperimentalSetting;
class Deferred {
  constructor() {
    this.reject = () => {};
    this.resolve = () => {};
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
  /**
   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(callback) {
    return (error, value) => {
      if (error) {
        this.reject(error);
      } else {
        this.resolve(value);
      }
      if (typeof callback === 'function') {
        // Attaching noop handler just in case developer wasn't expecting
        // promises
        this.promise.catch(() => {});
        // Some of our callbacks don't expect a value and our own tests
        // assert that the parameter length is 1
        if (callback.length === 1) {
          callback(error);
        } else {
          callback(error, value);
        }
      }
    };
  }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.Deferred = Deferred;
function createMockUserToken(token, projectId) {
  if (token.uid) {
    throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  }
  // Unsecured JWTs use "none" as the algorithm.
  const header = {
    alg: 'none',
    type: 'JWT'
  };
  const project = projectId || 'demo-project';
  const iat = token.iat || 0;
  const sub = token.sub || token.user_id;
  if (!sub) {
    throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  }
  const payload = Object.assign({
    // Set all required fields to decent defaults
    iss: `https://securetoken.google.com/${project}`,
    aud: project,
    iat,
    exp: iat + 3600,
    auth_time: iat,
    sub,
    user_id: sub,
    firebase: {
      sign_in_provider: 'custom',
      identities: {}
    }
  }, token);
  // Unsecured JWTs use the empty string as a signature.
  const signature = '';
  return [base64urlEncodeWithoutPadding(JSON.stringify(header)), base64urlEncodeWithoutPadding(JSON.stringify(payload)), signature].join('.');
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Standardized Firebase Error.
 *
 * Usage:
 *
 *   // Typescript string literals for type-safe codes
 *   type Err =
 *     'unknown' |
 *     'object-not-found'
 *     ;
 *
 *   // Closure enum for type-safe error codes
 *   // at-enum {string}
 *   var Err = {
 *     UNKNOWN: 'unknown',
 *     OBJECT_NOT_FOUND: 'object-not-found',
 *   }
 *
 *   let errors: Map<Err, string> = {
 *     'generic-error': "Unknown error",
 *     'file-not-found': "Could not find file: {$file}",
 *   };
 *
 *   // Type-safe function - must pass a valid error code as param.
 *   let error = new ErrorFactory<Err>('service', 'Service', errors);
 *
 *   ...
 *   throw error.create(Err.GENERIC);
 *   ...
 *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});
 *   ...
 *   // Service: Could not file file: foo.txt (service/file-not-found).
 *
 *   catch (e) {
 *     assert(e.message === "Could not find file: foo.txt.");
 *     if ((e as FirebaseError)?.code === 'service/file-not-found') {
 *       console.log("Could not read file: " + e['file']);
 *     }
 *   }
 */
const ERROR_NAME = 'FirebaseError';
// Based on code from:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
class FirebaseError extends Error {
  constructor( /** The error code for this error. */
  code, message, /** Custom data for this error. */
  customData) {
    super(message);
    this.code = code;
    this.customData = customData;
    /** The custom name for all FirebaseErrors. */
    this.name = ERROR_NAME;
    // Fix For ES5
    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
    Object.setPrototypeOf(this, FirebaseError.prototype);
    // Maintains proper stack trace for where our error was thrown.
    // Only available on V8.
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ErrorFactory.prototype.create);
    }
  }
}
exports.FirebaseError = FirebaseError;
class ErrorFactory {
  constructor(service, serviceName, errors) {
    this.service = service;
    this.serviceName = serviceName;
    this.errors = errors;
  }
  create(code, ...data) {
    const customData = data[0] || {};
    const fullCode = `${this.service}/${code}`;
    const template = this.errors[code];
    const message = template ? replaceTemplate(template, customData) : 'Error';
    // Service Name: Error message (service/code).
    const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
    const error = new FirebaseError(fullCode, fullMessage, customData);
    return error;
  }
}
exports.ErrorFactory = ErrorFactory;
function replaceTemplate(template, data) {
  return template.replace(PATTERN, (_, key) => {
    const value = data[key];
    return value != null ? String(value) : `<${key}?>`;
  });
}
const PATTERN = /\{\$([^}]+)}/g;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Evaluates a JSON string into a javascript object.
 *
 * @param {string} str A string containing JSON.
 * @return {*} The javascript object representing the specified JSON.
 */
function jsonEval(str) {
  return JSON.parse(str);
}
/**
 * Returns JSON representing a javascript object.
 * @param {*} data Javascript object to be stringified.
 * @return {string} The JSON contents of the object.
 */
function stringify(data) {
  return JSON.stringify(data);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Decodes a Firebase auth. token into constituent parts.
 *
 * Notes:
 * - May return with invalid / incomplete claims if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const decode = function (token) {
  let header = {},
    claims = {},
    data = {},
    signature = '';
  try {
    const parts = token.split('.');
    header = jsonEval(base64Decode(parts[0]) || '');
    claims = jsonEval(base64Decode(parts[1]) || '');
    signature = parts[2];
    data = claims['d'] || {};
    delete claims['d'];
  } catch (e) {}
  return {
    header,
    claims,
    data,
    signature
  };
};
/**
 * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the
 * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
exports.decode = decode;
const isValidTimestamp = function (token) {
  const claims = decode(token).claims;
  const now = Math.floor(new Date().getTime() / 1000);
  let validSince = 0,
    validUntil = 0;
  if (typeof claims === 'object') {
    if (claims.hasOwnProperty('nbf')) {
      validSince = claims['nbf'];
    } else if (claims.hasOwnProperty('iat')) {
      validSince = claims['iat'];
    }
    if (claims.hasOwnProperty('exp')) {
      validUntil = claims['exp'];
    } else {
      // token will expire after 24h by default
      validUntil = validSince + 86400;
    }
  }
  return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;
};
/**
 * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.
 *
 * Notes:
 * - May return null if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
exports.isValidTimestamp = isValidTimestamp;
const issuedAtTime = function (token) {
  const claims = decode(token).claims;
  if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {
    return claims['iat'];
  }
  return null;
};
/**
 * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
exports.issuedAtTime = issuedAtTime;
const isValidFormat = function (token) {
  const decoded = decode(token),
    claims = decoded.claims;
  return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');
};
/**
 * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
exports.isValidFormat = isValidFormat;
const isAdmin = function (token) {
  const claims = decode(token).claims;
  return typeof claims === 'object' && claims['admin'] === true;
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.isAdmin = isAdmin;
function contains(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function safeGet(obj, key) {
  if (Object.prototype.hasOwnProperty.call(obj, key)) {
    return obj[key];
  } else {
    return undefined;
  }
}
function isEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
function map(obj, fn, contextObj) {
  const res = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      res[key] = fn.call(contextObj, obj[key], key, obj);
    }
  }
  return res;
}
/**
 * Deep equal two objects. Support Arrays and Objects.
 */
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  for (const k of aKeys) {
    if (!bKeys.includes(k)) {
      return false;
    }
    const aProp = a[k];
    const bProp = b[k];
    if (isObject(aProp) && isObject(bProp)) {
      if (!deepEqual(aProp, bProp)) {
        return false;
      }
    } else if (aProp !== bProp) {
      return false;
    }
  }
  for (const k of bKeys) {
    if (!aKeys.includes(k)) {
      return false;
    }
  }
  return true;
}
function isObject(thing) {
  return thing !== null && typeof thing === 'object';
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Rejects if the given promise doesn't resolve in timeInMS milliseconds.
 * @internal
 */
function promiseWithTimeout(promise, timeInMS = 2000) {
  const deferredPromise = new Deferred();
  setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);
  promise.then(deferredPromise.resolve, deferredPromise.reject);
  return deferredPromise.promise;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a
 * params object (e.g. {arg: 'val', arg2: 'val2'})
 * Note: You must prepend it with ? when adding it to a URL.
 */
function querystring(querystringParams) {
  const params = [];
  for (const [key, value] of Object.entries(querystringParams)) {
    if (Array.isArray(value)) {
      value.forEach(arrayVal => {
        params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));
      });
    } else {
      params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
    }
  }
  return params.length ? '&' + params.join('&') : '';
}
/**
 * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object
 * (e.g. {arg: 'val', arg2: 'val2'})
 */
function querystringDecode(querystring) {
  const obj = {};
  const tokens = querystring.replace(/^\?/, '').split('&');
  tokens.forEach(token => {
    if (token) {
      const [key, value] = token.split('=');
      obj[decodeURIComponent(key)] = decodeURIComponent(value);
    }
  });
  return obj;
}
/**
 * Extract the query string part of a URL, including the leading question mark (if present).
 */
function extractQuerystring(url) {
  const queryStart = url.indexOf('?');
  if (!queryStart) {
    return '';
  }
  const fragmentStart = url.indexOf('#', queryStart);
  return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 */
/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 * @final
 * @struct
 */
class Sha1 {
  constructor() {
    /**
     * Holds the previous values of accumulated variables a-e in the compress_
     * function.
     * @private
     */
    this.chain_ = [];
    /**
     * A buffer holding the partially computed hash result.
     * @private
     */
    this.buf_ = [];
    /**
     * An array of 80 bytes, each a part of the message to be hashed.  Referred to
     * as the message schedule in the docs.
     * @private
     */
    this.W_ = [];
    /**
     * Contains data needed to pad messages less than 64 bytes.
     * @private
     */
    this.pad_ = [];
    /**
     * @private {number}
     */
    this.inbuf_ = 0;
    /**
     * @private {number}
     */
    this.total_ = 0;
    this.blockSize = 512 / 8;
    this.pad_[0] = 128;
    for (let i = 1; i < this.blockSize; ++i) {
      this.pad_[i] = 0;
    }
    this.reset();
  }
  reset() {
    this.chain_[0] = 0x67452301;
    this.chain_[1] = 0xefcdab89;
    this.chain_[2] = 0x98badcfe;
    this.chain_[3] = 0x10325476;
    this.chain_[4] = 0xc3d2e1f0;
    this.inbuf_ = 0;
    this.total_ = 0;
  }
  /**
   * Internal compress helper function.
   * @param buf Block to compress.
   * @param offset Offset of the block in the buffer.
   * @private
   */
  compress_(buf, offset) {
    if (!offset) {
      offset = 0;
    }
    const W = this.W_;
    // get 16 big endian words
    if (typeof buf === 'string') {
      for (let i = 0; i < 16; i++) {
        // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS
        // have a bug that turns the post-increment ++ operator into pre-increment
        // during JIT compilation.  We have code that depends heavily on SHA-1 for
        // correctness and which is affected by this bug, so I've removed all uses
        // of post-increment ++ in which the result value is used.  We can revert
        // this change once the Safari bug
        // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and
        // most clients have been updated.
        W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);
        offset += 4;
      }
    } else {
      for (let i = 0; i < 16; i++) {
        W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];
        offset += 4;
      }
    }
    // expand to 80 words
    for (let i = 16; i < 80; i++) {
      const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
      W[i] = (t << 1 | t >>> 31) & 0xffffffff;
    }
    let a = this.chain_[0];
    let b = this.chain_[1];
    let c = this.chain_[2];
    let d = this.chain_[3];
    let e = this.chain_[4];
    let f, k;
    // TODO(user): Try to unroll this loop to speed up the computation.
    for (let i = 0; i < 80; i++) {
      if (i < 40) {
        if (i < 20) {
          f = d ^ b & (c ^ d);
          k = 0x5a827999;
        } else {
          f = b ^ c ^ d;
          k = 0x6ed9eba1;
        }
      } else {
        if (i < 60) {
          f = b & c | d & (b | c);
          k = 0x8f1bbcdc;
        } else {
          f = b ^ c ^ d;
          k = 0xca62c1d6;
        }
      }
      const t = (a << 5 | a >>> 27) + f + e + k + W[i] & 0xffffffff;
      e = d;
      d = c;
      c = (b << 30 | b >>> 2) & 0xffffffff;
      b = a;
      a = t;
    }
    this.chain_[0] = this.chain_[0] + a & 0xffffffff;
    this.chain_[1] = this.chain_[1] + b & 0xffffffff;
    this.chain_[2] = this.chain_[2] + c & 0xffffffff;
    this.chain_[3] = this.chain_[3] + d & 0xffffffff;
    this.chain_[4] = this.chain_[4] + e & 0xffffffff;
  }
  update(bytes, length) {
    // TODO(johnlenz): tighten the function signature and remove this check
    if (bytes == null) {
      return;
    }
    if (length === undefined) {
      length = bytes.length;
    }
    const lengthMinusBlock = length - this.blockSize;
    let n = 0;
    // Using local instead of member variables gives ~5% speedup on Firefox 16.
    const buf = this.buf_;
    let inbuf = this.inbuf_;
    // The outer while loop should execute at most twice.
    while (n < length) {
      // When we have no data in the block to top up, we can directly process the
      // input buffer (assuming it contains sufficient data). This gives ~25%
      // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
      // the data is provided in large chunks (or in multiples of 64 bytes).
      if (inbuf === 0) {
        while (n <= lengthMinusBlock) {
          this.compress_(bytes, n);
          n += this.blockSize;
        }
      }
      if (typeof bytes === 'string') {
        while (n < length) {
          buf[inbuf] = bytes.charCodeAt(n);
          ++inbuf;
          ++n;
          if (inbuf === this.blockSize) {
            this.compress_(buf);
            inbuf = 0;
            // Jump to the outer loop so we use the full-block optimization.
            break;
          }
        }
      } else {
        while (n < length) {
          buf[inbuf] = bytes[n];
          ++inbuf;
          ++n;
          if (inbuf === this.blockSize) {
            this.compress_(buf);
            inbuf = 0;
            // Jump to the outer loop so we use the full-block optimization.
            break;
          }
        }
      }
    }
    this.inbuf_ = inbuf;
    this.total_ += length;
  }
  /** @override */
  digest() {
    const digest = [];
    let totalBits = this.total_ * 8;
    // Add pad 0x80 0x00*.
    if (this.inbuf_ < 56) {
      this.update(this.pad_, 56 - this.inbuf_);
    } else {
      this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
    }
    // Add # bits.
    for (let i = this.blockSize - 1; i >= 56; i--) {
      this.buf_[i] = totalBits & 255;
      totalBits /= 256; // Don't use bit-shifting here!
    }

    this.compress_(this.buf_);
    let n = 0;
    for (let i = 0; i < 5; i++) {
      for (let j = 24; j >= 0; j -= 8) {
        digest[n] = this.chain_[i] >> j & 255;
        ++n;
      }
    }
    return digest;
  }
}

/**
 * Helper to make a Subscribe function (just like Promise helps make a
 * Thenable).
 *
 * @param executor Function which can make calls to a single Observer
 *     as a proxy.
 * @param onNoObservers Callback when count of Observers goes to zero.
 */
exports.Sha1 = Sha1;
function createSubscribe(executor, onNoObservers) {
  const proxy = new ObserverProxy(executor, onNoObservers);
  return proxy.subscribe.bind(proxy);
}
/**
 * Implement fan-out for any number of Observers attached via a subscribe
 * function.
 */
class ObserverProxy {
  /**
   * @param executor Function which can make calls to a single Observer
   *     as a proxy.
   * @param onNoObservers Callback when count of Observers goes to zero.
   */
  constructor(executor, onNoObservers) {
    this.observers = [];
    this.unsubscribes = [];
    this.observerCount = 0;
    // Micro-task scheduling by calling task.then().
    this.task = Promise.resolve();
    this.finalized = false;
    this.onNoObservers = onNoObservers;
    // Call the executor asynchronously so subscribers that are called
    // synchronously after the creation of the subscribe function
    // can still receive the very first value generated in the executor.
    this.task.then(() => {
      executor(this);
    }).catch(e => {
      this.error(e);
    });
  }
  next(value) {
    this.forEachObserver(observer => {
      observer.next(value);
    });
  }
  error(error) {
    this.forEachObserver(observer => {
      observer.error(error);
    });
    this.close(error);
  }
  complete() {
    this.forEachObserver(observer => {
      observer.complete();
    });
    this.close();
  }
  /**
   * Subscribe function that can be used to add an Observer to the fan-out list.
   *
   * - We require that no event is sent to a subscriber sychronously to their
   *   call to subscribe().
   */
  subscribe(nextOrObserver, error, complete) {
    let observer;
    if (nextOrObserver === undefined && error === undefined && complete === undefined) {
      throw new Error('Missing Observer.');
    }
    // Assemble an Observer object when passed as callback functions.
    if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {
      observer = nextOrObserver;
    } else {
      observer = {
        next: nextOrObserver,
        error,
        complete
      };
    }
    if (observer.next === undefined) {
      observer.next = noop;
    }
    if (observer.error === undefined) {
      observer.error = noop;
    }
    if (observer.complete === undefined) {
      observer.complete = noop;
    }
    const unsub = this.unsubscribeOne.bind(this, this.observers.length);
    // Attempt to subscribe to a terminated Observable - we
    // just respond to the Observer with the final error or complete
    // event.
    if (this.finalized) {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      this.task.then(() => {
        try {
          if (this.finalError) {
            observer.error(this.finalError);
          } else {
            observer.complete();
          }
        } catch (e) {
          // nothing
        }
        return;
      });
    }
    this.observers.push(observer);
    return unsub;
  }
  // Unsubscribe is synchronous - we guarantee that no events are sent to
  // any unsubscribed Observer.
  unsubscribeOne(i) {
    if (this.observers === undefined || this.observers[i] === undefined) {
      return;
    }
    delete this.observers[i];
    this.observerCount -= 1;
    if (this.observerCount === 0 && this.onNoObservers !== undefined) {
      this.onNoObservers(this);
    }
  }
  forEachObserver(fn) {
    if (this.finalized) {
      // Already closed by previous event....just eat the additional values.
      return;
    }
    // Since sendOne calls asynchronously - there is no chance that
    // this.observers will become undefined.
    for (let i = 0; i < this.observers.length; i++) {
      this.sendOne(i, fn);
    }
  }
  // Call the Observer via one of it's callback function. We are careful to
  // confirm that the observe has not been unsubscribed since this asynchronous
  // function had been queued.
  sendOne(i, fn) {
    // Execute the callback asynchronously
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    this.task.then(() => {
      if (this.observers !== undefined && this.observers[i] !== undefined) {
        try {
          fn(this.observers[i]);
        } catch (e) {
          // Ignore exceptions raised in Observers or missing methods of an
          // Observer.
          // Log error to console. b/31404806
          if (typeof console !== 'undefined' && console.error) {
            console.error(e);
          }
        }
      }
    });
  }
  close(err) {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    if (err !== undefined) {
      this.finalError = err;
    }
    // Proxy is no longer needed - garbage collect references
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    this.task.then(() => {
      this.observers = undefined;
      this.onNoObservers = undefined;
    });
  }
}
/** Turn synchronous function into one called asynchronously. */
// eslint-disable-next-line @typescript-eslint/ban-types
function async(fn, onError) {
  return (...args) => {
    Promise.resolve(true).then(() => {
      fn(...args);
    }).catch(error => {
      if (onError) {
        onError(error);
      }
    });
  };
}
/**
 * Return true if the object passed in implements any of the named methods.
 */
function implementsAnyMethods(obj, methods) {
  if (typeof obj !== 'object' || obj === null) {
    return false;
  }
  for (const method of methods) {
    if (method in obj && typeof obj[method] === 'function') {
      return true;
    }
  }
  return false;
}
function noop() {
  // do nothing
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Check to make sure the appropriate number of arguments are provided for a public function.
 * Throws an error if it fails.
 *
 * @param fnName The function name
 * @param minCount The minimum number of arguments to allow for the function call
 * @param maxCount The maximum number of argument to allow for the function call
 * @param argCount The actual number of arguments provided.
 */
const validateArgCount = function (fnName, minCount, maxCount, argCount) {
  let argError;
  if (argCount < minCount) {
    argError = 'at least ' + minCount;
  } else if (argCount > maxCount) {
    argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;
  }
  if (argError) {
    const error = fnName + ' failed: Was called with ' + argCount + (argCount === 1 ? ' argument.' : ' arguments.') + ' Expects ' + argError + '.';
    throw new Error(error);
  }
};
/**
 * Generates a string to prefix an error message about failed argument validation
 *
 * @param fnName The function name
 * @param argName The name of the argument
 * @return The prefix to add to the error thrown for validation.
 */
exports.validateArgCount = validateArgCount;
function errorPrefix(fnName, argName) {
  return `${fnName} failed: ${argName} argument `;
}
/**
 * @param fnName
 * @param argumentNumber
 * @param namespace
 * @param optional
 */
function validateNamespace(fnName, namespace, optional) {
  if (optional && !namespace) {
    return;
  }
  if (typeof namespace !== 'string') {
    //TODO: I should do more validation here. We only allow certain chars in namespaces.
    throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');
  }
}
function validateCallback(fnName, argumentName,
// eslint-disable-next-line @typescript-eslint/ban-types
callback, optional) {
  if (optional && !callback) {
    return;
  }
  if (typeof callback !== 'function') {
    throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');
  }
}
function validateContextObject(fnName, argumentName, context, optional) {
  if (optional && !context) {
    return;
  }
  if (typeof context !== 'object' || context === null) {
    throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');
  }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they
// automatically replaced '\r\n' with '\n', and they didn't handle surrogate pairs,
// so it's been modified.
// Note that not all Unicode characters appear as single characters in JavaScript strings.
// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters
// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first
// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate
// pair).
// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3
/**
 * @param {string} str
 * @return {Array}
 */
const stringToByteArray = function (str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    // Is this the lead surrogate in a surrogate pair?
    if (c >= 0xd800 && c <= 0xdbff) {
      const high = c - 0xd800; // the high 10 bits.
      i++;
      assert(i < str.length, 'Surrogate pair missing trail surrogate.');
      const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.
      c = 0x10000 + (high << 10) + low;
    }
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if (c < 65536) {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
};
/**
 * Calculate length without actually converting; useful for doing cheaper validation.
 * @param {string} str
 * @return {number}
 */
exports.stringToByteArray = stringToByteArray;
const stringLength = function (str) {
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      p++;
    } else if (c < 2048) {
      p += 2;
    } else if (c >= 0xd800 && c <= 0xdbff) {
      // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.
      p += 4;
      i++; // skip trail surrogate.
    } else {
      p += 3;
    }
  }
  return p;
};

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Copied from https://stackoverflow.com/a/2117523
 * Generates a new uuid.
 * @public
 */
exports.stringLength = stringLength;
const uuidv4 = function () {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = Math.random() * 16 | 0,
      v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
};

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The amount of milliseconds to exponentially increase.
 */
exports.uuidv4 = uuidv4;
const DEFAULT_INTERVAL_MILLIS = 1000;
/**
 * The factor to backoff by.
 * Should be a number greater than 1.
 */
const DEFAULT_BACKOFF_FACTOR = 2;
/**
 * The maximum milliseconds to increase to.
 *
 * <p>Visible for testing
 */
const MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.
/**
 * The percentage of backoff time to randomize by.
 * See
 * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic
 * for context.
 *
 * <p>Visible for testing
 */
exports.MAX_VALUE_MILLIS = MAX_VALUE_MILLIS;
const RANDOM_FACTOR = 0.5;
/**
 * Based on the backoff method from
 * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.
 * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.
 */
exports.RANDOM_FACTOR = RANDOM_FACTOR;
function calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {
  // Calculates an exponentially increasing value.
  // Deviation: calculates value from count and a constant interval, so we only need to save value
  // and count to restore state.
  const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);
  // A random "fuzz" to avoid waves of retries.
  // Deviation: randomFactor is required.
  const randomWait = Math.round(
  // A fraction of the backoff value to add/subtract.
  // Deviation: changes multiplication order to improve readability.
  RANDOM_FACTOR * currBaseValue * (
  // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines
  // if we add or subtract.
  Math.random() - 0.5) * 2);
  // Limits backoff to max to avoid effectively permanent backoff.
  return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provide English ordinal letters after a number
 */
function ordinal(i) {
  if (!Number.isFinite(i)) {
    return `${i}`;
  }
  return i + indicator(i);
}
function indicator(i) {
  i = Math.abs(i);
  const cent = i % 100;
  if (cent >= 10 && cent <= 20) {
    return 'th';
  }
  const dec = i % 10;
  if (dec === 1) {
    return 'st';
  }
  if (dec === 2) {
    return 'nd';
  }
  if (dec === 3) {
    return 'rd';
  }
  return 'th';
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getModularInstance(service) {
  if (service && service._delegate) {
    return service._delegate;
  } else {
    return service;
  }
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":81}],71:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],72:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":71,"buffer":72,"ieee754":78}],73:[function(require,module,exports){
(function (global){(function (){
(function(a,b){if("function"==typeof define&&define.amd)define([],b);else if("undefined"!=typeof exports)b();else{b(),a.FileSaver={exports:{}}.exports}})(this,function(){"use strict";function b(a,b){return"undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error("could not download file")},d.send()}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"))}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof global&&global.global===global?global:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g,"undefined"!=typeof module&&(module.exports=g)});


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _app = require("@firebase/app");
Object.keys(_app).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _app[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _app[key];
    }
  });
});
var name = "firebase";
var version = "9.14.0";

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(0, _app.registerVersion)(name, version, 'app');

},{"@firebase/app":66}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _database = require("@firebase/database");
Object.keys(_database).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _database[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _database[key];
    }
  });
});

},{"@firebase/database":68}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deleteDB = deleteDB;
exports.openDB = openDB;
Object.defineProperty(exports, "unwrap", {
  enumerable: true,
  get: function () {
    return _wrapIdbValue.u;
  }
});
Object.defineProperty(exports, "wrap", {
  enumerable: true,
  get: function () {
    return _wrapIdbValue.w;
  }
});
var _wrapIdbValue = require("./wrap-idb-value.js");
/**
 * Open a database.
 *
 * @param name Name of the database.
 * @param version Schema version.
 * @param callbacks Additional callbacks.
 */
function openDB(name, version, {
  blocked,
  upgrade,
  blocking,
  terminated
} = {}) {
  const request = indexedDB.open(name, version);
  const openPromise = (0, _wrapIdbValue.w)(request);
  if (upgrade) {
    request.addEventListener('upgradeneeded', event => {
      upgrade((0, _wrapIdbValue.w)(request.result), event.oldVersion, event.newVersion, (0, _wrapIdbValue.w)(request.transaction));
    });
  }
  if (blocked) request.addEventListener('blocked', () => blocked());
  openPromise.then(db => {
    if (terminated) db.addEventListener('close', () => terminated());
    if (blocking) db.addEventListener('versionchange', () => blocking());
  }).catch(() => {});
  return openPromise;
}
/**
 * Delete a database.
 *
 * @param name Name of the database.
 */
function deleteDB(name, {
  blocked
} = {}) {
  const request = indexedDB.deleteDatabase(name);
  if (blocked) request.addEventListener('blocked', () => blocked());
  return (0, _wrapIdbValue.w)(request).then(() => undefined);
}
const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
const writeMethods = ['put', 'add', 'delete', 'clear'];
const cachedMethods = new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {
    return;
  }
  if (cachedMethods.get(prop)) return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, '');
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
  // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
    return;
  }
  const method = async function (storeName, ...args) {
    // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
    const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
    let target = tx.store;
    if (useIndex) target = target.index(args.shift());
    // Must reject if op rejects.
    // If it's a write operation, must reject if tx.done rejects.
    // Must reject with op rejection first.
    // Must resolve with op value.
    // Must handle both promises (no unhandled rejections)
    return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
(0, _wrapIdbValue.r)(oldTraps => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));

},{"./wrap-idb-value.js":77}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.i = exports.a = void 0;
exports.r = replaceTraps;
exports.u = void 0;
exports.w = wrap;
const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);
exports.i = instanceOfAny;
let idbProxyableTypes;
let cursorAdvanceMethods;
// This is a function to prevent it throwing up in node environments.
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);
}
// This is a function to prevent it throwing up in node environments.
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);
}
const cursorRequestMap = new WeakMap();
const transactionDoneMap = new WeakMap();
const transactionStoreNamesMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
exports.a = reverseTransformCache;
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener('success', success);
      request.removeEventListener('error', error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener('success', success);
    request.addEventListener('error', error);
  });
  promise.then(value => {
    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
    // (see wrapFunction).
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
    // Catching to avoid "Uncaught Promise exceptions"
  }).catch(() => {});
  // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
  // is because we create many promises from a single IDBRequest.
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  // Early bail if we've already created a done promise for this transaction.
  if (transactionDoneMap.has(tx)) return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener('complete', complete);
      tx.removeEventListener('error', error);
      tx.removeEventListener('abort', error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException('AbortError', 'AbortError'));
      unlisten();
    };
    tx.addEventListener('complete', complete);
    tx.addEventListener('error', error);
    tx.addEventListener('abort', error);
  });
  // Cache it for later retrieval.
  transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      // Special handling for transaction.done.
      if (prop === 'done') return transactionDoneMap.get(target);
      // Polyfill for objectStoreNames because of Edge.
      if (prop === 'objectStoreNames') {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      // Make tx.store return the only store in the transaction, or undefined if there are many.
      if (prop === 'store') {
        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    // Else transform whatever we get back.
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  // Due to expected object equality (which is enforced by the caching in `wrap`), we
  // only create one new func per func.
  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {
    return function (storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
  // with real promises, so each advance methods returns a new promise for the cursor object, or
  // undefined if the end of the cursor has been reached.
  if (getCursorAdvanceMethods().includes(func)) {
    return function (...args) {
      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
      // the original object.
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function (...args) {
    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
    // the original object.
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === 'function') return wrapFunction(value);
  // This doesn't return, it just creates a 'done' promise for the transaction,
  // which is later returned for transaction.done (see idbObjectHandler).
  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);
  // Return the same value back if we're not going to transform it.
  return value;
}
function wrap(value) {
  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
  if (value instanceof IDBRequest) return promisifyRequest(value);
  // If we've already transformed this value before, reuse the transformed value.
  // This is faster, but it also provides object equality.
  if (transformCache.has(value)) return transformCache.get(value);
  const newValue = transformCachableValue(value);
  // Not all types are transformed.
  // These may be primitive types, so they can't be WeakMap keys.
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
const unwrap = value => reverseTransformCache.get(value);
exports.u = unwrap;

},{}],78:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],79:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,setImmediate){(function (){
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/

!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).JSZip=e()}}(function(){return function s(a,o,h){function u(r,e){if(!o[r]){if(!a[r]){var t="function"==typeof require&&require;if(!e&&t)return t(r,!0);if(l)return l(r,!0);var n=new Error("Cannot find module '"+r+"'");throw n.code="MODULE_NOT_FOUND",n}var i=o[r]={exports:{}};a[r][0].call(i.exports,function(e){var t=a[r][1][e];return u(t||e)},i,i.exports,s,a,o,h)}return o[r].exports}for(var l="function"==typeof require&&require,e=0;e<h.length;e++)u(h[e]);return u}({1:[function(e,t,r){"use strict";var d=e("./utils"),c=e("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(e){for(var t,r,n,i,s,a,o,h=[],u=0,l=e.length,f=l,c="string"!==d.getTypeOf(e);u<e.length;)f=l-u,n=c?(t=e[u++],r=u<l?e[u++]:0,u<l?e[u++]:0):(t=e.charCodeAt(u++),r=u<l?e.charCodeAt(u++):0,u<l?e.charCodeAt(u++):0),i=t>>2,s=(3&t)<<4|r>>4,a=1<f?(15&r)<<2|n>>6:64,o=2<f?63&n:64,h.push(p.charAt(i)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join("")},r.decode=function(e){var t,r,n,i,s,a,o=0,h=0,u="data:";if(e.substr(0,u.length)===u)throw new Error("Invalid base64 input, it looks like a data url.");var l,f=3*(e=e.replace(/[^A-Za-z0-9+/=]/g,"")).length/4;if(e.charAt(e.length-1)===p.charAt(64)&&f--,e.charAt(e.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(l=c.uint8array?new Uint8Array(0|f):new Array(0|f);o<e.length;)t=p.indexOf(e.charAt(o++))<<2|(i=p.indexOf(e.charAt(o++)))>>4,r=(15&i)<<4|(s=p.indexOf(e.charAt(o++)))>>2,n=(3&s)<<6|(a=p.indexOf(e.charAt(o++))),l[h++]=t,64!==s&&(l[h++]=r),64!==a&&(l[h++]=n);return l}},{"./support":30,"./utils":32}],2:[function(e,t,r){"use strict";var n=e("./external"),i=e("./stream/DataWorker"),s=e("./stream/Crc32Probe"),a=e("./stream/DataLengthProbe");function o(e,t,r,n,i){this.compressedSize=e,this.uncompressedSize=t,this.crc32=r,this.compression=n,this.compressedContent=i}o.prototype={getContentWorker:function(){var e=new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")),t=this;return e.on("end",function(){if(this.streamInfo.data_length!==t.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),e},getCompressedWorker:function(){return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(e,t,r){return e.pipe(new s).pipe(new a("uncompressedSize")).pipe(t.compressWorker(r)).pipe(new a("compressedSize")).withStreamInfo("compression",t)},t.exports=o},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(e,t,r){"use strict";var n=e("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(){return new n("STORE compression")},uncompressWorker:function(){return new n("STORE decompression")}},r.DEFLATE=e("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(e,t,r){"use strict";var n=e("./utils");var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}();t.exports=function(e,t){return void 0!==e&&e.length?"string"!==n.getTypeOf(e)?function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return-1^e}(0|t,e,e.length,0):function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t.charCodeAt(a))];return-1^e}(0|t,e,e.length,0):0}},{"./utils":32}],5:[function(e,t,r){"use strict";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(e,t,r){"use strict";var n=null;n="undefined"!=typeof Promise?Promise:e("lie"),t.exports={Promise:n}},{lie:37}],7:[function(e,t,r){"use strict";var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,i=e("pako"),s=e("./utils"),a=e("./stream/GenericWorker"),o=n?"uint8array":"array";function h(e,t){a.call(this,"FlateWorker/"+e),this._pako=null,this._pakoAction=e,this._pakoOptions=t,this.meta={}}r.magic="\b\0",s.inherits(h,a),h.prototype.processChunk=function(e){this.meta=e.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,e.data),!1)},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},h.prototype._createPako=function(){this._pako=new i[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var t=this;this._pako.onData=function(e){t.push({data:e,meta:t.meta})}},r.compressWorker=function(e){return new h("Deflate",e)},r.uncompressWorker=function(){return new h("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(e,t,r){"use strict";function A(e,t){var r,n="";for(r=0;r<t;r++)n+=String.fromCharCode(255&e),e>>>=8;return n}function n(e,t,r,n,i,s){var a,o,h=e.file,u=e.compression,l=s!==O.utf8encode,f=I.transformTo("string",s(h.name)),c=I.transformTo("string",O.utf8encode(h.name)),d=h.comment,p=I.transformTo("string",s(d)),m=I.transformTo("string",O.utf8encode(d)),_=c.length!==h.name.length,g=m.length!==d.length,b="",v="",y="",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};t&&!r||(x.crc32=e.crc32,x.compressedSize=e.compressedSize,x.uncompressedSize=e.uncompressedSize);var S=0;t&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),"UNIX"===i?(C=798,z|=function(e,t){var r=e;return e||(r=t?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(e){return 63&(e||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+c,b+="up"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+="uc"+A(y.length,2)+y);var E="";return E+="\n\0",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+"\0\0\0\0"+A(z,4)+A(n,4)+f+b+p}}var I=e("../utils"),i=e("../stream/GenericWorker"),O=e("../utf8"),B=e("../crc32"),R=e("../signature");function s(e,t,r,n){i.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=t,this.zipPlatform=r,this.encodeFileName=n,this.streamFiles=e,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}I.inherits(s,i),s.prototype.push=function(e){var t=e.meta.percent||0,r=this.entriesCount,n=this._sources.length;this.accumulate?this.contentBuffer.push(e):(this.bytesWritten+=e.data.length,i.prototype.push.call(this,{data:e.data,meta:{currentFile:this.currentFile,percent:r?(t+100*(r-n-1))/r:100}}))},s.prototype.openedSource=function(e){this.currentSourceOffset=this.bytesWritten,this.currentFile=e.file.name;var t=this.streamFiles&&!e.file.dir;if(t){var r=n(e,t,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},s.prototype.closedSource=function(e){this.accumulate=!1;var t=this.streamFiles&&!e.file.dir,r=n(e,t,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),t)this.push({data:function(e){return R.DATA_DESCRIPTOR+A(e.crc32,4)+A(e.compressedSize,4)+A(e.uncompressedSize,4)}(e),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},s.prototype.flush=function(){for(var e=this.bytesWritten,t=0;t<this.dirRecords.length;t++)this.push({data:this.dirRecords[t],meta:{percent:100}});var r=this.bytesWritten-e,n=function(e,t,r,n,i){var s=I.transformTo("string",i(n));return R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+A(e,2)+A(e,2)+A(t,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,e,this.zipComment,this.encodeFileName);this.push({data:n,meta:{percent:100}})},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},s.prototype.registerPrevious=function(e){this._sources.push(e);var t=this;return e.on("data",function(e){t.processChunk(e)}),e.on("end",function(){t.closedSource(t.previous.streamInfo),t._sources.length?t.prepareNextSource():t.end()}),e.on("error",function(e){t.error(e)}),this},s.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(e){var t=this._sources;if(!i.prototype.error.call(this,e))return!1;for(var r=0;r<t.length;r++)try{t[r].error(e)}catch(e){}return!0},s.prototype.lock=function(){i.prototype.lock.call(this);for(var e=this._sources,t=0;t<e.length;t++)e[t].lock()},t.exports=s},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(e,t,r){"use strict";var u=e("../compressions"),n=e("./ZipFileWorker");r.generateWorker=function(e,a,t){var o=new n(a.streamFiles,t,a.platform,a.encodeFileName),h=0;try{e.forEach(function(e,t){h++;var r=function(e,t){var r=e||t,n=u[r];if(!n)throw new Error(r+" is not a valid compression method !");return n}(t.options.compression,a.compression),n=t.options.compressionOptions||a.compressionOptions||{},i=t.dir,s=t.date;t._compressWorker(r,n).withStreamInfo("file",{name:e,dir:i,date:s,comment:t.comment||"",unixPermissions:t.unixPermissions,dosPermissions:t.dosPermissions}).pipe(o)}),o.entriesCount=h}catch(e){o.error(e)}return o}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(e,t,r){"use strict";function n(){if(!(this instanceof n))return new n;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var e=new n;for(var t in this)"function"!=typeof this[t]&&(e[t]=this[t]);return e}}(n.prototype=e("./object")).loadAsync=e("./load"),n.support=e("./support"),n.defaults=e("./defaults"),n.version="3.10.1",n.loadAsync=function(e,t){return(new n).loadAsync(e,t)},n.external=e("./external"),t.exports=n},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(e,t,r){"use strict";var u=e("./utils"),i=e("./external"),n=e("./utf8"),s=e("./zipEntries"),a=e("./stream/Crc32Probe"),l=e("./nodejsUtils");function f(n){return new i.Promise(function(e,t){var r=n.decompressed.getContentWorker().pipe(new a);r.on("error",function(e){t(e)}).on("end",function(){r.streamInfo.crc32!==n.decompressed.crc32?t(new Error("Corrupted zip : CRC32 mismatch")):e()}).resume()})}t.exports=function(e,o){var h=this;return o=u.extend(o||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:n.utf8decode}),l.isNode&&l.isStream(e)?i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):u.prepareContent("the loaded zip file",e,!0,o.optimizedBinaryString,o.base64).then(function(e){var t=new s(o);return t.load(e),t}).then(function(e){var t=[i.Promise.resolve(e)],r=e.files;if(o.checkCRC32)for(var n=0;n<r.length;n++)t.push(f(r[n]));return i.Promise.all(t)}).then(function(e){for(var t=e.shift(),r=t.files,n=0;n<r.length;n++){var i=r[n],s=i.fileNameStr,a=u.resolve(i.fileNameStr);h.file(a,i.decompressed,{binary:!0,optimizedBinaryString:!0,date:i.date,dir:i.dir,comment:i.fileCommentStr.length?i.fileCommentStr:null,unixPermissions:i.unixPermissions,dosPermissions:i.dosPermissions,createFolders:o.createFolders}),i.dir||(h.file(a).unsafeOriginalName=s)}return t.zipComment.length&&(h.comment=t.zipComment),h})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(e,t,r){"use strict";var n=e("../utils"),i=e("../stream/GenericWorker");function s(e,t){i.call(this,"Nodejs stream input adapter for "+e),this._upstreamEnded=!1,this._bindStream(t)}n.inherits(s,i),s.prototype._bindStream=function(e){var t=this;(this._stream=e).pause(),e.on("data",function(e){t.push({data:e,meta:{percent:0}})}).on("error",function(e){t.isPaused?this.generatedError=e:t.error(e)}).on("end",function(){t.isPaused?t._upstreamEnded=!0:t.end()})},s.prototype.pause=function(){return!!i.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},t.exports=s},{"../stream/GenericWorker":28,"../utils":32}],13:[function(e,t,r){"use strict";var i=e("readable-stream").Readable;function n(e,t,r){i.call(this,t),this._helper=e;var n=this;e.on("data",function(e,t){n.push(e)||n._helper.pause(),r&&r(t)}).on("error",function(e){n.emit("error",e)}).on("end",function(){n.push(null)})}e("../utils").inherits(n,i),n.prototype._read=function(){this._helper.resume()},t.exports=n},{"../utils":32,"readable-stream":16}],14:[function(e,t,r){"use strict";t.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(e,t){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(e,t);if("number"==typeof e)throw new Error('The "data" argument must not be a number');return new Buffer(e,t)},allocBuffer:function(e){if(Buffer.alloc)return Buffer.alloc(e);var t=new Buffer(e);return t.fill(0),t},isBuffer:function(e){return Buffer.isBuffer(e)},isStream:function(e){return e&&"function"==typeof e.on&&"function"==typeof e.pause&&"function"==typeof e.resume}}},{}],15:[function(e,t,r){"use strict";function s(e,t,r){var n,i=u.getTypeOf(t),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(e=g(e)),s.createFolders&&(n=_(e))&&b.call(this,n,!0);var a="string"===i&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(t instanceof c&&0===t.uncompressedSize||s.dir||!t||0===t.length)&&(s.base64=!1,s.binary=!0,t="",s.compression="STORE",i="string");var o=null;o=t instanceof c||t instanceof l?t:p.isNode&&p.isStream(t)?new m(e,t):u.prepareContent(e,t,s.binary,s.optimizedBinaryString,s.base64);var h=new d(e,o,s);this.files[e]=h}var i=e("./utf8"),u=e("./utils"),l=e("./stream/GenericWorker"),a=e("./stream/StreamHelper"),f=e("./defaults"),c=e("./compressedObject"),d=e("./zipObject"),o=e("./generate"),p=e("./nodejsUtils"),m=e("./nodejs/NodejsStreamInputAdapter"),_=function(e){"/"===e.slice(-1)&&(e=e.substring(0,e.length-1));var t=e.lastIndexOf("/");return 0<t?e.substring(0,t):""},g=function(e){return"/"!==e.slice(-1)&&(e+="/"),e},b=function(e,t){return t=void 0!==t?t:f.createFolders,e=g(e),this.files[e]||s.call(this,e,null,{dir:!0,createFolders:t}),this.files[e]};function h(e){return"[object RegExp]"===Object.prototype.toString.call(e)}var n={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(e){var t,r,n;for(t in this.files)n=this.files[t],(r=t.slice(this.root.length,t.length))&&t.slice(0,this.root.length)===this.root&&e(r,n)},filter:function(r){var n=[];return this.forEach(function(e,t){r(e,t)&&n.push(t)}),n},file:function(e,t,r){if(1!==arguments.length)return e=this.root+e,s.call(this,e,t,r),this;if(h(e)){var n=e;return this.filter(function(e,t){return!t.dir&&n.test(e)})}var i=this.files[this.root+e];return i&&!i.dir?i:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(e,t){return t.dir&&r.test(e)});var e=this.root+r,t=b.call(this,e),n=this.clone();return n.root=t.name,n},remove:function(r){r=this.root+r;var e=this.files[r];if(e||("/"!==r.slice(-1)&&(r+="/"),e=this.files[r]),e&&!e.dir)delete this.files[r];else for(var t=this.filter(function(e,t){return t.name.slice(0,r.length)===r}),n=0;n<t.length;n++)delete this.files[t[n].name];return this},generate:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(e){var t,r={};try{if((r=u.extend(e||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:i.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");u.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var n=r.comment||this.comment||"";t=o.generateWorker(this,r,n)}catch(e){(t=new l("error")).error(e)}return new a(t,r.type||"string",r.mimeType)},generateAsync:function(e,t){return this.generateInternalStream(e).accumulate(t)},generateNodeStream:function(e,t){return(e=e||{}).type||(e.type="nodebuffer"),this.generateInternalStream(e).toNodejsStream(t)}};t.exports=n},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(e,t,r){"use strict";t.exports=e("stream")},{stream:void 0}],17:[function(e,t,r){"use strict";var n=e("./DataReader");function i(e){n.call(this,e);for(var t=0;t<this.data.length;t++)e[t]=255&e[t]}e("../utils").inherits(i,n),i.prototype.byteAt=function(e){return this.data[this.zero+e]},i.prototype.lastIndexOfSignature=function(e){for(var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===t&&this.data[s+1]===r&&this.data[s+2]===n&&this.data[s+3]===i)return s-this.zero;return-1},i.prototype.readAndCheckSignature=function(e){var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.readData(4);return t===s[0]&&r===s[1]&&n===s[2]&&i===s[3]},i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return[];var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{"../utils":32,"./DataReader":18}],18:[function(e,t,r){"use strict";var n=e("../utils");function i(e){this.data=e,this.length=e.length,this.index=0,this.zero=0}i.prototype={checkOffset:function(e){this.checkIndex(this.index+e)},checkIndex:function(e){if(this.length<this.zero+e||e<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+e+"). Corrupted zip ?")},setIndex:function(e){this.checkIndex(e),this.index=e},skip:function(e){this.setIndex(this.index+e)},byteAt:function(){},readInt:function(e){var t,r=0;for(this.checkOffset(e),t=this.index+e-1;t>=this.index;t--)r=(r<<8)+this.byteAt(t);return this.index+=e,r},readString:function(e){return n.transformTo("string",this.readData(e))},readData:function(){},lastIndexOfSignature:function(){},readAndCheckSignature:function(){},readDate:function(){var e=this.readInt(4);return new Date(Date.UTC(1980+(e>>25&127),(e>>21&15)-1,e>>16&31,e>>11&31,e>>5&63,(31&e)<<1))}},t.exports=i},{"../utils":32}],19:[function(e,t,r){"use strict";var n=e("./Uint8ArrayReader");function i(e){n.call(this,e)}e("../utils").inherits(i,n),i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(e,t,r){"use strict";var n=e("./DataReader");function i(e){n.call(this,e)}e("../utils").inherits(i,n),i.prototype.byteAt=function(e){return this.data.charCodeAt(this.zero+e)},i.prototype.lastIndexOfSignature=function(e){return this.data.lastIndexOf(e)-this.zero},i.prototype.readAndCheckSignature=function(e){return e===this.readData(4)},i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{"../utils":32,"./DataReader":18}],21:[function(e,t,r){"use strict";var n=e("./ArrayReader");function i(e){n.call(this,e)}e("../utils").inherits(i,n),i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return new Uint8Array(0);var t=this.data.subarray(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{"../utils":32,"./ArrayReader":17}],22:[function(e,t,r){"use strict";var n=e("../utils"),i=e("../support"),s=e("./ArrayReader"),a=e("./StringReader"),o=e("./NodeBufferReader"),h=e("./Uint8ArrayReader");t.exports=function(e){var t=n.getTypeOf(e);return n.checkSupport(t),"string"!==t||i.uint8array?"nodebuffer"===t?new o(e):i.uint8array?new h(n.transformTo("uint8array",e)):new s(n.transformTo("array",e)):new a(e)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(e,t,r){"use strict";r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b"},{}],24:[function(e,t,r){"use strict";var n=e("./GenericWorker"),i=e("../utils");function s(e){n.call(this,"ConvertWorker to "+e),this.destType=e}i.inherits(s,n),s.prototype.processChunk=function(e){this.push({data:i.transformTo(this.destType,e.data),meta:e.meta})},t.exports=s},{"../utils":32,"./GenericWorker":28}],25:[function(e,t,r){"use strict";var n=e("./GenericWorker"),i=e("../crc32");function s(){n.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}e("../utils").inherits(s,n),s.prototype.processChunk=function(e){this.streamInfo.crc32=i(e.data,this.streamInfo.crc32||0),this.push(e)},t.exports=s},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(e,t,r){"use strict";var n=e("../utils"),i=e("./GenericWorker");function s(e){i.call(this,"DataLengthProbe for "+e),this.propName=e,this.withStreamInfo(e,0)}n.inherits(s,i),s.prototype.processChunk=function(e){if(e){var t=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=t+e.data.length}i.prototype.processChunk.call(this,e)},t.exports=s},{"../utils":32,"./GenericWorker":28}],27:[function(e,t,r){"use strict";var n=e("../utils"),i=e("./GenericWorker");function s(e){i.call(this,"DataWorker");var t=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,e.then(function(e){t.dataIsReady=!0,t.data=e,t.max=e&&e.length||0,t.type=n.getTypeOf(e),t.isPaused||t._tickAndRepeat()},function(e){t.error(e)})}n.inherits(s,i),s.prototype.cleanUp=function(){i.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,n.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(n.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var e=null,t=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":e=this.data.substring(this.index,t);break;case"uint8array":e=this.data.subarray(this.index,t);break;case"array":case"nodebuffer":e=this.data.slice(this.index,t)}return this.index=t,this.push({data:e,meta:{percent:this.max?this.index/this.max*100:0}})},t.exports=s},{"../utils":32,"./GenericWorker":28}],28:[function(e,t,r){"use strict";function n(e){this.name=e||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}n.prototype={push:function(e){this.emit("data",e)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(e){this.emit("error",e)}return!0},error:function(e){return!this.isFinished&&(this.isPaused?this.generatedError=e:(this.isFinished=!0,this.emit("error",e),this.previous&&this.previous.error(e),this.cleanUp()),!0)},on:function(e,t){return this._listeners[e].push(t),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(e,t){if(this._listeners[e])for(var r=0;r<this._listeners[e].length;r++)this._listeners[e][r].call(this,t)},pipe:function(e){return e.registerPrevious(this)},registerPrevious:function(e){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=e.streamInfo,this.mergeStreamInfo(),this.previous=e;var t=this;return e.on("data",function(e){t.processChunk(e)}),e.on("end",function(){t.end()}),e.on("error",function(e){t.error(e)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var e=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),e=!0),this.previous&&this.previous.resume(),!e},flush:function(){},processChunk:function(e){this.push(e)},withStreamInfo:function(e,t){return this.extraStreamInfo[e]=t,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var e in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo,e)&&(this.streamInfo[e]=this.extraStreamInfo[e])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var e="Worker "+this.name;return this.previous?this.previous+" -> "+e:e}},t.exports=n},{}],29:[function(e,t,r){"use strict";var h=e("../utils"),i=e("./ConvertWorker"),s=e("./GenericWorker"),u=e("../base64"),n=e("../support"),a=e("../external"),o=null;if(n.nodestream)try{o=e("../nodejs/NodejsStreamOutputAdapter")}catch(e){}function l(e,o){return new a.Promise(function(t,r){var n=[],i=e._internalType,s=e._outputType,a=e._mimeType;e.on("data",function(e,t){n.push(e),o&&o(t)}).on("error",function(e){n=[],r(e)}).on("end",function(){try{var e=function(e,t,r){switch(e){case"blob":return h.newBlob(h.transformTo("arraybuffer",t),r);case"base64":return u.encode(t);default:return h.transformTo(e,t)}}(s,function(e,t){var r,n=0,i=null,s=0;for(r=0;r<t.length;r++)s+=t[r].length;switch(e){case"string":return t.join("");case"array":return Array.prototype.concat.apply([],t);case"uint8array":for(i=new Uint8Array(s),r=0;r<t.length;r++)i.set(t[r],n),n+=t[r].length;return i;case"nodebuffer":return Buffer.concat(t);default:throw new Error("concat : unsupported type '"+e+"'")}}(i,n),a);t(e)}catch(e){r(e)}n=[]}).resume()})}function f(e,t,r){var n=t;switch(t){case"blob":case"arraybuffer":n="uint8array";break;case"base64":n="string"}try{this._internalType=n,this._outputType=t,this._mimeType=r,h.checkSupport(n),this._worker=e.pipe(new i(n)),e.lock()}catch(e){this._worker=new s("error"),this._worker.error(e)}}f.prototype={accumulate:function(e){return l(this,e)},on:function(e,t){var r=this;return"data"===e?this._worker.on(e,function(e){t.call(r,e.data,e.meta)}):this._worker.on(e,function(){h.delay(t,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(e){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},e)}},t.exports=f},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(e,t,r){"use strict";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else{var n=new ArrayBuffer(0);try{r.blob=0===new Blob([n],{type:"application/zip"}).size}catch(e){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);i.append(n),r.blob=0===i.getBlob("application/zip").size}catch(e){r.blob=!1}}}try{r.nodestream=!!e("readable-stream").Readable}catch(e){r.nodestream=!1}},{"readable-stream":16}],31:[function(e,t,s){"use strict";for(var o=e("./utils"),h=e("./support"),r=e("./nodejsUtils"),n=e("./stream/GenericWorker"),u=new Array(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;u[254]=u[254]=1;function a(){n.call(this,"utf-8 decode"),this.leftOver=null}function l(){n.call(this,"utf-8 encode")}s.utf8encode=function(e){return h.nodebuffer?r.newBufferFrom(e,"utf-8"):function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=h.uint8array?new Uint8Array(o):new Array(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t}(e)},s.utf8decode=function(e){return h.nodebuffer?o.transformTo("nodebuffer",e).toString("utf-8"):function(e){var t,r,n,i,s=e.length,a=new Array(2*s);for(t=r=0;t<s;)if((n=e[t++])<128)a[r++]=n;else if(4<(i=u[n]))a[r++]=65533,t+=i-1;else{for(n&=2===i?31:3===i?15:7;1<i&&t<s;)n=n<<6|63&e[t++],i--;1<i?a[r++]=65533:n<65536?a[r++]=n:(n-=65536,a[r++]=55296|n>>10&1023,a[r++]=56320|1023&n)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(e=o.transformTo(h.uint8array?"uint8array":"array",e))},o.inherits(a,n),a.prototype.processChunk=function(e){var t=o.transformTo(h.uint8array?"uint8array":"array",e.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=t;(t=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),t.set(r,this.leftOver.length)}else t=this.leftOver.concat(t);this.leftOver=null}var n=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+u[e[r]]>t?r:t}(t),i=t;n!==t.length&&(h.uint8array?(i=t.subarray(0,n),this.leftOver=t.subarray(n,t.length)):(i=t.slice(0,n),this.leftOver=t.slice(n,t.length))),this.push({data:s.utf8decode(i),meta:e.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(l,n),l.prototype.processChunk=function(e){this.push({data:s.utf8encode(e.data),meta:e.meta})},s.Utf8EncodeWorker=l},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(e,t,a){"use strict";var o=e("./support"),h=e("./base64"),r=e("./nodejsUtils"),u=e("./external");function n(e){return e}function l(e,t){for(var r=0;r<e.length;++r)t[r]=255&e.charCodeAt(r);return t}e("setimmediate"),a.newBlob=function(t,r){a.checkSupport("blob");try{return new Blob([t],{type:r})}catch(e){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return n.append(t),n.getBlob(r)}catch(e){throw new Error("Bug : can't construct the Blob.")}}};var i={stringifyByChunk:function(e,t,r){var n=[],i=0,s=e.length;if(s<=r)return String.fromCharCode.apply(null,e);for(;i<s;)"array"===t||"nodebuffer"===t?n.push(String.fromCharCode.apply(null,e.slice(i,Math.min(i+r,s)))):n.push(String.fromCharCode.apply(null,e.subarray(i,Math.min(i+r,s)))),i+=r;return n.join("")},stringifyByChar:function(e){for(var t="",r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(e){return!1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(e){return!1}}()}};function s(e){var t=65536,r=a.getTypeOf(e),n=!0;if("uint8array"===r?n=i.applyCanBeUsed.uint8array:"nodebuffer"===r&&(n=i.applyCanBeUsed.nodebuffer),n)for(;1<t;)try{return i.stringifyByChunk(e,r,t)}catch(e){t=Math.floor(t/2)}return i.stringifyByChar(e)}function f(e,t){for(var r=0;r<e.length;r++)t[r]=e[r];return t}a.applyFromCharCode=s;var c={};c.string={string:n,array:function(e){return l(e,new Array(e.length))},arraybuffer:function(e){return c.string.uint8array(e).buffer},uint8array:function(e){return l(e,new Uint8Array(e.length))},nodebuffer:function(e){return l(e,r.allocBuffer(e.length))}},c.array={string:s,array:n,arraybuffer:function(e){return new Uint8Array(e).buffer},uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(e)}},c.arraybuffer={string:function(e){return s(new Uint8Array(e))},array:function(e){return f(new Uint8Array(e),new Array(e.byteLength))},arraybuffer:n,uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(new Uint8Array(e))}},c.uint8array={string:s,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return e.buffer},uint8array:n,nodebuffer:function(e){return r.newBufferFrom(e)}},c.nodebuffer={string:s,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return c.nodebuffer.uint8array(e).buffer},uint8array:function(e){return f(e,new Uint8Array(e.length))},nodebuffer:n},a.transformTo=function(e,t){if(t=t||"",!e)return t;a.checkSupport(e);var r=a.getTypeOf(t);return c[r][e](t)},a.resolve=function(e){for(var t=e.split("/"),r=[],n=0;n<t.length;n++){var i=t[n];"."===i||""===i&&0!==n&&n!==t.length-1||(".."===i?r.pop():r.push(i))}return r.join("/")},a.getTypeOf=function(e){return"string"==typeof e?"string":"[object Array]"===Object.prototype.toString.call(e)?"array":o.nodebuffer&&r.isBuffer(e)?"nodebuffer":o.uint8array&&e instanceof Uint8Array?"uint8array":o.arraybuffer&&e instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(e){if(!o[e.toLowerCase()])throw new Error(e+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(e){var t,r,n="";for(r=0;r<(e||"").length;r++)n+="\\x"+((t=e.charCodeAt(r))<16?"0":"")+t.toString(16).toUpperCase();return n},a.delay=function(e,t,r){setImmediate(function(){e.apply(r||null,t||[])})},a.inherits=function(e,t){function r(){}r.prototype=t.prototype,e.prototype=new r},a.extend=function(){var e,t,r={};for(e=0;e<arguments.length;e++)for(t in arguments[e])Object.prototype.hasOwnProperty.call(arguments[e],t)&&void 0===r[t]&&(r[t]=arguments[e][t]);return r},a.prepareContent=function(r,e,n,i,s){return u.Promise.resolve(e).then(function(n){return o.blob&&(n instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(n)))&&"undefined"!=typeof FileReader?new u.Promise(function(t,r){var e=new FileReader;e.onload=function(e){t(e.target.result)},e.onerror=function(e){r(e.target.error)},e.readAsArrayBuffer(n)}):n}).then(function(e){var t=a.getTypeOf(e);return t?("arraybuffer"===t?e=a.transformTo("uint8array",e):"string"===t&&(s?e=h.decode(e):n&&!0!==i&&(e=function(e){return l(e,o.uint8array?new Uint8Array(e.length):new Array(e.length))}(e))),e):u.Promise.reject(new Error("Can't read the data of '"+r+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,setimmediate:54}],33:[function(e,t,r){"use strict";var n=e("./reader/readerFor"),i=e("./utils"),s=e("./signature"),a=e("./zipEntry"),o=e("./support");function h(e){this.files=[],this.loadOptions=e}h.prototype={checkSignature:function(e){if(!this.reader.readAndCheckSignature(e)){this.reader.index-=4;var t=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+i.pretty(t)+", expected "+i.pretty(e)+")")}},isSignature:function(e,t){var r=this.reader.index;this.reader.setIndex(e);var n=this.reader.readString(4)===t;return this.reader.setIndex(r),n},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var e=this.reader.readData(this.zipCommentLength),t=o.uint8array?"uint8array":"array",r=i.transformTo(t,e);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var e,t,r,n=this.zip64EndOfCentralSize-44;0<n;)e=this.reader.readInt(2),t=this.reader.readInt(4),r=this.reader.readData(t),this.zip64ExtensibleData[e]={id:e,length:t,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var e,t;for(e=0;e<this.files.length;e++)t=this.files[e],this.reader.setIndex(t.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),t.readLocalPart(this.reader),t.handleUTF8(),t.processAttributes()},readCentralDir:function(){var e;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(e);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var e=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(e<0)throw!this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(e);var t=e;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,(e=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(e),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var n=t-r;if(0<n)this.isSignature(t,s.CENTRAL_FILE_HEADER)||(this.reader.zero=n);else if(n<0)throw new Error("Corrupted zip: missing "+Math.abs(n)+" bytes.")},prepareReader:function(e){this.reader=n(e)},load:function(e){this.prepareReader(e),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},t.exports=h},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utils":32,"./zipEntry":34}],34:[function(e,t,r){"use strict";var n=e("./reader/readerFor"),s=e("./utils"),i=e("./compressedObject"),a=e("./crc32"),o=e("./utf8"),h=e("./compressions"),u=e("./support");function l(e,t){this.options=e,this.loadOptions=t}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(e){var t,r;if(e.skip(22),this.fileNameLength=e.readInt(2),r=e.readInt(2),this.fileName=e.readData(this.fileNameLength),e.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(t=function(e){for(var t in h)if(Object.prototype.hasOwnProperty.call(h,t)&&h[t].magic===e)return h[t];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new i(this.compressedSize,this.uncompressedSize,this.crc32,t,e.readData(this.compressedSize))},readCentralPart:function(e){this.versionMadeBy=e.readInt(2),e.skip(2),this.bitFlag=e.readInt(2),this.compressionMethod=e.readString(2),this.date=e.readDate(),this.crc32=e.readInt(4),this.compressedSize=e.readInt(4),this.uncompressedSize=e.readInt(4);var t=e.readInt(2);if(this.extraFieldsLength=e.readInt(2),this.fileCommentLength=e.readInt(2),this.diskNumberStart=e.readInt(2),this.internalFileAttributes=e.readInt(2),this.externalFileAttributes=e.readInt(4),this.localHeaderOffset=e.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");e.skip(t),this.readExtraFields(e),this.parseZIP64ExtraField(e),this.fileComment=e.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var e=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==e&&(this.dosPermissions=63&this.externalFileAttributes),3==e&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(){if(this.extraFields[1]){var e=n(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(e){var t,r,n,i=e.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});e.index+4<i;)t=e.readInt(2),r=e.readInt(2),n=e.readData(r),this.extraFields[t]={id:t,length:r,value:n};e.setIndex(i)},handleUTF8:function(){var e=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var t=this.findExtraFieldUnicodePath();if(null!==t)this.fileNameStr=t;else{var r=s.transformTo(e,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var n=this.findExtraFieldUnicodeComment();if(null!==n)this.fileCommentStr=n;else{var i=s.transformTo(e,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(i)}}},findExtraFieldUnicodePath:function(){var e=this.extraFields[28789];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileName)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null},findExtraFieldUnicodeComment:function(){var e=this.extraFields[25461];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileComment)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null}},t.exports=l},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(e,t,r){"use strict";function n(e,t,r){this.name=e,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=t,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=e("./stream/StreamHelper"),i=e("./stream/DataWorker"),a=e("./utf8"),o=e("./compressedObject"),h=e("./stream/GenericWorker");n.prototype={internalStream:function(e){var t=null,r="string";try{if(!e)throw new Error("No output type specified.");var n="string"===(r=e.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),t=this._decompressWorker();var i=!this._dataBinary;i&&!n&&(t=t.pipe(new a.Utf8EncodeWorker)),!i&&n&&(t=t.pipe(new a.Utf8DecodeWorker))}catch(e){(t=new h("error")).error(e)}return new s(t,r,"")},async:function(e,t){return this.internalStream(e).accumulate(t)},nodeStream:function(e,t){return this.internalStream(e||"nodebuffer").toNodejsStream(t)},_compressWorker:function(e,t){if(this._data instanceof o&&this._data.compression.magic===e.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,e,t)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new i(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],l=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},f=0;f<u.length;f++)n.prototype[u[f]]=l;t.exports=n},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(e,l,t){(function(t){"use strict";var r,n,e=t.MutationObserver||t.WebKitMutationObserver;if(e){var i=0,s=new e(u),a=t.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=i=++i%2}}else if(t.setImmediate||void 0===t.MessageChannel)r="document"in t&&"onreadystatechange"in t.document.createElement("script")?function(){var e=t.document.createElement("script");e.onreadystatechange=function(){u(),e.onreadystatechange=null,e.parentNode.removeChild(e),e=null},t.document.documentElement.appendChild(e)}:function(){setTimeout(u,0)};else{var o=new t.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0)}}var h=[];function u(){var e,t;n=!0;for(var r=h.length;r;){for(t=h,h=[],e=-1;++e<r;)t[e]();r=h.length}n=!1}l.exports=function(e){1!==h.push(e)||n||r()}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],37:[function(e,t,r){"use strict";var i=e("immediate");function u(){}var l={},s=["REJECTED"],a=["FULFILLED"],n=["PENDING"];function o(e){if("function"!=typeof e)throw new TypeError("resolver must be a function");this.state=n,this.queue=[],this.outcome=void 0,e!==u&&d(this,e)}function h(e,t,r){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function f(t,r,n){i(function(){var e;try{e=r(n)}catch(e){return l.reject(t,e)}e===t?l.reject(t,new TypeError("Cannot resolve promise with itself")):l.resolve(t,e)})}function c(e){var t=e&&e.then;if(e&&("object"==typeof e||"function"==typeof e)&&"function"==typeof t)return function(){t.apply(e,arguments)}}function d(t,e){var r=!1;function n(e){r||(r=!0,l.reject(t,e))}function i(e){r||(r=!0,l.resolve(t,e))}var s=p(function(){e(i,n)});"error"===s.status&&n(s.value)}function p(e,t){var r={};try{r.value=e(t),r.status="success"}catch(e){r.status="error",r.value=e}return r}(t.exports=o).prototype.finally=function(t){if("function"!=typeof t)return this;var r=this.constructor;return this.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})})},o.prototype.catch=function(e){return this.then(null,e)},o.prototype.then=function(e,t){if("function"!=typeof e&&this.state===a||"function"!=typeof t&&this.state===s)return this;var r=new this.constructor(u);this.state!==n?f(r,this.state===a?e:t,this.outcome):this.queue.push(new h(r,e,t));return r},h.prototype.callFulfilled=function(e){l.resolve(this.promise,e)},h.prototype.otherCallFulfilled=function(e){f(this.promise,this.onFulfilled,e)},h.prototype.callRejected=function(e){l.reject(this.promise,e)},h.prototype.otherCallRejected=function(e){f(this.promise,this.onRejected,e)},l.resolve=function(e,t){var r=p(c,t);if("error"===r.status)return l.reject(e,r.value);var n=r.value;if(n)d(e,n);else{e.state=a,e.outcome=t;for(var i=-1,s=e.queue.length;++i<s;)e.queue[i].callFulfilled(t)}return e},l.reject=function(e,t){e.state=s,e.outcome=t;for(var r=-1,n=e.queue.length;++r<n;)e.queue[r].callRejected(t);return e},o.resolve=function(e){if(e instanceof this)return e;return l.resolve(new this(u),e)},o.reject=function(e){var t=new this(u);return l.reject(t,e)},o.all=function(e){var r=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var n=e.length,i=!1;if(!n)return this.resolve([]);var s=new Array(n),a=0,t=-1,o=new this(u);for(;++t<n;)h(e[t],t);return o;function h(e,t){r.resolve(e).then(function(e){s[t]=e,++a!==n||i||(i=!0,l.resolve(o,s))},function(e){i||(i=!0,l.reject(o,e))})}},o.race=function(e){var t=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var r=e.length,n=!1;if(!r)return this.resolve([]);var i=-1,s=new this(u);for(;++i<r;)a=e[i],t.resolve(a).then(function(e){n||(n=!0,l.resolve(s,e))},function(e){n||(n=!0,l.reject(s,e))});var a;return s}},{immediate:36}],38:[function(e,t,r){"use strict";var n={};(0,e("./lib/utils/common").assign)(n,e("./lib/deflate"),e("./lib/inflate"),e("./lib/zlib/constants")),t.exports=n},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(e,t,r){"use strict";var a=e("./zlib/deflate"),o=e("./utils/common"),h=e("./utils/strings"),i=e("./zlib/messages"),s=e("./zlib/zstream"),u=Object.prototype.toString,l=0,f=-1,c=0,d=8;function p(e){if(!(this instanceof p))return new p(e);this.options=o.assign({level:f,method:d,chunkSize:16384,windowBits:15,memLevel:8,strategy:c,to:""},e||{});var t=this.options;t.raw&&0<t.windowBits?t.windowBits=-t.windowBits:t.gzip&&0<t.windowBits&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(r!==l)throw new Error(i[r]);if(t.header&&a.deflateSetHeader(this.strm,t.header),t.dictionary){var n;if(n="string"==typeof t.dictionary?h.string2buf(t.dictionary):"[object ArrayBuffer]"===u.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(r=a.deflateSetDictionary(this.strm,n))!==l)throw new Error(i[r]);this._dict_set=!0}}function n(e,t){var r=new p(t);if(r.push(e,!0),r.err)throw r.msg||i[r.err];return r.result}p.prototype.push=function(e,t){var r,n,i=this.strm,s=this.options.chunkSize;if(this.ended)return!1;n=t===~~t?t:!0===t?4:0,"string"==typeof e?i.input=h.string2buf(e):"[object ArrayBuffer]"===u.call(e)?i.input=new Uint8Array(e):i.input=e,i.next_in=0,i.avail_in=i.input.length;do{if(0===i.avail_out&&(i.output=new o.Buf8(s),i.next_out=0,i.avail_out=s),1!==(r=a.deflate(i,n))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==i.avail_out&&(0!==i.avail_in||4!==n&&2!==n)||("string"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(i.output,i.next_out))):this.onData(o.shrinkBuf(i.output,i.next_out)))}while((0<i.avail_in||0===i.avail_out)&&1!==r);return 4===n?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==n||(this.onEnd(l),!(i.avail_out=0))},p.prototype.onData=function(e){this.chunks.push(e)},p.prototype.onEnd=function(e){e===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},r.Deflate=p,r.deflate=n,r.deflateRaw=function(e,t){return(t=t||{}).raw=!0,n(e,t)},r.gzip=function(e,t){return(t=t||{}).gzip=!0,n(e,t)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(e,t,r){"use strict";var c=e("./zlib/inflate"),d=e("./utils/common"),p=e("./utils/strings"),m=e("./zlib/constants"),n=e("./zlib/messages"),i=e("./zlib/zstream"),s=e("./zlib/gzheader"),_=Object.prototype.toString;function a(e){if(!(this instanceof a))return new a(e);this.options=d.assign({chunkSize:16384,windowBits:0,to:""},e||{});var t=this.options;t.raw&&0<=t.windowBits&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(0<=t.windowBits&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),15<t.windowBits&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new i,this.strm.avail_out=0;var r=c.inflateInit2(this.strm,t.windowBits);if(r!==m.Z_OK)throw new Error(n[r]);this.header=new s,c.inflateGetHeader(this.strm,this.header)}function o(e,t){var r=new a(t);if(r.push(e,!0),r.err)throw r.msg||n[r.err];return r.result}a.prototype.push=function(e,t){var r,n,i,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return!1;n=t===~~t?t:!0===t?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof e?h.input=p.binstring2buf(e):"[object ArrayBuffer]"===_.call(e)?h.input=new Uint8Array(e):h.input=e,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new d.Buf8(u),h.next_out=0,h.avail_out=u),(r=c.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o="string"==typeof l?p.string2buf(l):"[object ArrayBuffer]"===_.call(l)?new Uint8Array(l):l,r=c.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||n!==m.Z_FINISH&&n!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(i=p.utf8border(h.output,h.next_out),s=h.next_out-i,a=p.buf2string(h.output,i),h.next_out=s,h.avail_out=u-s,s&&d.arraySet(h.output,h.output,i,s,0),this.onData(a)):this.onData(d.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0)}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(n=m.Z_FINISH),n===m.Z_FINISH?(r=c.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):n!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(e){this.chunks.push(e)},a.prototype.onEnd=function(e){e===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=d.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(e,t){return(t=t||{}).raw=!0,o(e,t)},r.ungzip=o},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(e,t,r){"use strict";var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n])}}return e},r.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var i={arraySet:function(e,t,r,n,i){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+n),i);else for(var s=0;s<n;s++)e[i+s]=t[r+s]},flattenChunks:function(e){var t,r,n,i,s,a;for(t=n=0,r=e.length;t<r;t++)n+=e[t].length;for(a=new Uint8Array(n),t=i=0,r=e.length;t<r;t++)s=e[t],a.set(s,i),i+=s.length;return a}},s={arraySet:function(e,t,r,n,i){for(var s=0;s<n;s++)e[i+s]=t[r+s]},flattenChunks:function(e){return[].concat.apply([],e)}};r.setTyped=function(e){e?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,i)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(n)},{}],42:[function(e,t,r){"use strict";var h=e("./common"),i=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(e){i=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){s=!1}for(var u=new h.Buf8(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;function l(e,t){if(t<65537&&(e.subarray&&s||!e.subarray&&i))return String.fromCharCode.apply(null,h.shrinkBuf(e,t));for(var r="",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r}u[254]=u[254]=1,r.string2buf=function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=new h.Buf8(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t},r.buf2binstring=function(e){return l(e,e.length)},r.binstring2buf=function(e){for(var t=new h.Buf8(e.length),r=0,n=t.length;r<n;r++)t[r]=e.charCodeAt(r);return t},r.buf2string=function(e,t){var r,n,i,s,a=t||e.length,o=new Array(2*a);for(r=n=0;r<a;)if((i=e[r++])<128)o[n++]=i;else if(4<(s=u[i]))o[n++]=65533,r+=s-1;else{for(i&=2===s?31:3===s?15:7;1<s&&r<a;)i=i<<6|63&e[r++],s--;1<s?o[n++]=65533:i<65536?o[n++]=i:(i-=65536,o[n++]=55296|i>>10&1023,o[n++]=56320|1023&i)}return l(o,n)},r.utf8border=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+u[e[r]]>t?r:t}},{"./common":41}],43:[function(e,t,r){"use strict";t.exports=function(e,t,r,n){for(var i=65535&e|0,s=e>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(i=i+t[n++]|0)|0,--a;);i%=65521,s%=65521}return i|s<<16|0}},{}],44:[function(e,t,r){"use strict";t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(e,t,r){"use strict";var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}();t.exports=function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return-1^e}},{}],46:[function(e,t,r){"use strict";var h,c=e("../utils/common"),u=e("./trees"),d=e("./adler32"),p=e("./crc32"),n=e("./messages"),l=0,f=4,m=0,_=-2,g=-1,b=4,i=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(e,t){return e.msg=n[t],t}function T(e){return(e<<1)-(4<e?9:0)}function D(e){for(var t=e.length;0<=--t;)e[t]=0}function F(e){var t=e.state,r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(c.arraySet(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0))}function N(e,t){u._tr_flush_block(e,0<=e.block_start?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,F(e.strm)}function U(e,t){e.pending_buf[e.pending++]=t}function P(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t}function L(e,t){var r,n,i=e.max_chain_length,s=e.strstart,a=e.prev_length,o=e.nice_match,h=e.strstart>e.w_size-z?e.strstart-(e.w_size-z):0,u=e.window,l=e.w_mask,f=e.prev,c=e.strstart+S,d=u[s+a-1],p=u[s+a];e.prev_length>=e.good_match&&(i>>=2),o>e.lookahead&&(o=e.lookahead);do{if(u[(r=t)+a]===p&&u[r+a-1]===d&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<c);if(n=S-(c-s),s=c-S,a<n){if(e.match_start=t,o<=(a=n))break;d=u[s+a-1],p=u[s+a]}}}while((t=f[t&l])>h&&0!=--i);return a<=e.lookahead?a:e.lookahead}function j(e){var t,r,n,i,s,a,o,h,u,l,f=e.w_size;do{if(i=e.window_size-e.lookahead-e.strstart,e.strstart>=f+(f-z)){for(c.arraySet(e.window,e.window,f,f,0),e.match_start-=f,e.strstart-=f,e.block_start-=f,t=r=e.hash_size;n=e.head[--t],e.head[t]=f<=n?n-f:0,--r;);for(t=r=f;n=e.prev[--t],e.prev[t]=f<=n?n-f:0,--r;);i+=f}if(0===e.strm.avail_in)break;if(a=e.strm,o=e.window,h=e.strstart+e.lookahead,u=i,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,c.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=d(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),e.lookahead+=r,e.lookahead+e.insert>=x)for(s=e.strstart-e.insert,e.ins_h=e.window[s],e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+x-1])&e.hash_mask,e.prev[s&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=s,s++,e.insert--,!(e.lookahead+e.insert<x)););}while(e.lookahead<z&&0!==e.strm.avail_in)}function Z(e,t){for(var r,n;;){if(e.lookahead<z){if(j(e),e.lookahead<z&&t===l)return A;if(0===e.lookahead)break}if(r=0,e.lookahead>=x&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-z&&(e.match_length=L(e,r)),e.match_length>=x)if(n=u._tr_tally(e,e.strstart-e.match_start,e.match_length-x),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=x){for(e.match_length--;e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart,0!=--e.match_length;);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else n=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=e.strstart<x-1?e.strstart:x-1,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}function W(e,t){for(var r,n,i;;){if(e.lookahead<z){if(j(e),e.lookahead<z&&t===l)return A;if(0===e.lookahead)break}if(r=0,e.lookahead>=x&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=x-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-z&&(e.match_length=L(e,r),e.match_length<=5&&(1===e.strategy||e.match_length===x&&4096<e.strstart-e.match_start)&&(e.match_length=x-1)),e.prev_length>=x&&e.match_length<=e.prev_length){for(i=e.strstart+e.lookahead-x,n=u._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-x),e.lookahead-=e.prev_length-1,e.prev_length-=2;++e.strstart<=i&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!=--e.prev_length;);if(e.match_available=0,e.match_length=x-1,e.strstart++,n&&(N(e,!1),0===e.strm.avail_out))return A}else if(e.match_available){if((n=u._tr_tally(e,0,e.window[e.strstart-1]))&&N(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return A}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(n=u._tr_tally(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<x-1?e.strstart:x-1,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}function M(e,t,r,n,i){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=i}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new c.Buf16(2*w),this.dyn_dtree=new c.Buf16(2*(2*a+1)),this.bl_tree=new c.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new c.Buf16(k+1),this.heap=new c.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new c.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function G(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=i,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?C:E,e.adler=2===t.wrap?0:1,t.last_flush=l,u._tr_init(t),m):R(e,_)}function K(e){var t=G(e);return t===m&&function(e){e.window_size=2*e.w_size,D(e.head),e.max_lazy_match=h[e.level].max_lazy,e.good_match=h[e.level].good_length,e.nice_match=h[e.level].nice_length,e.max_chain_length=h[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=x-1,e.match_available=0,e.ins_h=0}(e.state),t}function Y(e,t,r,n,i,s){if(!e)return _;var a=1;if(t===g&&(t=6),n<0?(a=0,n=-n):15<n&&(a=2,n-=16),i<1||y<i||r!==v||n<8||15<n||t<0||9<t||s<0||b<s)return R(e,_);8===n&&(n=9);var o=new H;return(e.state=o).strm=e,o.wrap=a,o.gzhead=null,o.w_bits=n,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=i+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new c.Buf8(2*o.w_size),o.head=new c.Buf16(o.hash_size),o.prev=new c.Buf16(o.w_size),o.lit_bufsize=1<<i+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new c.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=t,o.strategy=s,o.method=r,K(e)}h=[new M(0,0,0,0,function(e,t){var r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(j(e),0===e.lookahead&&t===l)return A;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var n=e.block_start+r;if((0===e.strstart||e.strstart>=n)&&(e.lookahead=e.strstart-n,e.strstart=n,N(e,!1),0===e.strm.avail_out))return A;if(e.strstart-e.block_start>=e.w_size-z&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):(e.strstart>e.block_start&&(N(e,!1),e.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(e,t){return Y(e,t,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(e,t){return e&&e.state?2!==e.state.wrap?_:(e.state.gzhead=t,m):_},r.deflate=function(e,t){var r,n,i,s;if(!e||!e.state||5<t||t<0)return e?R(e,_):_;if(n=e.state,!e.output||!e.input&&0!==e.avail_in||666===n.status&&t!==f)return R(e,0===e.avail_out?-5:_);if(n.strm=e,r=n.last_flush,n.last_flush=t,n.status===C)if(2===n.wrap)e.adler=0,U(n,31),U(n,139),U(n,8),n.gzhead?(U(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),U(n,255&n.gzhead.time),U(n,n.gzhead.time>>8&255),U(n,n.gzhead.time>>16&255),U(n,n.gzhead.time>>24&255),U(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),U(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(U(n,255&n.gzhead.extra.length),U(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=p(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69):(U(n,0),U(n,0),U(n,0),U(n,0),U(n,0),U(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),U(n,3),n.status=E);else{var a=v+(n.w_bits-8<<4)<<8;a|=(2<=n.strategy||n.level<2?0:n.level<6?1:6===n.level?2:3)<<6,0!==n.strstart&&(a|=32),a+=31-a%31,n.status=E,P(n,a),0!==n.strstart&&(P(n,e.adler>>>16),P(n,65535&e.adler)),e.adler=1}if(69===n.status)if(n.gzhead.extra){for(i=n.pending;n.gzindex<(65535&n.gzhead.extra.length)&&(n.pending!==n.pending_buf_size||(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending!==n.pending_buf_size));)U(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++;n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=73)}else n.status=73;if(73===n.status)if(n.gzhead.name){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,U(n,s)}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.gzindex=0,n.status=91)}else n.status=91;if(91===n.status)if(n.gzhead.comment){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,U(n,s)}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.status=103)}else n.status=103;if(103===n.status&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&F(e),n.pending+2<=n.pending_buf_size&&(U(n,255&e.adler),U(n,e.adler>>8&255),e.adler=0,n.status=E)):n.status=E),0!==n.pending){if(F(e),0===e.avail_out)return n.last_flush=-1,m}else if(0===e.avail_in&&T(t)<=T(r)&&t!==f)return R(e,-5);if(666===n.status&&0!==e.avail_in)return R(e,-5);if(0!==e.avail_in||0!==n.lookahead||t!==l&&666!==n.status){var o=2===n.strategy?function(e,t){for(var r;;){if(0===e.lookahead&&(j(e),0===e.lookahead)){if(t===l)return A;break}if(e.match_length=0,r=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}(n,t):3===n.strategy?function(e,t){for(var r,n,i,s,a=e.window;;){if(e.lookahead<=S){if(j(e),e.lookahead<=S&&t===l)return A;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=x&&0<e.strstart&&(n=a[i=e.strstart-1])===a[++i]&&n===a[++i]&&n===a[++i]){s=e.strstart+S;do{}while(n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&i<s);e.match_length=S-(s-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=x?(r=u._tr_tally(e,1,e.match_length-x),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}(n,t):h[n.level].func(n,t);if(o!==O&&o!==B||(n.status=666),o===A||o===O)return 0===e.avail_out&&(n.last_flush=-1),m;if(o===I&&(1===t?u._tr_align(n):5!==t&&(u._tr_stored_block(n,0,0,!1),3===t&&(D(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),F(e),0===e.avail_out))return n.last_flush=-1,m}return t!==f?m:n.wrap<=0?1:(2===n.wrap?(U(n,255&e.adler),U(n,e.adler>>8&255),U(n,e.adler>>16&255),U(n,e.adler>>24&255),U(n,255&e.total_in),U(n,e.total_in>>8&255),U(n,e.total_in>>16&255),U(n,e.total_in>>24&255)):(P(n,e.adler>>>16),P(n,65535&e.adler)),F(e),0<n.wrap&&(n.wrap=-n.wrap),0!==n.pending?m:1)},r.deflateEnd=function(e){var t;return e&&e.state?(t=e.state.status)!==C&&69!==t&&73!==t&&91!==t&&103!==t&&t!==E&&666!==t?R(e,_):(e.state=null,t===E?R(e,-3):m):_},r.deflateSetDictionary=function(e,t){var r,n,i,s,a,o,h,u,l=t.length;if(!e||!e.state)return _;if(2===(s=(r=e.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(e.adler=d(e.adler,t,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new c.Buf8(r.w_size),c.arraySet(u,t,l-r.w_size,r.w_size,0),t=u,l=r.w_size),a=e.avail_in,o=e.next_in,h=e.input,e.avail_in=l,e.next_in=0,e.input=t,j(r);r.lookahead>=x;){for(n=r.strstart,i=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[n+x-1])&r.hash_mask,r.prev[n&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=n,n++,--i;);r.strstart=n,r.lookahead=x-1,j(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,e.next_in=o,e.input=h,e.avail_in=a,r.wrap=s,m},r.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(e,t,r){"use strict";t.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(e,t,r){"use strict";t.exports=function(e,t){var r,n,i,s,a,o,h,u,l,f,c,d,p,m,_,g,b,v,y,w,k,x,S,z,C;r=e.state,n=e.next_in,z=e.input,i=n+(e.avail_in-5),s=e.next_out,C=e.output,a=s-(t-e.avail_out),o=s+(e.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,c=r.window,d=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;e:do{p<15&&(d+=z[n++]<<p,p+=8,d+=z[n++]<<p,p+=8),v=m[d&g];t:for(;;){if(d>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else{if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(d&(1<<y)-1)];continue t}if(32&y){r.mode=12;break e}e.msg="invalid literal/length code",r.mode=30;break e}w=65535&v,(y&=15)&&(p<y&&(d+=z[n++]<<p,p+=8),w+=d&(1<<y)-1,d>>>=y,p-=y),p<15&&(d+=z[n++]<<p,p+=8,d+=z[n++]<<p,p+=8),v=_[d&b];r:for(;;){if(d>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(d&(1<<y)-1)];continue r}e.msg="invalid distance code",r.mode=30;break e}if(k=65535&v,p<(y&=15)&&(d+=z[n++]<<p,(p+=8)<y&&(d+=z[n++]<<p,p+=8)),h<(k+=d&(1<<y)-1)){e.msg="invalid distance too far back",r.mode=30;break e}if(d>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){e.msg="invalid distance too far back",r.mode=30;break e}if(S=c,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=c[x++],--y;);x=s-k,S=C}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=c[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=c[x++],--y;);x=s-k,S=C}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=c[x++],--y;);x=s-k,S=C}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]))}else{for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]))}break}}break}}while(n<i&&s<o);n-=w=p>>3,d&=(1<<(p-=w<<3))-1,e.next_in=n,e.next_out=s,e.avail_in=n<i?i-n+5:5-(n-i),e.avail_out=s<o?o-s+257:257-(s-o),r.hold=d,r.bits=p}},{}],49:[function(e,t,r){"use strict";var I=e("../utils/common"),O=e("./adler32"),B=e("./crc32"),R=e("./inffast"),T=e("./inftrees"),D=1,F=2,N=0,U=-2,P=1,n=852,i=592;function L(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=P,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new I.Buf32(n),t.distcode=t.distdyn=new I.Buf32(i),t.sane=1,t.back=-1,N):U}function o(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,a(e)):U}function h(e,t){var r,n;return e&&e.state?(n=e.state,t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||15<t)?U:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,o(e))):U}function u(e,t){var r,n;return e?(n=new s,(e.state=n).window=null,(r=h(e,t))!==N&&(e.state=null),r):U}var l,f,c=!0;function j(e){if(c){var t;for(l=new I.Buf32(512),f=new I.Buf32(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(T(D,e.lens,0,288,l,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;T(F,e.lens,0,32,f,0,e.work,{bits:5}),c=!1}e.lencode=l,e.lenbits=9,e.distcode=f,e.distbits=5}function Z(e,t,r,n){var i,s=e.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),n>=s.wsize?(I.arraySet(s.window,t,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(n<(i=s.wsize-s.wnext)&&(i=n),I.arraySet(s.window,t,r-n,i,s.wnext),(n-=i)?(I.arraySet(s.window,t,r-n,n,0),s.wnext=n,s.whave=s.wsize):(s.wnext+=i,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=i))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(e){return u(e,15)},r.inflateInit2=u,r.inflate=function(e,t){var r,n,i,s,a,o,h,u,l,f,c,d,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return U;12===(r=e.state).mode&&(r.mode=13),a=e.next_out,i=e.output,h=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,u=r.hold,l=r.bits,f=o,c=h,x=N;e:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){e.msg="incorrect header check",r.mode=30;break}if(8!=(15&u)){e.msg="unknown compression method",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,e.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(r.flags=u,8!=(255&r.flags)){e.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(d=r.length)&&(d=o),d&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,n,s,d,k)),512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,r.length-=d),r.length))break e;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break e;for(d=0;k=n[s+d++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&d<o;);if(512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break e;for(d=0;k=n[s+d++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&d<o;);if(512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,k)break e}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(u!==(65535&r.check)){e.msg="header crc mismatch",r.mode=30;break}l=u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}e.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,2;e.adler=r.check=1,r.mode=12;case 12:if(5===t||6===t)break e;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==t)break;u>>>=2,l-=2;break e;case 2:r.mode=17;break;case 3:e.msg="invalid block type",r.mode=30}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if((65535&u)!=(u>>>16^65535)){e.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===t)break e;case 15:r.mode=16;case 16:if(d=r.length){if(o<d&&(d=o),h<d&&(d=h),0===d)break e;I.arraySet(i,n,s,d,a),o-=d,s+=d,h-=d,a+=d,r.length-=d;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){e.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else{if(16===b){for(z=_+2;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(u>>>=_,l-=_,0===r.have){e.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],d=3+(3&u),u>>>=2,l-=2}else if(17===b){for(z=_+3;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}l-=_,k=0,d=3+(7&(u>>>=_)),u>>>=3,l-=3}else{for(z=_+7;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}l-=_,k=0,d=11+(127&(u>>>=_)),u>>>=7,l-=7}if(r.have+d>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=30;break}for(;d--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){e.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===t)break e;case 20:r.mode=21;case 21:if(6<=o&&258<=h){e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,R(e,c),a=e.next_out,i=e.output,h=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){e.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,64&g){e.msg="invalid distance code",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===h)break e;if(d=c-h,r.offset>d){if((d=r.offset-d)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=30;break}p=d>r.wnext?(d-=r.wnext,r.wsize-d):r.wnext-d,d>r.length&&(d=r.length),m=r.window}else m=i,p=a-r.offset,d=r.length;for(h<d&&(d=h),h-=d,r.length-=d;i[a++]=m[p++],--d;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break e;i[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break e;o--,u|=n[s++]<<l,l+=8}if(c-=h,e.total_out+=c,r.total+=c,c&&(e.adler=r.check=r.flags?B(r.check,i,c,a-c):O(r.check,i,c,a-c)),c=h,(r.flags?u:L(u))!==r.check){e.msg="incorrect data check",r.mode=30;break}l=u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8}if(u!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=30;break}l=u=0}r.mode=29;case 29:x=1;break e;case 30:x=-3;break e;case 31:return-4;case 32:default:return U}return e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,(r.wsize||c!==e.avail_out&&r.mode<30&&(r.mode<27||4!==t))&&Z(e,e.output,e.next_out,c-e.avail_out)?(r.mode=31,-4):(f-=e.avail_in,c-=e.avail_out,e.total_in+=f,e.total_out+=c,r.total+=c,r.wrap&&c&&(e.adler=r.check=r.flags?B(r.check,i,c,e.next_out-c):O(r.check,i,c,e.next_out-c)),e.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===c||4===t)&&x===N&&(x=-5),x)},r.inflateEnd=function(e){if(!e||!e.state)return U;var t=e.state;return t.window&&(t.window=null),e.state=null,N},r.inflateGetHeader=function(e,t){var r;return e&&e.state?0==(2&(r=e.state).wrap)?U:((r.head=t).done=!1,N):U},r.inflateSetDictionary=function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,t,n,0)!==r.check?-3:Z(e,t,n,n)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(e,t,r){"use strict";var D=e("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];t.exports=function(e,t,r,n,i,s,a,o){var h,u,l,f,c,d,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<n;v++)O[t[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return i[s++]=20971520,i[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return-1;if(0<z&&(0===e||1!==w))return-1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<n;v++)0!==t[r+v]&&(a[B[t[r+v]]++]=v);if(d=0===e?(A=R=a,19):1===e?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,c=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===e&&852<C||2===e&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<d?(m=0,a[v]):a[v]>d?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;i[c+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=t[r+a[v]]}if(k<b&&(E&f)!==l){for(0===S&&(S=k),c+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===e&&852<C||2===e&&592<C)return 1;i[l=E&f]=k<<24|x<<16|c-s|0}}return 0!==E&&(i[c+E]=b-S<<24|64<<16|0),o.bits=k,0}},{"../utils/common":41}],51:[function(e,t,r){"use strict";t.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(e,t,r){"use strict";var i=e("../utils/common"),o=0,h=1;function n(e){for(var t=e.length;0<=--t;)e[t]=0}var s=0,a=29,u=256,l=u+1+a,f=30,c=19,_=2*l+1,g=15,d=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));n(z);var C=new Array(2*f);n(C);var E=new Array(512);n(E);var A=new Array(256);n(A);var I=new Array(a);n(I);var O,B,R,T=new Array(f);function D(e,t,r,n,i){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=i,this.has_stree=e&&e.length}function F(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}function N(e){return e<256?E[e]:E[256+(e>>>7)]}function U(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255}function P(e,t,r){e.bi_valid>d-r?(e.bi_buf|=t<<e.bi_valid&65535,U(e,e.bi_buf),e.bi_buf=t>>d-e.bi_valid,e.bi_valid+=r-d):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r)}function L(e,t,r){P(e,r[2*t],r[2*t+1])}function j(e,t){for(var r=0;r|=1&e,e>>>=1,r<<=1,0<--t;);return r>>>1}function Z(e,t,r){var n,i,s=new Array(g+1),a=0;for(n=1;n<=g;n++)s[n]=a=a+r[n-1]<<1;for(i=0;i<=t;i++){var o=e[2*i+1];0!==o&&(e[2*i]=j(s[o]++,o))}}function W(e){var t;for(t=0;t<l;t++)e.dyn_ltree[2*t]=0;for(t=0;t<f;t++)e.dyn_dtree[2*t]=0;for(t=0;t<c;t++)e.bl_tree[2*t]=0;e.dyn_ltree[2*m]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0}function M(e){8<e.bi_valid?U(e,e.bi_buf):0<e.bi_valid&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0}function H(e,t,r,n){var i=2*t,s=2*r;return e[i]<e[s]||e[i]===e[s]&&n[t]<=n[r]}function G(e,t,r){for(var n=e.heap[r],i=r<<1;i<=e.heap_len&&(i<e.heap_len&&H(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!H(t,n,e.heap[i],e.depth));)e.heap[r]=e.heap[i],r=i,i<<=1;e.heap[r]=n}function K(e,t,r){var n,i,s,a,o=0;if(0!==e.last_lit)for(;n=e.pending_buf[e.d_buf+2*o]<<8|e.pending_buf[e.d_buf+2*o+1],i=e.pending_buf[e.l_buf+o],o++,0===n?L(e,i,t):(L(e,(s=A[i])+u+1,t),0!==(a=w[s])&&P(e,i-=I[s],a),L(e,s=N(--n),r),0!==(a=k[s])&&P(e,n-=T[s],a)),o<e.last_lit;);L(e,m,t)}function Y(e,t){var r,n,i,s=t.dyn_tree,a=t.stat_desc.static_tree,o=t.stat_desc.has_stree,h=t.stat_desc.elems,u=-1;for(e.heap_len=0,e.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(e.heap[++e.heap_len]=u=r,e.depth[r]=0):s[2*r+1]=0;for(;e.heap_len<2;)s[2*(i=e.heap[++e.heap_len]=u<2?++u:0)]=1,e.depth[i]=0,e.opt_len--,o&&(e.static_len-=a[2*i+1]);for(t.max_code=u,r=e.heap_len>>1;1<=r;r--)G(e,s,r);for(i=h;r=e.heap[1],e.heap[1]=e.heap[e.heap_len--],G(e,s,1),n=e.heap[1],e.heap[--e.heap_max]=r,e.heap[--e.heap_max]=n,s[2*i]=s[2*r]+s[2*n],e.depth[i]=(e.depth[r]>=e.depth[n]?e.depth[r]:e.depth[n])+1,s[2*r+1]=s[2*n+1]=i,e.heap[1]=i++,G(e,s,1),2<=e.heap_len;);e.heap[--e.heap_max]=e.heap[1],function(e,t){var r,n,i,s,a,o,h=t.dyn_tree,u=t.max_code,l=t.stat_desc.static_tree,f=t.stat_desc.has_stree,c=t.stat_desc.extra_bits,d=t.stat_desc.extra_base,p=t.stat_desc.max_length,m=0;for(s=0;s<=g;s++)e.bl_count[s]=0;for(h[2*e.heap[e.heap_max]+1]=0,r=e.heap_max+1;r<_;r++)p<(s=h[2*h[2*(n=e.heap[r])+1]+1]+1)&&(s=p,m++),h[2*n+1]=s,u<n||(e.bl_count[s]++,a=0,d<=n&&(a=c[n-d]),o=h[2*n],e.opt_len+=o*(s+a),f&&(e.static_len+=o*(l[2*n+1]+a)));if(0!==m){do{for(s=p-1;0===e.bl_count[s];)s--;e.bl_count[s]--,e.bl_count[s+1]+=2,e.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(n=e.bl_count[s];0!==n;)u<(i=e.heap[--r])||(h[2*i+1]!==s&&(e.opt_len+=(s-h[2*i+1])*h[2*i],h[2*i+1]=s),n--)}}(e,t),Z(s,u,e.bl_count)}function X(e,t,r){var n,i,s=-1,a=t[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),t[2*(r+1)+1]=65535,n=0;n<=r;n++)i=a,a=t[2*(n+1)+1],++o<h&&i===a||(o<u?e.bl_tree[2*i]+=o:0!==i?(i!==s&&e.bl_tree[2*i]++,e.bl_tree[2*b]++):o<=10?e.bl_tree[2*v]++:e.bl_tree[2*y]++,s=i,u=(o=0)===a?(h=138,3):i===a?(h=6,3):(h=7,4))}function V(e,t,r){var n,i,s=-1,a=t[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),n=0;n<=r;n++)if(i=a,a=t[2*(n+1)+1],!(++o<h&&i===a)){if(o<u)for(;L(e,i,e.bl_tree),0!=--o;);else 0!==i?(i!==s&&(L(e,i,e.bl_tree),o--),L(e,b,e.bl_tree),P(e,o-3,2)):o<=10?(L(e,v,e.bl_tree),P(e,o-3,3)):(L(e,y,e.bl_tree),P(e,o-11,7));s=i,u=(o=0)===a?(h=138,3):i===a?(h=6,3):(h=7,4)}}n(T);var q=!1;function J(e,t,r,n){P(e,(s<<1)+(n?1:0),3),function(e,t,r,n){M(e),n&&(U(e,r),U(e,~r)),i.arraySet(e.pending_buf,e.window,t,r,e.pending),e.pending+=r}(e,t,r,!0)}r._tr_init=function(e){q||(function(){var e,t,r,n,i,s=new Array(g+1);for(n=r=0;n<a-1;n++)for(I[n]=r,e=0;e<1<<w[n];e++)A[r++]=n;for(A[r-1]=n,n=i=0;n<16;n++)for(T[n]=i,e=0;e<1<<k[n];e++)E[i++]=n;for(i>>=7;n<f;n++)for(T[n]=i<<7,e=0;e<1<<k[n]-7;e++)E[256+i++]=n;for(t=0;t<=g;t++)s[t]=0;for(e=0;e<=143;)z[2*e+1]=8,e++,s[8]++;for(;e<=255;)z[2*e+1]=9,e++,s[9]++;for(;e<=279;)z[2*e+1]=7,e++,s[7]++;for(;e<=287;)z[2*e+1]=8,e++,s[8]++;for(Z(z,l+1,s),e=0;e<f;e++)C[2*e+1]=5,C[2*e]=j(e,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,c,p)}(),q=!0),e.l_desc=new F(e.dyn_ltree,O),e.d_desc=new F(e.dyn_dtree,B),e.bl_desc=new F(e.bl_tree,R),e.bi_buf=0,e.bi_valid=0,W(e)},r._tr_stored_block=J,r._tr_flush_block=function(e,t,r,n){var i,s,a=0;0<e.level?(2===e.strm.data_type&&(e.strm.data_type=function(e){var t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return o;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return h;for(t=32;t<u;t++)if(0!==e.dyn_ltree[2*t])return h;return o}(e)),Y(e,e.l_desc),Y(e,e.d_desc),a=function(e){var t;for(X(e,e.dyn_ltree,e.l_desc.max_code),X(e,e.dyn_dtree,e.d_desc.max_code),Y(e,e.bl_desc),t=c-1;3<=t&&0===e.bl_tree[2*S[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),i=e.opt_len+3+7>>>3,(s=e.static_len+3+7>>>3)<=i&&(i=s)):i=s=r+5,r+4<=i&&-1!==t?J(e,t,r,n):4===e.strategy||s===i?(P(e,2+(n?1:0),3),K(e,z,C)):(P(e,4+(n?1:0),3),function(e,t,r,n){var i;for(P(e,t-257,5),P(e,r-1,5),P(e,n-4,4),i=0;i<n;i++)P(e,e.bl_tree[2*S[i]+1],3);V(e,e.dyn_ltree,t-1),V(e,e.dyn_dtree,r-1)}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),K(e,e.dyn_ltree,e.dyn_dtree)),W(e),n&&M(e)},r._tr_tally=function(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(A[r]+u+1)]++,e.dyn_dtree[2*N(t)]++),e.last_lit===e.lit_bufsize-1},r._tr_align=function(e){P(e,2,3),L(e,m,z),function(e){16===e.bi_valid?(U(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):8<=e.bi_valid&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)}(e)}},{"../utils/common":41}],53:[function(e,t,r){"use strict";t.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(e,t,r){(function(e){!function(r,n){"use strict";if(!r.setImmediate){var i,s,t,a,o=1,h={},u=!1,l=r.document,e=Object.getPrototypeOf&&Object.getPrototypeOf(r);e=e&&e.setTimeout?e:r,i="[object process]"==={}.toString.call(r.process)?function(e){process.nextTick(function(){c(e)})}:function(){if(r.postMessage&&!r.importScripts){var e=!0,t=r.onmessage;return r.onmessage=function(){e=!1},r.postMessage("","*"),r.onmessage=t,e}}()?(a="setImmediate$"+Math.random()+"$",r.addEventListener?r.addEventListener("message",d,!1):r.attachEvent("onmessage",d),function(e){r.postMessage(a+e,"*")}):r.MessageChannel?((t=new MessageChannel).port1.onmessage=function(e){c(e.data)},function(e){t.port2.postMessage(e)}):l&&"onreadystatechange"in l.createElement("script")?(s=l.documentElement,function(e){var t=l.createElement("script");t.onreadystatechange=function(){c(e),t.onreadystatechange=null,s.removeChild(t),t=null},s.appendChild(t)}):function(e){setTimeout(c,0,e)},e.setImmediate=function(e){"function"!=typeof e&&(e=new Function(""+e));for(var t=new Array(arguments.length-1),r=0;r<t.length;r++)t[r]=arguments[r+1];var n={callback:e,args:t};return h[o]=n,i(o),o++},e.clearImmediate=f}function f(e){delete h[e]}function c(e){if(u)setTimeout(c,0,e);else{var t=h[e];if(t){u=!0;try{!function(e){var t=e.callback,r=e.args;switch(r.length){case 0:t();break;case 1:t(r[0]);break;case 2:t(r[0],r[1]);break;case 3:t(r[0],r[1],r[2]);break;default:t.apply(n,r)}}(t)}finally{f(e),u=!1}}}}function d(e){e.source===r&&"string"==typeof e.data&&0===e.data.indexOf(a)&&c(+e.data.slice(a.length))}}("undefined"==typeof self?void 0===e?this:e:self)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}]},{},[10])(10)});
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],require("timers").setImmediate)
},{"_process":81,"buffer":72,"timers":82}],80:[function(require,module,exports){
(function (global){(function (){
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(_dereq_,module,exports){
'use strict';
var immediate = _dereq_(1);

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"1":1}],3:[function(_dereq_,module,exports){
(function (global){
'use strict';
if (typeof global.Promise !== 'function') {
  global.Promise = _dereq_(2);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"2":2}],4:[function(_dereq_,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getIDB() {
    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
    try {
        if (typeof indexedDB !== 'undefined') {
            return indexedDB;
        }
        if (typeof webkitIndexedDB !== 'undefined') {
            return webkitIndexedDB;
        }
        if (typeof mozIndexedDB !== 'undefined') {
            return mozIndexedDB;
        }
        if (typeof OIndexedDB !== 'undefined') {
            return OIndexedDB;
        }
        if (typeof msIndexedDB !== 'undefined') {
            return msIndexedDB;
        }
    } catch (e) {
        return;
    }
}

var idb = getIDB();

function isIndexedDBValid() {
    try {
        // Initialize IndexedDB; fall back to vendor-prefixed versions
        // if needed.
        if (!idb || !idb.open) {
            return false;
        }
        // We mimic PouchDB here;
        //
        // We test for openDatabase because IE Mobile identifies itself
        // as Safari. Oh the lulz...
        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);

        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;

        // Safari <10.1 does not meet our requirements for IDB support
        // (see: https://github.com/pouchdb/pouchdb/issues/5572).
        // Safari 10.1 shipped with fetch, we can use that to detect it.
        // Note: this creates issues with `window.fetch` polyfills and
        // overrides; see:
        // https://github.com/localForage/localForage/issues/856
        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
        // some outdated implementations of IDB that appear on Samsung
        // and HTC Android devices <4.4 are missing IDBKeyRange
        // See: https://github.com/mozilla/localForage/issues/128
        // See: https://github.com/mozilla/localForage/issues/272
        typeof IDBKeyRange !== 'undefined';
    } catch (e) {
        return false;
    }
}

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
function createBlob(parts, properties) {
    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
    parts = parts || [];
    properties = properties || {};
    try {
        return new Blob(parts, properties);
    } catch (e) {
        if (e.name !== 'TypeError') {
            throw e;
        }
        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
        var builder = new Builder();
        for (var i = 0; i < parts.length; i += 1) {
            builder.append(parts[i]);
        }
        return builder.getBlob(properties.type);
    }
}

// This is CommonJS because lie is an external dependency, so Rollup
// can just ignore it.
if (typeof Promise === 'undefined') {
    // In the "nopromises" build this will just throw if you don't have
    // a global promise object, but it would throw anyway later.
    _dereq_(3);
}
var Promise$1 = Promise;

function executeCallback(promise, callback) {
    if (callback) {
        promise.then(function (result) {
            callback(null, result);
        }, function (error) {
            callback(error);
        });
    }
}

function executeTwoCallbacks(promise, callback, errorCallback) {
    if (typeof callback === 'function') {
        promise.then(callback);
    }

    if (typeof errorCallback === 'function') {
        promise["catch"](errorCallback);
    }
}

function normalizeKey(key) {
    // Cast the key to a string, as that's all we can set as a key.
    if (typeof key !== 'string') {
        console.warn(key + ' used as a key, but it is not a string.');
        key = String(key);
    }

    return key;
}

function getCallback() {
    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
        return arguments[arguments.length - 1];
    }
}

// Some code originally from async_storage.js in
// [Gaia](https://github.com/mozilla-b2g/gaia).

var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
var supportsBlobs = void 0;
var dbContexts = {};
var toString = Object.prototype.toString;

// Transaction Modes
var READ_ONLY = 'readonly';
var READ_WRITE = 'readwrite';

// Transform a binary string to an array buffer, because otherwise
// weird stuff happens when you try to work with the binary string directly.
// It is known.
// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
function _binStringToArrayBuffer(bin) {
    var length = bin.length;
    var buf = new ArrayBuffer(length);
    var arr = new Uint8Array(buf);
    for (var i = 0; i < length; i++) {
        arr[i] = bin.charCodeAt(i);
    }
    return buf;
}

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
// Code borrowed from PouchDB. See:
// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
//
function _checkBlobSupportWithoutCaching(idb) {
    return new Promise$1(function (resolve) {
        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
        var blob = createBlob(['']);
        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

        txn.onabort = function (e) {
            // If the transaction aborts now its due to not being able to
            // write to the database, likely due to the disk being full
            e.preventDefault();
            e.stopPropagation();
            resolve(false);
        };

        txn.oncomplete = function () {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            // MS Edge pretends to be Chrome 42:
            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
        };
    })["catch"](function () {
        return false; // error, so assume unsupported
    });
}

function _checkBlobSupport(idb) {
    if (typeof supportsBlobs === 'boolean') {
        return Promise$1.resolve(supportsBlobs);
    }
    return _checkBlobSupportWithoutCaching(idb).then(function (value) {
        supportsBlobs = value;
        return supportsBlobs;
    });
}

function _deferReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Create a deferred object representing the current database operation.
    var deferredOperation = {};

    deferredOperation.promise = new Promise$1(function (resolve, reject) {
        deferredOperation.resolve = resolve;
        deferredOperation.reject = reject;
    });

    // Enqueue the deferred operation.
    dbContext.deferredOperations.push(deferredOperation);

    // Chain its promise to the database readiness.
    if (!dbContext.dbReady) {
        dbContext.dbReady = deferredOperation.promise;
    } else {
        dbContext.dbReady = dbContext.dbReady.then(function () {
            return deferredOperation.promise;
        });
    }
}

function _advanceReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Resolve its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.resolve();
        return deferredOperation.promise;
    }
}

function _rejectReadiness(dbInfo, err) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Reject its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.reject(err);
        return deferredOperation.promise;
    }
}

function _getConnection(dbInfo, upgradeNeeded) {
    return new Promise$1(function (resolve, reject) {
        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();

        if (dbInfo.db) {
            if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
            } else {
                return resolve(dbInfo.db);
            }
        }

        var dbArgs = [dbInfo.name];

        if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
        }

        var openreq = idb.open.apply(idb, dbArgs);

        if (upgradeNeeded) {
            openreq.onupgradeneeded = function (e) {
                var db = openreq.result;
                try {
                    db.createObjectStore(dbInfo.storeName);
                    if (e.oldVersion <= 1) {
                        // Added when support for blob shims was added
                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                    }
                } catch (ex) {
                    if (ex.name === 'ConstraintError') {
                        console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                    } else {
                        throw ex;
                    }
                }
            };
        }

        openreq.onerror = function (e) {
            e.preventDefault();
            reject(openreq.error);
        };

        openreq.onsuccess = function () {
            var db = openreq.result;
            db.onversionchange = function (e) {
                // Triggered when the database is modified (e.g. adding an objectStore) or
                // deleted (even when initiated by other sessions in different tabs).
                // Closing the connection here prevents those operations from being blocked.
                // If the database is accessed again later by this instance, the connection
                // will be reopened or the database recreated as needed.
                e.target.close();
            };
            resolve(db);
            _advanceReadiness(dbInfo);
        };
    });
}

function _getOriginalConnection(dbInfo) {
    return _getConnection(dbInfo, false);
}

function _getUpgradedConnection(dbInfo) {
    return _getConnection(dbInfo, true);
}

function _isUpgradeNeeded(dbInfo, defaultVersion) {
    if (!dbInfo.db) {
        return true;
    }

    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
    var isDowngrade = dbInfo.version < dbInfo.db.version;
    var isUpgrade = dbInfo.version > dbInfo.db.version;

    if (isDowngrade) {
        // If the version is not the default one
        // then warn for impossible downgrade.
        if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
        }
        // Align the versions to prevent errors.
        dbInfo.version = dbInfo.db.version;
    }

    if (isUpgrade || isNewStore) {
        // If the store is new then increment the version (if needed).
        // This will trigger an "upgradeneeded" event which is required
        // for creating a store.
        if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
            }
        }

        return true;
    }

    return false;
}

// encode a blob for indexeddb engines that don't support blobs
function _encodeBlob(blob) {
    return new Promise$1(function (resolve, reject) {
        var reader = new FileReader();
        reader.onerror = reject;
        reader.onloadend = function (e) {
            var base64 = btoa(e.target.result || '');
            resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
            });
        };
        reader.readAsBinaryString(blob);
    });
}

// decode an encoded blob
function _decodeBlob(encodedBlob) {
    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
    return createBlob([arrayBuff], { type: encodedBlob.type });
}

// is this one of our fancy encoded blobs?
function _isEncodedBlob(value) {
    return value && value.__local_forage_encoded_blob;
}

// Specialize the default `ready()` function by making it dependent
// on the current database operations. Thus, the driver will be actually
// ready when it's been initialized (default) *and* there are no pending
// operations on the database (initiated by some other instances).
function _fullyReady(callback) {
    var self = this;

    var promise = self._initReady().then(function () {
        var dbContext = dbContexts[self._dbInfo.name];

        if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
        }
    });

    executeTwoCallbacks(promise, callback, callback);
    return promise;
}

// Try to establish a new db connection to replace the
// current one which is broken (i.e. experiencing
// InvalidStateError while creating a transaction).
function _tryReconnect(dbInfo) {
    _deferReadiness(dbInfo);

    var dbContext = dbContexts[dbInfo.name];
    var forages = dbContext.forages;

    for (var i = 0; i < forages.length; i++) {
        var forage = forages[i];
        if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
        }
    }
    dbInfo.db = null;

    return _getOriginalConnection(dbInfo).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        // store the latest db reference
        // in case the db was upgraded
        dbInfo.db = dbContext.db = db;
        for (var i = 0; i < forages.length; i++) {
            forages[i]._dbInfo.db = db;
        }
    })["catch"](function (err) {
        _rejectReadiness(dbInfo, err);
        throw err;
    });
}

// FF doesn't like Promises (micro-tasks) and IDDB store operations,
// so we have to do it with callbacks
function createTransaction(dbInfo, mode, callback, retries) {
    if (retries === undefined) {
        retries = 1;
    }

    try {
        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
        callback(null, tx);
    } catch (err) {
        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
            return Promise$1.resolve().then(function () {
                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                    // increase the db version, to create the new ObjectStore
                    if (dbInfo.db) {
                        dbInfo.version = dbInfo.db.version + 1;
                    }
                    // Reopen the database for upgrading.
                    return _getUpgradedConnection(dbInfo);
                }
            }).then(function () {
                return _tryReconnect(dbInfo).then(function () {
                    createTransaction(dbInfo, mode, callback, retries - 1);
                });
            })["catch"](callback);
        }

        callback(err);
    }
}

function createDbContext() {
    return {
        // Running localForages sharing a database.
        forages: [],
        // Shared database.
        db: null,
        // Database readiness (promise).
        dbReady: null,
        // Deferred operations on the database.
        deferredOperations: []
    };
}

// Open the IndexedDB database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    // Get the current context of the database;
    var dbContext = dbContexts[dbInfo.name];

    // ...or create a new context.
    if (!dbContext) {
        dbContext = createDbContext();
        // Register the new context in the global container.
        dbContexts[dbInfo.name] = dbContext;
    }

    // Register itself as a running localForage in the current context.
    dbContext.forages.push(self);

    // Replace the default `ready()` function with the specialized one.
    if (!self._initReady) {
        self._initReady = self.ready;
        self.ready = _fullyReady;
    }

    // Create an array of initialization states of the related localForages.
    var initPromises = [];

    function ignoreErrors() {
        // Don't handle errors here,
        // just makes sure related localForages aren't pending.
        return Promise$1.resolve();
    }

    for (var j = 0; j < dbContext.forages.length; j++) {
        var forage = dbContext.forages[j];
        if (forage !== self) {
            // Don't wait for itself...
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
        }
    }

    // Take a snapshot of the related localForages.
    var forages = dbContext.forages.slice(0);

    // Initialize the connection process only when
    // all the related localForages aren't pending.
    return Promise$1.all(initPromises).then(function () {
        dbInfo.db = dbContext.db;
        // Get the connection or open a new one without upgrade.
        return _getOriginalConnection(dbInfo);
    }).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        dbInfo.db = dbContext.db = db;
        self._dbInfo = dbInfo;
        // Share the final connection amongst related localForages.
        for (var k = 0; k < forages.length; k++) {
            var forage = forages[k];
            if (forage !== self) {
                // Self is already up-to-date.
                forage._dbInfo.db = dbInfo.db;
                forage._dbInfo.version = dbInfo.version;
            }
        }
    });
}

function getItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.get(key);

                    req.onsuccess = function () {
                        var value = req.result;
                        if (value === undefined) {
                            value = null;
                        }
                        if (_isEncodedBlob(value)) {
                            value = _decodeBlob(value);
                        }
                        resolve(value);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items stored in database.
function iterate(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openCursor();
                    var iterationNumber = 1;

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (cursor) {
                            var value = cursor.value;
                            if (_isEncodedBlob(value)) {
                                value = _decodeBlob(value);
                            }
                            var result = iterator(value, cursor.key, iterationNumber++);

                            // when the iterator callback returns any
                            // (non-`undefined`) value, then we stop
                            // the iteration immediately
                            if (result !== void 0) {
                                resolve(result);
                            } else {
                                cursor["continue"]();
                            }
                        } else {
                            resolve();
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);

    return promise;
}

function setItem(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        var dbInfo;
        self.ready().then(function () {
            dbInfo = self._dbInfo;
            if (toString.call(value) === '[object Blob]') {
                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
                    if (blobSupport) {
                        return value;
                    }
                    return _encodeBlob(value);
                });
            }
            return value;
        }).then(function (value) {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);

                    // The reason we don't _save_ null is because IE 10 does
                    // not support saving the `null` type in IndexedDB. How
                    // ironic, given the bug below!
                    // See: https://github.com/mozilla/localForage/issues/161
                    if (value === null) {
                        value = undefined;
                    }

                    var req = store.put(value, key);

                    transaction.oncomplete = function () {
                        // Cast to undefined so the value passed to
                        // callback/promise is the same as what one would get out
                        // of `getItem()` later. This leads to some weirdness
                        // (setItem('foo', undefined) will return `null`), but
                        // it's not my fault localStorage is our baseline and that
                        // it's weird.
                        if (value === undefined) {
                            value = null;
                        }

                        resolve(value);
                    };
                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function removeItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    // We use a Grunt task to make this safe for IE and some
                    // versions of Android (including those used by Cordova).
                    // Normally IE won't like `.delete()` and will insist on
                    // using `['delete']()`, but we have a build step that
                    // fixes this for us now.
                    var req = store["delete"](key);
                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onerror = function () {
                        reject(req.error);
                    };

                    // The request will be also be aborted if we've exceeded our storage
                    // space.
                    transaction.onabort = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function clear(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.clear();

                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function length(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.count();

                    req.onsuccess = function () {
                        resolve(req.result);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function key(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        if (n < 0) {
            resolve(null);

            return;
        }

        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var advanced = false;
                    var req = store.openKeyCursor();

                    req.onsuccess = function () {
                        var cursor = req.result;
                        if (!cursor) {
                            // this means there weren't enough keys
                            resolve(null);

                            return;
                        }

                        if (n === 0) {
                            // We have the first key, return it if that's what they
                            // wanted.
                            resolve(cursor.key);
                        } else {
                            if (!advanced) {
                                // Otherwise, ask the cursor to skip ahead n
                                // records.
                                advanced = true;
                                cursor.advance(n);
                            } else {
                                // When we get here, we've got the nth key.
                                resolve(cursor.key);
                            }
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openKeyCursor();
                    var keys = [];

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (!cursor) {
                            resolve(keys);
                            return;
                        }

                        keys.push(cursor.key);
                        cursor["continue"]();
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;

        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db;
            for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
            }
            return db;
        });

        if (!options.storeName) {
            promise = dbPromise.then(function (db) {
                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                }

                var dropDBPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.deleteDatabase(options.name);

                    req.onerror = function () {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        reject(req.error);
                    };

                    req.onblocked = function () {
                        // Closing all open connections in onversionchange handler should prevent this situation, but if
                        // we do get here, it just means the request remains pending - eventually it will succeed or error
                        console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        resolve(db);
                    };
                });

                return dropDBPromise.then(function (db) {
                    dbContext.db = db;
                    for (var i = 0; i < forages.length; i++) {
                        var _forage = forages[i];
                        _advanceReadiness(_forage._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        } else {
            promise = dbPromise.then(function (db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                    return;
                }

                var newVersion = db.version + 1;

                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                    forage._dbInfo.version = newVersion;
                }

                var dropObjectPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.open(options.name, newVersion);

                    req.onerror = function (err) {
                        var db = req.result;
                        db.close();
                        reject(err);
                    };

                    req.onupgradeneeded = function () {
                        var db = req.result;
                        db.deleteObjectStore(options.storeName);
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        db.close();
                        resolve(db);
                    };
                });

                return dropObjectPromise.then(function (db) {
                    dbContext.db = db;
                    for (var j = 0; j < forages.length; j++) {
                        var _forage2 = forages[j];
                        _forage2._dbInfo.db = db;
                        _advanceReadiness(_forage2._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        }
    }

    executeCallback(promise, callback);
    return promise;
}

var asyncStorage = {
    _driver: 'asyncStorage',
    _initStorage: _initStorage,
    _support: isIndexedDBValid(),
    iterate: iterate,
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    clear: clear,
    length: length,
    key: key,
    keys: keys,
    dropInstance: dropInstance
};

function isWebSQLValid() {
    return typeof openDatabase === 'function';
}

// Sadly, the best way to save binary data in WebSQL/localStorage is serializing
// it to Base64, so this is how we store it to prevent very strange errors with less
// verbose ways of binary <-> string data storage.
var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

var BLOB_TYPE_PREFIX = '~~local_forage_type~';
var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;

var SERIALIZED_MARKER = '__lfsc__:';
var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

// OMG the serializations!
var TYPE_ARRAYBUFFER = 'arbf';
var TYPE_BLOB = 'blob';
var TYPE_INT8ARRAY = 'si08';
var TYPE_UINT8ARRAY = 'ui08';
var TYPE_UINT8CLAMPEDARRAY = 'uic8';
var TYPE_INT16ARRAY = 'si16';
var TYPE_INT32ARRAY = 'si32';
var TYPE_UINT16ARRAY = 'ur16';
var TYPE_UINT32ARRAY = 'ui32';
var TYPE_FLOAT32ARRAY = 'fl32';
var TYPE_FLOAT64ARRAY = 'fl64';
var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;

var toString$1 = Object.prototype.toString;

function stringToBuffer(serializedString) {
    // Fill the string into a ArrayBuffer.
    var bufferLength = serializedString.length * 0.75;
    var len = serializedString.length;
    var i;
    var p = 0;
    var encoded1, encoded2, encoded3, encoded4;

    if (serializedString[serializedString.length - 1] === '=') {
        bufferLength--;
        if (serializedString[serializedString.length - 2] === '=') {
            bufferLength--;
        }
    }

    var buffer = new ArrayBuffer(bufferLength);
    var bytes = new Uint8Array(buffer);

    for (i = 0; i < len; i += 4) {
        encoded1 = BASE_CHARS.indexOf(serializedString[i]);
        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

        /*jslint bitwise: true */
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return buffer;
}

// Converts a buffer to a string to store, serialized, in the backend
// storage library.
function bufferToString(buffer) {
    // base64-arraybuffer
    var bytes = new Uint8Array(buffer);
    var base64String = '';
    var i;

    for (i = 0; i < bytes.length; i += 3) {
        /*jslint bitwise: true */
        base64String += BASE_CHARS[bytes[i] >> 2];
        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64String += BASE_CHARS[bytes[i + 2] & 63];
    }

    if (bytes.length % 3 === 2) {
        base64String = base64String.substring(0, base64String.length - 1) + '=';
    } else if (bytes.length % 3 === 1) {
        base64String = base64String.substring(0, base64String.length - 2) + '==';
    }

    return base64String;
}

// Serialize a value, afterwards executing a callback (which usually
// instructs the `setItem()` callback/promise to be executed). This is how
// we store binary data with localStorage.
function serialize(value, callback) {
    var valueType = '';
    if (value) {
        valueType = toString$1.call(value);
    }

    // Cannot use `value instanceof ArrayBuffer` or such here, as these
    // checks fail when running the tests using casper.js...
    //
    // TODO: See why those tests fail and use a better solution.
    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
        // Convert binary arrays to a string and prefix the string with
        // a special marker.
        var buffer;
        var marker = SERIALIZED_MARKER;

        if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
        } else {
            buffer = value.buffer;

            if (valueType === '[object Int8Array]') {
                marker += TYPE_INT8ARRAY;
            } else if (valueType === '[object Uint8Array]') {
                marker += TYPE_UINT8ARRAY;
            } else if (valueType === '[object Uint8ClampedArray]') {
                marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === '[object Int16Array]') {
                marker += TYPE_INT16ARRAY;
            } else if (valueType === '[object Uint16Array]') {
                marker += TYPE_UINT16ARRAY;
            } else if (valueType === '[object Int32Array]') {
                marker += TYPE_INT32ARRAY;
            } else if (valueType === '[object Uint32Array]') {
                marker += TYPE_UINT32ARRAY;
            } else if (valueType === '[object Float32Array]') {
                marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === '[object Float64Array]') {
                marker += TYPE_FLOAT64ARRAY;
            } else {
                callback(new Error('Failed to get type for BinaryArray'));
            }
        }

        callback(marker + bufferToString(buffer));
    } else if (valueType === '[object Blob]') {
        // Conver the blob to a binaryArray and then to a string.
        var fileReader = new FileReader();

        fileReader.onload = function () {
            // Backwards-compatible prefix for the blob type.
            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);

            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
        };

        fileReader.readAsArrayBuffer(value);
    } else {
        try {
            callback(JSON.stringify(value));
        } catch (e) {
            console.error("Couldn't convert value into a JSON string: ", value);

            callback(null, e);
        }
    }
}

// Deserialize data we've inserted into a value column/field. We place
// special markers into our strings to mark them as encoded; this isn't
// as nice as a meta field, but it's the only sane thing we can do whilst
// keeping localStorage support intact.
//
// Oftentimes this will just deserialize JSON content, but if we have a
// special marker (SERIALIZED_MARKER, defined above), we will extract
// some kind of arraybuffer/binary data/typed array out of the string.
function deserialize(value) {
    // If we haven't marked this string as being specially serialized (i.e.
    // something other than serialized JSON), we can just return it and be
    // done with it.
    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
        return JSON.parse(value);
    }

    // The following code deals with deserializing some kind of Blob or
    // TypedArray. First we separate out the type of data we're dealing
    // with from the data itself.
    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);

    var blobType;
    // Backwards-compatible blob type serialization strategy.
    // DBs created with older versions of localForage will simply not have the blob type.
    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
        blobType = matcher[1];
        serializedString = serializedString.substring(matcher[0].length);
    }
    var buffer = stringToBuffer(serializedString);

    // Return the right type based on the code/type set during
    // serialization.
    switch (type) {
        case TYPE_ARRAYBUFFER:
            return buffer;
        case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
        case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
        case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
        case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
        case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
        case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
        case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
        case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
        case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
        case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
        default:
            throw new Error('Unkown type: ' + type);
    }
}

var localforageSerializer = {
    serialize: serialize,
    deserialize: deserialize,
    stringToBuffer: stringToBuffer,
    bufferToString: bufferToString
};

/*
 * Includes code from:
 *
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */

function createDbTable(t, dbInfo, callback, errorCallback) {
    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
}

// Open the WebSQL database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage$1(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
        }
    }

    var dbInfoPromise = new Promise$1(function (resolve, reject) {
        // Open the database; the openDatabase API will automatically
        // create it for us if it doesn't exist.
        try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
        } catch (e) {
            return reject(e);
        }

        // Create our key/value table if it doesn't exist.
        dbInfo.db.transaction(function (t) {
            createDbTable(t, dbInfo, function () {
                self._dbInfo = dbInfo;
                resolve();
            }, function (t, error) {
                reject(error);
            });
        }, reject);
    });

    dbInfo.serializer = localforageSerializer;
    return dbInfoPromise;
}

function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
    t.executeSql(sqlStatement, args, callback, function (t, error) {
        if (error.code === error.SYNTAX_ERR) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
                if (!results.rows.length) {
                    // if the table is missing (was deleted)
                    // re-create it table and retry
                    createDbTable(t, dbInfo, function () {
                        t.executeSql(sqlStatement, args, callback, errorCallback);
                    }, errorCallback);
                } else {
                    errorCallback(t, error);
                }
            }, errorCallback);
        } else {
            errorCallback(t, error);
        }
    }, errorCallback);
}

function getItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).value : null;

                    // Check to see if this is serialized content we need to
                    // unpack.
                    if (result) {
                        result = dbInfo.serializer.deserialize(result);
                    }

                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function iterate$1(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;

            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
                    var rows = results.rows;
                    var length = rows.length;

                    for (var i = 0; i < length; i++) {
                        var item = rows.item(i);
                        var result = item.value;

                        // Check to see if this is serialized content
                        // we need to unpack.
                        if (result) {
                            result = dbInfo.serializer.deserialize(result);
                        }

                        result = iterator(result, item.key, i + 1);

                        // void(0) prevents problems with redefinition
                        // of `undefined`.
                        if (result !== void 0) {
                            resolve(result);
                            return;
                        }
                    }

                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function _setItem(key, value, callback, retriesLeft) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            // The localStorage API doesn't return undefined values in an
            // "expected" way, so undefined is always cast to null in all
            // drivers. See: https://github.com/mozilla/localForage/pull/42
            if (value === undefined) {
                value = null;
            }

            // Save the original value to pass to the callback.
            var originalValue = value;

            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
                            resolve(originalValue);
                        }, function (t, error) {
                            reject(error);
                        });
                    }, function (sqlError) {
                        // The transaction failed; check
                        // to see if it's a quota error.
                        if (sqlError.code === sqlError.QUOTA_ERR) {
                            // We reject the callback outright for now, but
                            // it's worth trying to re-run the transaction.
                            // Even if the user accepts the prompt to use
                            // more storage on Safari, this error will
                            // be called.
                            //
                            // Try to re-run the transaction.
                            if (retriesLeft > 0) {
                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
                                return;
                            }
                            reject(sqlError);
                        }
                    });
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function setItem$1(key, value, callback) {
    return _setItem.apply(this, [key, value, callback, 1]);
}

function removeItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Deletes every item in the table.
// TODO: Find out if this resets the AUTO_INCREMENT number.
function clear$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Does a simple `COUNT(key)` to get the number of items stored in
// localForage.
function length$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                // Ahhh, SQL makes this one soooooo easy.
                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
                    var result = results.rows.item(0).c;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Return the key located at key index X; essentially gets the key from a
// `WHERE id = ?`. This is the most efficient way I can think to implement
// this rarely-used (in my experience) part of the API, but it can seem
// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
// the ID of each key will change every time it's updated. Perhaps a stored
// procedure for the `setItem()` SQL would solve this problem?
// TODO: Don't change ID on `setItem()`.
function key$1(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).key : null;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
                    var keys = [];

                    for (var i = 0; i < results.rows.length; i++) {
                        keys.push(results.rows.item(i).key);
                    }

                    resolve(keys);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// https://www.w3.org/TR/webdatabase/#databases
// > There is no way to enumerate or delete the databases available for an origin from this API.
function getAllStoreNames(db) {
    return new Promise$1(function (resolve, reject) {
        db.transaction(function (t) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
                var storeNames = [];

                for (var i = 0; i < results.rows.length; i++) {
                    storeNames.push(results.rows.item(i).name);
                }

                resolve({
                    db: db,
                    storeNames: storeNames
                });
            }, function (t, error) {
                reject(error);
            });
        }, function (sqlError) {
            reject(sqlError);
        });
    });
}

function dropInstance$1(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            var db;
            if (options.name === currentConfig.name) {
                // use the db reference of the current instance
                db = self._dbInfo.db;
            } else {
                db = openDatabase(options.name, '', '', 0);
            }

            if (!options.storeName) {
                // drop all database tables
                resolve(getAllStoreNames(db));
            } else {
                resolve({
                    db: db,
                    storeNames: [options.storeName]
                });
            }
        }).then(function (operationInfo) {
            return new Promise$1(function (resolve, reject) {
                operationInfo.db.transaction(function (t) {
                    function dropTable(storeName) {
                        return new Promise$1(function (resolve, reject) {
                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
                                resolve();
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    }

                    var operations = [];
                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                        operations.push(dropTable(operationInfo.storeNames[i]));
                    }

                    Promise$1.all(operations).then(function () {
                        resolve();
                    })["catch"](function (e) {
                        reject(e);
                    });
                }, function (sqlError) {
                    reject(sqlError);
                });
            });
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var webSQLStorage = {
    _driver: 'webSQLStorage',
    _initStorage: _initStorage$1,
    _support: isWebSQLValid(),
    iterate: iterate$1,
    getItem: getItem$1,
    setItem: setItem$1,
    removeItem: removeItem$1,
    clear: clear$1,
    length: length$1,
    key: key$1,
    keys: keys$1,
    dropInstance: dropInstance$1
};

function isLocalStorageValid() {
    try {
        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
        // in IE8 typeof localStorage.setItem === 'object'
        !!localStorage.setItem;
    } catch (e) {
        return false;
    }
}

function _getKeyPrefix(options, defaultConfig) {
    var keyPrefix = options.name + '/';

    if (options.storeName !== defaultConfig.storeName) {
        keyPrefix += options.storeName + '/';
    }
    return keyPrefix;
}

// Check if localStorage throws when saving an item
function checkIfLocalStorageThrows() {
    var localStorageTestKey = '_localforage_support_test';

    try {
        localStorage.setItem(localStorageTestKey, true);
        localStorage.removeItem(localStorageTestKey);

        return false;
    } catch (e) {
        return true;
    }
}

// Check if localStorage is usable and allows to save an item
// This method checks if localStorage is usable in Safari Private Browsing
// mode, or in any other case where the available quota for localStorage
// is 0 and there wasn't any saved items yet.
function _isLocalStorageUsable() {
    return !checkIfLocalStorageThrows() || localStorage.length > 0;
}

// Config the localStorage backend, using options set in the config.
function _initStorage$2(options) {
    var self = this;
    var dbInfo = {};
    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);

    if (!_isLocalStorageUsable()) {
        return Promise$1.reject();
    }

    self._dbInfo = dbInfo;
    dbInfo.serializer = localforageSerializer;

    return Promise$1.resolve();
}

// Remove all keys from the datastore, effectively destroying all data in
// the app's key/value store!
function clear$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var keyPrefix = self._dbInfo.keyPrefix;

        for (var i = localStorage.length - 1; i >= 0; i--) {
            var key = localStorage.key(i);

            if (key.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key);
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Retrieve an item from the store. Unlike the original async_storage
// library in Gaia, we don't modify return values at all. If a key's value
// is `undefined`, we pass that value to the callback function.
function getItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result = localStorage.getItem(dbInfo.keyPrefix + key);

        // If a result was found, parse it from the serialized
        // string into a JS object. If result isn't truthy, the key
        // is likely undefined and we'll pass it straight to the
        // callback.
        if (result) {
            result = dbInfo.serializer.deserialize(result);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items in the store.
function iterate$2(iterator, callback) {
    var self = this;

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var keyPrefix = dbInfo.keyPrefix;
        var keyPrefixLength = keyPrefix.length;
        var length = localStorage.length;

        // We use a dedicated iterator instead of the `i` variable below
        // so other keys we fetch in localStorage aren't counted in
        // the `iterationNumber` argument passed to the `iterate()`
        // callback.
        //
        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
        var iterationNumber = 1;

        for (var i = 0; i < length; i++) {
            var key = localStorage.key(i);
            if (key.indexOf(keyPrefix) !== 0) {
                continue;
            }
            var value = localStorage.getItem(key);

            // If a result was found, parse it from the serialized
            // string into a JS object. If result isn't truthy, the
            // key is likely undefined and we'll pass it straight
            // to the iterator.
            if (value) {
                value = dbInfo.serializer.deserialize(value);
            }

            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

            if (value !== void 0) {
                return value;
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Same as localStorage's key() method, except takes a callback.
function key$2(n, callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result;
        try {
            result = localStorage.key(n);
        } catch (error) {
            result = null;
        }

        // Remove the prefix from the key, if a key is found.
        if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var length = localStorage.length;
        var keys = [];

        for (var i = 0; i < length; i++) {
            var itemKey = localStorage.key(i);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
        }

        return keys;
    });

    executeCallback(promise, callback);
    return promise;
}

// Supply the number of keys in the datastore to the callback function.
function length$2(callback) {
    var self = this;
    var promise = self.keys().then(function (keys) {
        return keys.length;
    });

    executeCallback(promise, callback);
    return promise;
}

// Remove an item from the store, nice and simple.
function removeItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        localStorage.removeItem(dbInfo.keyPrefix + key);
    });

    executeCallback(promise, callback);
    return promise;
}

// Set a key's value and run an optional callback once the value is set.
// Unlike Gaia's implementation, the callback function is passed the value,
// in case you want to operate on that value only after you're sure it
// saved, or something like that.
function setItem$2(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        // Convert undefined values to null.
        // https://github.com/mozilla/localForage/pull/42
        if (value === undefined) {
            value = null;
        }

        // Save the original value to pass to the callback.
        var originalValue = value;

        return new Promise$1(function (resolve, reject) {
            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    try {
                        localStorage.setItem(dbInfo.keyPrefix + key, value);
                        resolve(originalValue);
                    } catch (e) {
                        // localStorage capacity exceeded.
                        // TODO: Make this a specific error/event.
                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                            reject(e);
                        }
                        reject(e);
                    }
                }
            });
        });
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance$2(options, callback) {
    callback = getCallback.apply(this, arguments);

    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        var currentConfig = this.config();
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            if (!options.storeName) {
                resolve(options.name + '/');
            } else {
                resolve(_getKeyPrefix(options, self._defaultConfig));
            }
        }).then(function (keyPrefix) {
            for (var i = localStorage.length - 1; i >= 0; i--) {
                var key = localStorage.key(i);

                if (key.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key);
                }
            }
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var localStorageWrapper = {
    _driver: 'localStorageWrapper',
    _initStorage: _initStorage$2,
    _support: isLocalStorageValid(),
    iterate: iterate$2,
    getItem: getItem$2,
    setItem: setItem$2,
    removeItem: removeItem$2,
    clear: clear$2,
    length: length$2,
    key: key$2,
    keys: keys$2,
    dropInstance: dropInstance$2
};

var sameValue = function sameValue(x, y) {
    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
};

var includes = function includes(array, searchElement) {
    var len = array.length;
    var i = 0;
    while (i < len) {
        if (sameValue(array[i], searchElement)) {
            return true;
        }
        i++;
    }

    return false;
};

var isArray = Array.isArray || function (arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
};

// Drivers are stored here when `defineDriver()` is called.
// They are shared across all instances of localForage.
var DefinedDrivers = {};

var DriverSupport = {};

var DefaultDrivers = {
    INDEXEDDB: asyncStorage,
    WEBSQL: webSQLStorage,
    LOCALSTORAGE: localStorageWrapper
};

var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];

var OptionalDriverMethods = ['dropInstance'];

var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);

var DefaultConfig = {
    description: '',
    driver: DefaultDriverOrder.slice(),
    name: 'localforage',
    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
    // we can use without a prompt.
    size: 4980736,
    storeName: 'keyvaluepairs',
    version: 1.0
};

function callWhenReady(localForageInstance, libraryMethod) {
    localForageInstance[libraryMethod] = function () {
        var _args = arguments;
        return localForageInstance.ready().then(function () {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
        });
    };
}

function extend() {
    for (var i = 1; i < arguments.length; i++) {
        var arg = arguments[i];

        if (arg) {
            for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                    if (isArray(arg[_key])) {
                        arguments[0][_key] = arg[_key].slice();
                    } else {
                        arguments[0][_key] = arg[_key];
                    }
                }
            }
        }
    }

    return arguments[0];
}

var LocalForage = function () {
    function LocalForage(options) {
        _classCallCheck(this, LocalForage);

        for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;

                if (!DefinedDrivers[driverName]) {
                    // we don't need to wait for the promise,
                    // since the default drivers can be defined
                    // in a blocking manner
                    this.defineDriver(driver);
                }
            }
        }

        this._defaultConfig = extend({}, DefaultConfig);
        this._config = extend({}, this._defaultConfig, options);
        this._driverSet = null;
        this._initDriver = null;
        this._ready = false;
        this._dbInfo = null;

        this._wrapLibraryMethodsWithReady();
        this.setDriver(this._config.driver)["catch"](function () {});
    }

    // Set any config values for localForage; can be called anytime before
    // the first API call (e.g. `getItem`, `setItem`).
    // We loop through options so we don't overwrite existing config
    // values.


    LocalForage.prototype.config = function config(options) {
        // If the options argument is an object, we use it to set values.
        // Otherwise, we return either a specified config value or all
        // config values.
        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            // If localforage is ready and fully initialized, we can't set
            // any new configuration values. Instead, we return an error.
            if (this._ready) {
                return new Error("Can't call config() after localforage " + 'has been used.');
            }

            for (var i in options) {
                if (i === 'storeName') {
                    options[i] = options[i].replace(/\W/g, '_');
                }

                if (i === 'version' && typeof options[i] !== 'number') {
                    return new Error('Database version must be a number.');
                }

                this._config[i] = options[i];
            }

            // after all config options are set and
            // the driver option is used, try setting it
            if ('driver' in options && options.driver) {
                return this.setDriver(this._config.driver);
            }

            return true;
        } else if (typeof options === 'string') {
            return this._config[options];
        } else {
            return this._config;
        }
    };

    // Used to define a custom driver, shared across all instances of
    // localForage.


    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
        var promise = new Promise$1(function (resolve, reject) {
            try {
                var driverName = driverObject._driver;
                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');

                // A driver name should be defined and not overlap with the
                // library-defined, default drivers.
                if (!driverObject._driver) {
                    reject(complianceError);
                    return;
                }

                var driverMethods = LibraryMethods.concat('_initStorage');
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                    var driverMethodName = driverMethods[i];

                    // when the property is there,
                    // it should be a method even when optional
                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
                        reject(complianceError);
                        return;
                    }
                }

                var configureMissingMethods = function configureMissingMethods() {
                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
                        return function () {
                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
                            var promise = Promise$1.reject(error);
                            executeCallback(promise, arguments[arguments.length - 1]);
                            return promise;
                        };
                    };

                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                        var optionalDriverMethod = OptionalDriverMethods[_i];
                        if (!driverObject[optionalDriverMethod]) {
                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                        }
                    }
                };

                configureMissingMethods();

                var setDriverSupport = function setDriverSupport(support) {
                    if (DefinedDrivers[driverName]) {
                        console.info('Redefining LocalForage driver: ' + driverName);
                    }
                    DefinedDrivers[driverName] = driverObject;
                    DriverSupport[driverName] = support;
                    // don't use a then, so that we can define
                    // drivers that have simple _support methods
                    // in a blocking manner
                    resolve();
                };

                if ('_support' in driverObject) {
                    if (driverObject._support && typeof driverObject._support === 'function') {
                        driverObject._support().then(setDriverSupport, reject);
                    } else {
                        setDriverSupport(!!driverObject._support);
                    }
                } else {
                    setDriverSupport(true);
                }
            } catch (e) {
                reject(e);
            }
        });

        executeTwoCallbacks(promise, callback, errorCallback);
        return promise;
    };

    LocalForage.prototype.driver = function driver() {
        return this._driver || null;
    };

    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));

        executeTwoCallbacks(getDriverPromise, callback, errorCallback);
        return getDriverPromise;
    };

    LocalForage.prototype.getSerializer = function getSerializer(callback) {
        var serializerPromise = Promise$1.resolve(localforageSerializer);
        executeTwoCallbacks(serializerPromise, callback);
        return serializerPromise;
    };

    LocalForage.prototype.ready = function ready(callback) {
        var self = this;

        var promise = self._driverSet.then(function () {
            if (self._ready === null) {
                self._ready = self._initDriver();
            }

            return self._ready;
        });

        executeTwoCallbacks(promise, callback, callback);
        return promise;
    };

    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
        var self = this;

        if (!isArray(drivers)) {
            drivers = [drivers];
        }

        var supportedDrivers = this._getSupportedDrivers(drivers);

        function setDriverToConfig() {
            self._config.driver = self.driver();
        }

        function extendSelfWithDriver(driver) {
            self._extend(driver);
            setDriverToConfig();

            self._ready = self._initStorage(self._config);
            return self._ready;
        }

        function initDriver(supportedDrivers) {
            return function () {
                var currentDriverIndex = 0;

                function driverPromiseLoop() {
                    while (currentDriverIndex < supportedDrivers.length) {
                        var driverName = supportedDrivers[currentDriverIndex];
                        currentDriverIndex++;

                        self._dbInfo = null;
                        self._ready = null;

                        return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                    }

                    setDriverToConfig();
                    var error = new Error('No available storage method found.');
                    self._driverSet = Promise$1.reject(error);
                    return self._driverSet;
                }

                return driverPromiseLoop();
            };
        }

        // There might be a driver initialization in progress
        // so wait for it to finish in order to avoid a possible
        // race condition to set _dbInfo
        var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
            return Promise$1.resolve();
        }) : Promise$1.resolve();

        this._driverSet = oldDriverSetDone.then(function () {
            var driverName = supportedDrivers[0];
            self._dbInfo = null;
            self._ready = null;

            return self.getDriver(driverName).then(function (driver) {
                self._driver = driver._driver;
                setDriverToConfig();
                self._wrapLibraryMethodsWithReady();
                self._initDriver = initDriver(supportedDrivers);
            });
        })["catch"](function () {
            setDriverToConfig();
            var error = new Error('No available storage method found.');
            self._driverSet = Promise$1.reject(error);
            return self._driverSet;
        });

        executeTwoCallbacks(this._driverSet, callback, errorCallback);
        return this._driverSet;
    };

    LocalForage.prototype.supports = function supports(driverName) {
        return !!DriverSupport[driverName];
    };

    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
        extend(this, libraryMethodsAndProperties);
    };

    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
        var supportedDrivers = [];
        for (var i = 0, len = drivers.length; i < len; i++) {
            var driverName = drivers[i];
            if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
            }
        }
        return supportedDrivers;
    };

    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
        // Add a stub for each driver API method that delays the call to the
        // corresponding driver method until localForage is ready. These stubs
        // will be replaced by the driver methods as soon as the driver is
        // loaded, so there is no performance impact.
        for (var i = 0, len = LibraryMethods.length; i < len; i++) {
            callWhenReady(this, LibraryMethods[i]);
        }
    };

    LocalForage.prototype.createInstance = function createInstance(options) {
        return new LocalForage(options);
    };

    return LocalForage;
}();

// The actual localForage object that we expose as a module or via a
// global. It's extended by pulling in one of our other libraries.


var localforage_js = new LocalForage();

module.exports = localforage_js;

},{"3":3}]},{},[4])(4)
});

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],81:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],82:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":81,"timers":82}],83:[function(require,module,exports){
let nextId = 1;

class Node {
    constructor(id = nextId++) {
        this.id = id;
    }
}

class Directory extends Node {
    constructor() {
        super();
        this.children = {};
    }

    addChild(entry) {
        this.children[entry.name] = entry;
    }

    unlink(entry) {
        if (this.children[entry.name] == entry)
            delete this.children[entry.name];
    }

    lookup(name) {
        return this.children[name];
    }

    unserialize(tree, ids) {
        ids.forEach(id => {
            let entry = tree[id];
            this.children[entry.name] = entry;
        });
    }

    serialize(tree) {
        const ids = [];
        for (let key in this.children) {
            let child = this.children[key];
            ids.push(child.id);
            child.serialize(tree);
        }
        tree[this.id] = {Directory:[ids]}
    }
}

class File extends Node {
    constructor(data = null) {
        super();
        this.data = data;
    }

    serialize(tree) {
        tree[this.id] = {File:[this.data]};
    }
}

class Entry extends Node {
    constructor(name, node) {
        super();
        this.name = name;
        this.node = node;
    }

    is(type) {
        return this.node instanceof type;
    }

    isFile() {return this.is(File);}
    isDirectory() {return this.is(Directory);}

    get extension () {
        return (this.name.match(/\.([^./]+)$/i)?.[1] || '').toLowerCase();
    }

    unserialize(tree, name, node) {
        this.name = name;
        this.node = tree[node];
        if (!this.node) {
            this.node = new Directory();
            this.node.id = node;
        }
    }

    serialize(tree) {
        this.node.serialize(tree);
        tree[this.id] = {Entry:[this.name, this.node.id]};
    }
}

module.exports.PNGFS = class PNGFS {
    #jsonCache;

    onDirty;

    constructor(image) {
        this.root = new Entry("", new Directory());
        this.root.id = "root";
        this.path = [this.root];
        this.version = 1;
        if (image && image.pngfs <= this.version)
            this.loadJSON(image);
    }

    dirty() {
        this.#jsonCache = null;
        this.onDirty?.();
    }

    loadJSON(tree) {
        const classes = {Entry, File, Directory};
        const index = {};
        const args = {};
        for (let id in tree) {
            if (id == "pngfs")
                continue;
            const meta = tree[id];
            const ctorName = Object.keys(meta)[0];
            const ctor = classes[ctorName];
            args[id] = meta[ctorName];
            const obj = new ctor(...args[id]);
            obj.id = id;
            index[id] = obj;
            if (nextId <= id)
                nextId = id + 1;
        }
        for (const id in index) {
            const obj = index[id];
            if (obj.unserialize)
                obj.unserialize(index, ...args[id]);
        }
        this.root = index.root;
        this.path = [this.root];
    }

    toJSON(){
        if (this.#jsonCache) {
            // console.log("Skipping serialization of cached PNGFS");
            return this.#jsonCache;
        }
        const tree = {pngfs:this.version};
        this.root.serialize(tree);
        this.#jsonCache = tree;
        // console.log("Serialized PNGFS");
        return tree;
    }

    ls(p = "") {
        const path = [...this.path];

        const parts = p.split('/');
        if (p && parts.length) {
            if (parts[0] == '') {
                path.length = 1;
                parts.shift();
            }

            while (parts.length) {
                const part = parts.shift();
                if (part == '.' || part == '')
                    continue;

                if (part == '..') {
                    if (path.length == 1)
                        return false;
                    path.pop();
                    continue;
                }

                const top = path[path.length - 1];
                const child = top.node.lookup(part);

                if (!child || !child.is(Directory))
                    return false;
                path.push(child);
            }
        }

        const top = path[path.length - 1];

        return Object.values(top.node.children);
    }

    cd(p) {
        const parts = p.split('/');
        if (!parts.length)
            return true;

        if (parts[0] == '') {
            this.path.length = 1;
            parts.shift();
        }

        while (parts.length) {
            const part = parts.shift();
            if (part == '.' || part == '')
                continue;

            if (part == '..') {
                if (this.path.length == 1)
                    return false;
                this.path.pop();
                continue;
            }

            const top = this.path[this.path.length - 1];
            const child = top.node.lookup(part);
            if (!child || !child.is(Directory))
                return false;

            this.path.push(child);
        }

        return true;
    }

    mkdir(p) {
        const path = [...this.path];
        const parts = p.split('/');
        if (!parts.length)
            return true;

        if (parts[0] == '') {
            path.length = 1;
            parts.shift();
        }

        while (parts.length) {
            const part = parts.shift();
            if (part == '.' || part == '')
                continue;

            if (part == '..') {
                if (path.length == 1)
                    return false;
                path.pop();
                continue;
            }

            const top = path[path.length - 1];
            const child = top.node.lookup(part);

            if (!child) {
                const entry = new Entry(part, new Directory());
                top.node.addChild(entry);
                path.push(entry);
                this.dirty();
            } else {
                if (!child.is(Directory))
                    return false;
                path.push(child);
            }
        }

        return true;
    }

    link(p, node) {
        const path = [...this.path];
        const parts = p.split('/');
        if (!parts.length)
            return true;

        if (parts[0] == '') {
            path.length = 1;
            parts.shift();
        }

        while (parts.length) {
            const part = parts.shift();
            if (part == '.' || part == '')
                continue;

            if (part == '..') {
                if (path.length == 1)
                    return false;
                path.pop();
                continue;
            }

            const top = path[path.length - 1];

            if (!parts.length) {
                this.dirty();
                return top.node.addChild(new Entry(part, node));
            }

            const child = top.node.lookup(part);
            if (!child || !child.is(Directory))
                return false;

            path.push(child);
        }

        return true;
    }

    writeFile(name, data) {
        let {child} = this.lookup(name);
        if (!child) {
            this.link(name, new File(data));
            return true;
        }
        if (child.is(File)) {
            child.node.data = data;
            this.dirty();
            return true;
        }
        return false;
    }

    readFile(name) {
        let {child} = this.lookup(name);
        if (!child)
            throw `Could not read inexistant file ${name}.`;
        if (!child.is(File))
            throw `Could not read ${child.constructor.name} ${name} as file.`;

        return child.node.data;
    }

    rm(p) {
        let {parent, child} = this.lookup(p);
        if (!parent || !child)
            return false;
        this.dirty();
        parent.node.unlink(child);
        return true;
    }

    lookup(p) {
        const path = [...this.path];
        const parts = p.split('/');
        if (!parts.length)
            return true;

        if (parts[0] == '') {
            path.length = 1;
            parts.shift();
        }

        while (parts.length) {
            const part = parts.shift();
            if (part == '.' || part == '')
                continue;

            if (part == '..') {
                if (path.length == 1)
                    return false;
                path.pop();
                continue;
            }

            const top = path[path.length - 1];
            const child = top.node.lookup(part);

            if (!child) {
                return false;
            }

            if (!parts.length) {
                return {parent:top, child};
            }

            if (!child.is(Directory))
                return false;

            path.push(child);
        }

        return true;
    }

    cwd() {
        return this.path.map(entry => entry.name).join('/');
    }

    recurse(callback) {
        const path = [];
        recurse(this.root, callback);

        function recurse(entity, callback) {
            path.push(entity.name);
            if (callback(entity, path) !== false && entity.isDirectory()) {
                for (let child of Object.values(entity.node.children))
                    recurse(child, callback);
            }
            path.pop();
        }
    }
}

},{}],84:[function(require,module,exports){
const { sleep, Uint8Buffer, toByteArray } = require('./Uint8Buffer.js');

// Timeouts
const DEFAULT_TIMEOUT = 6000; // timeout for most flash operations
const CHIP_ERASE_TIMEOUT = 300000; // timeout for full chip erase
const MAX_TIMEOUT = CHIP_ERASE_TIMEOUT * 2; // longest any command can run
const SYNC_TIMEOUT = 200; // timeout for syncing with bootloader
const ERASE_REGION_TIMEOUT_PER_MB = 30000; // timeout (per megabyte) for erasing a region
const MEM_END_ROM_TIMEOUT = 50;

const TIMEOUT_QUICK   = 200;
const TIMEOUT_NORMAL  = 3000;
const TIMEOUT_LONG    = 5000;

class SamBAError extends Error {
  constructor(msg) {
    super(msg);
  }
}

module.exports.SamBAError = SamBAError;

const emptyByteArray = new Uint8Array();

class SamBA {

  options;

  serialPort;

  // readLoop state
  closed = true;
  readLoopPromise = undefined;
  serialReader = undefined;
  inputBuffer = new Uint8Buffer(64);

  _canChipErase = false;
  _canWriteBuffer = false;
  _canChecksumBuffer = false;
  _canProtect = false;

  _readBufferSize;

  get canChecksumBuffer() {
    return this._canChecksumBuffer;
  }

  get canProtect() {
    return this._canProtect;
  }

  get canChipErase() {
    return this._canChipErase;
  }

  get canWriteBuffer() {
    return this._canWriteBuffer;
  }

  get writeBufferSize() { return 4096; }

  constructor(serialPort, options) {
    this.options = Object.assign(
      {
        flashSize: 4 * 1024 * 1024,
        logger: console,
        debug: false,
        trace: false
      },
      options || {}
    );

    this.serialPort = serialPort;

    this._canChipErase = false;
    this._canWriteBuffer = false;
    this._canChecksumBuffer = false;
    this._canProtect = false;
    this._readBufferSize = 0;
  }

  get logger() {
    return this.options.logger;
  }

  async checksumBuffer(start_addr, size) {

    if (!this._canWriteBuffer)
        throw new SamBAError('Cannot write buffer');

    if (size > this.checksumBufferSize())
      throw new SamBAError('Size too large for checksum buffer');

    if (this.options.debug)
      this.options.logger.debug('checksumBuffer(start_addr=0x', this.hex(start_addr), ',size=0x', this.hex(size),')');

    let result = await this.sendCommand('Z' + this.hex(start_addr) + ',' + this.hex(size), 12, undefined, 0, TIMEOUT_LONG );

    if (!result || result[0] != 0x5A /* 'Z' */) // Expects "Z00000000#\n\r"
        throw new SamBAError('Board response for \'Z\' command wrong');

    let value = this.decodeResponse(result);
    value = value.substr(1, 8);

    let num = parseInt(value, 16);

    if (num == NaN) {
      throw new SamBAError('Invalid checksum returned');
    }

    return num;
  }

  checksumBufferSize() { return 4096; }

  checksumCalc(c, crc) {
    return -1;
  }

  async chipErase(start_addr) {

    if (!this._canChipErase)
        throw new SamBAError('Chip erase not supported');

    if (this.options.debug)
      this.options.logger.debug('chipErase(start_addr=0x', this.hex(start_addr),')');

    let result = await this.sendCommand('X' + this.hex(start_addr), 3, undefined, 0, TIMEOUT_LONG);

    if (!result || result[0] != 0x58 /* 'X' */)
      throw new SamBAError('Board response for \'X\' command wrong');
  }

  async writeBuffer(src_addr, dst_addr, size) {

    if (!this._canWriteBuffer)
        throw new SamBAError('Cannot write buffer');

    if (size > this.checksumBufferSize())
      throw new SamBAError('Size too large for checksum buffer');

    if (this.options.debug)
      this.options.logger.debug('writeBuffer(src_addr=0x', this.hex(src_addr), ',dst_addr=0x', this.hex(dst_addr), ',size=0x', this.hex(size),')');

    let result = await this.sendCommand('Y' + this.hex(src_addr) + ',0', 3, undefined, 0, TIMEOUT_QUICK );

    if (!result || result[0] != 0x59 /* 'Y' */)
        throw new SamBAError('Board response for \'Y\' command wrong');

//    await sleep(50);
    result = await this.sendCommand('Y' + this.hex(dst_addr) + ',' + this.hex(size), 3, undefined, 0, TIMEOUT_LONG * 2);
    await sleep(50);


    if (!result || result[0] != 0x59 /* 'Y' */)
        throw new SamBAError('Board response for \'Y\' command wrong');
  }

  /**
   * Send a byte stream to the device
   */
  async writeToStream(msg) {

    if (this.serialPort.writable) {

      const writer = this.serialPort.writable.getWriter();
      let chunkSize = 63;

      try {
        await sleep(50);
        await writer.write(msg);
      }
      finally {
        writer.releaseLock();
      }
    }
  }

  hex(value, digits = 8) {
    var result = value.toString(16);

    while (result.length < digits) {
      result = '0' + result;
    }

    return result;
  }

  writeByte(addr, value) {

    if (this.options.debug)
      this.options.logger.debug('writeByte(addr=0x', this.hex(addr), ',value=0x', this.hex(value,2),')');

    this.sendCommand('O' + this.hex(addr) + ',' + this.hex(value, 2), 0);
  }

  async readByte(addr) {

    if (this.options.debug)
      this.options.logger.debug('readByte(addr=0x', this.hex(addr),')');

    let result = await this.sendCommand('o' + this.hex(addr) + ",4", 1);

    if (result) {
      let value = result[0];

      if (this.options.debug)
        this.options.logger.debug('readByte(addr=0x', this.hex(addr),')=0x',this.hex(value,2));

      return value;
    }

    throw new SamBAError('Reading');
  }


  async writeWord(addr, value) {

    if (this.options.debug)
      this.options.logger.debug('writeWord(addr=0x', this.hex(addr), ',value=0x', this.hex(value),')');

    await this.sendCommand('W' + this.hex(addr) + ',' + this.hex(value, 8), 0);
  }

  async readWord(addr) {

    if (this.options.debug)
      this.options.logger.debug('readWord(addr=0x', this.hex(addr),')');

    let result = await this.sendCommand('w' + this.hex(addr) + ',4', 4);

    if (result) {
      let value = (result[3] << 24 | result[2] << 16 | result[1] << 8 | result[0] << 0);

      if (this.options.debug)
        this.options.logger.debug('readByte(addr=0x', this.hex(addr),')=0x',this.hex(value,8));

      return value;
    }

    throw new SamBAError('Reading');
  }

  async write(addr, buffer, size = buffer.length) {

    if (this.options.debug)
      this.options.logger.debug('write(addr=0x', this.hex(addr), ',size=0x', this.hex(size), ')');

    await this.sendCommand('S' + this.hex(addr) + ',' + this.hex(size, 8), 0, buffer, size, TIMEOUT_LONG);
  }

  async read(addr, buffer, size) {

    if (this.options.debug)
        this.options.logger.debug('read(addr=0x', this.hex(addr), ',size=0x', this.hex(size), ')');

    var start = 0;

    // The SAM firmware has a bug reading powers of 2 over 32 bytes
    // via USB.  If that is the case here, then read the first byte
    // with a readByte and then read one less than the requested size.
    if (this._readBufferSize == 0 && size > 32 && !(size & (size - 1))) {
        buffer[start] = await this.readByte(addr);
        addr++;
        start++;
        size--;
    }

    while (size > 0)
    {
        var chunk = size;

        // Handle any limitations on the size of the read
        if (this._readBufferSize > 0 && size > this._readBufferSize)
            chunk = this._readBufferSize;

        var result = await this.sendCommand('R' + this.hex(addr) + ',' + this.hex(chunk), chunk);

        if (result) {
          for (var i = 0; i < chunk; i++) {
            buffer[start++] = result[i];
          }
        }
        else
          throw new SamBAError('Reading binary');

        size -= chunk;
        addr += chunk;
        start += chunk;
    }
  }


  async go(addr) {

    if (this.options.debug)
      this.options.logger.debug('go(addr=0x', this.hex(addr), ')');

    await this.sendCommand('G' + this.hex(addr), 0);
  }

  /**
   * @param rebootWaitMs how long it may take to reboot
   * Start the read loop up.
   */
  async connect(preopened = false, rebootWaitMs = 1000) {

    if (this.readLoopPromise) {
      throw "already open";
    }

    if (!preopened) {
        await this.serialPort.open({
            dataBits: 8,
            stopBits: 1,
            parity: 'none',
            bufferSize: 63,
            flowControl: 'hardware',
            baudRate: 921600 });
        await sleep(50);
    }

    await this._connect();
  }

  async _connect() {

    this.closed = false;

    this.readLoopPromise = (async () => {
      this.readLoop()
        .catch( reason => {
          if (reason.name == 'NetworkError' && reason.code == 19) {
            console.log("readLoop terminated because the connection was closed.");
          }
        })
      this.readLoopPromise = undefined;
    })();

    // Clear the pipe
    await this.readBuffer(SYNC_TIMEOUT);

    await this.setBinaryMode();

    let version = await this.readVersion();
    var extIndex = version.indexOf('[Arduino:');

    if (this.options.debug)
      this.options.logger.debug('Version-Info from bootloader: ' + version);

    if (extIndex != -1)
    {
        extIndex += 9;
        while (extIndex < version.length && version[extIndex] != ']')
        {
            switch (version[extIndex]) {
                case 'X': this._canChipErase = true; break;
                case 'Y': this._canWriteBuffer = true; break;
                case 'Z': this._canChecksumBuffer = true; break;
                case 'P': this._canProtect = true; break;            }
            extIndex++;
        }

        // All SAMD-based Arduino/AdaFruit boards have a bug in their bootloader
        // that trying to read 64 bytes or more over USB corrupts the data.
        // We must limit these boards to read chunks of 63 bytes.
        this._readBufferSize = 63;
    }
  }

  async setBinaryMode() {
    return this.sendCommand( 'N', 2);
  }

  /**
   * Read the Arduino version information from the board
   *
   * @returns A promise providing the version string
   */
  async readVersion() {

    let buffer = await this.sendCommand( 'V', 256);

    if (buffer) {
      return this.decodeResponse(buffer);
    }

    throw new SamBAError('No data received')
  }

  decodeResponse(buffer) {

    if (buffer.length > 2) {
      // Strip CR/LF if found
      if ((buffer[buffer.length - 1] = 0x0c) && (buffer[buffer.length - 2] = 0x0a)) {
        buffer = buffer.subarray(0, buffer.length - 2);
      }
    }

    return new TextDecoder("ascii").decode(buffer);
  }

  async sendCommand(cmd, responseSize = 2, data = undefined, size = 0, timeout = DEFAULT_TIMEOUT) {
    this.inputBuffer.reset();

    const packet = this._sendCommandBuffer;
    packet.reset();
    packet.copy(toByteArray(cmd));
    packet.push( 0x23 ); // #

    const res = packet.view();
    if (this.options.trace) {
      this.logger.debug("Writing ", this.hex(res.length), " byte" + (res.length == 1 ? "" : "s") + ":", res.slice(0, packet.length));
    }

    await this.writeToStream(res);

    if (data) {
      // if (this.options.debug) {
      //   this.logger.debug("writing buffer", this.hex(data.length), " byte" + (res.length == 1 ? "" : "s"));
      // }
      await sleep(50);
      await this.writeToStream(data);
    }

    // if (this.options.debug) {
    //   this.logger.debug("done writing");
    // }

    if (responseSize > 0)
      return await this.readBuffer(timeout, responseSize );
    else
      return null;
  }

  /**
   * Change the baud rate for the serial port.
   */
  async setBaudRate(baud) {

    this.logger.log("Attempting to change baud rate to", baud, "...");

    // Close the read loop and port
    await this.disconnect();
    await this.serialPort.close();

    // Reopen the port and read loop
    await this.serialPort.open({ baudRate: baud });
    await sleep(50);
    this._connect();

    // Baud rate was changed
    this.logger.log("Changed baud rate to", baud);
  }

  /**
   * Shutdown the read loop.
   */
  async disconnect() {
    const p = this.readLoopPromise;
    const reader = this.serialReader;

    if (!p || !reader) {
      throw "not open";
    }

    this.closed = true;
    await reader.cancel();
    await p;
    return;
  }

  _sendCommandBuffer = new Uint8Buffer();

  async readBuffer(timeout = DEFAULT_TIMEOUT, responseSize = undefined) {
    let reply = [];

    const stamp = Date.now();
    while (Date.now() - stamp < timeout) {
      if (this.inputBuffer.length > 0) {
        const c = this.inputBuffer.shift() || 0;
        if (this.options.debug) {
        }
        reply.push(c);
      }
      else {
        await sleep(10);
      }

      if (!responseSize && reply.length > 1 && (reply[reply.length - 1] == 0x0)) {
        break;
      }

      if (responseSize && reply.length == responseSize) {
        break;
      }
    }

    // Check to see if we have a complete packet. If not, we timed out.
    if (reply.length == 0) {
      this.logger.log("Timed out after", timeout, "milliseconds");
      return null;
    }

    if (this.options.trace) {
      this.logger.debug("Reading", reply.length, "byte" + (reply.length == 1 ? "" : "s") + ":", reply);
    }

    return Uint8Array.from(reply);
  }

  async readLoop() {

    this.inputBuffer.reset();

    if (this.serialPort.readable) {

      const appReadable = this.serialPort.readable;

      this.serialReader = appReadable.getReader();
      try {
        while (!this.closed) {
          const { value, done } = await this.serialReader.read();
          if (done) {
            break;
          }
          if (value) {
            if (this.options.trace)
              this.logger.debug("Received " + value);

            this.inputBuffer.copy(value);
          }
        }
      }
      finally {
        await this.serialReader.cancel();
        this.serialReader.releaseLock();
        this.serialReader = undefined;
        this.closed = true;
      }
    }
  }

}

module.exports.SamBA = SamBA;

},{"./Uint8Buffer.js":59}],85:[function(require,module,exports){
module.exports.stdlib = `

/**
 * Prints messages into the console for debugging
 */
declare function debug(...args):void;

/**
 * Returns the current timestamp in milliseconds
 */
declare function getTime():number;

/**
 * Returns a floating-point value between 0 (inclusive) and 1 (exclusive)
 */
declare function rand():number;

/**
 * Returns an integer value between 0 (inclusive) and max (exclusive)
 */
declare function rand(max:number):number;

/**
 * Returns a floating-point value between min (inclusive) and max (exclusive)
 */
declare function rand(min:number, max:number):number;

/**
 * Returns an integer value between min (inclusive) and max (exclusive)
 */
declare function rand(min:number, max:number, ignored:any):number;

/**
 * Returns a 32-bit hash of the given string
 */
declare function hash(str:string):number;

/**
 * Returns the absolute value of value
 */
declare function abs(value:number):number;

/**
 * Returns the sign of value (either 1, 0 or -1)
 */
declare function sign(value:number):number;

/**
 * Returns value rounded down to the nearest integer
 */
declare function floor(value:number):number;

/**
 * Returns value rounded to the nearest integer
 */
declare function round(value:number):number;

/**
 * Returns value rounded up to the nearest integer
 */
declare function ceil(value:number):number;

/**
 * Returns the square root of value
 */
declare function sqrt(value:number):number;

/**
 * Returns the cosine of angle, given in radians
 */
declare function cos(angle:number):number;

/**
 * Returns the sine of angle, given in radians
 */
declare function sin(angle:number):number;

/**
 * Returns the arc tangent of y/x
 */
declare function atan2(y:number, x:number):number;

/**
 * Returns the arc tangent of angle, given in radians
 */
declare function tan(angle:number):number;

/**
 * Returns value restricted to the range defined by min and max, inclusive.
 */
declare function clamp(value, min, max):number;

/**
 * Returns the lowest of the given values
 */
declare function min(...value):number;

/**
 * Returns the highest of the given values
 */
declare function max(...value):number;

/**
 * Returns the root of the sum of each argument squared
 */
declare function vectorLength(...args):number;

/**
 * Returns the difference between two angles given in radians
 */
declare function angleDifference(angleA, angleB):number

/**
 * Sets the target framerate that the game should update at.
 */
declare function setFPS(fps:number):void;

/**
 * Sets current tilemap. See wiki for further info.
 */
declare function setTileMap(map:TileMapResource):void;

/**
 * Returns the value of the property of the tile under the given coordinates
 */
declare function getTileProperty(x:number, y:number, property:string):number;

/**
 * Calls callback for every tile where the filter's keys and values match.
 */
declare function scanTileMap(filter:number, callback:function):void;

/**
 * Sets the current drawing color.
 * Returns a color.
 */
declare function setPen(R:number, G:number, B:number):number;

/**
 * Sets the current drawing color.
 * Returns a color.
 */
declare function setPen(color:number):number;

/**
 * Sets the font used by the text() function.
 */
declare function setFont(font:FontResource):void;

/**
 * Sets the LED color on supported hardware.
 */
declare function setLED(R:number, G:number, B:number):void;

/**
 * Fills a rectangle on the screen using the current pen color.
 */
declare function rect(x:number, y:number, width:number, height:number):void;

/**
 * Sets the texture to be used by the image() function.
 */
declare function setTexture(texture:ImageResource):void;

/**
 * Sets if the following image() calls should be flipped horizontally.
 */
declare function setMirrored(mirror:boolean):void;

/**
 * Sets if the following image() calls should be flipped vertically.
 */
declare function setFlipped(flip:boolean):void;

/**
 * Sets if the following image() calls should support transparency.
 */
declare function setTransparent(transparent:boolean):void;

/**
 * Returns the screen's width in pixels.
 */
declare function getWidth():number;

/**
 * Returns the screen's height in pixels.
 */
declare function getHeight():number;

/**
 * Reads a byte from a resource at the specified offset.
 */
declare function readByte(resource:Resource, offset?:number):number;

/**
 * Returns the image's width in pixels.
 */
declare function getWidth(image:ImageResource):number;

/**
 * Returns the image's height in pixels.
 */
declare function getHeight(image:ImageResource):number;

/**
 * Fills the entire screen with the current pen's color.
 */
declare function clear():void;

/**
 * Draws the active texture onto the screen at position 0, 0.
 */
declare function image():void;

/**
 * Draws texture onto the screen at position 0, 0.
 */
declare function image(texture:ImageResource):void;

/**
 * Draws the active texture onto the screen at position X, Y.
 */
declare function image(X:number, Y:number):void;

/**
 * Draws texture onto the screen at position X, Y.
 */
declare function image(texture:ImageResource, X:number, Y:number, rotation?:number, scale?:number):void;

/**
 * Draws text onto the screen.
 */
declare function text(message:string, x?:number, y?:number):void;

/**
 * True while button is pressed, false otherwise.
 */
var UP:boolean;

/**
 * True while button is pressed, false otherwise.
 */
var DOWN:boolean;

/**
 * True while button is pressed, false otherwise.
 */
var LEFT:boolean;

/**
 * True while button is pressed, false otherwise.
 */
var RIGHT:boolean;

/**
 * True while button is pressed, false otherwise.
 */
var A:boolean;

/**
 * True while button is pressed, false otherwise.
 */
var B:boolean;

/**
 * True while button is pressed, false otherwise.
 */
var C:boolean;

/**
 * True while button is pressed, false otherwise.
 */
var D:boolean;

`;

},{}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WordCopyApplet = void 0;
var _applet = require("./applet");
var _samba = require("./samba");
const applet = {
  // dst_addr
  dst_addr: 0x00000028,
  // reset
  reset: 0x00000024,
  // src_addr
  src_addr: 0x0000002c,
  // stack
  stack: 0x00000020,
  // start
  start: 0x00000000,
  // words
  words: 0x00000030,
  // code
  code: new Uint8Array([0x09, 0x48, 0x0a, 0x49, 0x0a, 0x4a, 0x02, 0xe0, 0x08, 0xc9, 0x08, 0xc0, 0x01, 0x3a, 0x00, 0x2a, 0xfa, 0xd1, 0x04, 0x48, 0x00, 0x28, 0x01, 0xd1, 0x01, 0x48, 0x85, 0x46, 0x70, 0x47, 0xc0, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
};
class WordCopyApplet extends _applet.Applet {
  constructor(samba, addr) {
    super(samba, addr, applet.code, applet.code.length, addr + applet.start, addr + applet.stack, addr + applet.reset);
  }
  async setDstAddr(dstAddr) {
    // Check if applet is already on the board and install if not
    await this.checkInstall();
    await this._samba.writeWord(this._addr + applet.dst_addr, dstAddr);
  }
  async setSrcAddr(srcAddr) {
    // Check if applet is already on the board and install if not
    await this.checkInstall();
    await this._samba.writeWord(this._addr + applet.src_addr, srcAddr);
  }
  async setWords(words) {
    // Check if applet is already on the board and install if not
    await this.checkInstall();
    await this._samba.writeWord(this._addr + applet.words, words);
  }
}
exports.WordCopyApplet = WordCopyApplet;

},{"./applet":60,"./samba":84}]},{},[65]);
